<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.Sym.Pattern</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Lean.Meta.Sym.Pattern";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Pattern</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Pattern.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Lean/Data/AssocList.html">Lean.Data.AssocList</a></li><li><a href="../../.././Lean/Meta/SynthInstance.html">Lean.Meta.SynthInstance</a></li><li><a href="../../.././Init/Data/List/MapIdx.html">Init.Data.List.MapIdx</a></li><li><a href="../../.././Init/Data/Nat/Linear.html">Init.Data.Nat.Linear</a></li><li><a href="../../.././Lean/Meta/Sym/AbstractS.html">Lean.Meta.Sym.AbstractS</a></li><li><a href="../../.././Lean/Meta/Sym/AlphaShareBuilder.html">Lean.Meta.Sym.AlphaShareBuilder</a></li><li><a href="../../.././Lean/Meta/Sym/Eta.html">Lean.Meta.Sym.Eta</a></li><li><a href="../../.././Lean/Meta/Sym/InstantiateMVarsS.html">Lean.Meta.Sym.InstantiateMVarsS</a></li><li><a href="../../.././Lean/Meta/Sym/InstantiateS.html">Lean.Meta.Sym.InstantiateS</a></li><li><a href="../../.././Lean/Meta/Sym/IsClass.html">Lean.Meta.Sym.IsClass</a></li><li><a href="../../.././Lean/Meta/Sym/MaxFVar.html">Lean.Meta.Sym.MaxFVar</a></li><li><a href="../../.././Lean/Meta/Sym/Offset.html">Lean.Meta.Sym.Offset</a></li><li><a href="../../.././Lean/Meta/Sym/ProofInstInfo.html">Lean.Meta.Sym.ProofInstInfo</a></li><li><a href="../../.././Lean/Meta/Sym/SymM.html">Lean.Meta.Sym.SymM</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.Sym.Pattern" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Pattern"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Pattern</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.instInhabitedPattern.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">instInhabitedPattern</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.instInhabitedPattern"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">instInhabitedPattern</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.mkPatternFromDecl"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">mkPatternFromDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.mkPatternFromExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">mkPatternFromExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.mkEqPatternFromDecl"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">mkEqPatternFromDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.isDefEqS"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isDefEqS</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.MatchUnifyResult"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">MatchUnifyResult</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Pattern.match?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Pattern</span>.<span class="name">match?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Pattern.unify?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Pattern</span>.<span class="name">unify?</span></a></div></nav><main>
<div class="mod_doc"><p>This module implements efficient pattern matching and unification module for the symbolic simulation
framework (<code>Sym</code>). The design prioritizes performance by using a two-phase approach:</p><h1 id="Phase-1-Syntactic-Matching" class="markdown-heading">Phase 1 (Syntactic Matching) <a class="hover-link" href="#Phase-1-Syntactic-Matching">#</a></h1><ul><li>Patterns use de Bruijn indices for expression variables and renamed level params (<code>_uvar.0</code>, <code>_uvar.1</code>, ...) for universe variables</li><li>Matching is purely structural after reducible definitions are unfolded during preprocessing</li><li>Universe levels treat <code>max</code> and <code>imax</code> as uninterpreted functions (no AC reasoning)</li><li>Binders and term metavariables are deferred to Phase 2</li></ul><h1 id="Phase-2-Pending-Constraints" class="markdown-heading">Phase 2 (Pending Constraints) <a class="hover-link" href="#Phase-2-Pending-Constraints">#</a></h1><ul><li>Handles binders (Miller patterns) and metavariable unification</li><li>Converts remaining de Bruijn variables to metavariables</li><li>Falls back to structural <code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.isDefEqS">isDefEqS</a></code> when necessary.</li><li>It still uses the standard <code>isDefEq</code> for instances.</li></ul><h1 id="Key-design-decisions" class="markdown-heading">Key design decisions: <a class="hover-link" href="#Key-design-decisions">#</a></h1><ul><li>Preprocessing unfolds reducible definitions and performs beta/zeta reduction</li><li>Kernel projections are expected to be folded as projection applications before matching</li><li>Assignment conflicts are deferred to pending rather than invoking <code>isDefEq</code> inline</li><li><code>instantiateRevS</code> ensures maximal sharing of result expressions</li></ul></div><div class="decl" id="Lean.Meta.Sym.Pattern"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Pattern.lean#L65-L82">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Pattern</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Sym.Pattern.mk"><li id="Lean.Meta.Sym.Pattern.levelParams" class="structure_field"><div class="structure_field_info">levelParams : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Lean.Name">Name</a></span></div></li><li id="Lean.Meta.Sym.Pattern.varTypes" class="structure_field"><div class="structure_field_info">varTypes : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li><li id="Lean.Meta.Sym.Pattern.varInfos?" class="structure_field"><div class="structure_field_info">varInfos? : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo">ProofInstInfo</a></span></div><div class="structure_field_doc"><p>If <code>some argsInfo</code>, <code>argsInfo</code> stores whether the pattern variables are instances/proofs.
It is <code>none</code> if no pattern variables are instance/proof.</p></div></li><li id="Lean.Meta.Sym.Pattern.pattern" class="structure_field"><div class="structure_field_info">pattern : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Sym.Pattern.fnInfos" class="structure_field"><div class="structure_field_info">fnInfos : <span class="fn"><a href="../../.././Lean/Data/AssocList.html#Lean.AssocList">AssocList</a> <a href="../../.././Init/Prelude.html#Lean.Name">Name</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo">ProofInstInfo</a></span></div></li><li id="Lean.Meta.Sym.Pattern.checkTypeMask?" class="structure_field"><div class="structure_field_info">checkTypeMask? : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span></div><div class="structure_field_doc"><p>If <code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern.checkTypeMask?">checkTypeMask?</a> = some mask</code>, then we must check the type of pattern variable <code>i</code>
if <code>mask[i]</code> is true.
Moreover <code>mask.size == varTypes.size</code>.
See <code>mkCheckTypeMask</code></p></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.Pattern" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.instInhabitedPattern.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Pattern.lean#L82-L82">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.instInhabitedPattern.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">instInhabitedPattern</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern">Pattern</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.instInhabitedPattern.default">Lean.Meta.Sym.instInhabitedPattern.default</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern.mk">{</a> <span class="fn">levelParams</span> := <a href="../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">varTypes</span> := <a href="../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">varInfos?</span> := <a href="../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">pattern</span> := <a href="../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">fnInfos</span> := <a href="../../.././Init/Prelude.html#Inhabited.default">default</a>,
    <span class="fn">checkTypeMask?</span> := <a href="../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.instInhabitedPattern.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.instInhabitedPattern"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Pattern.lean#L82-L82">source</a></div><div class="attributes">@[instance_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.instInhabitedPattern"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">instInhabitedPattern</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern">Pattern</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.instInhabitedPattern">Lean.Meta.Sym.instInhabitedPattern</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.instInhabitedPattern.default">Lean.Meta.Sym.instInhabitedPattern.default</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.mkPatternFromDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Pattern.lean#L188-L203">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.mkPatternFromDecl"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">mkPatternFromDecl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">declName</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">num?</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Init/Prelude.html#Nat">Nat</a></span> := <a href="../../.././Init/Prelude.html#Option.none">none</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern">Pattern</a></span></div></div><p>Creates a <code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern">Pattern</a></code> from the type of a theorem.</p><p>The pattern is constructed by stripping leading universal quantifiers from the theorem's type.
Each quantified variable becomes a pattern variable, with its type recorded in <code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern.varTypes">varTypes</a></code> and
whether it is a type class instance recorded in <code>isInstance</code>. The remaining type after
stripping quantifiers becomes the <code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern.pattern">pattern</a></code> expression.</p><p>Universe level parameters are replaced with fresh unification variables (prefixed with <code>_uvar</code>).</p><p>If <code>num?</code> is <code>some n</code>, at most <code>n</code> leading quantifiers are stripped.
If <code>num?</code> is <code>none</code>, all leading quantifiers are stripped.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Sym.mkPatternFromDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.mkPatternFromExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Pattern.lean#L205-L207">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.mkPatternFromExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">mkPatternFromExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">levelParams</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Lean.Name">Name</a></span> := <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">num?</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Init/Prelude.html#Nat">Nat</a></span> := <a href="../../.././Init/Prelude.html#Option.none">none</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern">Pattern</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Sym.mkPatternFromExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.mkEqPatternFromDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Pattern.lean#L219-L232">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.mkEqPatternFromDecl"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">mkEqPatternFromDecl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">declName</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> (<a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern">Pattern</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></div></div><p>Creates a <code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern">Pattern</a></code> from an equational theorem, using the left-hand side of the equation.
It also returns the right-hand side of the equation</p><p>Like <code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.mkPatternFromDecl">mkPatternFromDecl</a></code>, this strips all leading universal quantifiers, recording variable
types and instance status. However, instead of using the entire resulting type as the pattern,
it extracts just the LHS of the equation.</p><p>For a theorem <code>∀ x₁ ... xₙ, lhs = rhs</code>, returns a pattern matching <code>lhs</code> with <code>n</code> pattern variables.
Throws an error if the theorem's conclusion is not an equality.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Sym.mkEqPatternFromDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.isDefEqS"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Pattern.lean#L818-L825">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.isDefEqS"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isDefEqS</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">t </span><span class="fn">s</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">unify </span><span class="fn">zetaDelta</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mvarsNew </span><span class="fn">mvarsToCheckType</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span> := <a href="../../.././Init/Prelude.html#List.toArray">#[</a><a href="../../.././Init/Prelude.html#List.toArray">]</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>A lightweight structural definitional equality for the symbolic simulation framework.
Unlike the full <code>isDefEq</code>, it avoids expensive operations while still supporting Miller pattern unification.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.isDefEqS">Lean.Meta.Sym.isDefEqS</a> <span class="fn">t</span> <span class="fn">s</span> <span class="fn">unify</span> <span class="fn">zetaDelta</span> <span class="fn">mvarsNew</span> <span class="fn">mvarsToCheckType</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Lean/Meta/Sym/Pattern.html#_private.Lean.Meta.Sym.Pattern.0.Lean.Meta.Sym.DefEqM.run">Lean.Meta.Sym.DefEqM.run✝</a> <span class="fn">unify</span> <span class="fn">zetaDelta</span> <span class="fn">mvarsNew</span> <span class="fn">mvarsToCheckType</span> <span class="fn">(<a href="../../.././Lean/Meta/Sym/Pattern.html#_private.Lean.Meta.Sym.Pattern.0.Lean.Meta.Sym.isDefEqMain">Lean.Meta.Sym.isDefEqMain✝</a> <span class="fn">t</span> <span class="fn">s</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.isDefEqS" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.MatchUnifyResult"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Pattern.lean#L932-L934">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.MatchUnifyResult"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">MatchUnifyResult</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Sym.MatchUnifyResult.mk"><li id="Lean.Meta.Sym.MatchUnifyResult.us" class="structure_field"><div class="structure_field_info">us : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Level.html#Lean.Level">Level</a></span></div></li><li id="Lean.Meta.Sym.MatchUnifyResult.args" class="structure_field"><div class="structure_field_info">args : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.MatchUnifyResult" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Pattern.match?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Pattern.lean#L949-L964">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern.match?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Pattern</span>.<span class="name">match?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern">Pattern</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">zetaDelta</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.MatchUnifyResult">MatchUnifyResult</a>)</span></span></div></div><p>Attempts to match expression <code>e</code> against pattern <code>p</code> using purely syntactic matching.</p><p>Returns <code>some result</code> if matching succeeds, where <code>result</code> contains:</p><ul><li><code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.MatchUnifyResult.us">us</a></code>: Level assignments for the pattern's universe variables</li><li><code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.MatchUnifyResult.args">args</a></code>: Expression assignments for the pattern's bound variables</li></ul><p>Matching fails if:</p><ul><li>The term contains metavariables (use <code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern.unify?">unify?</a></code> instead)</li><li>Structural mismatch after reducible unfolding</li></ul><p>Instance arguments are deferred for later synthesis. Proof arguments are
skipped via proof irrelevance.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern.match?">match?</a></span> <span class="fn">e</span> <span class="fn">zetaDelta</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Meta/Sym/Pattern.html#_private.Lean.Meta.Sym.Pattern.0.Lean.Meta.Sym.main">Lean.Meta.Sym.main✝</a> <span class="fn">p</span> <span class="fn">e</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a> <span class="fn">zetaDelta</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Pattern.match?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Pattern.unify?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Pattern.lean#L966-L981">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern.unify?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Pattern</span>.<span class="name">unify?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern">Pattern</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">zetaDelta</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.MatchUnifyResult">MatchUnifyResult</a>)</span></span></div></div><p>Attempts to unify expression <code>e</code> against pattern <code>p</code>, allowing metavariables in <code>e</code>.</p><p>Returns <code>some result</code> if unification succeeds, where <code>result</code> contains:</p><ul><li><code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.MatchUnifyResult.us">us</a></code>: Level assignments for the pattern's universe variables</li><li><code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.MatchUnifyResult.args">args</a></code>: Expression assignments for the pattern's bound variables</li></ul><p>Unlike <code><a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern.match?">match?</a></code>, this handles terms containing metavariables by deferring
constraints to Phase 2 unification. Use this when matching against goal
expressions that may contain unsolved metavariables.</p><p>Instance arguments are deferred for later synthesis. Proof arguments are
skipped via proof irrelevance.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern.unify?">unify?</a></span> <span class="fn">e</span> <span class="fn">zetaDelta</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Meta/Sym/Pattern.html#_private.Lean.Meta.Sym.Pattern.0.Lean.Meta.Sym.main">Lean.Meta.Sym.main✝</a> <span class="fn">p</span> <span class="fn">e</span> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <span class="fn">zetaDelta</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Pattern.unify?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>