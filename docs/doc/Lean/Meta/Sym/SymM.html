<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.Sym.SymM</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Lean.Meta.Sym.SymM";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">SymM</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Lean/Meta/CongrTheorems.html">Lean.Meta.CongrTheorems</a></li><li><a href="../../.././Lean/Meta/Sym/AlphaShareCommon.html">Lean.Meta.Sym.AlphaShareCommon</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.Sym.SymM" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.sym.debug"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">sym</span>.<span class="name">debug</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.ProofInstArgInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">ProofInstArgInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.instInhabitedProofInstArgInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">instInhabitedProofInstArgInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.instInhabitedProofInstArgInfo.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">instInhabitedProofInstArgInfo</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.ProofInstInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">ProofInstInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.instInhabitedProofInstInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">instInhabitedProofInstInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.instInhabitedProofInstInfo.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">instInhabitedProofInstInfo</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.CongrInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">CongrInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.SharedExprs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">SharedExprs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Context"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.SymM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">SymM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.SymM.run"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">SymM</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.getSharedExprs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getSharedExprs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.getTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.isTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.getFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.isFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.getBoolTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getBoolTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.isBoolTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isBoolTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.getBoolFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getBoolFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.isBoolFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isBoolFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.getNatZeroExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getNatZeroExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.getOrderingEqExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getOrderingEqExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.getIntExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getIntExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.shareCommon"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">shareCommon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.shareCommonInc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">shareCommonInc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.share"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">share</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.isDebugEnabled"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isDebugEnabled</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.isDefEqI"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isDefEqI</span></a></div></nav><main>
<div class="decl" id="Lean.Meta.Sym.sym.debug"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L13-L16">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.sym.debug"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">sym</span>.<span class="name">debug</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Sym.ProofInstArgInfo"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L18-L30">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">ProofInstArgInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Information about a single argument position in a function's type signature.</p><p>This is used during pattern matching and structural definitional equality tests
to identify arguments that can be skipped or handled specially
(e.g., instance arguments can be synthesized, proof arguments can be inferred).</p><ul class="structure_fields" id="Lean.Meta.Sym.ProofInstArgInfo.mk"><li id="Lean.Meta.Sym.ProofInstArgInfo.isProof" class="structure_field"><div class="structure_field_info">isProof : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code>true</code> if this argument is a proof (its type is a <code>Prop</code>).</p></div></li><li id="Lean.Meta.Sym.ProofInstArgInfo.isInstance" class="structure_field"><div class="structure_field_info">isInstance : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code>true</code> if this argument is a type class instance.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.ProofInstArgInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.instInhabitedProofInstArgInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L30-L30">source</a></div><div class="attributes">@[instance_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstArgInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">instInhabitedProofInstArgInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo">ProofInstArgInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstArgInfo">Lean.Meta.Sym.instInhabitedProofInstArgInfo</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstArgInfo.default">Lean.Meta.Sym.instInhabitedProofInstArgInfo.default</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.instInhabitedProofInstArgInfo.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L30-L30">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstArgInfo.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">instInhabitedProofInstArgInfo</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo">ProofInstArgInfo</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstArgInfo.default">Lean.Meta.Sym.instInhabitedProofInstArgInfo.default</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo.mk">{</a> <span class="fn">isProof</span> := <a href="../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">isInstance</span> := <a href="../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.instInhabitedProofInstArgInfo.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.ProofInstInfo"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L32-L40">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">ProofInstInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Information about a function symbol. It stores which argument positions are proofs or instances,
enabling optimizations during pattern matching and structural definitional equality tests
such as skipping proof arguments or deferring instance synthesis.</p><ul class="structure_fields" id="Lean.Meta.Sym.ProofInstInfo.mk"><li id="Lean.Meta.Sym.ProofInstInfo.argsInfo" class="structure_field"><div class="structure_field_info">argsInfo : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo">ProofInstArgInfo</a></span></div><div class="structure_field_doc"><p>Information about each argument position.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.ProofInstInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.instInhabitedProofInstInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L40-L40">source</a></div><div class="attributes">@[instance_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">instInhabitedProofInstInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo">ProofInstInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstInfo">Lean.Meta.Sym.instInhabitedProofInstInfo</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstInfo.default">Lean.Meta.Sym.instInhabitedProofInstInfo.default</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.instInhabitedProofInstInfo.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L40-L40">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstInfo.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">instInhabitedProofInstInfo</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo">ProofInstInfo</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstInfo.default">Lean.Meta.Sym.instInhabitedProofInstInfo.default</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo.mk">{</a> <span class="fn">argsInfo</span> := <a href="../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.instInhabitedProofInstInfo.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.CongrInfo"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L42-L83">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">CongrInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Information on how to build congruence proofs for function applications.
This enables efficient rewriting of subterms without repeatedly inferring types or instances.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Sym.CongrInfo.none">none : <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo">CongrInfo</a><div class="inductive_ctor_doc"><p>None of the arguments of the function can be rewritten.</p></div></li><li class="constructor" id="Lean.Meta.Sym.CongrInfo.fixedPrefix">fixedPrefix<span class="decl_args">
<span class="fn">(<span class="fn">prefixSize </span><span class="fn">suffixSize</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
 : <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo">CongrInfo</a><div class="inductive_ctor_doc"><p>For functions with a fixed prefix of implicit/instance arguments followed by
explicit non-dependent arguments that can be rewritten independently.</p><ul><li><code>prefixSize</code>: Number of leading arguments (types, instances) that are determined
by the suffix arguments and should not be rewritten directly.</li><li><code>suffixSize</code>: Number of trailing arguments that can be rewritten using simple congruence.</li></ul><p>Examples (showing <code>prefixSize</code>, <code>suffixSize</code>):</p><ul><li><code><a href="../../.././Init/Prelude.html#HAdd.hAdd">HAdd.hAdd</a> {α β γ} [HAdd α β γ] (a : α) (b : β)</code>: <code>(4, 2)</code> — rewrite <code>a</code> and <code>b</code></li><li><code><a href="../../.././Init/Prelude.html#And">And</a> (p q : Prop)</code>: <code>(0, 2)</code> — rewrite both propositions</li><li><code><a href="../../.././Init/Prelude.html#Eq">Eq</a> {α} (a b : α)</code>: <code>(1, 2)</code> — rewrite <code>a</code> and <code>b</code>, type <code>α</code> is fixed</li><li><code><a href="../../.././Init/Prelude.html#Neg.neg">Neg.neg</a> {α} [Neg α] (a : α)</code>: <code>(2, 1)</code> — rewrite just <code>a</code></li></ul></div></li><li class="constructor" id="Lean.Meta.Sym.CongrInfo.interlaced">interlaced<span class="decl_args">
<span class="fn">(<span class="fn">rewritable</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span>)</span></span>
 : <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo">CongrInfo</a><div class="inductive_ctor_doc"><p>For functions with interlaced rewritable and non-rewritable arguments.
Each element indicates whether the corresponding argument position can be rewritten.</p><p>Example: For <code><a href="../../.././Init/Prelude.html#HEq">HEq</a> {α : Sort u} (a : α) {β : Sort u} (b : β)</code>, the mask would be
<code>#[false, true, false, true]</code> — we can rewrite <code>a</code> and <code>b</code>, but not <code>α</code> or <code>β</code>.</p></div></li><li class="constructor" id="Lean.Meta.Sym.CongrInfo.congrTheorem">congrTheorem<span class="decl_args">
<span class="fn">(<span class="fn">thm</span> : <a href="../../.././Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem">CongrTheorem</a>)</span></span>
 : <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo">CongrInfo</a><div class="inductive_ctor_doc"><p>For functions that have proofs and <code><a href="../../.././Init/Prelude.html#Decidable">Decidable</a></code> arguments. For this kind of function we generate
a custom theorem.
Example: <code><a href="../../.././Init/Data/Array/Basic.html#Array.eraseIdx">Array.eraseIdx</a> {α : Type u} (xs : <a href="../../.././Init/Prelude.html#Array">Array</a> α) (i : Nat) (h : i &lt; xs.size) : <a href="../../.././Init/Prelude.html#Array">Array</a> α</code>.
The proof argument <code>h</code> depends on <code>xs</code> and <code>i</code>. To be able to rewrite <code>xs</code> and <code>i</code>, we use the
auto-generated theorem.</p><pre><code><a href="../../.././Init/Data/Array/Basic.html#Array.eraseIdx.congr_simp">Array.eraseIdx.congr_simp</a> {α : Type u} (xs xs' : <a href="../../.././Init/Prelude.html#Array">Array</a> α) (e_xs : xs = xs')
    (i i' : Nat) (e_i : i = i') (h : i &lt; xs.size) : xs.eraseIdx i h = xs'.eraseIdx i' ⋯
</code></pre></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.CongrInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.SharedExprs"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L85-L93">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">SharedExprs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Pre-shared expressions for commonly used terms.</p><ul class="structure_fields" id="Lean.Meta.Sym.SharedExprs.mk"><li id="Lean.Meta.Sym.SharedExprs.trueExpr" class="structure_field"><div class="structure_field_info">trueExpr : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Sym.SharedExprs.falseExpr" class="structure_field"><div class="structure_field_info">falseExpr : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Sym.SharedExprs.natZExpr" class="structure_field"><div class="structure_field_info">natZExpr : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Sym.SharedExprs.btrueExpr" class="structure_field"><div class="structure_field_info">btrueExpr : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Sym.SharedExprs.bfalseExpr" class="structure_field"><div class="structure_field_info">bfalseExpr : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Sym.SharedExprs.ordEqExpr" class="structure_field"><div class="structure_field_info">ordEqExpr : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Sym.SharedExprs.intExpr" class="structure_field"><div class="structure_field_info">intExpr : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.SharedExprs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L95-L97">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.Context"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Readonly context for the symbolic computation framework.</p><ul class="structure_fields" id="Lean.Meta.Sym.Context.mk"><li id="Lean.Meta.Sym.Context.sharedExprs" class="structure_field"><div class="structure_field_info">sharedExprs : <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs">SharedExprs</a></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.Context" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L99-L136">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Mutable state for the symbolic computation framework.</p><ul class="structure_fields" id="Lean.Meta.Sym.State.mk"><li id="Lean.Meta.Sym.State.share" class="structure_field"><div class="structure_field_info">share : <a href="../../.././Lean/Meta/Sym/AlphaShareCommon.html#Lean.Meta.Sym.AlphaShareCommon.State">AlphaShareCommon.State</a></div><div class="structure_field_doc"><p><code>ShareCommon</code> (aka <code>Hash-consing</code>) state.</p></div></li><li id="Lean.Meta.Sym.State.maxFVar" class="structure_field"><div class="structure_field_info">maxFVar : <span class="fn"><a href="../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../.././Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr">ExprPtr</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">FVarId</a>)</span></span></div><div class="structure_field_doc"><p>Maps expressions to their maximal free variable (by declaration index).</p><ul><li><code>maxFVar[e] = some fvarId</code> means <code>fvarId</code> is the free variable with the largest declaration
index occurring in <code>e</code>.</li><li><code>maxFVar[e] = <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo.none">none</a></code> means <code>e</code> contains no free variables (but may contain metavariables).</li></ul><p>Recall that if <code>e</code> contains a metavariable <code>?m</code>, then we assume <code>e</code> may contain any free variable
in the local context associated with <code>?m</code>.</p><p>This mapping enables O(1) local context compatibility checks during metavariable assignment.
Instead of traversing local contexts with <code>isSubPrefixOf</code>, we check if the maximal free variable
in the assigned value is in scope of the metavariable's local context.</p><p><strong>Note</strong>: We considered using a mapping <code>PHashMap ExprPtr FVarId</code>. However, there is a corner
case that is not supported by this representation. <code>e</code> contains a metavariable (with an empty local context),
and no free variables.</p></div></li><li id="Lean.Meta.Sym.State.proofInstInfo" class="structure_field"><div class="structure_field_info">proofInstInfo : <span class="fn"><a href="../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../.././Init/Prelude.html#Lean.Name">Name</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo">ProofInstInfo</a>)</span></span></div></li><li id="Lean.Meta.Sym.State.inferType" class="structure_field"><div class="structure_field_info">inferType : <span class="fn"><a href="../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../.././Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr">ExprPtr</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>Cache for <code><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.inferType">inferType</a></code> results, keyed by pointer equality.
<code><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a></code> uses a fixed configuration, so we can use a simpler key than <code>MetaM</code>.
Remark: type inference is a bottleneck on <code>Meta.Tactic.Simp</code> simplifier.</p></div></li><li id="Lean.Meta.Sym.State.getLevel" class="structure_field"><div class="structure_field_info">getLevel : <span class="fn"><a href="../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../.././Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr">ExprPtr</a> <a href="../../.././Lean/Level.html#Lean.Level">Level</a></span></div><div class="structure_field_doc"><p>Cache for <code><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.getLevel">getLevel</a></code> results, keyed by pointer equality.</p></div></li><li id="Lean.Meta.Sym.State.congrInfo" class="structure_field"><div class="structure_field_info">congrInfo : <span class="fn"><a href="../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../.././Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr">ExprPtr</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo">CongrInfo</a></span></div></li><li id="Lean.Meta.Sym.State.defEqI" class="structure_field"><div class="structure_field_info">defEqI : <span class="fn"><a href="../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> (<a href="../../.././Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr">ExprPtr</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr">ExprPtr</a>) <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div><div class="structure_field_doc"><p>Cache for <code><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isDefEqI">isDefEqI</a></code> results</p></div></li><li id="Lean.Meta.Sym.State.debug" class="structure_field"><div class="structure_field_info">debug : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.SymM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L138-L138">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">SymM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">Lean.Meta.Sym.SymM</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.Context">Lean.Meta.Sym.Context</a> <span class="fn">(<a href="../../.././Init/Control/StateRef.html#StateRefT'">StateRefT'</a> <a href="../../.././Init/System/IO.html#IO.RealWorld">IO.RealWorld</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State">Lean.Meta.Sym.State</a> <a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.SymM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.SymM.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L150-L153">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM.run"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">SymM</span>.<span class="name">run</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Sym.SymM.run" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.getSharedExprs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L155-L157">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getSharedExprs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getSharedExprs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs">SharedExprs</a></span></div></div><p>Returns maximally shared commonly used terms</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getSharedExprs">Lean.Meta.Sym.getSharedExprs</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Init/Prelude.html#MonadReader.read">read</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.Context.sharedExprs">sharedExprs</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.getSharedExprs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.getTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L159-L160">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getTrueExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../.././Init/Prelude.html#True">True</a></code> constant.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getTrueExpr">Lean.Meta.Sym.getTrueExpr</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getSharedExprs">Lean.Meta.Sym.getSharedExprs</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.trueExpr">trueExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.getTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.isTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L161-L162">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isTrueExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>e</code> is the internalized <code><a href="../../.././Init/Prelude.html#True">True</a></code> expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isTrueExpr">Lean.Meta.Sym.isTrueExpr</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getTrueExpr">Lean.Meta.Sym.getTrueExpr</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../.././Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.isSameExpr">Lean.Meta.Sym.isSameExpr</a> <span class="fn">e</span> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.isTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.getFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L163-L164">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getFalseExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../.././Init/Prelude.html#False">False</a></code> constant.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getFalseExpr">Lean.Meta.Sym.getFalseExpr</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getSharedExprs">Lean.Meta.Sym.getSharedExprs</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.falseExpr">falseExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.getFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.isFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L165-L166">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isFalseExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>e</code> is the internalized <code><a href="../../.././Init/Prelude.html#False">False</a></code> expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isFalseExpr">Lean.Meta.Sym.isFalseExpr</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getFalseExpr">Lean.Meta.Sym.getFalseExpr</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../.././Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.isSameExpr">Lean.Meta.Sym.isSameExpr</a> <span class="fn">e</span> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.isFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.getBoolTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L167-L168">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getBoolTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getBoolTrueExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../.././Init/Prelude.html#Bool.true">Bool.true</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getBoolTrueExpr">Lean.Meta.Sym.getBoolTrueExpr</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getSharedExprs">Lean.Meta.Sym.getSharedExprs</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.btrueExpr">btrueExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.getBoolTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.isBoolTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L169-L170">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isBoolTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isBoolTrueExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>e</code> is the internalized <code><a href="../../.././Init/Prelude.html#Bool.true">Bool.true</a></code> expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isBoolTrueExpr">Lean.Meta.Sym.isBoolTrueExpr</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getBoolTrueExpr">Lean.Meta.Sym.getBoolTrueExpr</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../.././Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.isSameExpr">Lean.Meta.Sym.isSameExpr</a> <span class="fn">e</span> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.isBoolTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.getBoolFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L171-L172">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getBoolFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getBoolFalseExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../.././Init/Prelude.html#Bool.false">Bool.false</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getBoolFalseExpr">Lean.Meta.Sym.getBoolFalseExpr</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getSharedExprs">Lean.Meta.Sym.getSharedExprs</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.bfalseExpr">bfalseExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.getBoolFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.isBoolFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L173-L174">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isBoolFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isBoolFalseExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>e</code> is the internalized <code><a href="../../.././Init/Prelude.html#Bool.false">Bool.false</a></code> expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isBoolFalseExpr">Lean.Meta.Sym.isBoolFalseExpr</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getBoolFalseExpr">Lean.Meta.Sym.getBoolFalseExpr</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../.././Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.isSameExpr">Lean.Meta.Sym.isSameExpr</a> <span class="fn">e</span> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.isBoolFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.getNatZeroExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L175-L176">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getNatZeroExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getNatZeroExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code>0 : <a href="../../.././Init/Prelude.html#Nat">Nat</a></code> numeral.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getNatZeroExpr">Lean.Meta.Sym.getNatZeroExpr</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getSharedExprs">Lean.Meta.Sym.getSharedExprs</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.natZExpr">natZExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.getNatZeroExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.getOrderingEqExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L177-L178">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getOrderingEqExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getOrderingEqExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../.././Init/Data/Ord/Basic.html#Ordering.eq">Ordering.eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getOrderingEqExpr">Lean.Meta.Sym.getOrderingEqExpr</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getSharedExprs">Lean.Meta.Sym.getSharedExprs</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.ordEqExpr">ordEqExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.getOrderingEqExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.getIntExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L179-L180">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getIntExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">getIntExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../.././Init/Data/Int/Basic.html#Int">Int</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getIntExpr">Lean.Meta.Sym.getIntExpr</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getSharedExprs">Lean.Meta.Sym.getSharedExprs</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.intExpr">intExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.getIntExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.shareCommon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L182-L190">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommon"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">shareCommon</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Applies hash-consing to <code>e</code>. Recall that all expressions in a <code>grind</code> goal have
been hash-consed. We perform this step before we internalize expressions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Sym.shareCommon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.shareCommonInc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L192-L214">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommonInc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">shareCommonInc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Incremental variant of <code><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommon">shareCommon</a></code> for expressions constructed from already-shared subterms.</p><p>Use this when an expression <code>e</code> was produced by a Lean API (e.g., <code><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.inferType">inferType</a></code>, <code>mkApp4</code>) that
does not preserve maximal sharing, but the inputs to that API were already maximally shared.</p><p>Unlike <code><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommon">shareCommon</a></code>, this function does not use a local <code><a href="../../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> ExprPtr Expr</code> to
track visited nodes. This is more efficient when the number of new (unshared) nodes is small,
which is the common case when wrapping API calls that build a few constructor nodes around
shared inputs.</p><p>Example:</p><pre><code>-- `a` and `b` are already maximally shared
let result := mkApp2 f a b  -- result is not maximally shared
let result ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommonInc">shareCommonInc</a> result -- efficiently restore sharing
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Sym.shareCommonInc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.share"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L216-L218">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.share"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">share</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Incremental variant of <code><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommon">shareCommon</a></code> for expressions constructed from already-shared subterms.</p><p>Use this when an expression <code>e</code> was produced by a Lean API (e.g., <code><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.inferType">inferType</a></code>, <code>mkApp4</code>) that
does not preserve maximal sharing, but the inputs to that API were already maximally shared.</p><p>Unlike <code><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommon">shareCommon</a></code>, this function does not use a local <code><a href="../../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> ExprPtr Expr</code> to
track visited nodes. This is more efficient when the number of new (unshared) nodes is small,
which is the common case when wrapping API calls that build a few constructor nodes around
shared inputs.</p><p>Example:</p><pre><code>-- `a` and `b` are already maximally shared
let result := mkApp2 f a b  -- result is not maximally shared
let result ← <a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommonInc">shareCommonInc</a> result -- efficiently restore sharing
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.share">Lean.Meta.Sym.share</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommonInc">Lean.Meta.Sym.shareCommonInc</a> <span class="fn">e</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.share" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.isDebugEnabled"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L220-L222">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isDebugEnabled"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isDebugEnabled</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.sym.debug">sym.debug</a></code> is set</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isDebugEnabled">Lean.Meta.Sym.isDebugEnabled</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.debug">debug</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.isDebugEnabled" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.isDefEqI"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L224-L231">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isDefEqI"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">isDefEqI</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s </span><span class="fn">t</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Similar to <code>Meta.<a href="../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isDefEqI">isDefEqI</a></code>, but the result is cache using pointer equality.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Sym.isDefEqI" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>