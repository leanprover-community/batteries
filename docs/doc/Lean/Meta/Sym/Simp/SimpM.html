<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.Sym.Simp.SimpM</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Lean.Meta.Sym.Simp.SimpM";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">SimpM</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Lean/Meta/Sym/Pattern.html">Lean.Meta.Sym.Pattern</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.Sym.Simp.SimpM" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.Config"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Config</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.Result"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Result</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.instInhabitedResult"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">instInhabitedResult</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.instInhabitedResult.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">instInhabitedResult</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.MethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">MethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.instNonemptyMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">instNonemptyMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.Context"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.Cache"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Cache</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.SimpM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">SimpM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.instInhabitedSimpM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">instInhabitedSimpM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.Simproc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Simproc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.Methods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Methods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.instInhabitedMethods.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">instInhabitedMethods</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.instInhabitedMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">instInhabitedMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.Methods.toMethodsRefImpl"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Methods</span>.<span class="name">toMethodsRefImpl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.Methods.toMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Methods</span>.<span class="name">toMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.MethodsRef.toMethodsImpl"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">MethodsRef</span>.<span class="name">toMethodsImpl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.MethodsRef.toMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">MethodsRef</span>.<span class="name">toMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.getMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">getMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.SimpM.run"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">SimpM</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.SimpM.run'"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">SimpM</span>.<span class="name">run'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.simp"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">simp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.getConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">getConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.getCache"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">getCache</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.pre"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">pre</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.post"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">post</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.withoutModifyingCache"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">withoutModifyingCache</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.Simp.withoutModifyingCacheIfNotWellBehaved"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">withoutModifyingCacheIfNotWellBehaved</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Sym.simp"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">simp</span></a></div></nav><main>
<div class="mod_doc"><h1 id="Structural-Simplifier-for-Symbolic-Simulation" class="markdown-heading">Structural Simplifier for Symbolic Simulation <a class="hover-link" href="#Structural-Simplifier-for-Symbolic-Simulation">#</a></h1><p>It is a specialized simplifier designed for symbolic simulation workloads.
It addresses performance bottlenecks identified in the standard <code><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.simp">simp</a></code> tactic
when applied to large terms typical in symbolic execution.</p><h2 id="Design-Goals" class="markdown-heading">Design Goals <a class="hover-link" href="#Design-Goals">#</a></h2><ol><li><strong>Efficient caching</strong> via pointer-based keys on maximally shared terms</li><li><strong>Fast pattern matching</strong> using the <code>Pattern</code> infrastructure instead of <code>isDefEq</code></li><li><strong>Minimal proof term overhead</strong> by using <code>shareCommon</code> and efficient congruence lemma application</li></ol><h2 id="Key-Performance-Problems-Addressed" class="markdown-heading">Key Performance Problems Addressed <a class="hover-link" href="#Key-Performance-Problems-Addressed">#</a></h2><h3 id="1-Cache-Inefficiency-Hash-Collisions" class="markdown-heading">1. Cache Inefficiency (Hash Collisions) <a class="hover-link" href="#1-Cache-Inefficiency-Hash-Collisions">#</a></h3><p>The standard simplifier uses structural equality for cache keys. With large terms,
hash collisions cause O(n) comparisons that fail, leading to O(n²) behavior.</p><p><strong>Solution:</strong> Require maximally shared input terms (<code>shareCommon</code>) and use
pointer-based cache keys. Structurally equal terms have equal pointers, making
cache lookup O(1).</p><h3 id="2-isDefEq-in-Rewrite-Matching" class="markdown-heading">2. <code>isDefEq</code> in Rewrite Matching <a class="hover-link" href="#2-isDefEq-in-Rewrite-Matching">#</a></h3><p>Profiling shows that <code>isDefEq</code> dominates simplification time in many workloads.
For each candidate rewrite rule, definitional equality checking with metavariable unification
is performed, and sometimes substantial time is spent checking whether the scopes are
compatible.</p><p><strong>Solution:</strong> Use the <code>Pattern</code> infrastructure for syntactic matching:</p><ul><li>No metavariable creation or assignment</li><li>No occurs check (<code>CheckAssignment</code>)</li><li>Direct de Bruijn index comparison</li></ul><h3 id="3-inferType-in-Proof-Construction" class="markdown-heading">3. <code>inferType</code> in Proof Construction <a class="hover-link" href="#3-inferType-in-Proof-Construction">#</a></h3><p>In the standard simplifier, building <code><a href="../../../.././Init/Prelude.html#Eq.trans">Eq.trans</a></code> and <code><a href="../../../.././Init/Prelude.html#congrArg">congrArg</a></code> proofs uses <code>inferType</code> on proof terms,
which reconstructs large expressions and destroys sharing. It often causes O(n²) allocation.</p><p><strong>Solution:</strong></p><ul><li>Never perform <code>inferType</code> on proof terms when constructing congruence and transitivity proofs.</li><li>Use a pointer-based cache for <code>inferType</code> on terms.</li></ul><h3 id="4-funext-Proof-Explosion" class="markdown-heading">4. <code><a href="../../../.././Init/Core.html#funext">funext</a></code> Proof Explosion <a class="hover-link" href="#4-funext-Proof-Explosion">#</a></h3><p>Nested <code><a href="../../../.././Init/Core.html#funext">funext</a></code> applications create O(n²) proof terms due to implicit arguments
<code>{f} {g}</code> of size O(n) repeated n times.</p><p><strong>Solution:</strong> Generate <code>funext_k</code> for k binders at once, stating the implicit
arguments only once.</p><h3 id="5-Binder-Re-entry-Cache-Invalidation" class="markdown-heading">5. Binder Re-entry Cache Invalidation <a class="hover-link" href="#5-Binder-Re-entry-Cache-Invalidation">#</a></h3><p>When a simplification theorem restructures a lambda, re-entering creates a fresh
free variable, invalidating all cached results for subterms.</p><p><strong>Solution:</strong> Reuse free variables across binder re-entry when safe:</p><ul><li>Stack-based approach: reuse when types match on re-entry path</li><li>Instance-aware: track local type class instances separately from hypotheses</li><li>If simplifier doesn't discharge hypotheses from local context, only instances matter</li></ul><h3 id="6-Contextual-ite-Handling" class="markdown-heading">6. Contextual <code><a href="../../../.././Init/Prelude.html#ite">ite</a></code> Handling <a class="hover-link" href="#6-Contextual-ite-Handling">#</a></h3><p>The standard <code><a href="../../../.././Init/SimpLemmas.html#ite_congr">ite_congr</a></code> theorem adds hypotheses when entering branches,
invalidating the cache and causing O(2^n) behavior on conditional trees.</p><p><strong>Solution:</strong> Non-contextual <code><a href="../../../.././Init/Prelude.html#ite">ite</a></code> handling for symbolic simulation:</p><ul><li>Only simplify the condition</li><li>If condition reduces to <code><a href="../../../.././Init/Prelude.html#True">True</a></code>/<code><a href="../../../.././Init/Prelude.html#False">False</a></code>, take the appropriate branch</li><li>Otherwise, keep <code><a href="../../../.././Init/Prelude.html#ite">ite</a></code> symbolic (let the simulator handle case-splitting)</li></ul><h2 id="Architecture" class="markdown-heading">Architecture <a class="hover-link" href="#Architecture">#</a></h2><h3 id="Input-Requirements" class="markdown-heading">Input Requirements <a class="hover-link" href="#Input-Requirements">#</a></h3><ul><li>Terms must be maximally shared via <code>shareCommon</code> like every other module in <code>Sym</code>.</li><li>Enables pointer-based cache keys throughout</li></ul><h3 id="Integration-with-SymM" class="markdown-heading">Integration with SymM <a class="hover-link" href="#Integration-with-SymM">#</a></h3><p><code><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a></code> is designed to work within the <code>SymM</code> symbolic simulation framework:</p><ul><li>Uses <code>BackwardRule</code> for control-flow (monadic bind, match, combinators)</li><li><code><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a></code> handles term simplification between control-flow steps</li><li>Avoids entering control-flow binders</li></ul></div><div class="decl" id="Lean.Meta.Sym.Simp.Config"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L100-L108">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Config"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Config</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Configuration options for the structural simplifier.</p><ul class="structure_fields" id="Lean.Meta.Sym.Simp.Config.mk"><li id="Lean.Meta.Sym.Simp.Config.maxSteps" class="structure_field"><div class="structure_field_info">maxSteps : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Maximum number of steps that can be performed by the simplifier.</p></div></li><li id="Lean.Meta.Sym.Simp.Config.maxDischargeDepth" class="structure_field"><div class="structure_field_info">maxDischargeDepth : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Maximum depth of reentrant simplifier calls through dischargers.
Prevents infinite loops when conditional rewrite rules trigger recursive discharge attempts.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.Simp.Config" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.Result"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L110-L155">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Result</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>The result of simplifying an expression <code>e</code>.</p><p>The <code>done</code> flag controls whether simplification should continue after this result:</p><ul><li><code>done = false</code> (default): Continue with subsequent simplification steps</li><li><code>done = true</code>: Stop processing, return this result as final</li></ul><h2 id="Use-cases-for-done-=-true" class="markdown-heading">Use cases for <code>done = true</code> <a class="hover-link" href="#Use-cases-for-done-=-true">#</a></h2><h3 id="In-pre-simprocs" class="markdown-heading">In <code><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.pre">pre</a></code> simprocs <a class="hover-link" href="#In-pre-simprocs">#</a></h3><p>Skip simplification of certain subterms entirely:</p><pre><code>def skipLambdas : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Simproc">Simproc</a> := fun e =&gt;
  if e.isLambda then return .<a href="../../../.././Init/Prelude.html#rfl">rfl</a> (done := true)
  else return .<a href="../../../.././Init/Prelude.html#rfl">rfl</a>
</code></pre><h3 id="In-post-simprocs" class="markdown-heading">In <code><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.post">post</a></code> simprocs <a class="hover-link" href="#In-post-simprocs">#</a></h3><p>Perform single-pass normalization without recursive simplification:</p><pre><code>def singlePassNormalize : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Simproc">Simproc</a> := fun e =&gt;
  if let some (e', h) ← tryNormalize e then
    return .<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result.step">step</a> e' h (done := true)
  else return .<a href="../../../.././Init/Prelude.html#rfl">rfl</a>
</code></pre><p>With <code>done = true</code>, the result <code>e'</code> won't be recursively simplified.</p><h2 id="Behavior" class="markdown-heading">Behavior <a class="hover-link" href="#Behavior">#</a></h2><p>The <code>done</code> flag affects:</p><ol><li><strong><code>andThen</code> composition</strong>: If the first simproc returns <code>done = true</code>,
the second simproc is skipped.</li><li><strong>Recursive simplification</strong>: After <code><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.pre">pre</a></code> or <code><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.post">post</a></code> returns <code>.<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result.step">step</a> e' h</code>,
<code><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.simp">simp</a></code> normally recurses on <code>e'</code>. With <code>done = true</code>, recursion is skipped.</li></ol><p>The flag is orthogonal to caching: both <code>.<a href="../../../.././Init/Prelude.html#rfl">rfl</a></code> and <code>.<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result.step">step</a></code> results are cached
regardless of the <code>done</code> flag, and cached results are always treated as final.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Sym.Simp.Result.rfl">rfl<span class="decl_args">
<span class="fn">(<span class="fn">done</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result">Result</a><div class="inductive_ctor_doc"><p>No change. If <code>done = true</code>, skip remaining simplification steps for this term.</p></div></li><li class="constructor" id="Lean.Meta.Sym.Simp.Result.step">step<span class="decl_args">
<span class="fn">(<span class="fn">e' </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">done</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result">Result</a><div class="inductive_ctor_doc"><p>Simplified to <code>e'</code> with proof <code>proof : e = e'</code>.
If <code>done = true</code>, skip recursive simplification of <code>e'</code>.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.Simp.Result" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.instInhabitedResult"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L155-L155">source</a></div><div class="attributes">@[instance_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instInhabitedResult"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">instInhabitedResult</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result">Result</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instInhabitedResult">Lean.Meta.Sym.Simp.instInhabitedResult</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instInhabitedResult.default">Lean.Meta.Sym.Simp.instInhabitedResult.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.instInhabitedResult.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L155-L155">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instInhabitedResult.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">instInhabitedResult</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result">Result</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instInhabitedResult.default">Lean.Meta.Sym.Simp.instInhabitedResult.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result.rfl">Lean.Meta.Sym.Simp.Result.rfl</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.instInhabitedResult.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.MethodsRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L158-L158">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.MethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">MethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.MethodsRef">Lean.Meta.Sym.Simp.MethodsRef</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#_private.Lean.Meta.Sym.Simp.SimpM.0.Lean.Meta.Sym.Simp.MethodsRefPointed">Lean.Meta.Sym.Simp.MethodsRefPointed✝</a>.<a href="../../../.././Init/Prelude.html#NonemptyType.type">type</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.MethodsRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.instNonemptyMethodsRef"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L159-L159">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instNonemptyMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">instNonemptyMethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Nonempty">Nonempty</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.MethodsRef">MethodsRef</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Sym.Simp.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L161-L168">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Context"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Read-only context for the simplifier.</p><ul class="structure_fields" id="Lean.Meta.Sym.Simp.Context.mk"><li id="Lean.Meta.Sym.Simp.Context.config" class="structure_field"><div class="structure_field_info">config : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Config">Config</a></div><div class="structure_field_doc"><p>Simplifier configuration options.</p></div></li><li id="Lean.Meta.Sym.Simp.Context.initialLCtxSize" class="structure_field"><div class="structure_field_info">initialLCtxSize : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Size of the local context when simplification started.
Used to determine which free variables were introduced during simplification.</p></div></li><li id="Lean.Meta.Sym.Simp.Context.dischargeDepth" class="structure_field"><div class="structure_field_info">dischargeDepth : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.Simp.Context" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.Cache"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L170-L171">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Cache"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Cache</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Cache mapping expressions (by pointer equality) to their simplified results.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Cache">Lean.Meta.Sym.Simp.Cache</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">Lean.PHashMap</a> <a href="../../../.././Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr">Lean.Meta.Sym.ExprPtr</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result">Lean.Meta.Sym.Simp.Result</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.Cache" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L173-L183">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Mutable state for the simplifier.</p><ul class="structure_fields" id="Lean.Meta.Sym.Simp.State.mk"><li id="Lean.Meta.Sym.Simp.State.numSteps" class="structure_field"><div class="structure_field_info">numSteps : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of steps performed so far.</p></div></li><li id="Lean.Meta.Sym.Simp.State.cache" class="structure_field"><div class="structure_field_info">cache : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Cache">Cache</a></div><div class="structure_field_doc"><p>Cache of previously simplified expressions to avoid redundant work.
<strong>Note</strong>: Consider moving to <code>SymM.<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.State">State</a></code></p></div></li><li id="Lean.Meta.Sym.Simp.State.funext" class="structure_field"><div class="structure_field_info">funext : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr">ExprPtr</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>Cache for generated funext theorems</p></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.Simp.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.SimpM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L185-L186">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">SimpM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Monad for the structural simplifier, layered on top of <code>SymM</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">Lean.Meta.Sym.Simp.SimpM</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.MethodsRef">Lean.Meta.Sym.Simp.MethodsRef</a>
    <span class="fn">(<a href="../../../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Context">Lean.Meta.Sym.Simp.Context</a> <span class="fn">(<a href="../../../.././Init/Control/StateRef.html#StateRefT'">StateRefT'</a> <a href="../../../.././Init/System/IO.html#IO.RealWorld">IO.RealWorld</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.State">Lean.Meta.Sym.Simp.State</a> <a href="../../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">Lean.Meta.Sym.SymM</a>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.SimpM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.instInhabitedSimpM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L188-L189">source</a></div><div class="attributes">@[instance_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instInhabitedSimpM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">instInhabitedSimpM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instInhabitedSimpM">Lean.Meta.Sym.Simp.instInhabitedSimpM</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href="../../../.././Lean/Exception.html#Lean.throwError">Lean.throwError</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;&lt;default&gt;&quot;</span>)</span></span> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.Simproc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L191-L191">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Simproc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Simproc</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Simproc">Lean.Meta.Sym.Simp.Simproc</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">Lean.Meta.Sym.Simp.SimpM</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result">Lean.Meta.Sym.Simp.Result</a></span>)</span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.Simproc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.Methods"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L193-L203">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Methods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Sym.Simp.Methods.mk"><li id="Lean.Meta.Sym.Simp.Methods.pre" class="structure_field"><div class="structure_field_info">pre : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Simproc">Simproc</a></div></li><li id="Lean.Meta.Sym.Simp.Methods.post" class="structure_field"><div class="structure_field_info">post : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Simproc">Simproc</a></div></li><li id="Lean.Meta.Sym.Simp.Methods.wellBehavedMethods" class="structure_field"><div class="structure_field_info">wellBehavedMethods : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.wellBehavedMethods">wellBehavedMethods</a></code> must <strong>not</strong> be set to <code>true</code> IF their behavior
depends on new hypotheses in the local context. For example, for applying
conditional rewrite rules.
Reason: it would prevent us from aggressively caching <code><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.simp">simp</a></code> results.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Sym.Simp.Methods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.instInhabitedMethods.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L203-L203">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instInhabitedMethods.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">instInhabitedMethods</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods">Methods</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instInhabitedMethods.default">Lean.Meta.Sym.Simp.instInhabitedMethods.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.mk">{</a> <span class="fn">pre</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">post</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">wellBehavedMethods</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.instInhabitedMethods.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.instInhabitedMethods"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L203-L203">source</a></div><div class="attributes">@[instance_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instInhabitedMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">instInhabitedMethods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods">Methods</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instInhabitedMethods">Lean.Meta.Sym.Simp.instInhabitedMethods</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.instInhabitedMethods.default">Lean.Meta.Sym.Simp.instInhabitedMethods.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.Methods.toMethodsRefImpl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L205-L206">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.toMethodsRefImpl"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Methods</span>.<span class="name">toMethodsRefImpl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods">Methods</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.MethodsRef">MethodsRef</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">m</span>.<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.toMethodsRefImpl">toMethodsRefImpl</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#unsafeCast">unsafeCast</a> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.Methods.toMethodsRefImpl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.Methods.toMethodsRef"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L208-L209">source</a></div><div class="attributes">@[implemented_by Lean.Meta.Sym.Simp.Methods.toMethodsRefImpl]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.toMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">Methods</span>.<span class="name">toMethodsRef</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods">Methods</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.MethodsRef">MethodsRef</a></div></div></div></div><div class="decl" id="Lean.Meta.Sym.Simp.MethodsRef.toMethodsImpl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L211-L212">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">unsafe abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.MethodsRef.toMethodsImpl"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">MethodsRef</span>.<span class="name">toMethodsImpl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.MethodsRef">MethodsRef</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods">Methods</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">m</span>.<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.MethodsRef.toMethodsImpl">toMethodsImpl</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#unsafeCast">unsafeCast</a> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.MethodsRef.toMethodsImpl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.MethodsRef.toMethods"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L214-L215">source</a></div><div class="attributes">@[implemented_by Lean.Meta.Sym.Simp.MethodsRef.toMethodsImpl]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.MethodsRef.toMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">MethodsRef</span>.<span class="name">toMethods</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.MethodsRef">MethodsRef</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods">Methods</a></div></div></div></div><div class="decl" id="Lean.Meta.Sym.Simp.getMethods"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L217-L218">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.getMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">getMethods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods">Methods</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.getMethods">Lean.Meta.Sym.Simp.getMethods</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadReader.read">read</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.MethodsRef.toMethods">toMethods</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.getMethods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.SimpM.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L220-L223">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM.run"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">SimpM</span>.<span class="name">run</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">methods</span> : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods">Methods</a> := <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.mk">{</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Config">Config</a> := <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Config.mk">{</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Config.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.State">State</a> := <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.State.mk">{</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.State.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.State">State</a>)</span></div></div><p>Runs a <code><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a></code> computation with the given theorems, configuration, and initial state</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.SimpM.run" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.SimpM.run'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L225-L228">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM.run'"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">SimpM</span>.<span class="name">run'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">methods</span> : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods">Methods</a> := <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.mk">{</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Config">Config</a> := <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Config.mk">{</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Config.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <span class="fn">α</span></span></div></div><p>Runs a <code><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a></code> computation with the given theorems and configuration.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.SimpM.run'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.simp"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L230-L231">source</a></div><div class="attributes">@[extern lean_sym_simp]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.simp"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">simp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Simproc">Simproc</a></div></div></div></div><div class="decl" id="Lean.Meta.Sym.Simp.getConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L233-L234">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.getConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">getConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Config">Config</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.getConfig">Lean.Meta.Sym.Simp.getConfig</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Context">Lean.Meta.Sym.Simp.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Context.config">config</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.getConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.getCache"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L236-L237">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.getCache"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">getCache</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Cache">Cache</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.getCache">Lean.Meta.Sym.Simp.getCache</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.State.cache">cache</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.getCache" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.pre"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L239-L240">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.pre"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">pre</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Simproc">Simproc</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.pre">Lean.Meta.Sym.Simp.pre</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.getMethods">Lean.Meta.Sym.Simp.getMethods</a>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.pre">pre</a></span> <span class="fn">e</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.pre" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.post"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L242-L243">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.post"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">post</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Simproc">Simproc</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.post">Lean.Meta.Sym.Simp.post</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.getMethods">Lean.Meta.Sym.Simp.getMethods</a>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.post">post</a></span> <span class="fn">e</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.post" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.withoutModifyingCache"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L245-L248">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.withoutModifyingCache"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">withoutModifyingCache</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.withoutModifyingCache" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.Simp.withoutModifyingCacheIfNotWellBehaved"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L250-L251">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.withoutModifyingCacheIfNotWellBehaved"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">Simp</span>.<span class="name">withoutModifyingCacheIfNotWellBehaved</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM">SimpM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Sym.Simp.withoutModifyingCacheIfNotWellBehaved" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Sym.simp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/SimpM.lean#L255-L256">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.simp"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span>.<span class="name">simp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">methods</span> : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods">Simp.Methods</a> := <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.mk">{</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Methods.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Config">Simp.Config</a> := <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Config.mk">{</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Config.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM">SymM</a> <a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result">Simp.Result</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.simp">Lean.Meta.Sym.simp</a> <span class="fn">e</span> <span class="fn">methods</span> <span class="fn">config</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.simp">Lean.Meta.Sym.Simp.simp</a> <span class="fn">e</span>)</span>.<a href="../../../.././Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM.run'">run'</a></span> <span class="fn">methods</span> <span class="fn">config</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Sym.simp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>