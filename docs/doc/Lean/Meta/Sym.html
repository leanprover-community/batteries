<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.Sym</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Lean.Meta.Sym";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Sym</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Lean/Meta/Sym/AbstractS.html">Lean.Meta.Sym.AbstractS</a></li><li><a href="../.././Lean/Meta/Sym/AlphaShareBuilder.html">Lean.Meta.Sym.AlphaShareBuilder</a></li><li><a href="../.././Lean/Meta/Sym/AlphaShareCommon.html">Lean.Meta.Sym.AlphaShareCommon</a></li><li><a href="../.././Lean/Meta/Sym/Apply.html">Lean.Meta.Sym.Apply</a></li><li><a href="../.././Lean/Meta/Sym/Eta.html">Lean.Meta.Sym.Eta</a></li><li><a href="../.././Lean/Meta/Sym/ExprPtr.html">Lean.Meta.Sym.ExprPtr</a></li><li><a href="../.././Lean/Meta/Sym/Grind.html">Lean.Meta.Sym.Grind</a></li><li><a href="../.././Lean/Meta/Sym/InferType.html">Lean.Meta.Sym.InferType</a></li><li><a href="../.././Lean/Meta/Sym/InstantiateMVarsS.html">Lean.Meta.Sym.InstantiateMVarsS</a></li><li><a href="../.././Lean/Meta/Sym/InstantiateS.html">Lean.Meta.Sym.InstantiateS</a></li><li><a href="../.././Lean/Meta/Sym/Intro.html">Lean.Meta.Sym.Intro</a></li><li><a href="../.././Lean/Meta/Sym/IsClass.html">Lean.Meta.Sym.IsClass</a></li><li><a href="../.././Lean/Meta/Sym/LooseBVarsS.html">Lean.Meta.Sym.LooseBVarsS</a></li><li><a href="../.././Lean/Meta/Sym/MaxFVar.html">Lean.Meta.Sym.MaxFVar</a></li><li><a href="../.././Lean/Meta/Sym/Pattern.html">Lean.Meta.Sym.Pattern</a></li><li><a href="../.././Lean/Meta/Sym/ProofInstInfo.html">Lean.Meta.Sym.ProofInstInfo</a></li><li><a href="../.././Lean/Meta/Sym/ReplaceS.html">Lean.Meta.Sym.ReplaceS</a></li><li><a href="../.././Lean/Meta/Sym/Simp.html">Lean.Meta.Sym.Simp</a></li><li><a href="../.././Lean/Meta/Sym/SymM.html">Lean.Meta.Sym.SymM</a></li><li><a href="../.././Lean/Meta/Sym/Util.html">Lean.Meta.Sym.Util</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.Sym" class="imported-by-list"></ul></details></div></nav><main>
<div class="mod_doc"><h1 id="Symbolic-computation-support" class="markdown-heading">Symbolic computation support. <a class="hover-link" href="#Symbolic-computation-support">#</a></h1><p>This module provides <code>SymM</code>, a monad for implementing symbolic computation (e.g., decision procedures and
verification condition generators) using Lean. The monad addresses performance issues found in symbolic
computation engines built on top of user-facing tactics (e.g., <code>apply</code> and <code>intros</code>).</p><h2 id="Overview" class="markdown-heading">Overview <a class="hover-link" href="#Overview">#</a></h2><p>The <code>SymM</code> monad provides an alternative to tactics built using the <code>MetaM</code> monad. Goals are still represented
by metavariables, but with restrictions that enable more efficient implementations. For example, we cannot
revert or clear local declarations. This simpler metavariable management reduces the complexity of key
operations from O(n log n) to O(1). The definitional equality test is more syntactic and cheaper than
the one available in <code>MetaM</code>. <code>SymM</code> also provides functions for efficiently discharging goals using <code>GrindM</code>.</p><h2 id="Design-decisions" class="markdown-heading">Design decisions <a class="hover-link" href="#Design-decisions">#</a></h2><h3 id="No-revert-or-clear" class="markdown-heading">No <code>revert</code> or <code>clear</code> <a class="hover-link" href="#No-revert-or-clear">#</a></h3><p>In <code>SymM</code>, you cannot revert or clear local declarations, so local contexts grow monotonically.
Each goal is represented by a <code>Grind.Goal</code> object which includes a metavariable.</p><p><strong>Why this restriction?</strong> In standard <code>MetaM</code>, validating a metavariable assignment <code>?m := e</code> requires
traversing <code>e</code>, checking free variables occurring in <code>e</code>, and checking that every nested metavariable
<code>?n</code> in <code>e</code> has a local context compatible with <code>?m</code>'s local context. This uses <code>LocalContext.isSubPrefixOf</code>,
which traverses two <code>PersistentArray</code>s with O(log n) lookups per element, expensive when called frequently.</p><p><strong>The key insight:</strong> Since free variable indices increase monotonically and are never reused, a local
context can be identified by its maximal free variable index. To check whether <code>lctx₁</code> is a sub-prefix
of <code>lctx₂</code>, we only need to verify that <code>lctx₂</code> contains the maximal free variable declared in <code>lctx₁</code>.</p><p><strong>Implementation:</strong> We maintain a mapping <code>maxFVar</code> from expressions to free variables, where <code>maxFVar[e] = x</code>
means <code>x</code> is the free variable with maximal index occurring in <code>e</code>. When assigning <code>?m := e</code>, we check
whether <code>maxFVar[e]</code> is in <code>?m.lctx</code> — a single hash lookup, O(1).</p><p><strong>Maintaining <code>maxFVar</code>:</strong> The mapping is automatically updated when we use <code>getMaxFVar?</code>.</p><h3 id="Structural-matching-and-definitional-equality" class="markdown-heading">Structural matching and definitional equality <a class="hover-link" href="#Structural-matching-and-definitional-equality">#</a></h3><p><strong>The problem:</strong> The <code>isDefEq</code> predicate in <code>MetaM</code> is designed for elaboration and user-facing tactics.
It supports reduction, type-class resolution, and many other features that can be expensive or have
unpredictable running time. For symbolic computation, where pattern matching is called frequently on
large ground terms, these features become performance bottlenecks.</p><p><strong>The solution:</strong> In <code>SymM</code>, pattern matching and definitional equality are restricted to a more syntactic,
predictable subset. Key design choices:</p><ol><li><strong>Reducible declarations are abbreviations.</strong> Reducible declarations are eagerly expanded when indexing
terms and when entering symbolic computation mode. During matching, we assume abbreviations have already
been expanded.</li></ol><p><strong>Why <code>MetaM</code> <code>simp</code> cannot make this assumption</strong>: The simplifier in <code>MetaM</code> is designed for interactive use,
where users want to preserve their abstractions. Even reducible definitions may represent meaningful
abstractions that users may not want unfolded. For example, when applying <code>simp</code> to <code>x ≥ y</code>, users
typically do not want it transformed to <code>y ≤ x</code> just because <code><a href="../.././Init/Prelude.html#GE.ge">GE.ge</a></code> is a reducible abbreviation.</p><ol start="2"><li><p><strong>Proofs are ignored.</strong> We skip proof arguments during matching due to proof irrelevance. Proofs are
&quot;noisy&quot;: they are typically built using different automation or manually, so we can have radically
different proof terms for the same trivial fact.</p></li><li><p><strong>Instances are ignored.</strong> Lean's class hierarchy contains many diamonds. For example, <code><a href="../.././Init/Prelude.html#Add">Add</a> <a href="../.././Init/Prelude.html#Nat">Nat</a></code> can be
obtained directly from the <code><a href="../.././Init/Prelude.html#Nat">Nat</a></code> library or derived from the fact that <code><a href="../.././Init/Prelude.html#Nat">Nat</a></code> is a <code>Semiring</code>. Proof
automation like <code>grind</code> attempts to canonicalize instances, but this is expensive. Instead, we treat
instances as support terms and skip them during matching, and we check them later using the standard
definitionally equality test in a mode where only reducible and instance declarations are unfolded.</p><p><strong>The implicit assumption:</strong> If two terms have the same instance type, they are definitionally equal.
This holds in well-designed Lean code. For example, the <code><a href="../.././Init/Prelude.html#Add">Add</a> <a href="../.././Init/Prelude.html#Nat">Nat</a></code> instance from the <code><a href="../.././Init/Prelude.html#Nat">Nat</a></code> library is
definitionally equal to the one derived from <code>Semiring</code>, and this can be established by unfolding only
reducible and instance declarations. Code that violates this assumption is considered misuse of Lean's
instance system.</p></li><li><p><strong>Types must be indexed.</strong> Unlike proofs and instances, types cannot be ignored, without indexing them,
pattern matching produces too many candidates. Like other abbreviations, type abbreviations are expanded.
Note that given <code>def Foo : Type := Bla</code>, the terms <code>Foo</code> and <code>Bla</code> are <em>not</em> considered structurally
equal in the symbolic computation framework.</p></li></ol><h3 id="Skipping-type-checks-on-assignment" class="markdown-heading">Skipping type checks on assignment <a class="hover-link" href="#Skipping-type-checks-on-assignment">#</a></h3><p><strong>The problem:</strong> In <code>MetaM</code>, assigning <code>?m := v</code> requires checking that <code>typeof(?m)</code> is definitionally
equal to <code>typeof(v)</code>. This is necessary when metavariable types contain unassigned universe or expression
metavariables that must be constrained. For example, applying <code>Exists.intro.{?u} ?α ...</code> requires the
type check to constrain <code>?u</code>.</p><p><strong>The optimization:</strong> When both types are ground (no unassigned metavariables), the check is redundant,
well-typed terms have unique types up to definitional equality, and the types were already checked when
the terms were constructed. <code>SymM</code> tracks whether types are ground and skips the check when possible.
Checks are also skipped when nothing new can be learned from them assuming terms are all well-typed.
For domain-specific constructors (e.g., <code>Exec.seq</code> in symbolic execution), types are typically ground,
so the check is almost always skipped.</p><h3 id="GrindM-state" class="markdown-heading"><code>GrindM</code> state <a class="hover-link" href="#GrindM-state">#</a></h3><p><strong>The problem:</strong> In symbolic computation, we often want to discharge many goals using proof automation such
as <code>grind</code>. Many of these goals share very similar local contexts. If we invoke <code>grind</code> on each goal
independently, we repeatedly reprocess the same hypotheses.</p><p><strong>The solution:</strong> In <code>SymM</code>, we carry the <code>GrindM</code> state across goals and use <code>Grind.Goal</code> instead of
bare metavariables. We also provide APIs for incrementally processing local declarations, so hypotheses
are only processed once.</p></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>