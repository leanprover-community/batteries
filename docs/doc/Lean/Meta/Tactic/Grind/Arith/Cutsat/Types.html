<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../../../.././style.css"></link><link rel="icon" href="../../../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.Tactic.Grind.Arith.Cutsat.Types</title><script defer="true" src="../../../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../../../.././";</script><script>const MODULE_NAME="Lean.Meta.Tactic.Grind.Arith.Cutsat.Types";</script><script type="module" src="../../../../../.././jump-src.js"></script><script type="module" src="../../../../../.././search.js"></script><script type="module" src="../../../../../.././expand-nav.js"></script><script type="module" src="../../../../../.././how-about.js"></script><script type="module" src="../../../../../.././instances.js"></script><script type="module" src="../../../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Tactic</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">Types</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../../../.././Init/Data/Int/Linear.html">Init.Data.Int.Linear</a></li><li><a href="../../../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html">Lean.Meta.Tactic.Grind.ExprPtr</a></li><li><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Util.html">Lean.Meta.Tactic.Grind.Arith.Util</a></li><li><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/CommRing/Types.html">Lean.Meta.Tactic.Grind.Arith.CommRing.Types</a></li><li><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/ToIntInfo.html">Lean.Meta.Tactic.Grind.Arith.Cutsat.ToIntInfo</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.Tactic.Grind.Arith.Cutsat.Types" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instHashablePoly_lean</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean.hash"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instHashablePoly_lean</span>.<span class="name">hash</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.EqCnstr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">EqCnstr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">EqCnstrProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">DvdCnstr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">CooperSplitPred</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.CooperSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">CooperSplit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.CooperSplitProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">CooperSplitProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">DvdCnstrProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.LeCnstr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">LeCnstr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">LeCnstrProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">DiseqCnstr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">DiseqCnstrProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.UnsatProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">UnsatProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.instInhabitedLeCnstr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instInhabitedLeCnstr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.instInhabitedDvdCnstr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instInhabitedDvdCnstr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.instInhabitedCooperSplitPred"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instInhabitedCooperSplitPred</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.instInhabitedCooperSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instInhabitedCooperSplit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.VarSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">VarSet</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Arith.Cutsat.cutsatExt"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">cutsatExt</span></a></div></nav><main>
<div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L18-L18">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instHashablePoly_lean</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean">Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean</a> <a href="../../../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../../../.././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean.hash">Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean.hash</a> <a href="../../../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean.hash"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L18-L18">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean.hash"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instHashablePoly_lean</span>.<span class="name">hash</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a> → <a href="../../../../../.././Init/Prelude.html#UInt64">UInt64</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean.hash">Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean.hash</a> <span class="fn">(<a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly.num">Int.Linear.Poly.num</a> <span class="fn">a</span>)</span></span> <a href="../../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../../../.././Init/Prelude.html#mixHash">mixHash</a> <span class="fn">0</span> <span class="fn">(<a href="../../../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn">a</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.instHashablePoly_lean.hash" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>This module implements a model-based decision procedure for linear integer arithmetic,
inspired by Section 4 of &quot;Cutting to the Chase: Solving Linear Integer Arithmetic&quot;.
Our implementation includes several enhancements and modifications:
Key Features:</p><ul>
<li>Extended constraint support (equality and disequality)</li>
<li>Optimized encoding of <code>Cooper-Left</code> rule using &quot;big&quot;-disjunction instead of fresh variables</li>
<li>Decision variable tracking for case splits (disequalities, <code>Cooper-Left</code>, <code>Cooper-Right</code>)</li>
</ul><p>Constraint Types:
We handle four categories of linear polynomial constraints (where p is a linear polynomial):</p><ol>
<li>Equality:     <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p">p</a> = 0</code></li>
<li>Divisibility: <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr.d">d</a> ∣ <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p">p</a></code></li>
<li>Inequality:   <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p">p</a> ≤ 0</code></li>
<li>Disequality:  <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p">p</a> ≠ 0</code></li>
</ol><p>Implementation Details:</p><ul>
<li>Polynomials use <code><a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Int.Linear.Poly</a></code> with sorted linear monomials (leading monomial contains max variable)</li>
<li>Equalities are eliminated eagerly</li>
<li>Divisibility constraints are maintained in solved form (one constraint per variable) using <code>Div-Solve</code></li>
</ul><p>Model Construction:
The procedure builds a model incrementally, resolving conflicts through constraint generation.
For example:
Given a partial model <code>{x := 1}</code> and constraint <code>3 ∣ 3*y + x + 1</code>:</p><ul>
<li>Cannot extend to <code>y</code> because <code>3 ∣ 3*y + 2</code> is unsatisfiable</li>
<li>Generate implied constraint <code>3 ∣ x + 1</code></li>
<li>Force model update for <code>x</code></li>
</ul><p>Variable Assignment:
When assigning a variable <code>y</code>, we consider:</p><ul>
<li>Best upper and lower bounds (inequalities)</li>
<li>Divisibility constraint</li>
<li>Disequality constraints
<code>Cooper-Left</code> and <code>Cooper-Right</code> rules handle the combination of inequalities and divisibility.
For unsatisfiable disequalities p ≠ 0, we generate case split: <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p">p</a> + 1 ≤ 0 ∨ -p + 1 ≤ 0</code></li>
</ul><p>Contradiction Handling:</p><ul>
<li>Check dependency on decision variables</li>
<li>If independent, use contradiction to close current grind goal</li>
<li>Otherwise, trigger backtracking</li>
</ul><p>Optimization:
We employ rational approximation for model construction:</p><ul>
<li>Continue with rational solutions when integer solutions aren't immediately found</li>
<li>Helps identify simpler unsatisfiability proofs before full integer model construction</li>
</ul></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstr"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L74-L77">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">EqCnstr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><p>A equality constraint and its justification/proof.</p><ul class="structure_fields" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstr.mk"><li id="Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" class="structure_field"><div class="structure_field_info">p : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.EqCnstr.h" class="structure_field"><div class="structure_field_info">h : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.EqCnstr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L79-L112">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">EqCnstrProof</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.core0">core0<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">zero</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a><div class="inductive_ctor_doc"><p>An equality <code>a = 0</code> coming from the core.</p></div></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.core">core<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p₁ </span><span class="fn">p₂</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a><div class="inductive_ctor_doc"><p>An equality <code>a = b</code> coming from the core.
<code>p₁</code> and <code>p₂</code> are the polynomials corresponding to <code>a</code> and <code>b</code>.</p></div></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.coreToInt">coreToInt<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">toIntThm</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Expr">Int.Linear.Expr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.defn">defn<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a><div class="inductive_ctor_doc"><p><code>e</code> is <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p">p</a></code></p></div></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.defnNat">defnNat<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e'</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Expr">Int.Linear.Expr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.norm">norm<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.divCoeffs">divCoeffs<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.subst">subst<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c₁ </span><span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.ofLeGe">ofLeGe<span class="decl_args">
<span class="fn">(<span class="fn">c₁ </span><span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.reorder">reorder<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.commRingNorm">commRingNorm<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/CommRing/Types.html#Lean.Meta.Grind.Arith.CommRing.RingExpr">CommRing.RingExpr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../../../.././Init/Grind/Ring/CommSolver.html#Lean.Grind.CommRing.Poly">CommRing.Poly</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.defnCommRing">defnCommRing<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">re</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/CommRing/Types.html#Lean.Meta.Grind.Arith.CommRing.RingExpr">CommRing.RingExpr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">rp</span> : <a href="../../../../../.././Init/Grind/Ring/CommSolver.html#Lean.Grind.CommRing.Poly">CommRing.Poly</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p'</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.defnNatCommRing">defnNatCommRing<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e'</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Expr">Int.Linear.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">re</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/CommRing/Types.html#Lean.Meta.Grind.Arith.CommRing.RingExpr">CommRing.RingExpr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">rp</span> : <a href="../../../../../.././Init/Grind/Ring/CommSolver.html#Lean.Grind.CommRing.Poly">CommRing.Poly</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p'</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.mul">mul<span class="decl_args">
<span class="fn">(<span class="fn">a?</span> : <span class="fn"><a href="../../../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cs</span> : <span class="fn"><a href="../../../../../.././Init/Prelude.html#Array">Array</a> (<a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../../../.././Init/Data/Int/Basic.html#Int">Int</a> <a href="../../../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.div">div<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <a href="../../../../../.././Init/Data/Int/Basic.html#Int">Int</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">y?</span> : <span class="fn"><a href="../../../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a><div class="inductive_ctor_doc"><p>Linearization proof for <code>/</code></p><ul>
<li>If <code>?y = some y</code>, then it is a proof for <code>a / b = y / <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit.k">k</a></code> where <code>c</code> is a proof that <code>b = <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit.k">k</a></code></li>
<li>If <code>?y = none</code>, then it is a proof for <code>a / b = a/k</code> where <code>c</code> is a proof that <code>b = <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit.k">k</a></code>. <code>a</code> is a numeral in this case.</li>
</ul></div></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.mod">mod<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <a href="../../../../../.././Init/Data/Int/Basic.html#Int">Int</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">y?</span> : <span class="fn"><a href="../../../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a><div class="inductive_ctor_doc"><p>Linearization proof for <code>%</code></p><ul>
<li>If <code>?y = some y</code>, then it is a proof for <code>a % b = y%k</code> where <code>c</code> is a proof that <code>b = <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit.k">k</a></code></li>
<li>If <code>?y = none</code>, then it is a proof for <code>a % b = a%k</code> where <code>c</code> is a proof that <code>b = <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit.k">k</a></code>. <code>a</code> is a numeral in this case.</li>
</ul></div></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof.pow">pow<span class="decl_args">
<span class="fn">(<span class="fn">ka</span> : <a href="../../../../../.././Init/Data/Int/Basic.html#Int">Int</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ca?</span> : <span class="fn"><a href="../../../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">kb</span> : <a href="../../../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cb?</span> : <span class="fn"><a href="../../../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a></span>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof">EqCnstrProof</a></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.EqCnstrProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstr"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L114-L118">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">DvdCnstr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><p>A divisibility constraint and its justification/proof.</p><ul class="structure_fields" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstr.mk"><li id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstr.d" class="structure_field"><div class="structure_field_info">d : <a href="../../../../../.././Init/Data/Int/Basic.html#Int">Int</a></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstr.p" class="structure_field"><div class="structure_field_info">p : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstr.h" class="structure_field"><div class="structure_field_info">h : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.DvdCnstr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L120-L136">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">CooperSplitPred</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><p>The predicate of type <code><a href="../../../../../.././Init/Prelude.html#Nat">Nat</a> → Prop</code>, which serves as the conclusion of the
<code>cooper_left</code>, <code>cooper_right</code>, <code>cooper_dvd_left</code>, and <code>cooper_dvd_right</code> theorems.</p><p>The specific predicate used is determined as follows:</p><ul>
<li><code>cooper_left_split</code> (if <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.left">left</a></code> is <code>true</code> and <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.c₃?">c₃?</a></code> is <code>none</code>)</li>
<li><code>cooper_right_split</code> (if <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.left">left</a></code> is <code>false</code> and <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.c₃?">c₃?</a></code> is <code>none</code>)</li>
<li><code>cooper_dvd_left_split</code> (if <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.left">left</a></code> is <code>true</code> and <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.c₃?">c₃?</a></code> is <code>some</code>)</li>
<li><code>cooper_dvd_right_split</code> (if <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.left">left</a></code> is <code>false</code> and <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.c₃?">c₃?</a></code> is <code>some</code>)</li>
</ul><p>See <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit">CooperSplit</a></code></p><ul class="structure_fields" id="Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.mk"><li id="Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.left" class="structure_field"><div class="structure_field_info">left : <a href="../../../../../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.c₁" class="structure_field"><div class="structure_field_info">c₁ : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.c₂" class="structure_field"><div class="structure_field_info">c₂ : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.c₃?" class="structure_field"><div class="structure_field_info">c₃? : <span class="fn"><a href="../../../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.CooperSplit"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L138-L144">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">CooperSplit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><p>An instance of the <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred">CooperSplitPred</a></code> at <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit.k">k</a></code>.</p><ul class="structure_fields" id="Lean.Meta.Grind.Arith.Cutsat.CooperSplit.mk"><li id="Lean.Meta.Grind.Arith.Cutsat.CooperSplit.pred" class="structure_field"><div class="structure_field_info">pred : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred">CooperSplitPred</a></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.CooperSplit.k" class="structure_field"><div class="structure_field_info">k : <a href="../../../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.CooperSplit.h" class="structure_field"><div class="structure_field_info">h : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitProof">CooperSplitProof</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.CooperSplit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.CooperSplitProof"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L146-L157">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">CooperSplitProof</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><p>The <code>cooper_left</code>, <code>cooper_right</code>, <code>cooper_dvd_left</code>, and <code>cooper_dvd_right</code> theorems have a resulting type
that is a big-or of the form <code>OrOver n (cooper_*_split ...)</code>. The predicate <code>(cooper_*_split ...)</code> has type <code><a href="../../../../../.././Init/Prelude.html#Nat">Nat</a> → Prop</code>.
The <code>cutsat</code> procedure performs case splitting on <code>(cooper_*_split ... (n-1))</code> down to <code>(cooper_*_split ... 1)</code>.
If it derives <code><a href="../../../../../.././Init/Prelude.html#False">False</a></code> from each case, it uses <code>orOver_resolve</code> and <code>orOver_one</code> to deduce the final case,
which has type <code>(cooper_*_split ... 0)</code>.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.CooperSplitProof.dec">dec<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../../../../.././Lean/Expr.html#Lean.FVarId">FVarId</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitProof">CooperSplitProof</a><div class="inductive_ctor_doc"><p>The first <code>n-1</code> cases are decisions (aka case-splits).</p></div></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.CooperSplitProof.last">last<span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../../../../.././Init/Prelude.html#Array">Array</a> (<a href="../../../../../.././Lean/Expr.html#Lean.FVarId">FVarId</a> <a href="../../../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.UnsatProof">UnsatProof</a>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">decVars</span> : <span class="fn"><a href="../../../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../../../.././Lean/Expr.html#Lean.FVarId">FVarId</a></span>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitProof">CooperSplitProof</a><div class="inductive_ctor_doc"><p>The last case which has type <code>(cooper_*_split ... 0)</code></p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.CooperSplitProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L159-L174">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">DvdCnstrProof</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.core">core<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a><div class="inductive_ctor_doc"><p>Given <code>e</code> of the form <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit.k">k</a> ∣ <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p">p</a></code> s.t. <code>e = <a href="../../../../../.././Init/Prelude.html#True">True</a></code> in the core.</p></div></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.coreOfNat">coreOfNat<span class="decl_args">
<span class="fn">(<span class="fn">e </span><span class="fn">thm</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <a href="../../../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Expr">Int.Linear.Expr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.norm">norm<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.divCoeffs">divCoeffs<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.solveCombine">solveCombine<span class="decl_args">
<span class="fn">(<span class="fn">c₁ </span><span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.solveElim">solveElim<span class="decl_args">
<span class="fn">(<span class="fn">c₁ </span><span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.elim">elim<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.ofEq">ofEq<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.subst">subst<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c₁</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.cooper₁">cooper₁<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit">CooperSplit</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.cooper₂">cooper₂<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit">CooperSplit</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a><div class="inductive_ctor_doc"><p><code>c.<a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.c₃?">c₃?</a></code> must be <code>some</code></p></div></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.reorder">reorder<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.commRingNorm">commRingNorm<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/CommRing/Types.html#Lean.Meta.Grind.Arith.CommRing.RingExpr">CommRing.RingExpr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../../../.././Init/Grind/Ring/CommSolver.html#Lean.Grind.CommRing.Poly">CommRing.Poly</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof">DvdCnstrProof</a></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstr"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L176-L179">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">LeCnstr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><p>An inequality constraint and its justification/proof.</p><ul class="structure_fields" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstr.mk"><li id="Lean.Meta.Grind.Arith.Cutsat.LeCnstr.p" class="structure_field"><div class="structure_field_info">p : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.LeCnstr.h" class="structure_field"><div class="structure_field_info">h : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.LeCnstr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L181-L199">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">LeCnstrProof</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.core">core<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.coreNeg">coreNeg<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.coreToInt">coreToInt<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">pos</span> : <a href="../../../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">toIntThm</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Expr">Int.Linear.Expr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.ofNatNonneg">ofNatNonneg<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.bound">bound<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.dec">dec<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../../../../.././Lean/Expr.html#Lean.FVarId">FVarId</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.norm">norm<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.divCoeffs">divCoeffs<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.combine">combine<span class="decl_args">
<span class="fn">(<span class="fn">c₁ </span><span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.combineDivCoeffs">combineDivCoeffs<span class="decl_args">
<span class="fn">(<span class="fn">c₁ </span><span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <a href="../../../../../.././Init/Data/Int/Basic.html#Int">Int</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.subst">subst<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c₁</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.ofLeDiseq">ofLeDiseq<span class="decl_args">
<span class="fn">(<span class="fn">c₁</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr">DiseqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.ofDiseqSplit">ofDiseqSplit<span class="decl_args">
<span class="fn">(<span class="fn">c₁</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr">DiseqCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">decVar</span> : <a href="../../../../../.././Lean/Expr.html#Lean.FVarId">FVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.UnsatProof">UnsatProof</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">decVars</span> : <span class="fn"><a href="../../../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../../../.././Lean/Expr.html#Lean.FVarId">FVarId</a></span>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.cooper">cooper<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit">CooperSplit</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.dvdTight">dvdTight<span class="decl_args">
<span class="fn">(<span class="fn">c₁</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.negDvdTight">negDvdTight<span class="decl_args">
<span class="fn">(<span class="fn">c₁</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.reorder">reorder<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.commRingNorm">commRingNorm<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/CommRing/Types.html#Lean.Meta.Grind.Arith.CommRing.RingExpr">CommRing.RingExpr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../../../.././Init/Grind/Ring/CommSolver.html#Lean.Grind.CommRing.Poly">CommRing.Poly</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof">LeCnstrProof</a></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L201-L204">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">DiseqCnstr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><p>A disequality constraint and its justification/proof.</p><ul class="structure_fields" id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr.mk"><li id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr.p" class="structure_field"><div class="structure_field_info">p : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr.h" class="structure_field"><div class="structure_field_info">h : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof">DiseqCnstrProof</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L206-L220">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">DiseqCnstrProof</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof.core0">core0<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">zero</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof">DiseqCnstrProof</a><div class="inductive_ctor_doc"><p>An disequality <code>a != 0</code> coming from the core. That is, <code>(a = 0) = <a href="../../../../../.././Init/Prelude.html#False">False</a></code> in the core.</p></div></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof.core">core<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p₁ </span><span class="fn">p₂</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof">DiseqCnstrProof</a><div class="inductive_ctor_doc"><p>An disequality <code>a ≠ b</code> coming from the core. That is, <code>(a = b) = <a href="../../../../../.././Init/Prelude.html#False">False</a></code> in the core.
<code>p₁</code> and <code>p₂</code> are the polynomials corresponding to <code>a</code> and <code>b</code>.</p></div></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof.coreToInt">coreToInt<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">toIntThm</span> : <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Expr">Int.Linear.Expr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof">DiseqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof.norm">norm<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr">DiseqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof">DiseqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof.divCoeffs">divCoeffs<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr">DiseqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof">DiseqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof.neg">neg<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr">DiseqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof">DiseqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof.subst">subst<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c₁</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr">DiseqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof">DiseqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof.reorder">reorder<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr">DiseqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof">DiseqCnstrProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof.commRingNorm">commRingNorm<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr">DiseqCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/CommRing/Types.html#Lean.Meta.Grind.Arith.CommRing.RingExpr">CommRing.RingExpr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../../../.././Init/Grind/Ring/CommSolver.html#Lean.Grind.CommRing.Poly">CommRing.Poly</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof">DiseqCnstrProof</a></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.DiseqCnstrProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.UnsatProof"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L222-L231">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.UnsatProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">UnsatProof</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><p>A proof of <code><a href="../../../../../.././Init/Prelude.html#False">False</a></code>.
Remark: We will later add support for a backtracking search inside of cutsat.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.UnsatProof.dvd">dvd<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.UnsatProof">UnsatProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.UnsatProof.le">le<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.UnsatProof">UnsatProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.UnsatProof.eq">eq<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.UnsatProof">UnsatProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.UnsatProof.diseq">diseq<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr">DiseqCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.UnsatProof">UnsatProof</a></li><li class="constructor" id="Lean.Meta.Grind.Arith.Cutsat.UnsatProof.cooper">cooper<span class="decl_args">
<span class="fn">(<span class="fn">c₁ </span><span class="fn">c₂</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c₃</span> : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span>
 : <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.UnsatProof">UnsatProof</a></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.UnsatProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.instInhabitedLeCnstr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L235-L236">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instInhabitedLeCnstr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instInhabitedLeCnstr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instInhabitedLeCnstr">Lean.Meta.Grind.Arith.Cutsat.instInhabitedLeCnstr</a> <a href="../../../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr.mk">{</a> <span class="fn">p</span> := <span class="fn"><a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly.num">Int.Linear.Poly.num</a> <span class="fn">0</span></span>, <span class="fn">h</span> := <span class="fn"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.core">Lean.Meta.Grind.Arith.Cutsat.LeCnstrProof.core</a> <a href="../../../../../.././Init/Prelude.html#Inhabited.default">default</a></span> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr.mk">}</a> <a href="../../../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.instInhabitedDvdCnstr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L238-L239">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instInhabitedDvdCnstr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instInhabitedDvdCnstr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instInhabitedDvdCnstr">Lean.Meta.Grind.Arith.Cutsat.instInhabitedDvdCnstr</a> <a href="../../../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr.mk">{</a> <span class="fn">d</span> := <span class="fn">0</span>, <span class="fn">p</span> := <span class="fn"><a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly.num">Int.Linear.Poly.num</a> <span class="fn">0</span></span>, <span class="fn">h</span> := <span class="fn"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.core">Lean.Meta.Grind.Arith.Cutsat.DvdCnstrProof.core</a> <a href="../../../../../.././Init/Prelude.html#Inhabited.default">default</a></span> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr.mk">}</a> <a href="../../../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.instInhabitedCooperSplitPred"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L241-L242">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instInhabitedCooperSplitPred"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instInhabitedCooperSplitPred</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred">CooperSplitPred</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instInhabitedCooperSplitPred">Lean.Meta.Grind.Arith.Cutsat.instInhabitedCooperSplitPred</a> <a href="../../../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.mk">{</a> <span class="fn">left</span> := <a href="../../../../../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">c₁</span> := <a href="../../../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">c₂</span> := <a href="../../../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">c₃?</span> := <a href="../../../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitPred.mk">}</a> <a href="../../../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.instInhabitedCooperSplit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L244-L245">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instInhabitedCooperSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instInhabitedCooperSplit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit">CooperSplit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instInhabitedCooperSplit">Lean.Meta.Grind.Arith.Cutsat.instInhabitedCooperSplit</a> <a href="../../../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit.mk">{</a> <span class="fn">pred</span> := <a href="../../../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">k</span> := <span class="fn">0</span>, <span class="fn">h</span> := <span class="fn"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplitProof.dec">Lean.Meta.Grind.Arith.Cutsat.CooperSplitProof.dec</a> <a href="../../../../../.././Init/Prelude.html#Inhabited.default">default</a></span> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.CooperSplit.mk">}</a> <a href="../../../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.VarSet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L247-L247">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.VarSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">VarSet</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.VarSet">Lean.Meta.Grind.Arith.Cutsat.VarSet</a> <a href="../../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">Std.TreeSet</a> <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Int.Linear.Var</a> <a href="../../../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.VarSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L249-L371">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././foundational_types.html">Type</a></div></div><p>State of the cutsat procedure.</p><ul class="structure_fields" id="Lean.Meta.Grind.Arith.Cutsat.State.mk"><li id="Lean.Meta.Grind.Arith.Cutsat.State.vars" class="structure_field"><div class="structure_field_info">vars : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>Mapping from variables to their denotations.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.varMap" class="structure_field"><div class="structure_field_info">varMap : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a></span></div><div class="structure_field_doc"><p>Mapping from <code>Expr</code> to a variable representing it.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.vars'" class="structure_field"><div class="structure_field_info">vars' : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p><code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.vars">vars</a></code> before they were reordered.
This array is empty if the variables were not reordered.
We need them to generate the proof term because some
justification objects contain terms using variables before the reordering.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.varMap'" class="structure_field"><div class="structure_field_info">varMap' : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a></span></div><div class="structure_field_doc"><p><code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.varMap">varMap</a></code> before variables were reordered.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.natToIntMap" class="structure_field"><div class="structure_field_info">natToIntMap : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> (<a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></div><div class="structure_field_doc"><p>The field <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.natToIntMap">natToIntMap</a></code> contains a mapping
from a <code><a href="../../../../../.././Init/Prelude.html#Nat">Nat</a></code>-term <code>e</code> to the pair <code>(e', he)</code>, where
<code>he : <a href="../../../../../.././Init/Data/Cast.html#NatCast.natCast">NatCast.natCast</a> e = e'</code></p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.natDef" class="structure_field"><div class="structure_field_info">natDef : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a></span></div><div class="structure_field_doc"><p>Some <code><a href="../../../../../.././Init/Prelude.html#Nat">Nat</a></code> variables encode nested terms such as <code>b+1</code>.
This is a mapping from this kind of variable to the integer variable
representing <code>natCast (b+1)</code>.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.dvds" class="structure_field"><div class="structure_field_info">dvds : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <span class="fn">(<a href="../../../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr">DvdCnstr</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from variables to divisibility constraints. Recall that we keep the divisibility constraint in solved form.
Thus, we have at most one divisibility per variable.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.lowers" class="structure_field"><div class="structure_field_info">lowers : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <span class="fn">(<a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from variables to their &quot;lower&quot; bounds. We say a relational constraint <code>c</code> is a lower bound for a variable <code>x</code>
if <code>x</code> is the maximal variable in <code>c</code>, and <code>x</code> coefficient in <code>c</code> is negative.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.uppers" class="structure_field"><div class="structure_field_info">uppers : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <span class="fn">(<a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.LeCnstr">LeCnstr</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from variables to their &quot;upper&quot; bounds. We say a relational constraint <code>c</code> is a upper bound for a variable <code>x</code>
if <code>x</code> is the maximal variable in <code>c</code>, and <code>x</code> coefficient in <code>c</code> is positive.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.diseqs" class="structure_field"><div class="structure_field_info">diseqs : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <span class="fn">(<a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DiseqCnstr">DiseqCnstr</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from variables to their disequalities. We say a disequality constraint <code>c</code> is a disequality for a variable <code>x</code>
if <code>x</code> is the maximal variable in <code>c</code>.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.elimEqs" class="structure_field"><div class="structure_field_info">elimEqs : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <span class="fn">(<a href="../../../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.EqCnstr">EqCnstr</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from variable to equation constraint used to eliminate it. <code>solved</code> variables should not occur in
<code>dvdCnstrs</code>, <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.lowers">lowers</a></code>, or <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.uppers">uppers</a></code>.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.elimStack" class="structure_field"><div class="structure_field_info">elimStack : <span class="fn"><a href="../../../../../.././Init/Prelude.html#List">List</a> <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a></span></div><div class="structure_field_doc"><p>Elimination stack. For every variable in <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.elimStack">elimStack</a></code>. If <code>x</code> in <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.elimStack">elimStack</a></code>, then <code>elimEqs[x]</code> is not <code>none</code>.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.occurs" class="structure_field"><div class="structure_field_info">occurs : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.VarSet">VarSet</a></span></div><div class="structure_field_doc"><p>Mapping from variable to occurrences. For example, an entry <code>x ↦ {y, z}</code> means that <code>x</code> may occur in <code>dvdCnstrs</code>, <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.lowers">lowers</a></code>, or <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.uppers">uppers</a></code> of
variables <code>y</code> and <code>z</code>.
If <code>x</code> occurs in <code>dvdCnstrs[y]</code>, <code>lowers[y]</code>, or <code>uppers[y]</code>, then <code>y</code> is in <code>occurs[x]</code>, but the reverse is not true.
If <code>x</code> is in <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.elimStack">elimStack</a></code>, then <code>occurs[x]</code> is the empty set.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.assignment" class="structure_field"><div class="structure_field_info">assignment : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../../../.././Init/Data/Rat/Basic.html#Rat">Rat</a></span></div><div class="structure_field_doc"><p>Partial assignment being constructed by cutsat.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.nextCnstrId" class="structure_field"><div class="structure_field_info">nextCnstrId : <a href="../../../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Next unique id for a constraint.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.caseSplits" class="structure_field"><div class="structure_field_info">caseSplits : <a href="../../../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.caseSplits">caseSplits</a></code> is <code>true</code> if cutsat is searching for model and already performed case splits.
This information is used to decide whether a conflict should immediately close the
current <code>grind</code> goal or not.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.conflict?" class="structure_field"><div class="structure_field_info">conflict? : <span class="fn"><a href="../../../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.UnsatProof">UnsatProof</a></span></div><div class="structure_field_doc"><p><code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.conflict?">conflict?</a></code> is <code>some ..</code> if a contradictory constraint was derived.
This field is only set when <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.caseSplits">caseSplits</a></code> is <code>true</code>. Otherwise, we
can convert <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.UnsatProof">UnsatProof</a></code> into a Lean term and close the current <code>grind</code> goal.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.diseqSplits" class="structure_field"><div class="structure_field_info">diseqSplits : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Poly">Poly</a> <a href="../../../../../.././Lean/Expr.html#Lean.FVarId">FVarId</a></span></div><div class="structure_field_doc"><p>Cache decision variables used when splitting on disequalities.
This is necessary because the same disequality may be in different conflicts.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.divMod" class="structure_field"><div class="structure_field_info">divMod : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> (<a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../../../.././Init/Data/Int/Basic.html#Int">Int</a>)</span></div><div class="structure_field_doc"><p>Pairs <code>(x, n)</code> s.t. we have expanded the theorems</p><ul>
<li><code><a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.ediv_emod">Int.Linear.ediv_emod</a></code></li>
<li><code><a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.emod_nonneg">Int.Linear.emod_nonneg</a></code></li>
<li><code><a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.emod_le">Int.Linear.emod_le</a></code></li>
</ul></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.toIntIds" class="structure_field"><div class="structure_field_info">toIntIds : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <span class="fn">(<a href="../../../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from a type <code>α</code> to its corresponding <code>ToIntInfo</code> object idx in <code>toInfos</code>, which contains
the information needed to embed <code>α</code> terms into <code><a href="../../../../../.././Init/Data/Int/Basic.html#Int">Int</a></code> terms.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.toIntInfos" class="structure_field"><div class="structure_field_info">toIntInfos : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/ToIntInfo.html#Lean.Meta.Grind.Arith.Cutsat.ToIntInfo">ToIntInfo</a></span></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.toIntTermMap" class="structure_field"><div class="structure_field_info">toIntTermMap : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/ToIntInfo.html#Lean.Meta.Grind.Arith.Cutsat.ToIntTermInfo">ToIntTermInfo</a></span></div><div class="structure_field_doc"><p>For each type <code>α</code> in <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.toIntInfos">toIntInfos</a></code>, the mapping <code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.toIntVarMap">toIntVarMap</a></code> contains a mapping
from a α-term <code>e</code> to the pair <code>(toInt e, α)</code>.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.toIntVarMap" class="structure_field"><div class="structure_field_info">toIntVarMap : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <a href="../../../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>Mapping from <code>a : α</code> (where <code>ToInt α</code>) to <code>toInt a</code> that has been internalized.
We use this information during model construction.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.usedCommRing" class="structure_field"><div class="structure_field_info">usedCommRing : <a href="../../../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State.usedCommRing">usedCommRing</a></code> is <code>true</code> if the <code>CommRing</code> has been used to normalize expressions.</p></div></li><li id="Lean.Meta.Grind.Arith.Cutsat.State.nonlinearOccs" class="structure_field"><div class="structure_field_info">nonlinearOccs : <span class="fn"><a href="../../../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a> <span class="fn">(<a href="../../../../../.././Init/Prelude.html#List">List</a> <a href="../../../../../.././Init/Data/Int/Linear.html#Int.Linear.Var">Var</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from terms to variables representing nonlinear terms.
For example, suppose the denotation of variable <code>x</code> is the nonlinear term <code>a*b*c</code>,
and <code>y</code> is the nonlinear term <code>a / <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr.d">d</a></code>. Then the mapping contains the entries</p><ul>
<li><code>a ↦ [x, y]</code></li>
<li><code>b ↦ [x]</code></li>
<li><code>c ↦ [x]</code></li>
<li><code><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.DvdCnstr.d">d</a> ↦ [y]</code></li>
</ul></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L371-L371">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instInhabitedState">Lean.Meta.Grind.Arith.Cutsat.instInhabitedState</a> <a href="../../../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instInhabitedState.default">Lean.Meta.Grind.Arith.Cutsat.instInhabitedState.default</a> <a href="../../../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L371-L371">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Arith.Cutsat.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Arith.Cutsat.cutsatExt"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.lean#L373-L373">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.cutsatExt"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Arith</span>.<span class="name">Cutsat</span>.<span class="name">cutsatExt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <a href="../../../../../.././Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.html#Lean.Meta.Grind.Arith.Cutsat.State">State</a></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>