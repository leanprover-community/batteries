<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.Tactic.Grind.ProveEq</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Lean.Meta.Tactic.Grind.ProveEq";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Tactic</span>.<span class="name">Grind</span>.<span class="name">ProveEq</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/ProveEq.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Lean/Meta/Tactic/Grind/Simp.html">Lean.Meta.Tactic.Grind.Simp</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html">Lean.Meta.Tactic.Grind.Types</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.Tactic.Grind.ProveEq" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.proveEq?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">proveEq?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.proveHEq?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">proveHEq?</span></a></div></nav><main>
<div class="mod_doc"><p><code>abstractGroundMismatches?</code> is an auxiliary function for creating auxiliary equality
proofs. When trying to prove <code>lhs = rhs</code>, we use two different approaches. In the first
one, we just internalize the terms, propagate, and then check whether they are in the same
equivalence class. The function <code>abstractGroundMismatches?</code> is used to implement the
second approach that focus on terms containing binders. Here is a motivating example,
suppose we are trying to prove that <code>(b : Bool) → a[i]? = some b → <a href="../../../.././Init/Prelude.html#Nat">Nat</a></code> is equal to
<code>(b : Bool) → some v = some b → <a href="../../../.././Init/Prelude.html#Nat">Nat</a></code> and the goal contains the equivalence class
<code>{a[i]?, some v}</code>.
Congruence closure does not process terms containing free variables, and fails to
prove the equality.
<code>abstractGroundMismatches?</code> extracts ground terms that are equal in the current goal,
and creates an auxiliary function. In the example above, the following two terms
are generated.</p><ul>
<li><code>(fun x =&gt; (b : Bool) → x = some b → Nat) a[i]?</code></li>
<li><code>(fun x =&gt; (b : Bool) → x = some b → Nat) (some v)</code></li>
</ul><p>The two new terms are definitionally equal to the original ones, but congruence
closure will now detect the equality.</p><p>The motivation for this infrastructure is match-expression equalities.
Suppose we have</p><pre><code>match h : assign[v]? with
| none =&gt; ...
| some b =&gt; ...
</code></pre><p>When instantiating the match-expr equations for the <code>none</code> and <code>some</code> cases,
we need to introduce casts.</p></div><div class="mod_doc"><p>Helper functions for creating equalities proofs.</p></div><div class="decl" id="Lean.Meta.Grind.proveEq?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/ProveEq.lean#L169-L215">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/ProveEq.html#Lean.Meta.Grind.proveEq?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">proveEq?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">abstract</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Try to construct a proof that <code>lhs = rhs</code> using the information in the
goal state. If <code>lhs</code> and <code>rhs</code> have not been internalized, this function
will internalize then, process propagated equalities, and then check
whether they are in the same equivalence class or not.
The goal state is not modified by this function.
This function mainly relies on congruence closure, and constraint
propagation. It will not perform case analysis.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.proveEq?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.proveHEq?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/ProveEq.lean#L217-L230">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/ProveEq.html#Lean.Meta.Grind.proveHEq?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">proveHEq?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Similar to <code><a href="../../../.././Lean/Meta/Tactic/Grind/ProveEq.html#Lean.Meta.Grind.proveEq?">proveEq?</a></code>, but for heterogeneous equality.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.proveHEq?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>