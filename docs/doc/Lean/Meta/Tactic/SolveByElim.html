<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.Tactic.SolveByElim</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Lean.Meta.Tactic.SolveByElim";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Lean/LabelAttribute.html">Lean.LabelAttribute</a></li><li><a href="../../.././Init/Data/Sum.html">Init.Data.Sum</a></li><li><a href="../../.././Lean/Elab/Term.html">Lean.Elab.Term</a></li><li><a href="../../.././Lean/Meta/Tactic/Backtrack.html">Lean.Meta.Tactic.Backtrack</a></li><li><a href="../../.././Lean/Meta/Tactic/Constructor.html">Lean.Meta.Tactic.Constructor</a></li><li><a href="../../.././Lean/Meta/Tactic/Repeat.html">Lean.Meta.Tactic.Repeat</a></li><li><a href="../../.././Lean/Meta/Tactic/Symm.html">Lean.Meta.Tactic.Symm</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.Tactic.SolveByElim" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.applyTactics"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">applyTactics</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.applyFirst"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">applyFirst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.ApplyRulesConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">ApplyRulesConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.instCoeBacktrackConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">instCoeBacktrackConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.accept"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">accept</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.mainGoalProc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">mainGoalProc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.intros"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">intros</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.synthInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">synthInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.withDischarge"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">withDischarge</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.introsAfter"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">introsAfter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.constructorAfter"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">constructorAfter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.synthInstanceAfter"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">synthInstanceAfter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.testPartialSolutions"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">testPartialSolutions</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.testSolutions"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">testSolutions</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.requireUsingAll"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">requireUsingAll</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.SolveByElimConfig.processOptions"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">processOptions</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.elabContextLemmas"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">elabContextLemmas</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.applyLemmas"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">applyLemmas</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.applyFirstLemma"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">applyFirstLemma</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.solveByElim"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">solveByElim</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.saturateSymm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">saturateSymm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.applyRules"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">applyRules</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.SolveByElim.mkAssumptionSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">mkAssumptionSet</span></a></div></nav><main>
<div class="mod_doc"><h1 id="solve-by-elim-apply-rules-and-apply-assumption" class="markdown-heading"><code>solve_by_elim</code>, <code>apply_rules</code>, and <code>apply_assumption</code>. <a class="hover-link" href="#solve-by-elim-apply-rules-and-apply-assumption">#</a></h1><p><code>solve_by_elim</code> takes a collection of facts from the local context or
supplied as arguments by the user, and performs a backtracking
depth-first search by attempting to <code>apply</code> these facts to the goal.</p><p>It is a highly configurable tactic, with options to control the
backtracking, to solve multiple goals simultaneously (with backtracking
between goals), or to supply a discharging tactic for unprovable goals.</p><p><code>apply_rules</code> and <code>apply_assumption</code> are much simpler tactics which do
not perform backtracking, but are currently implemented in terms of
<code>solve_by_elim</code> with backtracking disabled, in order to be able to share
the front-end customisation and parsing of user options. It would be
reasonable to further separate these in future.</p></div><div class="decl" id="Lean.Meta.SolveByElim.applyTactics"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L43-L64">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.applyTactics"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">applyTactics</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig">ApplyConfig</a> := <a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.mk">{</a> <a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">transparency</span> : <a href="../../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode">TransparencyMode</a> := <a href="../../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">TransparencyMode.default</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lemmas</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Lean/Meta/Iterator.html#Lean.Meta.Iterator">Meta.Iterator</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span>)</span></span></div></div><p><code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.applyTactics">applyTactics</a> lemmas goal</code> will return an iterator that applies the
lemmas to the goal <code>goal</code> and returns ones that succeed.</p><p>Providing this to the <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.backtracking">backtracking</a></code> tactic,
we can perform backtracking search based on applying a list of lemmas.</p><p><code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.applyTactics">applyTactics</a> (trace := `name)</code> will construct trace nodes for ``name<code>indicating which calls to</code>apply` succeeded or failed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.applyTactics" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.applyFirst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L66-L74">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.applyFirst"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">applyFirst</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig">ApplyConfig</a> := <a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.mk">{</a> <a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">transparency</span> : <a href="../../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode">TransparencyMode</a> := <a href="../../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">TransparencyMode.default</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lemmas</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span></div></div><p><code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.applyFirst">applyFirst</a> lemmas goal</code> applies the first of the <code>lemmas</code>
which can be successfully applied to <code>goal</code>, and fails if none apply.</p><p>We use this in <code>apply_rules</code> and <code>apply_assumption</code> where backtracking is not needed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.applyFirst">Lean.Meta.SolveByElim.applyFirst</a> <span class="fn">cfg</span> <span class="fn">transparency</span> <span class="fn">lemmas</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.applyTactics">Lean.Meta.SolveByElim.applyTactics</a> <span class="fn">cfg</span> <span class="fn">transparency</span> <span class="fn">lemmas</span> <span class="fn">g</span></span>
  <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Lean/Meta/Iterator.html#Lean.Meta.Iterator.head">head</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.applyFirst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.ApplyRulesConfig"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L78-L87">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.ApplyRulesConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">ApplyRulesConfig</span></a></span><span class="decl_extends">extends</span> <a href="../../.././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig">Lean.Meta.Tactic.Backtrack.BacktrackConfig</a>, <a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig">Lean.Meta.ApplyConfig</a><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>The default <code>maxDepth</code> for <code>apply_rules</code> is higher.</p><ul class="structure_fields" id="Lean.Meta.SolveByElim.ApplyRulesConfig.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig.maxDepth">maxDepth</a> : <a href="../../.././Init/Prelude.html#Nat">Nat</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig.proc">proc</a> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span> → <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span>)</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig.suspend">suspend</a> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig.discharge">discharge</a> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span>)</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig.commitIndependentGoals">commitIndependentGoals</a> : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.newGoals">newGoals</a> : <a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyNewGoals">ApplyNewGoals</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.synthAssignedInstances">synthAssignedInstances</a> : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.allowSynthFailures">allowSynthFailures</a> : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.approx">approx</a> : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Lean.Meta.SolveByElim.ApplyRulesConfig.transparency" class="structure_field"><div class="structure_field_info">transparency : <a href="../../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode">TransparencyMode</a></div><div class="structure_field_doc"><p>Transparency mode for calls to <code>apply</code>.</p></div></li><li id="Lean.Meta.SolveByElim.ApplyRulesConfig.symm" class="structure_field"><div class="structure_field_info">symm : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Also use symmetric versions (via <code>@[symm]</code>) of local hypotheses.</p></div></li><li id="Lean.Meta.SolveByElim.ApplyRulesConfig.exfalso" class="structure_field"><div class="structure_field_info">exfalso : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Try proving the goal via <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.ApplyRulesConfig.exfalso">exfalso</a></code> if <code>solve_by_elim</code> otherwise fails.
This is only used when operating on a single goal.</p></div></li></ul><details id="instances-for-list-Lean.Meta.SolveByElim.ApplyRulesConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L89-L108">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span></a></span><span class="decl_extends">extends</span> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.ApplyRulesConfig">Lean.Meta.SolveByElim.ApplyRulesConfig</a><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Configuration structure to control the behaviour of <code>solve_by_elim</code>:</p><ul><li>transparency mode for calls to <code>apply</code></li><li>whether to use <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.ApplyRulesConfig.symm">symm</a></code> on hypotheses and <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.ApplyRulesConfig.exfalso">exfalso</a></code> on the goal as needed,</li><li>see also <code>BacktrackConfig</code> for hooks allowing flow control.</li></ul><ul class="structure_fields" id="Lean.Meta.SolveByElim.SolveByElimConfig.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig.maxDepth">maxDepth</a> : <a href="../../.././Init/Prelude.html#Nat">Nat</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig.proc">proc</a> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span> → <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span>)</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig.suspend">suspend</a> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig.discharge">discharge</a> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span>)</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig.commitIndependentGoals">commitIndependentGoals</a> : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.newGoals">newGoals</a> : <a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyNewGoals">ApplyNewGoals</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.synthAssignedInstances">synthAssignedInstances</a> : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.allowSynthFailures">allowSynthFailures</a> : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.approx">approx</a> : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.ApplyRulesConfig.transparency">transparency</a> : <a href="../../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode">TransparencyMode</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.ApplyRulesConfig.symm">symm</a> : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.ApplyRulesConfig.exfalso">exfalso</a> : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Lean.Meta.SolveByElim.SolveByElimConfig.backtracking" class="structure_field"><div class="structure_field_info">backtracking : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Enable backtracking search.</p></div></li><li id="Lean.Meta.SolveByElim.SolveByElimConfig.intro" class="structure_field"><div class="structure_field_info">intro : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Trying calling <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.intro">intro</a></code> if no lemmas apply.</p></div></li><li id="Lean.Meta.SolveByElim.SolveByElimConfig.constructor" class="structure_field"><div class="structure_field_info">constructor : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Try calling <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.constructor">constructor</a></code> if no lemmas apply.</p></div></li><li id="Lean.Meta.SolveByElim.SolveByElimConfig.suggestions" class="structure_field"><div class="structure_field_info">suggestions : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.suggestions">suggestions</a></code> is <code>true</code>, <code>solve_by_elim</code> will invoke the currently configured library
suggestion engine on the current goal, and attempt to use the resulting suggestions as
additional lemmas.</p></div></li></ul><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.instCoeBacktrackConfig"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L112-L112">source</a></div><div class="attributes">@[instance_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.instCoeBacktrackConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">instCoeBacktrackConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Coe.html#Coe">Coe</a> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> <a href="../../.././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig">Tactic.Backtrack.BacktrackConfig</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.instCoeBacktrackConfig">Lean.Meta.SolveByElim.SolveByElimConfig.instCoeBacktrackConfig</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Coe.html#Coe.mk">{</a> <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">Lean.Meta.SolveByElim.SolveByElimConfig</a>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.ApplyRulesConfig.toBacktrackConfig">toBacktrackConfig</a></span></span> <a href="../../.././Init/Coe.html#Coe.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.accept"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L114-L121">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.accept"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">accept</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> := <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">{</a> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">test</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></div></div><p>Create or modify a <code>Config</code> which allows a class of goals to be returned as subgoals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig.accept" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.mainGoalProc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L123-L133">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mainGoalProc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">mainGoalProc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> := <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">{</a> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">proc</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></div></div><p>Create or modify a <code>Config</code> which runs a tactic on the main goal.
If that tactic fails, fall back to the <code>proc</code> behaviour of <code>cfg</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig.mainGoalProc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.intros"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L135-L140">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.intros"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">intros</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> := <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">{</a> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></div></div><p>Create or modify a <code>Config</code> which calls <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.intro">intro</a></code> on each goal before applying lemmas.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.intros">intros</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mainGoalProc">mainGoalProc</a></span> <span class="fn">fun (<span class="fn">g</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">do
    let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn">g</span>.<a href="../../.././Lean/Meta/Tactic/Intro.html#Lean.MVarId.intro1P">intro1P</a></span>
    <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Init/Prelude.html#List.cons">[</a><span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Init/Prelude.html#Prod.snd">snd</a></span><a href="../../.././Init/Prelude.html#List.cons">]</a></span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig.intros" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.synthInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L142-L149">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.synthInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">synthInstance</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> := <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">{</a> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></div></div><p>Attempt typeclass inference on each goal, before applying lemmas.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.synthInstance">synthInstance</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mainGoalProc">mainGoalProc</a></span> <span class="fn">fun (<span class="fn">g</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">do
    let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn">g</span>.<a href="../../.././Lean/Meta/Tactic/Util.html#Lean.MVarId.getType">getType</a></span>
    let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../.././Lean/Meta/SynthInstance.html#Lean.Meta.synthInstance">Lean.Meta.synthInstance</a> <span class="fn">__do_lift</span></span>
    <span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../.././Lean/MetavarContext.html#Lean.MVarId.assign">assign</a></span> <span class="fn">__do_lift</span></span>
    <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig.synthInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.withDischarge"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L151-L156">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.withDischarge"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">withDischarge</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> := <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">{</a> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">discharge</span> : <span class="fn"><a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></div></div><p>Add a discharging tactic, falling back to the original discharging tactic if it fails.
Return <code>none</code> to return the goal as a new subgoal, or <code>some goals</code> to replace it.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig.withDischarge" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.introsAfter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L158-L160">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.introsAfter"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">introsAfter</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> := <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">{</a> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></div></div><p>Create or modify a <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></code> which calls <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.intro">intro</a></code> on any goal for which no lemma applies.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.introsAfter">introsAfter</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.withDischarge">withDischarge</a></span> <span class="fn">fun (<span class="fn">g</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">do
    let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn">g</span>.<a href="../../.././Lean/Meta/Tactic/Intro.html#Lean.MVarId.intro1P">intro1P</a></span>
    <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option.some">some</a> <a href="../../.././Init/Prelude.html#List.cons">[</a><span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Init/Prelude.html#Prod.snd">snd</a></span><a href="../../.././Init/Prelude.html#List.cons">]</a>)</span></span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig.introsAfter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.constructorAfter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L162-L164">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.constructorAfter"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">constructorAfter</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> := <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">{</a> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></div></div><p>Call <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.constructor">constructor</a></code> when no lemmas apply.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.constructorAfter">constructorAfter</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.withDischarge">withDischarge</a></span> <span class="fn">fun (<span class="fn">g</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">do
    let <span class="fn">a</span> ← <span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../.././Lean/Meta/Tactic/Constructor.html#Lean.MVarId.constructor">constructor</a></span> <a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.mk">{</a> <span class="fn">newGoals</span> := <a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyNewGoals.all">Lean.Meta.ApplyNewGoals.all</a> <a href="../../.././Init/Meta/Defs.html#Lean.Meta.ApplyConfig.mk">}</a></span>
    <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span>)</span></span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig.constructorAfter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.synthInstanceAfter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L166-L171">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.synthInstanceAfter"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">synthInstanceAfter</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> := <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">{</a> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></div></div><p>Create or modify a <code>Config</code> which
calls <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.synthInstance">synthInstance</a></code> on any goal for which no lemma applies.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.synthInstanceAfter">synthInstanceAfter</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.withDischarge">withDischarge</a></span> <span class="fn">fun (<span class="fn">g</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">do
    let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn">g</span>.<a href="../../.././Lean/Meta/Tactic/Util.html#Lean.MVarId.getType">getType</a></span>
    let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../.././Lean/Meta/SynthInstance.html#Lean.Meta.synthInstance">Lean.Meta.synthInstance</a> <span class="fn">__do_lift</span></span>
    <span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../.././Lean/MetavarContext.html#Lean.MVarId.assign">assign</a></span> <span class="fn">__do_lift</span></span>
    <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option.some">some</a> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a>)</span></span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig.synthInstanceAfter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.testPartialSolutions"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L173-L181">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.testPartialSolutions"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">testPartialSolutions</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> := <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">{</a> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">test</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></div></div><p>Create or modify a <code>Config</code> which rejects branches for which <code>test</code>,
applied to the instantiations of the original goals, fails or returns <code>false</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig.testPartialSolutions" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.testSolutions"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L183-L192">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.testSolutions"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">testSolutions</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> := <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">{</a> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">test</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></div></div><p>Create or modify a <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></code> which rejects complete solutions for which <code>test</code>,
applied to the instantiations of the original goals, fails or returns <code>false</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.testSolutions">testSolutions</a></span> <span class="fn">test</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.testPartialSolutions">testPartialSolutions</a></span> <span class="fn">fun (<span class="fn">sols</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>) =&gt;
    <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn"><span class="fn">sols</span>.<a href="../../.././Init/Data/List/Basic.html#List.any">any</a></span> <a href="../../.././Lean/Expr.html#Lean.Expr.hasMVar">Lean.Expr.hasMVar</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">test</span> <span class="fn">sols</span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig.testSolutions" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.requireUsingAll"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L194-L200">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.requireUsingAll"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">requireUsingAll</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> := <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">{</a> <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">use</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></div></div><p>Create or modify a <code>Config</code> which only accept solutions
for which every expression in <code>use</code> appears as a subexpression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.requireUsingAll">requireUsingAll</a></span> <span class="fn">use</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">cfg</span>.<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.testSolutions">testSolutions</a></span> <span class="fn">fun (<span class="fn">sols</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>) =&gt;
    <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">use</span>.<a href="../../.././Init/Data/List/Basic.html#List.all">all</a></span> <span class="fn">fun (<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>) =&gt; <span class="fn"><span class="fn"><span class="fn">sols</span>.<a href="../../.././Init/Data/List/Basic.html#List.any">any</a></span> <span class="fn">fun (<span class="fn">s</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>) =&gt; <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../../.././Lean/Util/FindExpr.html#Lean.Expr.occurs">occurs</a></span> <span class="fn">s</span></span></span></span></span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig.requireUsingAll" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.SolveByElimConfig.processOptions"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L202-L208">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.processOptions"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">SolveByElimConfig</span>.<span class="name">processOptions</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></div></div><p>Process the <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.intro">intro</a></code> and <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig.constructor">constructor</a></code> options by implementing the <code>discharger</code> tactic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.SolveByElimConfig.processOptions" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.elabContextLemmas"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L212-L219">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.elabContextLemmas"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">elabContextLemmas</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lemmas</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Elab.TermElabM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ctx</span> : <span class="fn"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> → <span class="fn"><a href="../../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Elab.TermElabM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Elaborate a list of lemmas and local context.
See <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.mkAssumptionSet">mkAssumptionSet</a></code> for an explanation of why this is needed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.elabContextLemmas" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.applyLemmas"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L221-L226">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.applyLemmas"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">applyLemmas</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lemmas</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Elab.TermElabM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ctx</span> : <span class="fn"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> → <span class="fn"><a href="../../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Elab.TermElabM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Lean/Meta/Iterator.html#Lean.Meta.Iterator">Meta.Iterator</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span>)</span></span></div></div><p>Returns the list of tactics corresponding to applying the available lemmas to the goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.applyLemmas" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.applyFirstLemma"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L228-L233">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.applyFirstLemma"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">applyFirstLemma</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lemmas</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Elab.TermElabM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ctx</span> : <span class="fn"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> → <span class="fn"><a href="../../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Elab.TermElabM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span></div></div><p>Applies the first possible lemma to the goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.applyFirstLemma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.solveByElim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L235-L272">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.solveByElim"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">solveByElim</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lemmas</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Elab.TermElabM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ctx</span> : <span class="fn"><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> → <span class="fn"><a href="../../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Elab.TermElabM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">goals</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span></div></div><p>Solve a collection of goals by repeatedly applying lemmas, backtracking as necessary.</p><p>Arguments:</p><ul><li><code>cfg : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a></code> additional configuration options
(options for <code>apply</code>, maximum depth, and custom flow control)</li><li><code>lemmas : <a href="../../.././Init/Prelude.html#List">List</a> (TermElabM Expr)</code> lemmas to apply.
These are thunks in <code>TermElabM</code> to avoid stuck metavariables.</li><li><code>ctx : TermElabM (List Expr)</code> monadic function returning the local hypotheses to use.</li><li><code>goals : <a href="../../.././Init/Prelude.html#List">List</a> MVarId</code> the initial list of goals for <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.solveByElim">solveByElim</a></code></li></ul><p>Returns a list of suspended goals, if it succeeded on all other subgoals.
By default <code>cfg.suspend</code> is <code>false,</code> <code>cfg.discharge</code> fails, and <code>cfg.failAtMaxDepth</code> is <code>true</code>,
and so the returned list is always empty.
Custom wrappers (e.g. <code>apply_assumption</code> and <code>apply_rules</code>) may modify this behaviour.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.solveByElim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.saturateSymm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L274-L282">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.saturateSymm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">saturateSymm</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">symm</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hyps</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>If <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.ApplyRulesConfig.symm">symm</a></code> is <code>true</code>, then adds in symmetric versions of each hypothesis.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.saturateSymm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.applyRules"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L284-L298">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.MVarId.applyRules"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">applyRules</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">Meta.SolveByElim.SolveByElimConfig</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lemmas</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Elab.TermElabM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">only</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span></div></div><p>A <code>MetaM</code> analogue of the <code>apply_rules</code> user tactic.</p><p>We pass the lemmas as <code>TermElabM Expr</code> rather than just <code>Expr</code>,
so they can be generated fresh for each application, to avoid stuck metavariables.</p><p>By default it uses all local hypotheses, but you can disable this with <code>only := true</code>.
If you need to remove particular local hypotheses, call <code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.solveByElim">solveByElim</a></code> directly.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.MVarId.applyRules" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.SolveByElim.mkAssumptionSet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/SolveByElim.lean#L302-L373">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.mkAssumptionSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">SolveByElim</span>.<span class="name">mkAssumptionSet</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">noDefaults </span><span class="fn">star</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">add </span><span class="fn">remove</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Meta/Defs.html#Lean.Syntax.Term">Term</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">use</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Meta/Defs.html#Lean.Syntax.Ident">Ident</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> (<span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Elab.TermElabM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">(<a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.SolveByElimConfig">SolveByElimConfig</a> → <span class="fn"><a href="../../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Elab.TermElabM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>)</span>)</span></div></div><p><code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.mkAssumptionSet">mkAssumptionSet</a></code> builds a collection of lemmas for use in
the backtracking search in <code>solve_by_elim</code>.</p><ul><li>By default, it includes all local hypotheses, along with <code><a href="../../.././Init/Prelude.html#rfl">rfl</a></code>, <code><a href="../../.././Init/Core.html#trivial">trivial</a></code>, <code><a href="../../.././Init/Prelude.html#congrFun">congrFun</a></code>
and <code><a href="../../.././Init/Prelude.html#congrArg">congrArg</a></code>.</li><li>The flag <code>noDefaults</code> removes these.</li><li>The flag <code>star</code> includes all local hypotheses, but not <code><a href="../../.././Init/Prelude.html#rfl">rfl</a></code>, <code><a href="../../.././Init/Core.html#trivial">trivial</a></code>, <code><a href="../../.././Init/Prelude.html#congrFun">congrFun</a></code>,
or <code><a href="../../.././Init/Prelude.html#congrArg">congrArg</a></code>. (It doesn't make sense to use <code>star</code> without <code>noDefaults</code>.)</li><li>The argument <code>add</code> is the list of terms inside the square brackets that did not have <code>-</code>
and can be used to add expressions or local hypotheses</li><li>The argument <code>remove</code> is the list of terms inside the square brackets that had a <code>-</code>,
and can be used to remove local hypotheses.
(It doesn't make sense to remove expressions which are not local hypotheses,
to remove local hypotheses unless <code>!noDefaults || star</code>,
and it does not make sense to use <code>star</code> unless you remove at least one local hypothesis.)</li></ul><p><code><a href="../../.././Lean/Meta/Tactic/SolveByElim.html#Lean.Meta.SolveByElim.mkAssumptionSet">mkAssumptionSet</a></code> returns not a <code><a href="../../.././Init/Prelude.html#List">List</a> expr</code>, but a <code><a href="../../.././Init/Prelude.html#List">List</a> (TermElabM Expr) × TermElabM (List Expr)</code>.
There are two separate problems that need to be solved.</p><h3 id="Stuck-metavariables" class="markdown-heading">Stuck metavariables <a class="hover-link" href="#Stuck-metavariables">#</a></h3><p>Lemmas with implicit arguments would be filled in with metavariables if we created the
<code>Expr</code> objects immediately, so instead we return thunks that generate the expressions
on demand. This is the first component, with type <code><a href="../../.././Init/Prelude.html#List">List</a> (TermElabM Expr)</code>.</p><p>As an example, we have <code>def <a href="../../.././Init/Prelude.html#rfl">rfl</a> : ∀ {α : Sort u} {a : α}, a = a</code>, which on elaboration will become
<code>@rfl ?m_1 ?m_2</code>.</p><p>Because <code>solve_by_elim</code> works by repeated application of lemmas against subgoals,
the first time such a lemma is successfully applied,
those metavariables will be unified, and thereafter have fixed values.
This would make it impossible to apply the lemma
a second time with different values of the metavariables.</p><p>See <a href="https://github.com/leanprover-community/mathlib/issues/2269">https://github.com/leanprover-community/mathlib/issues/2269</a></p><h3 id="Relevant-local-hypotheses" class="markdown-heading">Relevant local hypotheses <a class="hover-link" href="#Relevant-local-hypotheses">#</a></h3><p><code>solve_by_elim*</code> works with multiple goals,
and we need to use separate sets of local hypotheses for each goal.
The second component of the returned value provides these local hypotheses.
(Essentially using <code>getLocalHyps</code>, along with some filtering to remove hypotheses
that have been explicitly removed via <code>only</code> or <code>[-h]</code>.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.SolveByElim.mkAssumptionSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>