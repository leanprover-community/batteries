<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.DiscrTree.Main</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Lean.Meta.DiscrTree.Main";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">Main</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Lean/Meta/Basic.html">Lean.Meta.Basic</a></li><li><a href="../../.././Lean/Meta/WHNF.html">Lean.Meta.WHNF</a></li><li><a href="../../.././Lean/Meta/DiscrTree/Basic.html">Lean.Meta.DiscrTree.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.DiscrTree.Main" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DiscrTree.Key.arity"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">Key</span>.<span class="name">arity</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DiscrTree.reduce"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">reduce</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DiscrTree.reduceDT"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">reduceDT</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DiscrTree.mkPathAux"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">mkPathAux</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DiscrTree.mkPath"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">mkPath</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DiscrTree.insert"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">insert</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DiscrTree.insertIfSpecific"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">insertIfSpecific</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DiscrTree.getMatch"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">getMatch</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DiscrTree.getMatchWithExtra"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">getMatchWithExtra</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DiscrTree.getMatchKeyRootFor"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">getMatchKeyRootFor</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DiscrTree.getMatchLiberal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">getMatchLiberal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DiscrTree.getUnify"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">getUnify</span></a></div></nav><main>
<div class="mod_doc"><p>(Imperfect) discrimination trees.
We use a hybrid representation.</p><ul><li>A <code>PersistentHashMap</code> for the root node which usually contains many children.</li><li>A sorted array of key/node pairs for inner nodes.</li></ul><p>The edges are labeled by keys:</p><ul><li>Constant names (and arity). Universe levels are ignored.</li><li>Free variables (and arity). Thus, an entry in the discrimination tree
may reference hypotheses from the local context.</li><li>Literals</li><li>Star/Wildcard. We use them to represent metavariables and terms
we want to ignore. We ignore implicit arguments and proofs.</li><li>Other. We use to represent other kinds of terms (e.g., nested lambda, forall, sort, etc).</li></ul><p>We reduce terms using <code>TransparencyMode.reducible</code>. Thus, all reducible
definitions in an expression <code>e</code> are unfolded before we insert it into the
discrimination tree.</p><p>Recall that projections from classes are <strong>NOT</strong> reducible.
For example, the expressions <code><a href="../../.././Init/Prelude.html#Add.add">Add.add</a> α (ringAdd ?α ?s) ?x ?x</code>
and <code><a href="../../.././Init/Prelude.html#Add.add">Add.add</a> <a href="../../.././Init/Prelude.html#Nat">Nat</a> Nat.hasAdd a b</code> generates paths with the following keys
respectively</p><pre><code>⟨Add.add, 4⟩, α, *, *, *
⟨Add.add, 4⟩, Nat, *, ⟨a,0⟩, ⟨b,0⟩
</code></pre><p>That is, we don't reduce <code><a href="../../.././Init/Prelude.html#Add.add">Add.add</a> <a href="../../.././Init/Prelude.html#Nat">Nat</a> inst a b</code> into <code><a href="../../.././Init/Prelude.html#Nat.add">Nat.add</a> a b</code>.
We say the <code><a href="../../.././Init/Prelude.html#Add.add">Add.add</a></code> applications are the de-facto canonical forms in
the metaprogramming framework.
Moreover, it is the metaprogrammer's responsibility to re-pack applications such as
<code><a href="../../.././Init/Prelude.html#Nat.add">Nat.add</a> a b</code> into <code><a href="../../.././Init/Prelude.html#Add.add">Add.add</a> <a href="../../.././Init/Prelude.html#Nat">Nat</a> inst a b</code>.</p><p>Remark: we store the arity in the keys
1- To be able to implement the &quot;skip&quot; operation when retrieving &quot;candidate&quot;
unifiers.
2- Distinguish partial applications <code>f a</code>, <code>f a b</code>, and <code>f a b c</code>.</p></div><div class="decl" id="Lean.Meta.DiscrTree.Key.arity"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean#L53-L67">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.Key.arity"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">Key</span>.<span class="name">arity</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree.Key">Key</a> → <a href="../../.././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree.Key.const">Lean.Meta.DiscrTree.Key.const</a> <span class="fn">a</span> <span class="fn">a_1</span>)</span>.<a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.Key.arity">arity</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a_1</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree.Key.fvar">Lean.Meta.DiscrTree.Key.fvar</a> <span class="fn">a</span> <span class="fn">a_1</span>)</span>.<a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.Key.arity">arity</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a_1</span></li><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree.Key.arrow">Lean.Meta.DiscrTree.Key.arrow</a>.<a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.Key.arity">arity</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">1</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree.Key.proj">Lean.Meta.DiscrTree.Key.proj</a> <span class="fn">a</span> <span class="fn">a_1</span> <span class="fn">a_2</span>)</span>.<a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.Key.arity">arity</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">1</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a_2</span></li><li class="equation"><span class="fn"><span class="fn">x✝</span>.<a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.Key.arity">arity</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></li></ul></details><details id="instances-for-list-Lean.Meta.DiscrTree.Key.arity" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.DiscrTree.reduce"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean#L201-L210">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.reduce"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">reduce</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Reduction procedure for the discrimination tree indexing.</p></div></div><div class="decl" id="Lean.Meta.DiscrTree.reduceDT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean#L243-L245">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.reduceDT"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">reduceDT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">root</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>whnf for the discrimination tree module</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.reduceDT">Lean.Meta.DiscrTree.reduceDT</a> <span class="fn">e</span> <span class="fn">root</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn">root</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Main.html#_private.Lean.Meta.DiscrTree.Main.0.Lean.Meta.DiscrTree.reduceUntilBadKey">Lean.Meta.DiscrTree.reduceUntilBadKey✝</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.reduce">Lean.Meta.DiscrTree.reduce</a> <span class="fn">e</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.DiscrTree.reduceDT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.DiscrTree.mkPathAux"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean#L316-L324">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.mkPathAux"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">mkPathAux</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">root</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">todo</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">keys</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree.Key">Key</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">noIndexAtArgs</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree.Key">Key</a>)</span></span></div></div><p>When <code>noIndexAtArgs := true</code>, <code>pushArgs</code> assumes function application arguments have a <code>no_index</code> annotation.
That is, <code>f a b</code> is indexed as it was <code>f (no_index a) (no_index b)</code>.
This feature is used when indexing local proofs in the simplifier. This is useful in examples like the one described on issue #2670.
In this issue, we have a local hypotheses <code>(h : ∀ p : α × β, f p p.2 = p.2)</code>, and users expect it to be applicable to
<code>f (a, b) b = b</code>. This worked in Lean 3 since no indexing was used. We can retrieve Lean 3 behavior by writing
<code>(h : ∀ p : α × β, f p (no_index p.2) = p.2)</code>, but this is very inconvenient when the hypotheses was not written by the user in first place.
For example, it was introduced by another tactic. Thus, when populating the discrimination tree explicit arguments provided to <code>simp</code> (e.g., <code>simp [h]</code>),
we use <code>noIndexAtArgs := true</code>. See comment: <a href="https://github.com/leanprover/lean4/issues/2670#issuecomment-1758889365">https://github.com/leanprover/lean4/issues/2670#issuecomment-1758889365</a></p></div></div><div class="decl" id="Lean.Meta.DiscrTree.mkPath"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean#L328-L333">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.mkPath"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">mkPath</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">noIndexAtArgs</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree.Key">Key</a>)</span></span></div></div><p>When <code>noIndexAtArgs := true</code>, <code>pushArgs</code> assumes function application arguments have a <code>no_index</code> annotation.
That is, <code>f a b</code> is indexed as it was <code>f (no_index a) (no_index b)</code>.
This feature is used when indexing local proofs in the simplifier. This is useful in examples like the one described on issue #2670.
In this issue, we have a local hypotheses <code>(h : ∀ p : α × β, f p p.2 = p.2)</code>, and users expect it to be applicable to
<code>f (a, b) b = b</code>. This worked in Lean 3 since no indexing was used. We can retrieve Lean 3 behavior by writing
<code>(h : ∀ p : α × β, f p (no_index p.2) = p.2)</code>, but this is very inconvenient when the hypotheses was not written by the user in first place.
For example, it was introduced by another tactic. Thus, when populating the discrimination tree explicit arguments provided to <code>simp</code> (e.g., <code>simp [h]</code>),
we use <code>noIndexAtArgs := true</code>. See comment: <a href="https://github.com/leanprover/lean4/issues/2670#issuecomment-1758889365">https://github.com/leanprover/lean4/issues/2670#issuecomment-1758889365</a></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.DiscrTree.mkPath" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.DiscrTree.insert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean#L335-L337">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.insert"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree">DiscrTree</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">noIndexAtArgs</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree">DiscrTree</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">d</span>.<a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.insert">insert</a></span> <span class="fn">e</span> <span class="fn">v</span> <span class="fn">noIndexAtArgs</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">keys</span> ← <span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.mkPath">Lean.Meta.DiscrTree.mkPath</a> <span class="fn">e</span> <span class="fn">noIndexAtArgs</span></span>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">d</span>.<a href="../../.././Lean/Meta/DiscrTree/Basic.html#Lean.Meta.DiscrTree.insertKeyValue">insertKeyValue</a></span> <span class="fn">keys</span> <span class="fn">v</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.DiscrTree.insert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.DiscrTree.insertIfSpecific"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean#L339-L348">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.insertIfSpecific"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">insertIfSpecific</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree">DiscrTree</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">noIndexAtArgs</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree">DiscrTree</a> <span class="fn">α</span>)</span></span></div></div><p>Inserts a value into a discrimination tree,
but only if its key is not of the form <code>#[*]</code> or <code>#[=, *, *, *]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.DiscrTree.insertIfSpecific" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.DiscrTree.getMatch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean#L480-L484">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.getMatch"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">getMatch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree">DiscrTree</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span>)</span></span></div></div><p>Find values that match <code>e</code> in <code>d</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">d</span>.<a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.getMatch">getMatch</a></span> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Main.html#_private.Lean.Meta.DiscrTree.Main.0.Lean.Meta.DiscrTree.getMatchCore">Lean.Meta.DiscrTree.getMatchCore✝</a> <span class="fn">d</span> <span class="fn">e</span></span>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../.././Init/Prelude.html#Prod.snd">snd</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.DiscrTree.getMatch" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.DiscrTree.getMatchWithExtra"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean#L486-L516">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.getMatchWithExtra"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">getMatchWithExtra</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree">DiscrTree</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Init/Prelude.html#Nat">Nat</a>))</span></span></div></div><p>Similar to <code><a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.getMatch">getMatch</a></code>, but returns solutions that are prefixes of <code>e</code>.
We store the number of ignored arguments in the result.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.DiscrTree.getMatchWithExtra" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.DiscrTree.getMatchKeyRootFor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean#L518-L535">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.getMatchKeyRootFor"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">getMatchKeyRootFor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> (<a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree.Key">Key</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></div></div><p>Return the root symbol for <code>e</code>, and the number of arguments after <code><a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.reduceDT">reduceDT</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.DiscrTree.getMatchKeyRootFor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.DiscrTree.getMatchLiberal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean#L553-L565">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.getMatchLiberal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">getMatchLiberal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree">DiscrTree</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> (<span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></div></div><p>A liberal version of <code><a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.getMatch">getMatch</a></code> which only takes the root symbol of <code>e</code> into account.
We use this method to simulate Lean 3's indexing.</p><p>The natural number in the result is the number of arguments in <code>e</code> after <code><a href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.reduceDT">reduceDT</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.DiscrTree.getMatchLiberal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.DiscrTree.getUnify"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/DiscrTree/Main.lean#L567-L606">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Meta/DiscrTree/Main.html#Lean.Meta.DiscrTree.getUnify"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DiscrTree</span>.<span class="name">getUnify</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Lean/Meta/DiscrTree/Types.html#Lean.Meta.DiscrTree">DiscrTree</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.DiscrTree.getUnify" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>