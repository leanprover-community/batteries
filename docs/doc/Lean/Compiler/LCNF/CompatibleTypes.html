<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Compiler.LCNF.CompatibleTypes</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Lean.Compiler.LCNF.CompatibleTypes";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Compiler</span>.<span class="name">LCNF</span>.<span class="name">CompatibleTypes</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Compiler/LCNF/CompatibleTypes.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Lean/Compiler/LCNF/InferType.html">Lean.Compiler.LCNF.InferType</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Compiler.LCNF.CompatibleTypes" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Compiler.LCNF.compatibleTypesQuick"><span class="name">Lean</span>.<span class="name">Compiler</span>.<span class="name">LCNF</span>.<span class="name">compatibleTypesQuick</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Compiler.LCNF.InferType.compatibleTypesFull"><span class="name">Lean</span>.<span class="name">Compiler</span>.<span class="name">LCNF</span>.<span class="name">InferType</span>.<span class="name">compatibleTypesFull</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Compiler.LCNF.InferType.compatibleTypes"><span class="name">Lean</span>.<span class="name">Compiler</span>.<span class="name">LCNF</span>.<span class="name">InferType</span>.<span class="name">compatibleTypes</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Compatible-Types">Compatible Types <a class="hover-link" href="#Compatible-Types">#</a></h1><p>We used to type check LCNF after each compiler pass. However, we disable this capability because cast management was too costly.
The casts may be needed to ensure the result of each pass is still typeable.
However, these sanity checks are useful for catching silly mistakes.
Thus, we have added an &quot;LCNF type linter&quot;. When turned on, this &quot;linter&quot; option instructs the compiler to perform compatibility type checking
in the LCNF code after some compiler passes.
Recall most casts are only needed in functions that make heavy use of dependent types.
We claim it is &quot;defensible&quot; to say this sanity checker is a linter. If the sanity checker fails, it means the user is &quot;abusing&quot; dependent types
and performance may suffer at runtime.
Here is an example of code that &quot;abuses&quot; dependent types:</p><pre><code>@[expose] def Tuple (α : Type u) : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → Type u
  | 0   =&gt; <a href="../../.././Init/Prelude.html#PUnit">PUnit</a>
  | 1   =&gt; α
  | n+2 =&gt; α × Tuple α (n+1)

def mkConstTuple (a : α) : (n : Nat) → Tuple α n
  | 0 =&gt; ⟨⟩
  | 1 =&gt; a
  | n+2 =&gt; (a, mkConstTuple a (n+1))

def Tuple.map (f : α → β) (xs : Tuple α n) : Tuple β n :=
  match n with
  | 0 =&gt; ⟨⟩
  | 1 =&gt; f xs
  | _+2 =&gt; match xs with
    | (a, xs) =&gt; (f a, Tuple.map f xs)
</code></pre></div><div class="decl" id="Lean.Compiler.LCNF.compatibleTypesQuick"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Compiler/LCNF/CompatibleTypes.lean#L48-L73">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.compatibleTypesQuick"><span class="name">Lean</span>.<span class="name">Compiler</span>.<span class="name">LCNF</span>.<span class="name">compatibleTypesQuick</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>Quick check for <code><a href="../../.././Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypes">compatibleTypes</a></code>. It is not monadic, but it is incomplete
because it does not eta-expand type formers. See comment at <code><a href="../../.././Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypes">compatibleTypes</a></code>.
Remark: if the result is <code>true</code>, then <code>a</code> and <code>b</code> are indeed compatible.
If it is <code>false</code>, we must use the full-check.</p></div></div><div class="decl" id="Lean.Compiler.LCNF.InferType.compatibleTypesFull"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Compiler/LCNF/CompatibleTypes.lean#L75-L124">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypesFull"><span class="name">Lean</span>.<span class="name">Compiler</span>.<span class="name">LCNF</span>.<span class="name">InferType</span>.<span class="name">compatibleTypesFull</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.InferTypeM">InferTypeM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Complete check for <code><a href="../../.././Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypes">compatibleTypes</a></code>. It eta-expands type formers. See comment at <code><a href="../../.././Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypes">compatibleTypes</a></code>.</p></div></div><div class="decl" id="Lean.Compiler.LCNF.InferType.compatibleTypes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Compiler/LCNF/CompatibleTypes.lean#L126-L148">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypes"><span class="name">Lean</span>.<span class="name">Compiler</span>.<span class="name">LCNF</span>.<span class="name">InferType</span>.<span class="name">compatibleTypes</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.InferTypeM">InferTypeM</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Return true if the LCNF types <code>a</code> and <code>b</code> are compatible.
Remark: <code>a</code> and <code>b</code> can be type formers (e.g., <code><a href="../../.././Init/Prelude.html#List">List</a></code>, or <code>fun (α : Type) =&gt; <a href="../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../.././Init/Prelude.html#Nat">Nat</a> × α</code>)
Remark: We may need to eta-expand type formers to establish whether they are compatible or not.
For example, suppose we have</p><pre><code>fun (x : B) =&gt; <a href="../../.././Init/Control/Id.html#Id">Id</a> B ◾ ◾
<a href="../../.././Init/Control/Id.html#Id">Id</a> B ◾
</code></pre><p>We must eta-expand <code><a href="../../.././Init/Control/Id.html#Id">Id</a> B ◾</code> to <code>fun (x : B) =&gt; <a href="../../.././Init/Control/Id.html#Id">Id</a> B ◾ x</code>. Note that, we use <code>x</code> instead of <code>◾</code> to
make the implementation simpler and skip the check whether <code>B</code> is a type former type. However,
this simplification should not affect correctness since <code>◾</code> is compatible with everything.
Remark: see comment at <code>isErasedCompatible</code>.
Remark: because of &quot;erasure confusion&quot; see note above, we assume <code>◾</code> (aka <code>lcErasure</code>) is compatible with everything.
This is a simplification. We used to use <code>isErasedCompatible</code>, but this only address item 1.
For item 2, we would have to modify the <code>toLCNFType</code> function and make sure a type former is erased if the expected
type is not always a type former (see <code>S.mk</code> type and example in the note above).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypes">Lean.Compiler.LCNF.InferType.compatibleTypes</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../.././Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.compatibleTypesQuick">Lean.Compiler.LCNF.compatibleTypesQuick</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span>
  <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../.././Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypesFull">Lean.Compiler.LCNF.InferType.compatibleTypesFull</a> <span class="fn">a</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-Lean.Compiler.LCNF.InferType.compatibleTypes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>