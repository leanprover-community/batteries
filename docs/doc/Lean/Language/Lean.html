<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Language.Lean</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Lean.Language.Lean";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Lean/Elab/Import.html">Lean.Elab.Import</a></li><li><a href="../.././Lean/Language/Util.html">Lean.Language.Util</a></li><li><a href="../.././Lean/Language/Lean/Types.html">Lean.Language.Lean.Types</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Language.Lean" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.LeanProcessingContext"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">LeanProcessingContext</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.LeanProcessingT"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">LeanProcessingT</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.LeanProcessingM"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">LeanProcessingM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.instMonadLiftLeanProcessingMLeanProcessingTIO"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">instMonadLiftLeanProcessingMLeanProcessingTIO</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.instMonadLiftProcessingTLeanProcessingT"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">instMonadLiftProcessingTLeanProcessingT</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.LeanProcessingM.run"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">LeanProcessingM</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.isBeforeEditPos"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">isBeforeEditPos</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.SetupImportsResult"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">SetupImportsResult</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.reparseOptions"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">reparseOptions</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.experimental.module"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">experimental</span>.<span class="name">module</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.process"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">process</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.processCommands"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">processCommands</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Language.Lean.waitForFinalCmdState?"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">waitForFinalCmdState?</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Note-Incremental-Parsing">Note [Incremental Parsing] <a class="hover-link" href="#Note-Incremental-Parsing">#</a></h1><p>In the language server, we want to minimize the work we do after each edit by reusing previous state
where possible. This is true for both parsing, i.e. reusing syntax trees without running the parser,
and elaboration. For both, we currently assume that we have to reprocess at least everything from
the point of change downwards. This note is about how to find the correct starting point for
incremental parsing; for elaboration, we then start with the first changed syntax tree.</p><p>One initial thought about incremental parsing could be that it's not necessary as parsing is very
fast compared to elaboration; on mathlib we average 41ms parsing per 1000 LoC. But there are quite a
few files &gt;= 1kloc (up to 4.5kloc) in there, so near the end of such files lag from always reparsing
from the beginning may very well be noticeable.</p><p>So if we do want incremental parsing, another thought might be that a user edit can only invalidate
commands at or after the location of the change. Unfortunately, that's not true; take the (partial)
input <code>def a := b private def c</code>. If we remove the space after <code>private</code>, the two commands
syntactically become one with an application of <code>privatedef</code> to <code>b</code> even though the edit was
strictly after the end of the first command.</p><p>So obviously we must include at least the extent of the token that made the parser stop parsing a
command as well such that invalidating the private token invalidates the preceding command.
Unfortunately this is not sufficient either, given the following input:</p><pre><code>structure a where /-- b -/ @[c] private axiom d : <a href="../.././Init/Prelude.html#Nat">Nat</a>
</code></pre><p>This is a syntactically valid sequence of a field-less structure and a declaration. If we again
delete the space after private, it becomes a syntactically correct structure with a single field
privateaxiom! So clearly, because of uses of atomic in the grammar, an edit can affect a command
syntax tree even across multiple tokens.</p><p>What we did in Lean 3 was to always reparse the last command completely preceding the edit location.
If its syntax tree is unchanged, we preserve its data and reprocess all following commands only,
otherwise we reprocess it fully as well. This worked well but did seem a bit arbitrary given that
even if it works for a grammar at some point, it can certainly be extended in ways that break the
assumption.</p><p>With grammar changes in Lean 4, we found that the following example indeed breaks this assumption:</p><pre><code>structure Signature where
  /-- a docstring -/
  Sort : Type
    --^ insert: &quot;s&quot;
</code></pre><p>As the keyword <code>Sort</code> is not a valid start of a structure field and the parser backtracks across the
docstring in that case, this is parsed as the complete command <code>structure Signature where</code> followed
by the partial command <code>/-- a docstring -/ &lt;missing&gt;</code>. If we insert an <code>s</code> after the <code>t</code>, the last
command completely preceding the edit location is the partial command containing the docstring. Thus
we need to go up two commands to ensure we reparse the <code>structure</code> command as well. This kind of
nested docstring is the only part of the grammar to our knowledge that requires going up at least
two commands; as we never backtrack across more than one docstring, going up two commands should
also be sufficient.</p><p>Finally, a more actually principled and generic solution would be to invalidate a syntax tree when
the parser has reached the edit location during parsing. If it did not, surely the edit cannot have
an effect on the syntax tree in question. Sadly such a &quot;high-water mark&quot; parser position does not
exist currently and likely it could at best be approximated by e.g. &quot;furthest <code>tokenFn</code> parse&quot;. Thus
we remain at &quot;go up two commands&quot; at this point.</p></div><div class="mod_doc"><h1 class="markdown-heading" id="Note-Incremental-Command-Elaboration">Note [Incremental Command Elaboration] <a class="hover-link" href="#Note-Incremental-Command-Elaboration">#</a></h1><p>Because of Lean's use of persistent data structures, incremental reuse of fully elaborated commands
is easy because we can simply snapshot the entire state after each command and then restart
elaboration using the stored state at the next command above the point of change. However,
incrementality <em>within</em> elaboration of a single command such as between tactic steps is much harder
because the existing control flow does not allow us to simply return from those points to the
language processor in a way that we can later resume from there. Instead, we exchange the need for
continuations with some limited mutability: by allocating an <code><a href="../.././Init/System/Promise.html#IO.Promise">IO.Promise</a></code> &quot;cell&quot; in the language
processor, we can both pass it to the elaborator to eventually fill it using <code>Promise.resolve</code> as
well as convert it to a <code><a href="../.././Init/Core.html#Task">Task</a></code> that will wait on that resolution using <code>Promise.result</code> and return
it as part of the command snapshot created by the language processor. The elaborator can then in
turn create new promises itself and store their <code>result</code> when resolving an outer promise to create
an arbitrary tree of promise-backed snapshot tasks. Thus, we can enable incremental reporting and
reuse inside the elaborator using the same snapshot tree data structures as outside without having
to change the elaborator's control flow.</p><p>While ideally we would decide what can be reused during command elaboration using strong hashes over
the full state and inputs, currently we rely on simpler syntactic checks: if all the syntax
inspected up to a certain point is unchanged, we can assume that the old state can be reused. The
central <code>SnapshotBundle</code> type passed inwards through the elaborator for this purpose combines the
following data:</p><ul>
<li>the <code><a href="../.././Init/System/Promise.html#IO.Promise">IO.Promise</a></code> to be resolved to an elaborator snapshot (whose type depends on the specific
elaborator part we're in, e.g. <code>TacticParsedSnapshot</code>, <code>BodyProcessedSnapshot</code>)</li>
<li>if there was a previous run:<ul>
<li>a <code>SnapshotTask</code> holding the corresponding snapshot of the run</li>
<li>the relevant <code>Syntax</code> of the previous run to be compared before any reuse</li>
</ul>
</li>
</ul><p>Note that as we do not wait for the previous run to finish before starting to elaborate the next
one, the old <code>SnapshotTask</code> task may not be finished yet. Indeed, if we do find that we can reuse
the contained state because of a successful syntax comparison, we always want to explicitly wait for
the task instead of redoing the work. On the other hand, the <code>Syntax</code> is not surrounded by a task so
that we can immediately access it for comparisons, even if the snapshot task may, eventually, give
access to the same syntax tree.</p><p>For the most part, inside an elaborator participating in incrementality, we just have to ensure that
we stop forwarding the old run's data as soon as we notice a relevant difference between old and new
syntax tree. For example, allowing incrementality inside the cdot tactic combinator is as simple as</p><pre><code>builtin_initialize registerBuiltinIncrementalTactic ``cdot
@[builtin_tactic cdot] def evalTacticCDot : Tactic := fun stx =&gt; do
  ...
  closeUsingOrAdmit do
    -- save state before/after entering focus on `·`
    ...
    Term.withNarrowedArgTacticReuse (argIdx := 1) evalTactic stx
</code></pre><p>The <code>Term.withNarrowedArgTacticReuse</code> combinator will focus on the given argument of <code>stx</code>, which in
this case is the nested tactic sequence, and run <code>evalTactic</code> on it. But crucially, it will first
compare all preceding arguments, in this case the cdot token itself, with the old syntax in the
current snapshot bundle, which in the case of tactics is stored in <code>Term.Context.tacSnap?</code>. Indeed
it is important here to check if the cdot token is identical because its position has been saved in
the info tree, so it would be bad if we later restored some old state that uses a different position
for it even if everything else is unchanged.  If there is any mismatch, the bundle's old value is
set to <code>none</code> in order to prevent reuse from this point on. Note that in any case we still want to
forward the &quot;new&quot; promise in order to provide incremental reporting as well as to construct a
snapshot tree for reuse in future document versions! Note also that we explicitly opted into
incrementality using <code>registerBuiltinIncrementalTactic</code> as any tactic combinator not written with
these concerns in mind would likely misbehave under incremental reuse.</p><p>While it is generally true that we can provide incremental reporting even without reuse, we
generally want to avoid that when it would be confusing/annoying, e.g. when a tactic block is run
multiple times because otherwise the progress bar would snap back and forth multiple times. For this
purpose, we can disable both incremental modes using <code>Term.withoutTacticIncrementality</code>, assuming we
opted into incrementality because of other parts of the combinator. <code>induction</code> is an example of
this because there are some induction alternatives that are run multiple times, so we disable all of
incrementality for them.</p><p>Using <code>induction</code> as a more complex example than <code>cdot</code> as it calls into <code>evalTactic</code> multiple
times, here is a summary of what it has to do to implement incrementality:</p><ul>
<li><code>Narrow</code> down to the syntax of alternatives, disabling reuse if anything before them changed</li>
<li>allocate one new promise for each given alternative, immediately resolve passed promise to a new
snapshot tree node holding them so that the language server can wait on them</li>
<li>when executing an alternative,<ul>
<li>we put the corresponding promise into the context</li>
<li>we disable reuse if anything in front of the contained tactic block has changed, including
previous alternatives</li>
<li>we disable reuse <em>and reporting</em> if the tactic block is run multiple times, e.g. in the case of
a wildcard pattern</li>
</ul>
</li>
</ul></div><div class="decl" id="Lean.Language.Lean.LeanProcessingContext"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L237-L240">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingContext"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">LeanProcessingContext</span></a></span><span class="decl_extends">extends</span> <a href="../.././Lean/Language/Basic.html#Lean.Language.ProcessingContext">Lean.Language.ProcessingContext</a><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Lean-specific processing context.</p><ul class="structure_fields" id="Lean.Language.Lean.LeanProcessingContext.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Lean/Parser/Types.html#Lean.Parser.InputContext.inputString">inputString</a> : <a href="../.././Init/Prelude.html#String">String</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Lean/Parser/Types.html#Lean.Parser.InputContext.fileName">fileName</a> : <a href="../.././Init/Prelude.html#String">String</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Lean/Parser/Types.html#Lean.Parser.InputContext.fileMap">fileMap</a> : <a href="../.././Lean/Data/Position.html#Lean.FileMap">FileMap</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Lean/Parser/Types.html#Lean.Parser.InputContext.endPos">endPos</a> : <a href="../.././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Lean/Parser/Types.html#Lean.Parser.InputContext.endPos_valid">endPos_valid</a> : <span class="fn"><span class="fn">self</span>.<a href="../.././Lean/Parser/Types.html#Lean.Parser.InputContext.endPos">endPos</a></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Lean/Parser/Types.html#Lean.Parser.InputContext.inputString">inputString</a></span>.<a href="../.././Init/Prelude.html#String.endPos">endPos</a></span></div></li><li id="Lean.Language.Lean.LeanProcessingContext.firstDiffPos?" class="structure_field"><div class="structure_field_info">firstDiffPos? : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></span></div><div class="structure_field_doc"><p>Position of the first file difference if there was a previous invocation.</p></div></li></ul><details id="instances-for-list-Lean.Language.Lean.LeanProcessingContext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Language.Lean.LeanProcessingT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L242-L243">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingT"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">LeanProcessingT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> → <a href="../.././foundational_types.html">Type</a> u_1</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u_1</div></div><p>Monad transformer holding all relevant data for Lean processing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingT">Lean.Language.Lean.LeanProcessingT</a> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingContext">Lean.Language.Lean.LeanProcessingContext</a> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Lean.Language.Lean.LeanProcessingT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Language.Lean.LeanProcessingM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L244-L245">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingM"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">LeanProcessingM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Monad holding all relevant data for Lean processing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingM">Lean.Language.Lean.LeanProcessingM</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingT">Lean.Language.Lean.LeanProcessingT</a> <a href="../.././Init/System/IO.html#BaseIO">BaseIO</a></span></li></ul></details><details id="instances-for-list-Lean.Language.Lean.LeanProcessingM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Language.Lean.instMonadLiftLeanProcessingMLeanProcessingTIO"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L247-L248">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.instMonadLiftLeanProcessingMLeanProcessingTIO"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">instMonadLiftLeanProcessingMLeanProcessingTIO</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#MonadLift">MonadLift</a> <a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingM">LeanProcessingM</a> <span class="fn">(<a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingT">LeanProcessingT</a> <a href="../.././Init/System/IO.html#IO">IO</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Language.Lean.instMonadLiftProcessingTLeanProcessingT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L250-L251">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.instMonadLiftProcessingTLeanProcessingT"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">instMonadLiftProcessingTLeanProcessingT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">(<a href="../.././Lean/Language/Basic.html#Lean.Language.ProcessingT">ProcessingT</a> <span class="fn">m</span>)</span> <span class="fn">(<a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingT">LeanProcessingT</a> <span class="fn">m</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Language.Lean.LeanProcessingM.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L253-L262">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingM.run"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">LeanProcessingM</span>.<span class="name">run</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">act</span> : <span class="fn"><a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingM">LeanProcessingM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">oldInputCtx?</span> : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.InputContext">Parser.InputContext</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Language/Basic.html#Lean.Language.ProcessingM">ProcessingM</a> <span class="fn">α</span></span></div></div><p>Embeds a <code><a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingM">LeanProcessingM</a></code> action into <code>ProcessingM</code>, optionally using the old input string to speed
up reuse analysis and supplying a cancellation token that should be triggered as soon as reuse is
ruled out.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Language.Lean.LeanProcessingM.run" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Language.Lean.isBeforeEditPos"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L264-L269">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.isBeforeEditPos"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">isBeforeEditPos</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">pos</span> : <a href="../.././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingM">LeanProcessingM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns true if there was a previous run and the given position is before any textual change
compared to it.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.isBeforeEditPos">Lean.Language.Lean.isBeforeEditPos</a> <span class="fn">pos</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../.././Init/Prelude.html#MonadReader.read">read</a>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../.././Init/Data/Option/Basic.html#Option.any">Option.any</a> <span class="fn">(fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn">pos</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x</span>)</span>)</span> <span class="fn"><span class="fn">__do_lift</span>.<a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingContext.firstDiffPos?">firstDiffPos?</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Language.Lean.isBeforeEditPos" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Language.Lean.SetupImportsResult"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L280-L299">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.SetupImportsResult"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">SetupImportsResult</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Result of retrieving additional metadata about the current file after parsing imports. In the
language server, these are derived from the <code>lake setup-file</code> result. On the cmdline and for similar
simple uses, these can be computed eagerly without looking at the imports.</p><ul class="structure_fields" id="Lean.Language.Lean.SetupImportsResult.mk"><li id="Lean.Language.Lean.SetupImportsResult.mainModuleName" class="structure_field"><div class="structure_field_info">mainModuleName : <a href="../.././Init/Prelude.html#Lean.Name">Name</a></div><div class="structure_field_doc"><p>Module name of the file being processed.</p></div></li><li id="Lean.Language.Lean.SetupImportsResult.isModule" class="structure_field"><div class="structure_field_info">isModule : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Whether the file is participating in the module system.</p></div></li><li id="Lean.Language.Lean.SetupImportsResult.imports" class="structure_field"><div class="structure_field_info">imports : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Setup.html#Lean.Import">Import</a></span></div><div class="structure_field_doc"><p>Direct imports of the file being processed.</p></div></li><li id="Lean.Language.Lean.SetupImportsResult.opts" class="structure_field"><div class="structure_field_info">opts : <a href="../.././Lean/Data/Options.html#Lean.Options">Options</a></div><div class="structure_field_doc"><p>Options provided outside of the file content, e.g. on the cmdline or in the lakefile.</p></div></li><li id="Lean.Language.Lean.SetupImportsResult.trustLevel" class="structure_field"><div class="structure_field_info">trustLevel : <a href="../.././Init/Prelude.html#UInt32">UInt32</a></div><div class="structure_field_doc"><p>Kernel trust level.</p></div></li><li id="Lean.Language.Lean.SetupImportsResult.importArts" class="structure_field"><div class="structure_field_info">importArts : <span class="fn"><a href="../.././Lean/Data/NameMap/Basic.html#Lean.NameMap">NameMap</a> <a href="../.././Lean/Setup.html#Lean.ImportArtifacts">ImportArtifacts</a></span></div><div class="structure_field_doc"><p>Pre-resolved artifacts of transitively imported modules.</p></div></li><li id="Lean.Language.Lean.SetupImportsResult.plugins" class="structure_field"><div class="structure_field_info">plugins : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Init/System/FilePath.html#System.FilePath">System.FilePath</a></span></div><div class="structure_field_doc"><p>Lean plugins to load as part of the environment setup.</p></div></li></ul><details id="instances-for-list-Lean.Language.Lean.SetupImportsResult" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Language.Lean.reparseOptions"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L301-L340">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.reparseOptions"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">reparseOptions</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">opts</span> : <a href="../.././Lean/Data/Options.html#Lean.Options">Options</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/System/IO.html#IO">IO</a> <a href="../.././Lean/Data/Options.html#Lean.Options">Options</a></span></div></div><p>Parses values of options registered during import and left by the C++ frontend as strings.
Removes <code>weak</code> prefixes from both parsed and unparsed options and fails if any option names remain
unknown.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Language.Lean.reparseOptions" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Language.Lean.experimental.module"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L349-L353">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.experimental.module"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">experimental</span>.<span class="name">module</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Allow use of module system</p></div></div><div class="decl" id="Lean.Language.Lean.process"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L355-L778">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.process"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">process</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">setupImports</span> : <span class="fn"><a href="../.././Lean/Elab/Import.html#Lean.Elab.HeaderSyntax">Elab.HeaderSyntax</a> → <span class="fn"><a href="../.././Lean/Language/Basic.html#Lean.Language.ProcessingT">ProcessingT</a> <a href="../.././Init/System/IO.html#IO">IO</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Language/Lean/Types.html#Lean.Language.Lean.HeaderProcessedSnapshot">HeaderProcessedSnapshot</a> <a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.SetupImportsResult">SetupImportsResult</a>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">old?</span> : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Lean/Language/Lean/Types.html#Lean.Language.Lean.InitialSnapshot">InitialSnapshot</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Language/Basic.html#Lean.Language.ProcessingM">ProcessingM</a> <a href="../.././Lean/Language/Lean/Types.html#Lean.Language.Lean.InitialSnapshot">InitialSnapshot</a></span></div></div><p>Entry point of the Lean language processor.</p><p>The <code>setupImports</code> function is called after the header has been parsed and before the first command
is parsed in order to supply additional file metadata (or abort with a given terminal snapshot); see
<code><a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.SetupImportsResult">SetupImportsResult</a></code>.</p><p><code>old?</code> is a previous resulting snapshot, if any, to be reused for incremental processing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.process">Lean.Language.Lean.process</a> <span class="fn">setupImports</span> <span class="fn">old?</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Lean/Language/Lean.html#_private.Lean.Language.Lean.0.Lean.Language.Lean.process.parseHeader">Lean.Language.Lean.process.parseHeader✝</a> <span class="fn">setupImports</span> <span class="fn">old?</span>)</span>.<a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.LeanProcessingM.run">run</a></span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <a href="../.././Lean/Language/Lean/Types.html#Lean.Language.Lean.InitialSnapshot">Lean.Language.Lean.InitialSnapshot</a>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../.././Lean/Language/Lean/Types.html#Lean.Language.Lean.HeaderParsedSnapshot.ictx">ictx</a></span>)</span> <span class="fn">old?</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Language.Lean.process" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Language.Lean.processCommands"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L780-L792">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.processCommands"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">processCommands</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">inputCtx</span> : <a href="../.././Lean/Parser/Types.html#Lean.Parser.InputContext">Parser.InputContext</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">parserState</span> : <a href="../.././Lean/Parser/Module.html#Lean.Parser.ModuleParserState">Parser.ModuleParserState</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">commandState</span> : <a href="../.././Lean/Elab/Command.html#Lean.Elab.Command.State">Elab.Command.State</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">old?</span> : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> (<a href="../.././Lean/Parser/Types.html#Lean.Parser.InputContext">Parser.InputContext</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Language/Lean/Types.html#Lean.Language.Lean.CommandParsedSnapshot">CommandParsedSnapshot</a>)</span> := <a href="../.././Init/Prelude.html#Option.none">none</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <span class="fn">(<a href="../.././Init/Core.html#Task">Task</a> <a href="../.././Lean/Language/Lean/Types.html#Lean.Language.Lean.CommandParsedSnapshot">CommandParsedSnapshot</a>)</span></span></div></div><p>Convenience function for tool uses of the language processor that skips header handling.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Language.Lean.processCommands" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Language.Lean.waitForFinalCmdState?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Language/Lean.lean#L794-L803">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Language/Lean.html#Lean.Language.Lean.waitForFinalCmdState?"><span class="name">Lean</span>.<span class="name">Language</span>.<span class="name">Lean</span>.<span class="name">waitForFinalCmdState?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">snap</span> : <a href="../.././Lean/Language/Lean/Types.html#Lean.Language.Lean.InitialSnapshot">InitialSnapshot</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Lean/Elab/Command.html#Lean.Elab.Command.State">Elab.Command.State</a></span></div></div><p>Waits for and returns final command state, if importing was successful.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Language/Lean.html#Lean.Language.Lean.waitForFinalCmdState?">Lean.Language.Lean.waitForFinalCmdState?</a> <span class="fn">snap</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">snap</span> ← <span class="fn"><span class="fn">snap</span>.<a href="../.././Lean/Language/Lean/Types.html#Lean.Language.Lean.HeaderParsedSnapshot.result?">result?</a></span>
  let <span class="fn">snap</span> ← <span class="fn"><span class="fn"><span class="fn"><span class="fn">snap</span>.<a href="../.././Lean/Language/Lean/Types.html#Lean.Language.Lean.HeaderParsedState.processedSnap">processedSnap</a></span>.<a href="../.././Lean/Language/Basic.html#Lean.Language.SnapshotTask.get">get</a></span>.<a href="../.././Lean/Language/Lean/Types.html#Lean.Language.Lean.HeaderProcessedSnapshot.result?">result?</a></span>
  <span class="fn"><a href="../.././Lean/Language/Lean.html#_private.Lean.Language.Lean.0.Lean.Language.Lean.waitForFinalCmdState?.goCmd">Lean.Language.Lean.waitForFinalCmdState?.goCmd✝</a> <span class="fn"><span class="fn"><span class="fn">snap</span>.<a href="../.././Lean/Language/Lean/Types.html#Lean.Language.Lean.HeaderProcessedState.firstCmdSnap">firstCmdSnap</a></span>.<a href="../.././Lean/Language/Basic.html#Lean.Language.SnapshotTask.get">get</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Language.Lean.waitForFinalCmdState?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>