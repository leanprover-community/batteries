<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Parser.Term.Basic</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Lean.Parser.Term.Basic";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">Basic</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Lean/Parser/Attr.html">Lean.Parser.Attr</a></li><li><a href="../../.././Lean/Parser/Level.html">Lean.Parser.Level</a></li><li><a href="../../.././Lean/Parser/Term/Doc.html">Lean.Parser.Term.Doc</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Parser.Term.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.tacticParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">tacticParser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.convParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">convParser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sepByIndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepByIndentSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sepBy1IndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepBy1IndentSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeq1Indented"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq1Indented</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeqBracketed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqBracketed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeqIndentGt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqIndentGt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.seq1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">seq1</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.hole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">hole</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.syntheticHole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">syntheticHole</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.omission"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">omission</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderTactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderDefault"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderDefault.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span>.<span class="name">parenthesizer</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.implicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">implicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitLeftBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitLeftBracket</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitRightBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitRightBracket</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.bracketedBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeSpec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeSpec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstFieldDeclParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFieldDeclParser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optEllipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optEllipsis</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstArrayRef"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstArrayRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstLVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstLVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstFieldBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFieldBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optTypeForStructInst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optTypeForStructInst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstField"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstField</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstFields"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFields</span></a></div></nav><main>
<div class="mod_doc"><p>This module contains the bare minimum of term syntax that's required to get documentation syntax to
parse, namely structure initializers and their dependencies.</p><p>This matters because some term syntax (such as <code>let rec</code>) includes docstrings, but docstrings
include metadata blocks that themselves include a structure initializer. Separating these layers
prevents an import cycle.</p><p>The remaining term syntax is found in <code><a href="../../.././Lean/Parser/Term.html">Lean.Parser.Term</a></code>. It may freely make use of documentation
comments.</p></div><div class="decl" id="Lean.Parser.tacticParser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L35-L36">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.tacticParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">tacticParser</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">rbp</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a> := <span class="fn">0</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.tacticParser">Lean.Parser.tacticParser</a> <span class="fn">rbp</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.categoryParser">Lean.Parser.categoryParser</a> <span class="fn">`tactic</span> <span class="fn">rbp</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.tacticParser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.convParser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L38-L39">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.convParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">convParser</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">rbp</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a> := <span class="fn">0</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.convParser">Lean.Parser.convParser</a> <span class="fn">rbp</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.categoryParser">Lean.Parser.categoryParser</a> <span class="fn">`conv</span> <span class="fn">rbp</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.convParser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sepByIndentSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L43-L54">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.sepByIndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepByIndentSemicolon</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p><code>sepByIndentSemicolon(p)</code> parses a sequence of <code>p</code> optionally followed by <code>;</code>,
similar to <code>manyIndent(p &quot;;&quot;?)</code>, except that if two occurrences of <code>p</code> occur on the same line,
the <code>;</code> is mandatory. This is used by tactic parsing, so that</p><pre><code>example := by
  skip
  skip
</code></pre><p>is legal, but <code>by skip skip</code> is not - it must be written as <code>by skip; skip</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.sepByIndentSemicolon">Lean.Parser.Tactic.sepByIndentSemicolon</a> <span class="fn">p</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Parser/Extra.html#Lean.Parser.sepByIndent">Lean.Parser.sepByIndent</a> <span class="fn">p</span> <span class="fn">&quot;; &quot;</span> <span class="fn">(<a href="../../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;; &quot;</span>)</span> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.sepByIndentSemicolon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sepBy1IndentSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L56-L67">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.sepBy1IndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepBy1IndentSemicolon</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p><code>sepBy1IndentSemicolon(p)</code> parses a (nonempty) sequence of <code>p</code> optionally followed by <code>;</code>,
similar to <code>many1Indent(p &quot;;&quot;?)</code>, except that if two occurrences of <code>p</code> occur on the same line,
the <code>;</code> is mandatory. This is used by tactic parsing, so that</p><pre><code>example := by
  skip
  skip
</code></pre><p>is legal, but <code>by skip skip</code> is not - it must be written as <code>by skip; skip</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.sepBy1IndentSemicolon">Lean.Parser.Tactic.sepBy1IndentSemicolon</a> <span class="fn">p</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent">Lean.Parser.sepBy1Indent</a> <span class="fn">p</span> <span class="fn">&quot;; &quot;</span> <span class="fn">(<a href="../../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;; &quot;</span>)</span> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.sepBy1IndentSemicolon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeq1Indented"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L73-L74">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeq1Indented"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq1Indented</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeq1Indented" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeqBracketed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L75-L78">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeqBracketed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqBracketed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p>The syntax <code>{ tacs }</code> is an alternative syntax for <code>· tacs</code>.
It runs the tactics in sequence, and fails if the goal is not solved.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeqBracketed" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L80-L83">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p>A sequence of tactics in brackets, or a delimiter-free indented sequence of tactics.
Delimiter-free indentation is determined by the <em>first</em> tactic of the sequence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeqIndentGt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L85-L90">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeqIndentGt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqIndentGt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p>Same as [<code><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeq">tacticSeq</a></code>] but requires delimiter-free tactic sequence to have strict indentation.
The strict indentation requirement only apply to <em>nested</em> <code>by</code>s, as top-level <code>by</code>s do not have a
position set.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeqIndentGt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.seq1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L93-L95">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.seq1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">seq1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.seq1">Lean.Parser.Tactic.seq1</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.node">Lean.Parser.node</a> <span class="fn">`Lean.Parser.Tactic.seq1</span>
    <span class="fn">(<a href="../../.././Lean/Parser/Basic.html#Lean.Parser.sepBy1">Lean.Parser.sepBy1</a> <a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.tacticParser">Lean.Parser.tacticParser</a> <span class="fn">&quot;;\n&quot;</span> <span class="fn">(<a href="../../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;;\n&quot;</span>)</span> <a href="../../.././Init/Prelude.html#Bool.true">true</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.seq1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.hole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L100-L117">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.hole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">hole</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p>A <em>hole</em> (or <em>placeholder term</em>), which stands for an unknown term that is expected to be inferred based on context.
For example, in <code>@id _ <a href="../../.././Init/Prelude.html#Nat.zero">Nat.zero</a></code>, the <code>_</code> must be the type of <code><a href="../../.././Init/Prelude.html#Nat.zero">Nat.zero</a></code>, which is <code><a href="../../.././Init/Prelude.html#Nat">Nat</a></code>.</p><p>The way this works is that holes create fresh metavariables.
The elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.
This is often known as <em>unification</em>.</p><p>Normally, all holes must be solved for. However, there are a few contexts where this is not necessary:</p><ul><li>In <code>match</code> patterns, holes are catch-all patterns.</li><li>In some tactics, such as <code>refine'</code> and <code>apply</code>, unsolved-for placeholders become new goals.</li></ul><p>Related concept: implicit parameters are automatically filled in with holes during the elaboration process.</p><p>See also <code>?m</code> syntax (synthetic holes).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.hole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.syntheticHole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L118-L163">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.syntheticHole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">syntheticHole</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p>A <em>synthetic hole</em> (or <em>synthetic placeholder</em>), which stands for an unknown term that should be synthesized using tactics.</p><ul><li><code>?_</code> creates a fresh metavariable with an auto-generated name.</li><li><code>?m</code> either refers to a pre-existing metavariable named <code>m</code> or creates a fresh metavariable with that name.</li></ul><p>In particular, the synthetic hole syntax creates &quot;synthetic opaque metavariables&quot;,
the same kind of metavariable used to represent goals in the tactic state.</p><p>Synthetic holes are similar to holes in that <code>_</code> also creates metavariables,
but synthetic opaque metavariables have some different properties:</p><ul><li>In tactics such as <code>refine</code>, only synthetic holes yield new goals.</li><li>During elaboration, unification will not solve for synthetic opaque metavariables, they are &quot;opaque&quot;.
This is to prevent counterintuitive behavior such as disappearing goals.</li><li>When synthetic holes appear under binders, they capture local variables using a more complicated mechanism known as delayed assignment.</li></ul><h2 id="Delayed-assigned-metavariables" class="markdown-heading">Delayed assigned metavariables <a class="hover-link" href="#Delayed-assigned-metavariables">#</a></h2><p>This section gives an overview of some technical details of synthetic holes, which you should feel free to skip.
Understanding delayed assignments is mainly useful for those who are working on tactics and other metaprogramming.
It is included here until there is a suitable place for it in the reference manual.</p><p>When a synthetic hole appears under a binding construct, such as for example <code>fun (x : α) (y : β) =&gt; ?s</code>,
the system creates a <em>delayed assignment</em>. This consists of</p><ol><li>A metavariable <code>?m</code> of type <code>(x : α) → (y : β) → γ x y</code> whose local context is the local context outside the <code>fun</code>,
where <code>γ x y</code> is the type of <code>?s</code>. Recall that <code>x</code> and <code>y</code> appear in the local context of <code>?s</code>.</li><li>A delayed assignment record associating <code>?m</code> to <code>?s</code> and the variables <code>#[x, y]</code> in the local context of <code>?s</code></li></ol><p>Then, this function elaborates as <code>fun (x : α) (y : β) =&gt; ?m x y</code>, where one should understand <code>x</code> and <code>y</code> here
as being De Bruijn indexes, since Lean uses the locally nameless encoding of lambda calculus.</p><p>Once <code>?s</code> is fully solved for, in the sense that after metavariable instantiation it is a metavariable-free term <code>e</code>,
then we can make the assignment <code>?m := fun (x' : α) (y' : β) =&gt; e[x := x', y := y']</code>.
(Implementation note: Lean only instantiates full applications <code>?m x' y'</code> of delayed assigned metavariables, to skip forming this function.)
This delayed assignment mechanism is essential to the operation of basic tactics like <code>intro</code>,
and a good mental model is that it is a way to &quot;apply&quot; the metavariable <code>?s</code> by substituting values in for some of its local variables.
While it would be easier to immediately assign <code>?s := ?m x y</code>,
delayed assignment preserves <code>?s</code> as an unsolved-for metavariable with a local context that still contains <code>x</code> and <code>y</code>,
which is exactly what tactics like <code>intro</code> need.</p><p>By default, delayed assigned metavariables pretty print with what they are delayed assigned to.
The delayed assigned metavariables themselves can be pretty printed using <code>set_option pp.mvars.delayed true</code>.</p><p>For more information, see the &quot;Gruesome details&quot; module docstrings in <code><a href="../../.././Lean/MetavarContext.html#Lean.MetavarContext">Lean.MetavarContext</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.syntheticHole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.omission"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L165-L174">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.omission"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">omission</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p>The <code>⋯</code> term denotes a term that was omitted by the pretty printer.
The presence of <code>⋯</code> in pretty printer output is controlled by the <code>pp.deepTerms</code> and <code>pp.proofs</code> options,
and these options can be further adjusted using <code>pp.deepTerms.threshold</code> and <code>pp.proofs.threshold</code>.</p><p>It is only meant to be used for pretty printing.
However, in case it is copied and pasted from the Infoview, <code>⋯</code> logs a warning and elaborates like <code>_</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.omission" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L175-L176">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderIdent">Lean.Parser.Term.binderIdent</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../../.././Lean/Parser/Extra.html#Lean.Parser.ident">Lean.Parser.ident</a> &lt;|&gt; <a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.hole">Lean.Parser.Term.hole</a>)</span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L178-L180">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderType</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">requireType</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L181-L183">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderTactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderTactic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderDefault"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L184-L185">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderDefault"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderDefault" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderDefault.parenthesizer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L188-L195">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderDefault.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span>.<span class="name">parenthesizer</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer">PrettyPrinter.Parenthesizer</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderDefault.parenthesizer" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L197-L202">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.explicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitBinder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">requireType</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p>Explicit binder, like <code>(x y : A)</code> or <code>(x y)</code>.
Default values can be specified using <code>(x : A := v)</code> syntax, and tactics using <code>(x : A := by tac)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.explicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.implicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L203-L213">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.implicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">implicitBinder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">requireType</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p>Implicit binder, like <code>{x y : A}</code> or <code>{x y}</code>.
In regular applications, whenever all parameters before it have been specified,
then a <code>_</code> placeholder is automatically inserted for this parameter.
Implicit parameters should be able to be determined from the other arguments and the return type
by unification.</p><p>In <code>@</code> explicit mode, implicit binders behave like explicit binders.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.implicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitLeftBracket"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L214-L214">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.strictImplicitLeftBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitLeftBracket</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.strictImplicitLeftBracket">Lean.Parser.Term.strictImplicitLeftBracket</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(<span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.atomic">Lean.Parser.atomic</a> <span class="fn">(<a href="../../.././Lean/Parser/Extra.html#Lean.Parser.group">Lean.Parser.group</a> <span class="fn">(<span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;{&quot;</span></span> &gt;&gt; <span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;{&quot;</span></span>)</span>)</span></span> &lt;|&gt; <span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;⦃&quot;</span></span>)</span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.strictImplicitLeftBracket" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitRightBracket"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L215-L215">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.strictImplicitRightBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitRightBracket</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.strictImplicitRightBracket">Lean.Parser.Term.strictImplicitRightBracket</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(<span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.atomic">Lean.Parser.atomic</a> <span class="fn">(<a href="../../.././Lean/Parser/Extra.html#Lean.Parser.group">Lean.Parser.group</a> <span class="fn">(<span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;}&quot;</span></span> &gt;&gt; <span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;}&quot;</span></span>)</span>)</span></span> &lt;|&gt; <span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;⦄&quot;</span></span>)</span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.strictImplicitRightBracket" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L216-L231">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.strictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitBinder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">requireType</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p>Strict-implicit binder, like <code>⦃x y : A⦄</code> or <code>⦃x y⦄</code>.
In contrast to <code>{ ... }</code> implicit binders, strict-implicit binders do not automatically insert
a <code>_</code> placeholder until at least one subsequent explicit parameter is specified.
Do <em>not</em> use strict-implicit binders unless there is a subsequent explicit parameter.
Assuming this rule is followed, for fully applied expressions implicit and strict-implicit binders have the same behavior.</p><p>Example: If <code>h : ∀ ⦃x : A⦄, x ∈ s → p x</code> and <code>hs : y ∈ s</code>,
then <code>h</code> by itself elaborates to itself without inserting <code>_</code> for the <code>x : A</code> parameter,
and <code>h hs</code> has type <code>p y</code>.
In contrast, if <code>h' : ∀ {x : A}, x ∈ s → p x</code>, then <code>h</code> by itself elaborates to have type <code>?m ∈ s → p ?m</code>
with <code>?m</code> a fresh metavariable.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.strictImplicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L233-L234">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.optIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.optIdent">Lean.Parser.Term.optIdent</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Parser/Extra.html#Lean.Parser.optional">Lean.Parser.optional</a> <span class="fn">(<a href="../../.././Lean/Parser/Basic.html#Lean.Parser.atomic">Lean.Parser.atomic</a> <span class="fn">(<a href="../../.././Lean/Parser/Extra.html#Lean.Parser.ident">Lean.Parser.ident</a> &gt;&gt; <span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot; : &quot;</span></span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L236-L244">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.instBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p>Instance-implicit binder, like <code>[C]</code> or <code>[inst : C]</code>.
In regular applications without <code>@</code> explicit mode, it is automatically inserted
and solved for by typeclass inference for the specified class <code>C</code>.
In <code>@</code> explicit mode, if <code>_</code> is used for an instance-implicit parameter, then it is still solved for by typeclass inference;
use <code>(_)</code> to inhibit this and have it be solved for by unification instead, like an implicit argument.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.instBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.bracketedBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L245-L254">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.bracketedBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">requireType</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><p>A <code><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.bracketedBinder">bracketedBinder</a></code> matches any kind of binder group that uses some kind of brackets:</p><ul><li>An explicit binder like <code>(x y : A)</code></li><li>An implicit binder like <code>{x y : A}</code></li><li>A strict implicit binder, <code>⦃y z : A⦄</code> or its ASCII alternative <code>{{y z : A}}</code></li><li>An instance binder <code>[A]</code> or <code>[x : A]</code> (multiple variables are not allowed here)</li></ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.bracketedBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeSpec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L256-L257">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.typeSpec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeSpec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.typeSpec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L259-L260">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.optType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.optType">Lean.Parser.Term.optType</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Parser/Extra.html#Lean.Parser.optional">Lean.Parser.optional</a> <a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.typeSpec">Lean.Parser.Term.typeSpec</a></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstFieldDeclParser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L268-L269">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstFieldDeclParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFieldDeclParser</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">rbp</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a> := <span class="fn">0</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstFieldDeclParser">Lean.Parser.Term.structInstFieldDeclParser</a> <span class="fn">rbp</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.categoryParser">Lean.Parser.categoryParser</a> <span class="fn">`structInstFieldDecl</span> <span class="fn">rbp</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstFieldDeclParser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optEllipsis"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L270-L272">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.optEllipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optEllipsis</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.optEllipsis" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstArrayRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L273-L275">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstArrayRef"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstArrayRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstArrayRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstLVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L276-L279">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstLVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstLVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstLVal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstFieldBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L280-L283">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstFieldBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFieldBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstFieldBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optTypeForStructInst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L284-L285">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.optTypeForStructInst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optTypeForStructInst</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.optTypeForStructInst">Lean.Parser.Term.optTypeForStructInst</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Lean/Parser/Extra.html#Lean.Parser.optional">Lean.Parser.optional</a>
    <span class="fn">(<a href="../../.././Lean/Parser/Basic.html#Lean.Parser.atomic">Lean.Parser.atomic</a> <span class="fn">(<a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.typeSpec">Lean.Parser.Term.typeSpec</a> &gt;&gt; <span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.notFollowedBy">Lean.Parser.notFollowedBy</a> <span class="fn">(<a href="../../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;}&quot;</span>)</span> <span class="fn">&quot;}&quot;</span></span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optTypeForStructInst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstField"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L287-L289">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstField"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstField</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstField" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstFields"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Term/Basic.lean#L295-L296">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstFields"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFields</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Parser/Types.html#Lean.Parser.Parser">Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstFields">Lean.Parser.Term.structInstFields</a> <span class="fn">p</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Parser/Basic.html#Lean.Parser.node">Lean.Parser.node</a> <span class="fn">`Lean.Parser.Term.structInstFields</span> <span class="fn">p</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstFields" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>