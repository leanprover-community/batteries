<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Std.Data.DHashMap.Raw</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Std.Data.DHashMap.Raw";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Std</span>.<span class="name">Data</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init/Data/LawfulHashable.html">Init.Data.LawfulHashable</a></li><li><a href="../../.././Std/Data/DHashMap/Internal/Defs.html">Std.Data.DHashMap.Internal.Defs</a></li><li><a href="../../.././Std/Data/DHashMap/Internal/Defs.html">Std.Data.DHashMap.Internal.Defs</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Std.Data.DHashMap.Raw" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.emptyWithCapacity"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">emptyWithCapacity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.empty"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">empty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instEmptyCollection"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instEmptyCollection</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instInhabited"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instInhabited</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Equiv"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Equiv</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.«term_~m_»"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">«term_~m_»</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.insert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">insert</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instSingletonSigmaOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instSingletonSigmaOfBEqOfHashable</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instInsertSigmaOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instInsertSigmaOfBEqOfHashable</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instLawfulSingletonSigma"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instLawfulSingletonSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.insertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">insertIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.containsThenInsert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">containsThenInsert</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getThenInsertIfNew?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.containsThenInsertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">containsThenInsertIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.get?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">get?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.contains"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instMembershipOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instMembershipOfBEqOfHashable</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instDecidableMem"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instDecidableMem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.get"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">get</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.getD"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.get!"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">get!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.erase"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.get?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">get?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.get"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">get</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.getD"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">getD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.get!"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">get!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">getThenInsertIfNew?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.getKey?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.getKey"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.getKeyD"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.getKey!"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.isEmpty"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.modify"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">modify</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.modify"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">modify</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.alter"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">alter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.alter"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">alter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.foldM"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">foldM</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.fold"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">fold</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Internal.foldRevM"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Internal</span>.<span class="name">foldRevM</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Internal.foldRev"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Internal</span>.<span class="name">foldRev</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.foldRevM"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">foldRevM</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.foldRev"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">foldRev</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.forMUncurried"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">forMUncurried</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.forInUncurried"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">forInUncurried</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.filterMap"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.map"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.filter"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.toArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">toArray</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.toArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">toArray</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.keysArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">keysArray</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.union"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">union</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instUnionOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instUnionOfBEqOfHashable</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.values"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">values</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.valuesArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">valuesArray</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">insertMany</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">insertMany</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.insertManyIfNewUnit"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">insertManyIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.unitOfArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">unitOfArray</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Internal.numBuckets"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Internal</span>.<span class="name">numBuckets</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.toList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">toList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.toList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">toList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.instRepr"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instRepr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.keys"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.Const.unitOfList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">unitOfList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.empty₀"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">empty₀</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.size_buckets_pos"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">size_buckets_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.emptyWithCapacity"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">emptyWithCapacity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.empty"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">empty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.emptyc"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">emptyc</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.insert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">insert</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.containsThenInsert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">containsThenInsert</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.containsThenInsertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">containsThenInsertIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.erase"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.insertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">insertIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">getThenInsertIfNew?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.filter"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.Const.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">getThenInsertIfNew?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">insertMany</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.Const.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">insertMany</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.Const.insertManyIfNewUnit"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">insertManyIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.Const.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.Const.unitOfList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">unitOfList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.union₀"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">union₀</span></a></div><div class="nav_link"><a class="break_within" href="#Std.DHashMap.Raw.WF.union"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">union</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Dependent-hash-maps-with-unbundled-well-formedness-invariant">Dependent hash maps with unbundled well-formedness invariant <a class="hover-link" href="#Dependent-hash-maps-with-unbundled-well-formedness-invariant">#</a></h1><p>This file develops the type <code><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a></code> of dependent hash
maps with unbundled well-formedness invariant.</p><p>This version is safe to use in nested inductive types. The well-formedness predicate is
available as <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">Std.DHashMap.Raw.WF</a></code> and we prove in this file that all operations preserve
well-formedness. When in doubt, prefer <code>DHashMap</code> over <code>DHashMap.Raw</code>.</p><p>Lemmas about the operations on <code><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a></code> are available in the module
<code><a href="../../.././Std/Data/DHashMap/RawLemmas.html">Std.Data.DHashMap.RawLemmas</a></code>.</p></div><div class="mod_doc"><p>The type <code>DHashMap.Raw</code> itself is defined in the module <code>Std.Data.DHashmap.RawDef</code> for import
structure reasons.</p></div><div class="decl" id="Std.DHashMap.Raw.emptyWithCapacity"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L49-L56">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.emptyWithCapacity"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">emptyWithCapacity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">capacity</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a> := <span class="fn">8</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Creates a new empty hash map. The optional parameter <code>capacity</code> can be supplied to presize the
map so that it can hold the given number of mappings without reallocating. It is also possible to
use the empty collection notations <code>∅</code> and <code>{}</code> to create an empty hash map with the default
capacity.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.emptyWithCapacity">Std.DHashMap.Raw.emptyWithCapacity</a> <span class="fn">capacity</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.emptyWithCapacity">Std.DHashMap.Internal.Raw₀.emptyWithCapacity</a> <span class="fn">capacity</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.emptyWithCapacity" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.empty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L58-L59">source</a></div><div class="attributes">@[reducible, inline, deprecated Std.DHashMap.Raw.emptyWithCapacity (since := &quot;2025-03-12&quot;)]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.empty"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">capacity</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a> := <span class="fn">8</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Creates a new empty hash map. The optional parameter <code>capacity</code> can be supplied to presize the
map so that it can hold the given number of mappings without reallocating. It is also possible to
use the empty collection notations <code>∅</code> and <code>{}</code> to create an empty hash map with the default
capacity.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.empty">Std.DHashMap.Raw.empty</a> <a href="../../.././Init/Prelude.html#Eq">=</a> @<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.emptyWithCapacity">Std.DHashMap.Raw.emptyWithCapacity</a></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.empty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instEmptyCollection"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L61-L62">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instEmptyCollection"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instEmptyCollection</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#EmptyCollection">EmptyCollection</a> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instEmptyCollection">Std.DHashMap.Raw.instEmptyCollection</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.mk">{</a> <span class="fn">emptyCollection</span> := <a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.emptyWithCapacity">Std.DHashMap.Raw.emptyWithCapacity</a> <a href="../../.././Init/Core.html#EmptyCollection.mk">}</a></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instInhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L64-L65">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instInhabited"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instInhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instInhabited">Std.DHashMap.Raw.instInhabited</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Equiv"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L67-L73">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Equiv"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Equiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m₁ </span><span class="fn">m₂</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>Two hash maps are equivalent in the sense of <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Equiv">Equiv</a></code> iff
all the keys and values are equal.</p><ul class="structure_fields" id="Std.DHashMap.Raw.Equiv.mk"><li id="Std.DHashMap.Raw.Equiv.impl" class="structure_field"><div class="structure_field_info">impl : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.toListModel">Internal.toListModel</a> <span class="fn"><span class="fn">m₁</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>)</span>.<a href="../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.toListModel">Internal.toListModel</a> <span class="fn"><span class="fn">m₂</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>)</span></span></div><div class="structure_field_doc"><p>Internal implementation detail of the hash map</p></div></li></ul><details id="instances-for-list-Std.DHashMap.Raw.Equiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.«term_~m_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L75-L75">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.«term_~m_»"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">«term_~m_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Two hash maps are equivalent in the sense of <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Equiv">Equiv</a></code> iff
all the keys and values are equal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.«term_~m_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.insert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L77-L88">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Inserts the given mapping into the map. If there is already a mapping for the given key, then both
key and value will be replaced.</p><p>Note: this replacement behavior is true for <code>HashMap</code>, <code>DHashMap</code>, <code>HashMap.Raw</code> and <code>DHashMap.Raw</code>.
The <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert">insert</a></code> function on <code>HashSet</code> and <code>HashSet.Raw</code> behaves differently: it will return the set
unchanged if a matching key is already present.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert">insert</a></span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.insert">Std.DHashMap.Internal.Raw₀.insert</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.insert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instSingletonSigmaOfBEqOfHashable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L90-L91">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instSingletonSigmaOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instSingletonSigmaOfBEqOfHashable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#Singleton">Singleton</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instSingletonSigmaOfBEqOfHashable">Std.DHashMap.Raw.instSingletonSigmaOfBEqOfHashable</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Core.html#Singleton.mk">{</a>     <span class="fn">singleton</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt;
      <span class="fn">match <span class="fn">x</span> with
      | <a href="../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn">b</span><a href="../../.././Init/Core.html#Sigma.mk">⟩</a> =&gt; <span class="fn"><span class="fn"><a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert">insert</a></span> <span class="fn">a</span> <span class="fn">b</span></span></span></span> <a href="../../.././Init/Core.html#Singleton.mk">}</a></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instInsertSigmaOfBEqOfHashable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L93-L94">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instInsertSigmaOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instInsertSigmaOfBEqOfHashable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#Insert">Insert</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instInsertSigmaOfBEqOfHashable">Std.DHashMap.Raw.instInsertSigmaOfBEqOfHashable</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Core.html#Insert.mk">{</a>     <span class="fn">insert</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">s</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>) =&gt;
      <span class="fn">match <span class="fn">x</span> with
      | <a href="../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn">b</span><a href="../../.././Init/Core.html#Sigma.mk">⟩</a> =&gt; <span class="fn"><span class="fn"><span class="fn">s</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert">insert</a></span> <span class="fn">a</span> <span class="fn">b</span></span></span></span> <a href="../../.././Init/Core.html#Insert.mk">}</a></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instLawfulSingletonSigma"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L96-L97">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instLawfulSingletonSigma"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instLawfulSingletonSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#LawfulSingleton">LawfulSingleton</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.insertIfNew"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L99-L106">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">insertIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>If there is no mapping for the given key, inserts the given mapping into the map. Otherwise,
returns the map unaltered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertIfNew">insertIfNew</a></span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.insertIfNew">Std.DHashMap.Internal.Raw₀.insertIfNew</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.insertIfNew" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.containsThenInsert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L108-L118">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.containsThenInsert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">containsThenInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Checks whether a key is present in a map, and unconditionally inserts a value for the key.</p><p>Equivalent to (but potentially faster than) calling <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains">contains</a></code> followed by <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert">insert</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.containsThenInsert">containsThenInsert</a></span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then
    <span class="fn">match <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.containsThenInsert">Std.DHashMap.Internal.Raw₀.containsThenInsert</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">b</span></span> with
    | <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">replaced</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">r</span>, <span class="fn">property</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a><a href="../../.././Init/Prelude.html#Prod.mk">)</a> =&gt; <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">replaced</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">r</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></span>
  else <a href="../../.././Init/Prelude.html#Prod.mk">(</a><a href="../../.././Init/Prelude.html#Bool.false">false</a><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">m</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.containsThenInsert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.getThenInsertIfNew?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L120-L136">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getThenInsertIfNew?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Checks whether a key is present in a map, returning the associated value, and inserts a value for
the key if it was not found.</p><p>If the returned value is <code>some v</code>, then the returned map is unaltered. If it is <code>none</code>, then the
returned map has a new value inserted.</p><p>Equivalent to (but potentially faster than) calling <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.get?">get?</a></code> followed by <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertIfNew">insertIfNew</a></code>.</p><p>Uses the <code><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a></code> instance to cast the retrieved value to the correct type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getThenInsertIfNew?">getThenInsertIfNew?</a></span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then
    <span class="fn">match <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getThenInsertIfNew?">Std.DHashMap.Internal.Raw₀.getThenInsertIfNew?</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">b</span></span> with
    | <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">previous</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">r</span>, <span class="fn">property</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a><a href="../../.././Init/Prelude.html#Prod.mk">)</a> =&gt; <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">previous</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">r</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></span>
  else <a href="../../.././Init/Prelude.html#Prod.mk">(</a><a href="../../.././Init/Prelude.html#Option.none">none</a><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">m</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.getThenInsertIfNew?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.containsThenInsertIfNew"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L138-L151">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.containsThenInsertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">containsThenInsertIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Checks whether a key is present in a map and inserts a value for the key if it was not found.</p><p>If the returned <code><a href="../../.././Init/Prelude.html#Bool">Bool</a></code> is <code>true</code>, then the returned map is unaltered. If the <code><a href="../../.././Init/Prelude.html#Bool">Bool</a></code> is <code>false</code>, then
the returned map has a new value inserted.</p><p>Equivalent to (but potentially faster than) calling <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains">contains</a></code> followed by <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertIfNew">insertIfNew</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.containsThenInsertIfNew" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.get?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L153-L161">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.get?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">get?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></div></div><p>Tries to retrieve the mapping for the given key, returning <code>none</code> if no such mapping is present.</p><p>Uses the <code><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a></code> instance to cast the retrieved value to the correct type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.get?">get?</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.get?">Std.DHashMap.Internal.Raw₀.get?</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span></span> else <a href="../../.././Init/Prelude.html#Option.none">none</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.get?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.contains"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L163-L173">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>Returns <code>true</code> if there is a mapping for the given key. There is also a <code>Prop</code>-valued version
of this: <code>a ∈ m</code> is equivalent to <code>m.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains">contains</a> a = true</code>.</p><p>Observe that this is different behavior than for lists: for lists, <code>∈</code> uses <code>=</code> and <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains">contains</a></code> uses
<code>==</code> for comparisons, while for hash maps, both use <code>==</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.contains">Std.DHashMap.Internal.Raw₀.contains</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span></span> else <a href="../../.././Init/Prelude.html#Bool.false">false</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.contains" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instMembershipOfBEqOfHashable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L175-L176">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instMembershipOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instMembershipOfBEqOfHashable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instMembershipOfBEqOfHashable">Std.DHashMap.Raw.instMembershipOfBEqOfHashable</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Prelude.html#Membership.mk">{</a> <span class="fn">mem</span> := <span class="fn">fun (<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>) (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span> <a href="../../.././Init/Prelude.html#Membership.mk">}</a></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instDecidableMem"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L178-L179">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instDecidableMem"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instDecidableMem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">m</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instDecidableMem">Std.DHashMap.Raw.instDecidableMem</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a>))</span></span></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.get"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L181-L189">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.get"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Retrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof
of <code>a ∈ m</code>.</p><p>Uses the <code><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a></code> instance to cast the retrieved value to the correct type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.get">get</a></span> <span class="fn">a</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.get">Std.DHashMap.Internal.Raw₀.get</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">⋯</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.get" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.getD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L191-L200">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getD"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Tries to retrieve the mapping for the given key, returning <code>fallback</code> if no such mapping is present.</p><p>Uses the <code><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a></code> instance to cast the retrieved value to the correct type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getD">getD</a></span> <span class="fn">a</span> <span class="fn">fallback</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getD">Std.DHashMap.Internal.Raw₀.getD</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">fallback</span></span> else <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.getD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.get!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L202-L211">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.get!"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">get!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Tries to retrieve the mapping for the given key, panicking if no such mapping is present.</p><p>Uses the <code><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a></code> instance to cast the retrieved value to the correct type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.get!">get!</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.get!">Std.DHashMap.Internal.Raw₀.get!</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span></span> else <a href="../../.././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.get!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.erase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L213-L217">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.erase"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Removes the mapping for the given key if it exists.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.erase">erase</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.erase">Std.DHashMap.Internal.Raw₀.erase</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.erase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.get?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L223-L229">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">get?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></div></div><p>Tries to retrieve the mapping for the given key, returning <code>none</code> if no such mapping is present.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get?">Std.DHashMap.Raw.Const.get?</a> <span class="fn">m</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.get?">Std.DHashMap.Internal.Raw₀.Const.get?</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span></span> else <a href="../../.././Init/Prelude.html#Option.none">none</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.get?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.get"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L231-L237">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Retrieves the mapping for the given key. Ensures that such a mapping exists by requiring a proof of
<code>a ∈ m</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get">Std.DHashMap.Raw.Const.get</a> <span class="fn">m</span> <span class="fn">a</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.get">Std.DHashMap.Internal.Raw₀.Const.get</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">⋯</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.get" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.getD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L239-L245">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.getD"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">getD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Tries to retrieve the mapping for the given key, returning <code>fallback</code> if no such mapping is present.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.getD">Std.DHashMap.Raw.Const.getD</a> <span class="fn">m</span> <span class="fn">a</span> <span class="fn">fallback</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.getD">Std.DHashMap.Internal.Raw₀.Const.getD</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">fallback</span></span> else <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.getD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.get!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L247-L251">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get!"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">get!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Tries to retrieve the mapping for the given key, panicking if no such mapping is present.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get!">Std.DHashMap.Raw.Const.get!</a> <span class="fn">m</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.get!">Std.DHashMap.Internal.Raw₀.Const.get!</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span></span> else <a href="../../.././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.get!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.getThenInsertIfNew?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L253-L267">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">getThenInsertIfNew?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span></div></div><p>Equivalent to (but potentially faster than) calling <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.get?">Const.get?</a></code> followed by <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertIfNew">insertIfNew</a></code>.</p><p>Checks whether a key is present in a map, returning the associated value, and inserts a value for
the key if it was not found.</p><p>If the returned value is <code>some v</code>, then the returned map is unaltered. If it is <code>none</code>, then the
returned map has a new value inserted.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.getThenInsertIfNew?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.getKey?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L271-L278">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getKey?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></div></div><p>Checks if a mapping for the given key exists and returns the key if it does, otherwise <code>none</code>.
The result in the <code>some</code> case is guaranteed to be pointer equal to the key in the map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getKey?">getKey?</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getKey?">Std.DHashMap.Internal.Raw₀.getKey?</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span></span> else <a href="../../.././Init/Prelude.html#Option.none">none</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.getKey?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.getKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L280-L286">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getKey"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Retrieves the key from the mapping that matches <code>a</code>. Ensures that such a mapping exists by
requiring a proof of <code>a ∈ m</code>. The result is guaranteed to be pointer equal to the key in the map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getKey">getKey</a></span> <span class="fn">a</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getKey">Std.DHashMap.Internal.Raw₀.getKey</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">⋯</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.getKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.getKeyD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L288-L295">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getKeyD"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Checks if a mapping for the given key exists and returns the key if it does, otherwise <code>fallback</code>.
If a mapping exists the result is guaranteed to be pointer equal to the key in the map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getKeyD">getKeyD</a></span> <span class="fn">a</span> <span class="fn">fallback</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getKeyD">Std.DHashMap.Internal.Raw₀.getKeyD</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">fallback</span></span> else <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.getKeyD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.getKey!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L297-L304">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getKey!"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">getKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Checks if a mapping for the given key exists and returns the key if it does, otherwise panics.
If no panic occurs the result is guaranteed to be pointer equal to the key in the map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getKey!">getKey!</a></span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getKey!">Std.DHashMap.Internal.Raw₀.getKey!</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span></span> else <a href="../../.././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.getKey!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.isEmpty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L306-L314">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.isEmpty"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>Returns <code>true</code> if the hash map contains no mappings.</p><p>Note that if your <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code> instance is not reflexive or your <code><a href="../../.././Init/Prelude.html#Hashable">Hashable</a></code> instance is not
lawful, then it is possible that this function returns <code>false</code> even though is not possible
to get anything out of the hash map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.isEmpty">isEmpty</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.size">size</a></span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">0</span>)</li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.isEmpty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.modify"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L316-L326">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.modify"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">modify</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Modifies in place the value associated with a given key.</p><p>This function ensures that the value is used linearly.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.modify">modify</a></span> <span class="fn">a</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.modify">Std.DHashMap.Internal.Raw₀.modify</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">f</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.modify" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.modify"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L328-L333">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.modify"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">modify</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span></div></div><p>Modifies in place the value associated with a given key.</p><p>This function ensures that the value is used linearly.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.modify">Std.DHashMap.Raw.Const.modify</a> <span class="fn">m</span> <span class="fn">a</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.modify">Std.DHashMap.Internal.Raw₀.Const.modify</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">f</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.modify" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.alter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L335-L346">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.alter"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">alter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Modifies in place the value associated with a given key,
allowing creating new values and deleting values via an <code><a href="../../.././Init/Prelude.html#Option">Option</a></code> valued replacement function.</p><p>This function ensures that the value is used linearly.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.alter">alter</a></span> <span class="fn">a</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.alter">Std.DHashMap.Internal.Raw₀.alter</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">f</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.alter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.alter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L348-L353">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.alter"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">alter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span></div></div><p>Modifies in place the value associated with a given key,
allowing creating new values and deleting values via an <code><a href="../../.././Init/Prelude.html#Option">Option</a></code> valued replacement function.</p><p>This function ensures that the value is used linearly.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.alter">Std.DHashMap.Raw.Const.alter</a> <span class="fn">m</span> <span class="fn">a</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.alter">Std.DHashMap.Internal.Raw₀.Const.alter</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">f</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.alter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.foldM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L355-L360">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldM"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">foldM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././foundational_types.html">Type</a> w → <a href="../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">δ</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">init</span> : <span class="fn">δ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">δ</span></span></div></div><p>Monadically computes a value by folding the given function over the mappings in the hash
map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldM">Std.DHashMap.Raw.foldM</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Data/Array/Basic.html#Array.foldlM">Array.foldlM</a>
    <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn">δ</span>) (<span class="fn">l</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/AssocList/Basic.html#Std.DHashMap.Internal.AssocList">Std.DHashMap.Internal.AssocList</a> <span class="fn">α</span> <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/AssocList/Basic.html#Std.DHashMap.Internal.AssocList.foldlM">Std.DHashMap.Internal.AssocList.foldlM</a> <span class="fn">f</span> <span class="fn">acc</span> <span class="fn">l</span></span>)</span> <span class="fn">init</span>
    <span class="fn"><span class="fn">b</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.foldM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.fold"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L362-L364">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">fold</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn">δ</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">init</span> : <span class="fn">δ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">δ</span></div></div><p>Folds the given function over the mappings in the hash map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldM">Std.DHashMap.Raw.foldM</a> <span class="fn">(fun (<span class="fn">x1</span> : <span class="fn">δ</span>) (<span class="fn">x2</span> : <span class="fn">α</span>) (<span class="fn">x3</span> : <span class="fn"><span class="fn">β</span> <span class="fn">x2</span></span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn">f</span> <span class="fn">x1</span> <span class="fn">x2</span> <span class="fn">x3</span>)</span></span>)</span> <span class="fn">init</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.fold" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Internal.foldRevM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L368-L375">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.foldRevM"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Internal</span>.<span class="name">foldRevM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././foundational_types.html">Type</a> w → <a href="../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">δ</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">init</span> : <span class="fn">δ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">δ</span></span></div></div><p>Internal implementation detail of the hash map.</p><p>Monadically computes a value by folding the given function over the mappings in the hash
map in the reverse order used by <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldM">foldM</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Internal.foldRevM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Internal.foldRev"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L377-L383">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.foldRev"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Internal</span>.<span class="name">foldRev</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn">δ</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">init</span> : <span class="fn">δ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">δ</span></div></div><p>Internal implementation detail of the hash map.</p><p>Folds the given function over the mappings in the hash map in the reverse order used
by <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldM">foldM</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.foldRev">Std.DHashMap.Raw.Internal.foldRev</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.foldRevM">Std.DHashMap.Raw.Internal.foldRevM</a> <span class="fn">(fun (<span class="fn">x1</span> : <span class="fn">δ</span>) (<span class="fn">x2</span> : <span class="fn">α</span>) (<span class="fn">x3</span> : <span class="fn"><span class="fn">β</span> <span class="fn">x2</span></span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn">f</span> <span class="fn">x1</span> <span class="fn">x2</span> <span class="fn">x3</span>)</span></span>)</span> <span class="fn">init</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Internal.foldRev" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.foldRevM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L387-L394">source</a></div><div class="attributes">@[inline, deprecated &quot;Deprecated without replacement. If the order does not matter, use foldM.&quot; (since := &quot;2025-03-07&quot;)]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldRevM"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">foldRevM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././foundational_types.html">Type</a> w → <a href="../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">δ</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">init</span> : <span class="fn">δ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">δ</span></span></div></div><p>Monadically computes a value by folding the given function over the mappings in the hash
map in the reverse order used by <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldM">foldM</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.foldRevM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.foldRev"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L396-L402">source</a></div><div class="attributes">@[inline, deprecated &quot;Deprecated without replacement. If the order does not matter, use fold.&quot; (since := &quot;2025-03-07&quot;)]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldRev"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">foldRev</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn">δ</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">init</span> : <span class="fn">δ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">δ</span></div></div><p>Folds the given function over the mappings in the hash map in the reverse order used
by <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldM">foldM</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.foldRev">Std.DHashMap.Raw.foldRev</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.foldRevM">Std.DHashMap.Raw.Internal.foldRevM</a> <span class="fn">(fun (<span class="fn">x1</span> : <span class="fn">δ</span>) (<span class="fn">x2</span> : <span class="fn">α</span>) (<span class="fn">x3</span> : <span class="fn"><span class="fn">β</span> <span class="fn">x2</span></span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn">f</span> <span class="fn">x1</span> <span class="fn">x2</span> <span class="fn">x3</span>)</span></span>)</span> <span class="fn">init</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.foldRev" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>We do not define <code><a href="../../.././Init/Control/Basic.html#ForM">ForM</a></code> and <code><a href="../../.././Init/Core.html#ForIn">ForIn</a></code> instances that are specialized to constant <code>β</code>. Instead, we
define uncurried versions of <code>forM</code> and <code>forIn</code> that will be used in the <code>Const</code> lemmas and to
define the <code><a href="../../.././Init/Control/Basic.html#ForM">ForM</a></code> and <code><a href="../../.././Init/Core.html#ForIn">ForIn</a></code> instances for <code>HashMap.Raw</code>.</p></div><div class="decl" id="Std.DHashMap.Raw.Const.forMUncurried"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L414-L416">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.forMUncurried"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">forMUncurried</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././foundational_types.html">Type</a> w → <a href="../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span> → <span class="fn"><span class="fn">m</span> <a href="../../.././Init/Prelude.html#PUnit">PUnit</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href="../../.././Init/Prelude.html#PUnit">PUnit</a></span></div></div><p>Carries out a monadic action on each mapping in the hash map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.forMUncurried">Std.DHashMap.Raw.Const.forMUncurried</a> <span class="fn">f</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.forM">Std.DHashMap.Raw.forM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">a</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">b</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></span>)</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.forMUncurried" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.forInUncurried"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L418-L420">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.forInUncurried"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">forInUncurried</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././foundational_types.html">Type</a> w → <a href="../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">δ</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">init</span> : <span class="fn">δ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">δ</span></span></div></div><p>Support for the <code>for</code> loop construct in <code>do</code> blocks.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.forInUncurried">Std.DHashMap.Raw.Const.forInUncurried</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.forIn">Std.DHashMap.Raw.forIn</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>) (<span class="fn">d</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">a</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">b</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <span class="fn">d</span></span>)</span> <span class="fn">init</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.forInUncurried" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.filterMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L424-L432">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.filterMap"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">γ</span></span></div></div><p>Updates the values of the hash map by applying the given function to all mappings, keeping
only those mappings where the function returns <code>some</code> value.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.filterMap">Std.DHashMap.Raw.filterMap</a> <span class="fn">f</span> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.filterMap">Std.DHashMap.Internal.Raw₀.filterMap</a> <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.filterMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L434-L438">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.map"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">γ</span></span></div></div><p>Updates the values of the hash map by applying the given function to all mappings.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.map">Std.DHashMap.Raw.map</a> <span class="fn">f</span> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.map">Std.DHashMap.Internal.Raw₀.map</a> <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.filter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L440-L444">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.filter"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Removes all mappings of the hash map for which the given function returns <code>false</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.filter">Std.DHashMap.Raw.filter</a> <span class="fn">f</span> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.filter">Std.DHashMap.Internal.Raw₀.filter</a> <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.filter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.toArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L446-L448">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.toArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">toArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Transforms the hash map into an array of mappings in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.toArray">toArray</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>) (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">acc</span>.<a href="../../.././Init/Prelude.html#Array.push">push</a></span> <a href="../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../.././Init/Core.html#Sigma.mk">⟩</a></span>)</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.size">size</a></span>)</span> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.toArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.toArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L450-L452">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.toArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">toArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></div></div><p>Transforms the hash map into an array of mappings in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.toArray">Std.DHashMap.Raw.Const.toArray</a> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">acc</span>.<a href="../../.././Init/Prelude.html#Array.push">push</a></span> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.size">size</a></span>)</span>
    <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.toArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.keysArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L454-L456">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.keysArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">keysArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Returns an array of all keys present in the hash map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.keysArray">keysArray</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>) (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">acc</span>.<a href="../../.././Init/Prelude.html#Array.push">push</a></span> <span class="fn">k</span></span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.size">size</a></span>)</span> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.keysArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.union"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L458-L472">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.union"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">union</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m₁ </span><span class="fn">m₂</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Computes the union of the given hash maps. If a key appears in both maps, the entry contains in
the second argument will appear in the result.</p><p>This function always merges the smaller map into the larger map, so the expected runtime is
<code>O(min(m₁.size, m₂.size))</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m₁</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.union">union</a></span> <span class="fn">m₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h₁ : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m₁</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then
    <span class="fn">if h₂ : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m₂</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.union">Std.DHashMap.Internal.Raw₀.union</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m₁</span>, <span class="fn">h₁</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m₂</span>, <span class="fn">h₂</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <span class="fn">m₁</span></span>
  else <span class="fn">m₂</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.union" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instUnionOfBEqOfHashable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L474-L474">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instUnionOfBEqOfHashable"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instUnionOfBEqOfHashable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#Union">Union</a> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instUnionOfBEqOfHashable">Std.DHashMap.Raw.instUnionOfBEqOfHashable</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#Union.mk">{</a> <span class="fn">union</span> := <a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.union">Std.DHashMap.Raw.union</a> <a href="../../.././Init/Core.html#Union.mk">}</a></li></ul></details></div></div><div class="mod_doc"><p>We currently do not provide lemmas for the functions below.</p></div><div class="decl" id="Std.DHashMap.Raw.values"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L481-L483">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.values"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">values</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">β</span></span></div></div><p>Returns a list of all values present in the hash map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.values">values</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.foldRev">Std.DHashMap.Raw.Internal.foldRev</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">β</span></span>) (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn">β</span>) =&gt; <span class="fn">v</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">acc</span>)</span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.values" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.valuesArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L485-L487">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.valuesArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">valuesArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">β</span></span></div></div><p>Returns an array of all values present in the hash map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.valuesArray">valuesArray</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.fold">Std.DHashMap.Raw.fold</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">β</span></span>) (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">acc</span>.<a href="../../.././Init/Prelude.html#Array.push">push</a></span> <span class="fn">v</span></span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.size">size</a></span>)</span> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.valuesArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.insertMany"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L489-L501">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">insertMany</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <a href="../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">ρ</span> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn">ρ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Inserts multiple mappings into the hash map by iterating over the given collection and calling
<code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert">insert</a></code>. If the same key appears multiple times, the last occurrence takes precedence.</p><p>Note: this precedence behavior is true for <code>HashMap</code>, <code>DHashMap</code>, <code>HashMap.Raw</code> and <code>DHashMap.Raw</code>.
The <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertMany">insertMany</a></code> function on <code>HashSet</code> and <code>HashSet.Raw</code> behaves differently: it will prefer the first
appearance.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertMany">insertMany</a></span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.insertMany">Std.DHashMap.Internal.Raw₀.insertMany</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">l</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.insertMany" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.insertMany"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L503-L507">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">insertMany</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <a href="../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">ρ</span> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn">ρ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span></div></div><p>Inserts multiple mappings into the hash map by iterating over the given collection and calling
<code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert">insert</a></code>. If the same key appears multiple times, the last occurrence takes precedence.</p><p>Note: this precedence behavior is true for <code>HashMap</code>, <code>DHashMap</code>, <code>HashMap.Raw</code> and <code>DHashMap.Raw</code>.
The <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertMany">insertMany</a></code> function on <code>HashSet</code> and <code>HashSet.Raw</code> behaves differently: it will prefer the first
appearance.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertMany">Std.DHashMap.Raw.Const.insertMany</a> <span class="fn">m</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.insertMany">Std.DHashMap.Internal.Raw₀.Const.insertMany</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">l</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.insertMany" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.insertManyIfNewUnit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L509-L521">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertManyIfNewUnit"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">insertManyIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <a href="../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">ρ</span> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn">ρ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></span></div></div><p>Inserts multiple keys with the value <code>()</code> into the hash map by iterating over the given collection
and calling <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertIfNew">insertIfNew</a></code>. If the same key appears multiple times, the first occurrence takes
precedence.</p><p>This is mainly useful to implement <code>HashSet.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertMany">insertMany</a></code>, so if you are considering using this,
<code>HashSet</code> or <code>HashSet.Raw</code> might be a better fit for you.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertManyIfNewUnit">Std.DHashMap.Raw.Const.insertManyIfNewUnit</a> <span class="fn">m</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.insertManyIfNewUnit">Std.DHashMap.Internal.Raw₀.Const.insertManyIfNewUnit</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">l</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span> else <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.insertManyIfNewUnit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.unitOfArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L523-L529">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.unitOfArray"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">unitOfArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></span></div></div><p>Creates a hash map from an array of keys, associating the value <code>()</code> with each key.</p><p>This is mainly useful to implement <code>HashSet.ofArray</code>, so if you are considering using this,
<code>HashSet</code> or <code>HashSet.Raw</code> might be a better fit for you.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.unitOfArray">Std.DHashMap.Raw.Const.unitOfArray</a> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertManyIfNewUnit">Std.DHashMap.Raw.Const.insertManyIfNewUnit</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.unitOfArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Internal.numBuckets"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L531-L537">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.numBuckets"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Internal</span>.<span class="name">numBuckets</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Nat">Nat</a></div></div><p>Returns the number of buckets in the internal representation of the hash map. This function may be
useful for things like monitoring system health, but it should be considered an internal
implementation detail.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.numBuckets">Std.DHashMap.Raw.Internal.numBuckets</a> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Internal.numBuckets" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.toList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L541-L543">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.toList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Transforms the hash map into a list of mappings in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.toList">toList</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.foldRev">Std.DHashMap.Raw.Internal.foldRev</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>) (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) =&gt; <a href="../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">acc</span>)</span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.toList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.toList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L545-L547">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.toList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></div></div><p>Transforms the hash map into a list of mappings in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.toList">Std.DHashMap.Raw.Const.toList</a> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.foldRev">Std.DHashMap.Raw.Internal.foldRev</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn">β</span>) =&gt; <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">acc</span>)</span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.toList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.instRepr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L549-L550">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instRepr"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">instRepr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <span class="fn">(<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.instRepr">Std.DHashMap.Raw.instRepr</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Data/Repr.html#Repr.mk">{</a>     <span class="fn">reprPrec</span> := <span class="fn">fun (<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Std.DHashMap.Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>) (<span class="fn">prec</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>) =&gt;
      <span class="fn"><a href="../../.././Init/Data/Repr.html#Repr.addAppParen">Repr.addAppParen</a> (<span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.Format.text">Std.Format.text</a> <span class="fn">&quot;Std.DHashMap.Raw.ofList &quot;</span></span> <a href="../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../.././Init/Data/Repr.html#reprArg">reprArg</a> <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.toList">toList</a></span></span>) <span class="fn">prec</span></span></span> <a href="../../.././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.keys"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L552-L554">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.keys"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></div></div><p>Returns a list of all keys present in the hash map in some order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.keys">keys</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Internal.foldRev">Std.DHashMap.Raw.Internal.foldRev</a> <span class="fn">(fun (<span class="fn">acc</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>) (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) =&gt; <span class="fn">k</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">acc</span>)</span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.keys" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.ofList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L556-L559">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Creates a hash map from a list of mappings. If the same key appears multiple times, the last
occurrence takes precedence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.ofList">Std.DHashMap.Raw.ofList</a> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertMany">insertMany</a></span> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.ofList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.ofList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L561-L563">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span></div></div><p>Creates a hash map from a list of mappings. If the same key appears multiple times, the last
occurrence takes precedence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.ofList">Std.DHashMap.Raw.Const.ofList</a> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertMany">Std.DHashMap.Raw.Const.insertMany</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.ofList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.Const.unitOfList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L565-L571">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.unitOfList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">Const</span>.<span class="name">unitOfList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></span></div></div><p>Creates a hash map from a list of keys, associating the value <code>()</code> with each key.</p><p>This is mainly useful to implement <code>HashSet.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.ofList">ofList</a></code>, so if you are considering using this,
<code>HashSet</code> or <code>HashSet.Raw</code> might be a better fit for you.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.unitOfList">Std.DHashMap.Raw.Const.unitOfList</a> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertManyIfNewUnit">Std.DHashMap.Raw.Const.insertManyIfNewUnit</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.Const.unitOfList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.WF"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L575-L623">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span> → <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>Well-formedness predicate for hash maps. Users of <code>DHashMap</code> will not need to interact with
this. Users of <code>DHashMap.Raw</code> will need to provide proofs of <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></code> to lemmas and should use lemmas
like <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.empty">WF.empty</a></code> and <code><a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.insert">WF.insert</a></code> (which are always named exactly like the operations they are about)
to show that map operations preserve well-formedness. The constructors of this type are internal
implementation details and should not be accessed by users.</p><ul class="constructors"><li class="constructor" id="Std.DHashMap.Raw.WF.wf">wf<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span> : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span> → <span class="fn"><span class="fn">(∀ [<span class="fn"><a href="../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>] [<span class="fn"><a href="../../.././Init/Data/LawfulHashable.html#LawfulHashable">LawfulHashable</a> <span class="fn">α</span></span>], <span class="fn"><a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw.WFImp">Internal.Raw.WFImp</a> <span class="fn">m</span></span>)</span> → <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.emptyWithCapacity₀">emptyWithCapacity₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.emptyWithCapacity">Internal.Raw₀.emptyWithCapacity</a> <span class="fn">c</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.insert₀">insert₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.insert">Internal.Raw₀.insert</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.containsThenInsert₀">containsThenInsert₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.containsThenInsert">Internal.Raw₀.containsThenInsert</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Prelude.html#Prod.snd">snd</a></span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.containsThenInsertIfNew₀">containsThenInsertIfNew₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.containsThenInsertIfNew">Internal.Raw₀.containsThenInsertIfNew</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Prelude.html#Prod.snd">snd</a></span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.erase₀">erase₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.erase">Internal.Raw₀.erase</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.insertIfNew₀">insertIfNew₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.insertIfNew">Internal.Raw₀.insertIfNew</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.getThenInsertIfNew?₀">getThenInsertIfNew?₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.getThenInsertIfNew?">Internal.Raw₀.getThenInsertIfNew?</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Prelude.html#Prod.snd">snd</a></span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.filter₀">filter₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.filter">Internal.Raw₀.filter</a> <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.constGetThenInsertIfNew?₀">constGetThenInsertIfNew?₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.getThenInsertIfNew?">Internal.Raw₀.Const.getThenInsertIfNew?</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Prelude.html#Prod.snd">snd</a></span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.modify₀">modify₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.modify">Internal.Raw₀.modify</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">f</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.constModify₀">constModify₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.modify">Internal.Raw₀.Const.modify</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">f</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.alter₀">alter₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.alter">Internal.Raw₀.alter</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">f</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li><li class="constructor" id="Std.DHashMap.Raw.WF.constAlter₀">constAlter₀<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.Const.alter">Internal.Raw₀.Const.alter</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m</span>, <span class="fn">h</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <span class="fn">a</span> <span class="fn">f</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></span><div class="inductive_ctor_doc"><p>Internal implementation detail of the hash map</p></div></li></ul><details id="instances-for-list-Std.DHashMap.Raw.WF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.WF.empty₀"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L627-L628">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.empty₀"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">empty₀</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.emptyWithCapacity">Internal.Raw₀.emptyWithCapacity</a> <span class="fn">c</span>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.empty₀">Std.DHashMap.Raw.WF.empty₀</a> <a href="../../.././Init/Prelude.html#Eq">=</a> @<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.emptyWithCapacity₀">Std.DHashMap.Raw.WF.emptyWithCapacity₀</a></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.WF.empty₀" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.WF.size_buckets_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L630-L645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.size_buckets_pos"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">size_buckets_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span> → <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw.buckets">buckets</a></span>.<a href="../../.././Init/Prelude.html#Array.size">size</a></span></span></div></div><p>Internal implementation detail of the hash map</p></div></div><div class="decl" id="Std.DHashMap.Raw.WF.emptyWithCapacity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L647-L648">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.emptyWithCapacity"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">emptyWithCapacity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.emptyWithCapacity">Raw.emptyWithCapacity</a> <span class="fn">c</span>)</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.empty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L650-L651">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.empty"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.emptyc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L654-L655">source</a></div><div class="attributes">@[reducible, inline, deprecated Std.DHashMap.Raw.WF.empty (since := &quot;2025-03-12&quot;)]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.emptyc"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">emptyc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.emptyc">Std.DHashMap.Raw.WF.emptyc</a> <a href="../../.././Init/Prelude.html#Eq">=</a> @<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.empty">Std.DHashMap.Raw.WF.empty</a></li></ul></details><details id="instances-for-list-Std.DHashMap.Raw.WF.emptyc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.DHashMap.Raw.WF.insert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L657-L659">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.insert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insert">insert</a></span> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.containsThenInsert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L661-L663">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.containsThenInsert"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">containsThenInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.containsThenInsert">containsThenInsert</a></span> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Prelude.html#Prod.snd">snd</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.containsThenInsertIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L665-L667">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.containsThenInsertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">containsThenInsertIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.containsThenInsertIfNew">containsThenInsertIfNew</a></span> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Prelude.html#Prod.snd">snd</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.erase"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L669-L670">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.erase"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.erase">erase</a></span> <span class="fn">a</span>)</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.insertIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L672-L674">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.insertIfNew"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">insertIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertIfNew">insertIfNew</a></span> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.getThenInsertIfNew?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L676-L678">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">getThenInsertIfNew?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.getThenInsertIfNew?">getThenInsertIfNew?</a></span> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Prelude.html#Prod.snd">snd</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L680-L682">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.filter"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.filter">Raw.filter</a> <span class="fn">f</span> <span class="fn">m</span>)</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.Const.getThenInsertIfNew?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L684-L686">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.Const.getThenInsertIfNew?"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">getThenInsertIfNew?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.getThenInsertIfNew?">Raw.Const.getThenInsertIfNew?</a> <span class="fn">m</span> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Prelude.html#Prod.snd">snd</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.insertMany"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L688-L691">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">insertMany</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <a href="../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">ρ</span> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.insertMany">insertMany</a></span> <span class="fn">l</span>)</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.Const.insertMany"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L693-L696">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.Const.insertMany"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">insertMany</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <a href="../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">ρ</span> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertMany">Raw.Const.insertMany</a> <span class="fn">m</span> <span class="fn">l</span>)</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.Const.insertManyIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L698-L701">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.Const.insertManyIfNewUnit"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">insertManyIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#ForIn">ForIn</a> <a href="../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">ρ</span> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">m</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.insertManyIfNewUnit">Raw.Const.insertManyIfNewUnit</a> <span class="fn">m</span> <span class="fn">l</span>)</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.ofList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L703-L705">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.ofList">Raw.ofList</a> <span class="fn">l</span>)</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.Const.ofList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L707-L709">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.Const.ofList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.ofList">Raw.Const.ofList</a> <span class="fn">l</span>)</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.Const.unitOfList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L711-L713">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.Const.unitOfList"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">Const</span>.<span class="name">unitOfList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.Const.unitOfList">Raw.Const.unitOfList</a> <span class="fn">l</span>)</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.union₀"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L715-L719">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.union₀"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">union₀</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m₁ </span><span class="fn">m₂</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">m₁</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">m₂</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Std/Data/DHashMap/Internal/Defs.html#Std.DHashMap.Internal.Raw₀.union">Internal.Raw₀.union</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m₁</span>, <span class="fn">⋯</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a> <a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn">m₂</span>, <span class="fn">⋯</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a>)</span>.<a href="../../.././Init/Prelude.html#Subtype.val">val</a></span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div><div class="decl" id="Std.DHashMap.Raw.WF.union"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Data/DHashMap/Raw.lean#L721-L723">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF.union"><span class="name">Std</span>.<span class="name">DHashMap</span>.<span class="name">Raw</span>.<span class="name">WF</span>.<span class="name">union</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m₁ </span><span class="fn">m₂</span> : <span class="fn"><a href="../../.././Std/Data/DHashMap/RawDef.html#Std.DHashMap.Raw">Raw</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">m₁</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">m₂</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m₁</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.union">union</a></span> <span class="fn">m₂</span>)</span>.<a href="../../.././Std/Data/DHashMap/Raw.html#Std.DHashMap.Raw.WF">WF</a></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>