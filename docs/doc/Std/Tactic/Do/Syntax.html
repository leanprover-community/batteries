<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Std.Tactic.Do.Syntax</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Std.Tactic.Do.Syntax";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">Do</span>.<span class="name">Syntax</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Std/Do.html">Std.Do</a></li><li><a href="../../.././Std/Tactic/Do/ProofMode.html">Std.Tactic.Do.ProofMode</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Std.Tactic.Do.Syntax" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Tactic.Do.VCGen.Config"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">Do</span>.<span class="name">VCGen</span>.<span class="name">Config</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.spec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">spec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.massumption"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">massumption</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mclear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mclear</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mconstructor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mconstructor</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mexact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mexact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mexfalso"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mexfalso</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mexists"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mexists</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mframe"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mframe</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mdup"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mdup</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mhave"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mhave</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mreplace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mreplace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mright"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mright</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mleft"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mleft</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mpure"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mpure</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mpureIntro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mpureIntro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrenameI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrenameI</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mspecialize"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecialize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mspecializePure"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecializePure</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mstart"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mstart</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mstop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mstop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mleave"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mleave</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.mcasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mcasesPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mcasesPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcasesPat</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mcasesPatAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcasesPatAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mcasesPat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcasesPat_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat-»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat-»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat⟨_⟩»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat⟨_⟩»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat(_)»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat(_)»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat⌜_⌝»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat⌜_⌝»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat□_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat□_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat%_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat%_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat#_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat#_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MCasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.instReprMCasesPat.repr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instReprMCasesPat</span>.<span class="name">repr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.instReprMCasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instReprMCasesPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.instInhabitedMCasesPat.default"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instInhabitedMCasesPat</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.instInhabitedMCasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instInhabitedMCasesPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MCasesPat.parse"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span>.<span class="name">parse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MCasesPat.parse.go"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span>.<span class="name">parse</span>.<span class="name">go</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MCasesPat.parse.goAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span>.<span class="name">parse</span>.<span class="name">goAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mcases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcases</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrefinePat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePat</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.mrefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mrefinePat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrefinePat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePat_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrefinePats"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePats</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrefinePat⟨_⟩»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat⟨_⟩»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrefinePat(_)»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat(_)»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrefinePat⌜_⌝»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat⌜_⌝»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrefinePat□_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat□_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrefinePat?_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePat?_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrefinePat%_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat%_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrefinePat#_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat#_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MRefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MRefinePat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.instReprMRefinePat.repr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instReprMRefinePat</span>.<span class="name">repr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.instReprMRefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instReprMRefinePat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.instInhabitedMRefinePat.default"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instInhabitedMRefinePat</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.instInhabitedMRefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instInhabitedMRefinePat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MRefinePat.parse"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MRefinePat</span>.<span class="name">parse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MRefinePat.parse.go"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MRefinePat</span>.<span class="name">parse</span>.<span class="name">go</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrefine"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefine</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mintroPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mintroPat</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.mintroPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mintroPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mintroPat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mintroPat_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mintroPat∀_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mintroPat∀_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mintro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mintro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrevertPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrevertPat</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.mrevertPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mrevertPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrevertPat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrevertPat_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrevertPat∀_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrevertPat∀_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrevert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrevert</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mspecNoBind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecNoBind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mspecNoSimp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecNoSimp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mspec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticMvcgen_trivial_extensible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticMvcgen_trivial_extensible</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticMvcgen_trivial"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticMvcgen_trivial</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.invariantDotAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">invariantDotAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.invariantCaseAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">invariantCaseAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.invariantsKW"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">invariantsKW</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.invariantAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">invariantAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.vcAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">vcAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.vcAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">vcAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mvcgen"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mvcgen</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mvcgenHint"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mvcgenHint</span></a></div></nav><main>
<div class="decl" id="Lean.Elab.Tactic.Do.VCGen.Config"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L18-L46">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">Do</span>.<span class="name">VCGen</span>.<span class="name">Config</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Elab.Tactic.Do.VCGen.Config.mk"><li id="Lean.Elab.Tactic.Do.VCGen.Config.trivial" class="structure_field"><div class="structure_field_info">trivial : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code>true</code> (the default), we will try to prove VCs via <code>mvcgen_trivial</code>, which is extensible
via <code>macro_rules</code>.</p></div></li><li id="Lean.Elab.Tactic.Do.VCGen.Config.leave" class="structure_field"><div class="structure_field_info">leave : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code>true</code> (the default), we will simplify every generated VC after trying
<code>mvcgen_trivial</code> by running <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleave">mleave</a></code>. (Note that this can be expensive.)</p></div></li><li id="Lean.Elab.Tactic.Do.VCGen.Config.elimLets" class="structure_field"><div class="structure_field_info">elimLets : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code>true</code> (the default), we substitute away let-declarations that are used at most once before
starting VC generation and will do the same for every VC generated.</p></div></li><li id="Lean.Elab.Tactic.Do.VCGen.Config.jp" class="structure_field"><div class="structure_field_info">jp : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code>false</code> (the default), then we aggressively split <code>if</code> and <code>match</code> statements and inline join
points unconditionally. For some programs this causes exponential blowup of VCs.
Set this flag to choose a more conservative (but slightly lossy) encoding that traverses
every join point only once and yields a formula the size of which is linear in the number of
control flow splits.</p></div></li><li id="Lean.Elab.Tactic.Do.VCGen.Config.stepLimit" class="structure_field"><div class="structure_field_info">stepLimit : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Init/Prelude.html#Nat">Nat</a></span></div><div class="structure_field_doc"><p>If set to <code>some n</code>, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> will only do 42 steps of the VC generation procedure.
This is helpful for bisecting bugs in <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> and tracing its execution.</p></div></li></ul><details id="instances-for-list-Lean.Elab.Tactic.Do.VCGen.Config" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.spec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L53-L62">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Attr.spec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">spec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Theorems tagged with the <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Attr.spec">spec</a></code> attribute are used by the <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> and <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> tactics.</p><ul>
<li>When used on a theorem <code>foo_spec : Triple (foo a b c) P Q</code>, then <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> and <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> will use
<code>foo_spec</code> as a specification for calls to <code>foo</code>.</li>
<li>Otherwise, when used on a definition that <code>@[simp]</code> would work on, it is added to the internal
simp set of <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> that is used within <code>wp⟦·⟧</code> contexts to simplify match discriminants and
applications of constants.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.spec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.massumption"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L68-L69">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.massumption"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">massumption</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.massumption">massumption</a></code> is like <code>assumption</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : Q ⊢ₛ P → Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> _ _
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.massumption">massumption</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.massumption">Lean.Parser.Tactic.massumption</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.massumption</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;massumption&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.massumption" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mclear"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L71-L72">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mclear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mclear</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mclear">mclear</a></code> is like <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.clear">clear</a></code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ Q → Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mclear">mclear</a> HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HQ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mclear" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mconstructor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L74-L75">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mconstructor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mconstructor</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mconstructor">mconstructor</a></code> is like <code>constructor</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (Q : SPred σs) : Q ⊢ₛ Q ∧ Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mconstructor">mconstructor</a> &lt;;&gt; <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HQ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mconstructor">Lean.Parser.Tactic.mconstructor</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mconstructor</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mconstructor&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mconstructor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mexact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L77-L78">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mexact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a></code> is like <code>exact</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (Q : SPred σs) : Q ⊢ₛ Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstart">mstart</a>
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HQ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mexact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mexfalso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L80-L81">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexfalso"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mexfalso</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexfalso">mexfalso</a></code> is like <code>exfalso</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P : SPred σs) : ⌜False⌝ ⊢ₛ P := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexfalso">mexfalso</a>
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HP
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexfalso">Lean.Parser.Tactic.mexfalso</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mexfalso</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mexfalso&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mexfalso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mexists"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L83-L84">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexists"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mexists</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexists">mexists</a></code> is like <code>exists</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (ψ : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> H
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexists">mexists</a> 42
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mexists" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mframe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L86-L87">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mframe</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe">mframe</a></code> infers which hypotheses from the stateful context can be moved into the pure context.
This is useful because pure hypotheses &quot;survive&quot; the next application of modus ponens
(<code><a href="../../.././Std/Do/SPred/DerivedLaws.html#Std.Do.SPred.mp">Std.Do.SPred.mp</a></code>) and transitivity (<code><a href="../../.././Std/Do/SPred/Laws.html#Std.Do.SPred.entails.trans">Std.Do.SPred.entails.trans</a></code>).</p><p>It is used as part of the <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> tactic.</p><pre><code class="language-lean">example (P Q : SPred σs) : ⊢ₛ ⌜p⌝ ∧ Q ∧ ⌜q⌝ ∧ ⌜r⌝ ∧ P ∧ ⌜s⌝ ∧ ⌜t⌝ → Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> _
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe">mframe</a>
  /- `h : p ∧ q ∧ r ∧ s ∧ t` in the <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.pure">pure</a> context -/
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases">mcases</a> h with hP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> h
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe">Lean.Parser.Tactic.mframe</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mframe</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mframe&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mframe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mdup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L89-L90">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mdup"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mdup</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Duplicate a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> hypothesis.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mdup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mhave"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L92-L93">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mhave"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mhave</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mhave">mhave</a></code> is like <code>have</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP HPQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mhave">mhave</a> HQ : Q := by <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize">mspecialize</a> HPQ HP; <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HPQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HQ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mhave" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mreplace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L95-L96">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mreplace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mreplace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mreplace">mreplace</a></code> is like <code>replace</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP HPQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mreplace">mreplace</a> HPQ : Q := by <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize">mspecialize</a> HPQ HP; <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HPQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HPQ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mreplace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mright"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L98-L99">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mright"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mright</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mright">mright</a></code> is like <code>right</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ Q ∨ P := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mright">mright</a>
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HP
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mright">Lean.Parser.Tactic.mright</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mright</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mright&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mright" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mleft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L101-L102">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleft"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mleft</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleft">mleft</a></code> is like <code>left</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ P ∨ Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleft">mleft</a>
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HP
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleft">Lean.Parser.Tactic.mleft</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mleft</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mleft&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mleft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mpure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L104-L105">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpure"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mpure</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpure">mpure</a></code> moves a pure hypothesis from the stateful context into the pure context.</p><pre><code class="language-lean">example (Q : SPred σs) (ψ : φ → ⊢ₛ Q): ⌜φ⌝ ⊢ₛ Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> Hφ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpure">mpure</a> Hφ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> (ψ Hφ)
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mpure" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mpureIntro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L108-L109">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpureIntro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mpureIntro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>mpure_intro</code> operates on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal of the form <code>P ⊢ₛ ⌜φ⌝</code>.
It leaves the stateful proof mode (thereby discarding <code>P</code>), leaving the regular goal <code>φ</code>.</p><pre><code class="language-lean">theorem simple : ⊢ₛ (⌜True⌝ : SPred σs) := by
  mpure_intro
  exact <a href="../../.././Init/Prelude.html#True.intro">True.intro</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpureIntro">Lean.Parser.Tactic.mpureIntro</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mpureIntro</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mpure_intro&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mpureIntro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrenameI"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L111-L112">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrenameI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrenameI</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>mrename_i</code> is like <code>rename_i</code>, but names inaccessible stateful hypotheses in a <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrenameI" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mspecialize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L114-L115">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecialize</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize">mspecialize</a></code> is like <code>specialize</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.
It specializes a hypothesis from the stateful context with hypotheses from either the pure
or stateful context or pure terms.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP HPQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize">mspecialize</a> HPQ HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HPQ

example (y : Nat) (P Q : SPred σs) (Ψ : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → SPred σs) (hP : ⊢ₛ P) : ⊢ₛ Q → (∀ x, P → Q → Ψ x) → Ψ (y + 1) := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HQ HΨ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize">mspecialize</a> HΨ (y + 1) hP HQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HΨ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mspecialize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mspecializePure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L117-L118">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecializePure"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecializePure</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>mspecialize_pure</code> is like <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize">mspecialize</a></code>, but it specializes a hypothesis from the
<em>pure</em> context with hypotheses from either the pure or stateful context or pure terms.</p><pre><code class="language-lean">example (y : Nat) (P Q : SPred σs) (Ψ : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → SPred σs) (hP : ⊢ₛ P) (hΨ : ∀ x, ⊢ₛ P → Q → Ψ x) : ⊢ₛ Q → Ψ (y + 1) := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HQ
  mspecialize_pure (hΨ (y + 1)) hP HQ =&gt; HΨ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HΨ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mspecializePure" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mstart"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L120-L121">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstart"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mstart</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Start the stateful proof mode of <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code>.
This will transform a stateful goal of the form <code>H ⊢ₛ T</code> into <code>⊢ₛ H → T</code>
upon which <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a></code> can be used to re-introduce <code>H</code> and give it a name.
It is often more convenient to use <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a></code> directly, which will
try <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstart">mstart</a></code> automatically if necessary.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstart">Lean.Parser.Tactic.mstart</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mstart</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mstart&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mstart" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mstop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L123-L124">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mstop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Stops the stateful proof mode of <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code>.
This will simply forget all the names given to stateful hypotheses and pretty-print
a bit differently.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstop">Lean.Parser.Tactic.mstop</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mstop</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mstop&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mstop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mleave"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L127-L171">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleave"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mleave</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Leaves the stateful proof mode of <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code>, tries to eta-expand through all definitions
related to the logic of the <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> and gently simplifies the resulting pure Lean
proposition. This is often the right thing to do after <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> in order for automation to prove
the goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleave">Lean.Parser.Tactic.mleave</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mleave</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mleave&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mleave" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.mcasesPat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L173-L173">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mcasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mcasesPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mcasesPat">Lean.Parser.Category.mcasesPat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.mcasesPat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mcasesPat.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L173-L173">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcasesPat</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mcasesPat.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mcasesPatAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L174-L174">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPatAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcasesPatAlts</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mcasesPatAlts" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mcasesPat_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L175-L175">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcasesPat_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat_">Lean.Parser.Tactic.mcasesPat_</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mcasesPat_</span> <span class="fn">1022</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mcasesPat_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat-»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L176-L176">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat-»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat-»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat-»">Lean.Parser.Tactic.«mcasesPat-»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mcasesPat-»</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;-&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat-»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat⟨_⟩»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L177-L177">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat⟨_⟩»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat⟨_⟩»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat⟨_⟩»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat(_)»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L178-L178">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat(_)»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat(_)»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat(_)»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat⌜_⌝»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L179-L179">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat⌜_⌝»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat⌜_⌝»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat⌜_⌝»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat□_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L180-L180">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat□_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat□_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat□_»">Lean.Parser.Tactic.«mcasesPat□_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mcasesPat□_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;□&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat□_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat%_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L182-L182">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat%_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat%_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat%_»">Lean.Parser.Tactic.«mcasesPat%_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mcasesPat%_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;%&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat%_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat#_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L183-L183">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat#_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat#_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat#_»">Lean.Parser.Tactic.«mcasesPat#_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mcasesPat#_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;#&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat#_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.MCasesPat"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L185-L192">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><ul class="constructors"><li class="constructor" id="Lean.Parser.Tactic.MCasesPat.one">one<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></li><li class="constructor" id="Lean.Parser.Tactic.MCasesPat.clear">clear : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></li><li class="constructor" id="Lean.Parser.Tactic.MCasesPat.tuple">tuple<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></li><li class="constructor" id="Lean.Parser.Tactic.MCasesPat.alts">alts<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></li><li class="constructor" id="Lean.Parser.Tactic.MCasesPat.pure">pure<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></li><li class="constructor" id="Lean.Parser.Tactic.MCasesPat.stateful">stateful<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></li></ul><details id="instances-for-list-Lean.Parser.Tactic.MCasesPat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.instReprMCasesPat.repr"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L192-L192">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMCasesPat.repr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instReprMCasesPat</span>.<span class="name">repr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../.././Init/Data/Format/Basic.html#Std.Format">Std.Format</a></span></span></div></div></div></div><div class="decl" id="Lean.Parser.Tactic.instReprMCasesPat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L192-L192">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMCasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instReprMCasesPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMCasesPat">Lean.Parser.Tactic.instReprMCasesPat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMCasesPat.repr">Lean.Parser.Tactic.instReprMCasesPat.repr</a> <a href="../../.././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.instInhabitedMCasesPat.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L192-L192">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat.default"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instInhabitedMCasesPat</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat.default">Lean.Parser.Tactic.instInhabitedMCasesPat.default</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.one">Lean.Parser.Tactic.MCasesPat.one</a> <a href="../../.././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.instInhabitedMCasesPat.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.instInhabitedMCasesPat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L192-L192">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instInhabitedMCasesPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat">Lean.Parser.Tactic.instInhabitedMCasesPat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat.default">Lean.Parser.Tactic.instInhabitedMCasesPat.default</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.MCasesPat.parse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L194-L212">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span>.<span class="name">parse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`mcasesPat</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.MCasesPat.parse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.MCasesPat.parse.go"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L199-L206">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse.go"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span>.<span class="name">parse</span>.<span class="name">go</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`mcasesPat</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span></span></div></div></div></div><div class="decl" id="Lean.Parser.Tactic.MCasesPat.parse.goAlts"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L207-L212">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse.goAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span>.<span class="name">parse</span>.<span class="name">goAlts</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.Parser.Tactic.mcasesPatAlts</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span></span></div></div></div></div><div class="decl" id="Lean.Parser.Tactic.mcases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L214-L215">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcases</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code>rcases</code>, but operating on stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goals.
Example: Given a goal <code>h : (P ∧ (Q ∨ R) ∧ (Q → R)) ⊢ₛ R</code>,
<code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases">mcases</a> h with ⟨-, ⟨hq | hr⟩, hqr⟩</code> will yield two goals:
<code>(hq : Q, hqr : Q → R) ⊢ₛ R</code> and <code>(hr : R) ⊢ₛ R</code>.</p><p>That is, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases">mcases</a> h with pat</code> has the following semantics, based on <code>pat</code>:</p><ul>
<li><code>pat=□h'</code> renames <code>h</code> to <code>h'</code> in the stateful context, regardless of whether <code>h</code> is pure</li>
<li><code>pat=⌜h'⌝</code> introduces <code>h' : φ</code>  to the pure local context if <code>h : ⌜φ⌝</code>
(c.f. <code>Lean.Elab.Tactic.Do.ProofMode.IsPure</code>)</li>
<li><code>pat=h'</code> is like <code>pat=⌜h'⌝</code> if <code>h</code> is pure
(c.f. <code>Lean.Elab.Tactic.Do.ProofMode.IsPure</code>), otherwise it is like <code>pat=□h'</code>.</li>
<li><code>pat=_</code> renames <code>h</code> to an inaccessible name</li>
<li><code>pat=-</code> discards <code>h</code></li>
<li><code>⟨pat₁, pat₂⟩</code> matches on conjunctions and existential quantifiers and recurses via
<code>pat₁</code> and <code>pat₂</code>.</li>
<li><code>⟨pat₁ | pat₂⟩</code> matches on disjunctions, matching the left alternative via <code>pat₁</code> and the right
alternative via <code>pat₂</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mcases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrefinePat.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L217-L217">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePat</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrefinePat.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.mrefinePat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L217-L217">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mrefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mrefinePat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mrefinePat">Lean.Parser.Category.mrefinePat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.mrefinePat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrefinePat_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L218-L218">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePat_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat_">Lean.Parser.Tactic.mrefinePat_</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mrefinePat_</span> <span class="fn">1022</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrefinePat_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrefinePats"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L219-L219">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePats"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePats</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrefinePats" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrefinePat⟨_⟩»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L220-L220">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat⟨_⟩»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat⟨_⟩»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrefinePat⟨_⟩»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrefinePat(_)»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L221-L221">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat(_)»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat(_)»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrefinePat(_)»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrefinePat⌜_⌝»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L222-L222">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat⌜_⌝»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat⌜_⌝»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrefinePat⌜_⌝»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrefinePat□_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L223-L223">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat□_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat□_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat□_»">Lean.Parser.Tactic.«mrefinePat□_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mrefinePat□_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;□&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrefinePat□_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrefinePat?_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L224-L224">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat?_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePat?_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat?_">Lean.Parser.Tactic.mrefinePat?_</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mrefinePat?_</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;?&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrefinePat?_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrefinePat%_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L226-L226">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat%_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat%_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat%_»">Lean.Parser.Tactic.«mrefinePat%_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mrefinePat%_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;%&quot;</span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrefinePat%_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrefinePat#_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L227-L227">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat#_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat#_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat#_»">Lean.Parser.Tactic.«mrefinePat#_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mrefinePat#_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;#&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrefinePat#_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.MRefinePat"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L229-L235">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MRefinePat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><ul class="constructors"><li class="constructor" id="Lean.Parser.Tactic.MRefinePat.one">one<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></li><li class="constructor" id="Lean.Parser.Tactic.MRefinePat.tuple">tuple<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></li><li class="constructor" id="Lean.Parser.Tactic.MRefinePat.pure">pure<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`term</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></li><li class="constructor" id="Lean.Parser.Tactic.MRefinePat.stateful">stateful<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></li><li class="constructor" id="Lean.Parser.Tactic.MRefinePat.hole">hole<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></li></ul><details id="instances-for-list-Lean.Parser.Tactic.MRefinePat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.instReprMRefinePat.repr"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L235-L235">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMRefinePat.repr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instReprMRefinePat</span>.<span class="name">repr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../.././Init/Data/Format/Basic.html#Std.Format">Std.Format</a></span></span></div></div></div></div><div class="decl" id="Lean.Parser.Tactic.instReprMRefinePat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L235-L235">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMRefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instReprMRefinePat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMRefinePat">Lean.Parser.Tactic.instReprMRefinePat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMRefinePat.repr">Lean.Parser.Tactic.instReprMRefinePat.repr</a> <a href="../../.././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.instInhabitedMRefinePat.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L235-L235">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat.default"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instInhabitedMRefinePat</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat.default">Lean.Parser.Tactic.instInhabitedMRefinePat.default</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.one">Lean.Parser.Tactic.MRefinePat.one</a> <a href="../../.././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.instInhabitedMRefinePat.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.instInhabitedMRefinePat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L235-L235">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instInhabitedMRefinePat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat">Lean.Parser.Tactic.instInhabitedMRefinePat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat.default">Lean.Parser.Tactic.instInhabitedMRefinePat.default</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.MRefinePat.parse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L237-L249">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.parse"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MRefinePat</span>.<span class="name">parse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`mrefinePat</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.MRefinePat.parse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.MRefinePat.parse.go"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L242-L249">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.parse.go"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MRefinePat</span>.<span class="name">parse</span>.<span class="name">go</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`mrefinePat</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></span></span></div></div></div></div><div class="decl" id="Lean.Parser.Tactic.mrefine"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L251-L252">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefine"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefine</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code>refine</code>, but operating on stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goals.</p><pre><code class="language-lean">example (P Q R : SPred σs) : (P ∧ Q ∧ R) ⊢ₛ P ∧ R := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ⟨HP, HQ, HR⟩
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefine">mrefine</a> ⟨HP, HR⟩

example (ψ : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> H
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefine">mrefine</a> ⟨⌜42⌝, H⟩
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrefine" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mintroPat.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L254-L254">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mintroPat</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mintroPat.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.mintroPat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L254-L254">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mintroPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mintroPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mintroPat">Lean.Parser.Category.mintroPat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.mintroPat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mintroPat_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L255-L255">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mintroPat_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat_">Lean.Parser.Tactic.mintroPat_</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mintroPat_</span> <span class="fn">1022</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`mcasesPat</span> <span class="fn">0</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mintroPat_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mintroPat∀_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L256-L256">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mintroPat∀_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mintroPat∀_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mintroPat∀_»">Lean.Parser.Tactic.«mintroPat∀_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mintroPat∀_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;∀&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mintroPat∀_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mintro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L258-L259">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mintro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code>intro</code>, but introducing stateful hypotheses into the stateful context of the <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code>
proof mode.
That is, given a stateful goal <code>(hᵢ : Hᵢ)* ⊢ₛ P → T</code>, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> h</code> transforms
into <code>(hᵢ : Hᵢ)*, (h : P) ⊢ₛ T</code>.</p><p>Furthermore, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ∀s</code> is like <code>intro s</code>, but preserves the stateful goal.
That is, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ∀s</code> brings the topmost state variable <code>s:σ</code> in scope and transforms
<code>(hᵢ : Hᵢ)* ⊢ₛ T</code> (where the entailment is in <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a> (σ::σs)</code>) into
<code>(hᵢ : Hᵢ s)* ⊢ₛ T s</code> (where the entailment is in <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a> σs</code>).</p><p>Beyond that, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a></code> supports the full syntax of <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases">mcases</a></code> patterns
(<code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> pat = (mintro h; <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases">mcases</a> h with pat</code>), and can perform multiple
introductions in sequence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mintro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrevertPat.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L270-L270">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevertPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrevertPat</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrevertPat.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.mrevertPat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L270-L270">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mrevertPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mrevertPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mrevertPat">Lean.Parser.Category.mrevertPat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.mrevertPat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrevertPat_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L272-L272">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevertPat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrevertPat_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevertPat_">Lean.Parser.Tactic.mrevertPat_</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mrevertPat_</span> <span class="fn">1022</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrevertPat_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrevertPat∀_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L273-L273">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrevertPat∀_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrevertPat∀_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrevertPat∀_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrevert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L275-L276">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrevert</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevert">mrevert</a></code> is like <code>revert</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q R : SPred σs) : P ∧ Q ∧ R ⊢ₛ P → R := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ⟨HP, HQ, HR⟩
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevert">mrevert</a> HR
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevert">mrevert</a> HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP'
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HR'
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HR'
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrevert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mspecNoBind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L281-L289">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoBind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecNoBind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>mspec_no_simp $spec</code> first tries to decompose <code><a href="../../.././Init/Prelude.html#Bind.bind">Bind.bind</a></code>s before applying <code>$spec</code>.
This variant of <code>mspec_no_simp</code> does not; <code>mspec_no_bind $spec</code> is defined as</p><pre><code>try with_reducible mspec_no_bind <a href="../../.././Std/Do/Triple/SpecLemmas.html#Std.Do.Spec.bind">Std.Do.Spec.bind</a>
mspec_no_bind $spec
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mspecNoBind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mspecNoSimp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L301-L302">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoSimp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecNoSimp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code>, but does not attempt slight simplification and closing of trivial sub-goals.
<code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a> $spec</code> is roughly (the set of simp lemmas below might not be up to date)</p><pre><code>mspec_no_simp $spec
all_goals
  ((try simp only [SPred.true_intro_simp, SPred.apply_pure]);
   (try mpure_intro; trivial))
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mspecNoSimp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mspec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L305-L310">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> is an <code>apply</code>-like tactic that applies a Hoare triple specification to the target of the
stateful goal.</p><p>Given a stateful goal <code>H ⊢ₛ wp⟦prog⟧ Q'</code>, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a> foo_spec</code> will instantiate
<code>foo_spec : ... → ⦃P⦄ foo ⦃Q⦄</code>, match <code>foo</code> against <code>prog</code> and produce subgoals for
the verification conditions <code>?pre : H ⊢ₛ P</code> and <code>?post : Q ⊢ₚ Q'</code>.</p><ul>
<li>If <code>prog = x &gt;&gt;= f</code>, then <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a> Specs.bind</code> is tried first so that <code>foo</code> is matched against <code>x</code>
instead. Tactic <code>mspec_no_bind</code> does not attempt to do this decomposition.</li>
<li>If <code>?pre</code> or <code>?post</code> follow by <code>.<a href="../../.././Init/Prelude.html#rfl">rfl</a></code>, then they are discharged automatically.</li>
<li><code>?post</code> is automatically simplified into constituent <code>⊢ₛ</code> entailments on
success and failure continuations.</li>
<li><code>?pre</code> and <code>?post.*</code> goals introduce their stateful hypothesis under an inaccessible name.
You can give it a name with the <code>mrename_i</code> tactic.</li>
<li>Any uninstantiated MVar arising from instantiation of <code>foo_spec</code> becomes a new subgoal.</li>
<li>If the target of the stateful goal looks like <code>fun s =&gt; _</code> then <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> will first <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ∀s</code>.</li>
<li>If <code>P</code> has schematic variables that can be instantiated by doing <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ∀s</code>, for example
<code>foo_spec : ∀(n:Nat), ⦃fun s =&gt; ⌜n = s⌝⦄ foo ⦃Q⦄</code>, then <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> will do <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ∀s</code> first to
instantiate <code>n = s</code>.</li>
<li>Right before applying the spec, the <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe">mframe</a></code> tactic is used, which has the following effect:
Any hypothesis <code>Hᵢ</code> in the goal <code>h₁:H₁, h₂:H₂, ..., hₙ:Hₙ ⊢ₛ T</code> that is
pure (i.e., equivalent to some <code>⌜φᵢ⌝</code>) will be moved into the pure context as <code>hᵢ:φᵢ</code>.</li>
</ul><p>Additionally, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> can be used without arguments or with a term argument:</p><ul>
<li><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> without argument will try and look up a spec for <code>x</code> registered with <code>@[spec]</code>.</li>
<li><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a> (foo_spec blah ?bleh)</code> will elaborate its argument as a term with expected type
<code>⦃?P⦄ x ⦃?Q⦄</code> and introduce <code>?bleh</code> as a subgoal.
This is useful to pass an invariant to e.g., <code>Specs.forIn_list</code> and leave the inductive step
as a hole.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mspec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticMvcgen_trivial_extensible"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L312-L312">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.tacticMvcgen_trivial_extensible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticMvcgen_trivial_extensible</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticMvcgen_trivial_extensible" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticMvcgen_trivial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L321-L325">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.tacticMvcgen_trivial"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticMvcgen_trivial</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>mvcgen_trivial</code> is the tactic automatically called by <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> to discharge VCs.
It tries to discharge the VC by applying <code>(try mpure_intro); <a href="../../.././Init/Core.html#trivial">trivial</a></code> and otherwise delegates to
<code>mvcgen_trivial_extensible</code>.
Users are encouraged to extend <code>mvcgen_trivial_extensible</code> instead of this tactic in order not to
override the default <code>(try mpure_intro); <a href="../../.././Init/Core.html#trivial">trivial</a></code> behavior.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.tacticMvcgen_trivial">Lean.Parser.Tactic.tacticMvcgen_trivial</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticMvcgen_trivial</span> <span class="fn">1024</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mvcgen_trivial&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticMvcgen_trivial" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.invariantDotAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L327-L330">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.invariantDotAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">invariantDotAlt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>An invariant alternative of the form <code>· term</code>, one per invariant goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.invariantDotAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.invariantCaseAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L332-L335">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.invariantCaseAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">invariantCaseAlt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>An invariant alternative of the form <code>| inv&lt;n&gt; a b c =&gt; term</code>, one per invariant goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.invariantCaseAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.invariantsKW"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L337-L341">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.invariantsKW"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">invariantsKW</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Either the contextual keyword <code>invariants</code> or its tracing form <code>invariants?</code> which suggests
skeletons for missing invariants as a hint.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.invariantsKW" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.invariantAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L343-L351">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.invariantAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">invariantAlts</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>After <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a> [...]</code>, there can be an optional <code>invariants</code> followed by either</p><ul>
<li>a bulleted list of invariants <code>· term; · term</code>.</li>
<li>a labelled list of invariants <code>| inv1 =&gt; term; inv2 a b c =&gt; term</code>, which is useful for naming
inaccessibles.
The tracing variant <code>invariants?</code> will suggest a skeleton for missing invariants; see the
docstring for <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.invariantAlts" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.vcAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L353-L357">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.vcAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">vcAlt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>In induction alternative, which can have 1 or more cases on the left
and <code>_</code>, <code>?_</code>, or a tactic sequence after the <code>=&gt;</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.vcAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.vcAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L359-L363">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.vcAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">vcAlts</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>After <code>with</code>, there is an optional tactic that runs on all branches, and
then a list of alternatives.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.vcAlts" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mvcgen"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L365-L368">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mvcgen</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> will break down a Hoare triple proof goal like <code>⦃P⦄ prog ⦃Q⦄</code> into verification conditions,
provided that all functions used in <code>prog</code> have specifications registered with <code>@[spec]</code>.</p><h3 class="markdown-heading" id="Verification-Conditions-and-specifications">Verification Conditions and specifications <a class="hover-link" href="#Verification-Conditions-and-specifications">#</a></h3><p>A verification condition is an entailment in the stateful logic of <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code>
in which the original program <code>prog</code> no longer occurs.
Verification conditions are introduced by the <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> tactic; see the <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> tactic for what they
look like.
When there's no applicable <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> spec, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> will try and rewrite an application
<code>prog = f a b c</code> with the simp set registered via <code>@[spec]</code>.</p><h3 class="markdown-heading" id="Features">Features <a class="hover-link" href="#Features">#</a></h3><p>When used like <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a> +noLetElim [foo_spec, bar_def, instBEqFloat]</code>, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> will additionally</p><ul>
<li>add a Hoare triple specification <code>foo_spec : ... → ⦃P⦄ foo ... ⦃Q⦄</code> to <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Attr.spec">spec</a></code> set for a
function <code>foo</code> occurring in <code>prog</code>,</li>
<li>unfold a definition <code>def bar_def ... := ...</code> in <code>prog</code>,</li>
<li>unfold any method of the <code><a href="../../.././Init/Data/Float.html#instBEqFloat">instBEqFloat</a> : <a href="../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../.././Init/Data/Float.html#Float">Float</a></code> instance in <code>prog</code>.</li>
<li>it will no longer substitute away <code>let</code>-expressions that occur at most once in <code>P</code>, <code>Q</code> or <code>prog</code>.</li>
</ul><h3 class="markdown-heading" id="Config-options">Config options <a class="hover-link" href="#Config-options">#</a></h3><p><code>+noLetElim</code> is just one config option of many. Check out <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config">Lean.Elab.Tactic.Do.VCGen.Config</a></code> for all
options. Of particular note is <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.stepLimit">stepLimit</a> = some 42</code>, which is useful for bisecting bugs in
<code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> and tracing its execution.</p><h3 class="markdown-heading" id="Extended-syntax">Extended syntax <a class="hover-link" href="#Extended-syntax">#</a></h3><p>Often, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> will be used like this:</p><pre><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a> [...]
case inv1 =&gt; by exact I1
case inv2 =&gt; by exact I2
all_goals (mleave; try grind)
</code></pre><p>There is special syntax for this:</p><pre><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a> [...] invariants
· I1
· I2
with grind
</code></pre><p>When <code>I1</code> and <code>I2</code> need to refer to inaccessibles (<code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> will introduce a lot of them for program
variables), you can use case label syntax:</p><pre><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a> [...] invariants
| inv1 _ acc _ =&gt; I1 acc
| _ =&gt; I2
with grind
</code></pre><p>This is more convenient than the equivalent <code>· by rename_i _ acc _; exact I1 acc</code>.</p><h3 class="markdown-heading" id="Invariant-suggestions">Invariant suggestions <a class="hover-link" href="#Invariant-suggestions">#</a></h3><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> will suggest invariants for you if you use the <code>invariants?</code> keyword.</p><pre><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a> [...] invariants?
</code></pre><p>This is useful if you do not recall the exact syntax to construct invariants.
Furthermore, it will suggest a concrete invariant encoding &quot;this holds at the start of the loop and
this must hold at the end of the loop&quot; by looking at the corresponding VCs.
Although the suggested invariant is a good starting point, it is too strong and requires users to
interpolate it such that the inductive step can be proved. Example:</p><pre><code>def mySum (l : <a href="../../.././Init/Prelude.html#List">List</a> Nat) : <a href="../../.././Init/Prelude.html#Nat">Nat</a> := <a href="../../.././Init/Control/Id.html#Id.run">Id.run</a> do
  let mut acc := 0
  for x in l do
    acc := acc + x
  return acc

/--
info: Try this:
  invariants
    · ⇓⟨xs, letMuts⟩ =&gt; ⌜xs.prefix = [] ∧ letMuts = 0 ∨ xs.suffix = [] ∧ letMuts = l.sum⌝
-/
#guard_msgs (info) in
theorem mySum_suggest_invariant (l : <a href="../../.././Init/Prelude.html#List">List</a> Nat) : mySum l = l.sum := by
  generalize h : mySum l = r
  apply Id.of_wp_run_eq h
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a> invariants?
  all_goals admit
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mvcgen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mvcgenHint"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L370-L374">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgenHint"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mvcgenHint</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>A hint tactic that expands to <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a> invariants?</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mvcgenHint" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>