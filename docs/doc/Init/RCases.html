<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="icon" href=".././favicon.svg"></link><link rel="mask-icon" href=".././favicon.svg" color="#000000"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>Init.RCases</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="Init.RCases";</script><script type="module" src=".././jump-src.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././expand-nav.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Init</span>.<span class="name">RCases</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href=".././Init/Meta.html">Init.Meta</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.RCases" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.rcasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">rcasesPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rcasesPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rcasesPatMed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPatMed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rcasesPatLo"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPatLo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rcasesPat.one"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">one</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rcasesPat.ignore"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">ignore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rcasesPat.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">clear</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rcasesPat.explicit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">explicit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rcasesPat.tuple"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">tuple</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rcasesPat.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">paren</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rintroPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rintroPat</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.rintroPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">rintroPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rintroPat.one"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rintroPat</span>.<span class="name">one</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rintroPat.binder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rintroPat</span>.<span class="name">binder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rcases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcases</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.obtain"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">obtain</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rintro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rintro</span></a></div></nav><main>
<div class="mod_doc"><h1 id="Recursive-cases-rcases-tactic-and-related-tactics" class="markdown-heading">Recursive cases (<code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code>) tactic and related tactics <a class="hover-link" href="#Recursive-cases-rcases-tactic-and-related-tactics">#</a></h1><p><code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> is a tactic that will perform <code>cases</code> recursively, according to a pattern. It is used to
destructure hypotheses or expressions composed of inductive types like <code>h1 : a ∧ b ∧ c ∨ d</code> or
<code>h2 : ∃ x y, trans_rel R x y</code>. Usual usage might be <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a> h1 with ⟨ha, hb, hc⟩ | hd</code> or
<code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a> h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩</code> for these examples.</p><p>Each element of an <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> pattern is matched against a particular local hypothesis (most of which
are generated during the execution of <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> and represent individual elements destructured from
the input expression). An <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> pattern has the following grammar:</p><ul><li>A name like <code>x</code>, which names the active hypothesis as <code>x</code>.</li><li>A blank <code>_</code>, which does nothing (letting the automatic naming system used by <code>cases</code> name the
hypothesis).</li><li>A hyphen <code>-</code>, which clears the active hypothesis and any dependents.</li><li>The keyword <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, which expects the hypothesis to be <code>h : a = b</code>, and calls <code>subst</code> on the
hypothesis (which has the effect of replacing <code>b</code> with <code>a</code> everywhere or vice versa).</li><li>A type ascription <code>p : ty</code>, which sets the type of the hypothesis to <code>ty</code> and then matches it
against <code>p</code>. (Of course, <code>ty</code> must unify with the actual type of <code>h</code> for this to work.)</li><li>A tuple pattern <code>⟨p1, p2, p3⟩</code>, which matches a constructor with many arguments, or a series
of nested conjunctions or existentials. For example if the active hypothesis is <code>a ∧ b ∧ c</code>,
then the conjunction will be destructured, and <code>p1</code> will be matched against <code>a</code>, <code>p2</code> against <code>b</code>
and so on.</li><li>A <code>@</code> before a tuple pattern as in <code>@⟨p1, p2, p3⟩</code> will bind all arguments in the constructor,
while leaving the <code>@</code> off will only use the patterns on the explicit arguments.</li><li>An alternation pattern <code>p1 | p2 | p3</code>, which matches an inductive type with multiple constructors,
or a nested disjunction like <code>a ∨ b ∨ c</code>.</li></ul><p>The patterns are fairly liberal about the exact shape of the constructors, and will insert
additional alternation branches and tuple arguments if there are not enough arguments provided, and
reuse the tail for further matches if there are too many arguments provided to alternation and
tuple patterns.</p><p>This file also contains the <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.obtain">obtain</a></code> and <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rintro">rintro</a></code> tactics, which use the same syntax of <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code>
patterns but with a slightly different use case:</p><ul><li><code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rintro">rintro</a></code> (or <code>rintros</code>) is used like <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rintro">rintro</a> x ⟨y, z⟩</code> and is the same as <code>intros</code> followed by
<code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> on the newly introduced arguments.</li><li><code><a href=".././Init/RCases.html#Lean.Parser.Tactic.obtain">obtain</a></code> is the same as <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> but with a syntax styled after <code>have</code> rather than <code>cases</code>.
<code><a href=".././Init/RCases.html#Lean.Parser.Tactic.obtain">obtain</a> ⟨hx, hy⟩ | hz := foo</code> is equivalent to <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a> foo with ⟨hx, hy⟩ | hz</code>. Unlike <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code>,
<code><a href=".././Init/RCases.html#Lean.Parser.Tactic.obtain">obtain</a></code> also allows one to omit <code>:= foo</code>, although a type must be provided in this case,
as in <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.obtain">obtain</a> ⟨hx, hy⟩ | hz : a ∧ b ∨ c</code>, in which case it produces a subgoal for proving
<code>a ∧ b ∨ c</code> in addition to the subgoals <code>hx : a, hy : b |- goal</code> and <code>hz : c |- goal</code>.</li></ul><h2 id="Tags" class="markdown-heading">Tags <a class="hover-link" href="#Tags">#</a></h2><p>rcases, rintro, obtain, destructuring, cases, pattern matching, match</p></div><div class="decl" id="Lean.Parser.Category.rcasesPat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L65-L66">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Category.rcasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">rcasesPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p>The syntax category of <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> patterns.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/RCases.html#Lean.Parser.Category.rcasesPat">Lean.Parser.Category.rcasesPat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.rcasesPat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rcasesPat.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L65-L66">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rcasesPat.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rcasesPatMed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L67-L68">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPatMed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPatMed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>A medium precedence <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> pattern is a list of <code><a href=".././Init/RCases.html#Lean.Parser.Category.rcasesPat">rcasesPat</a></code> separated by <code>|</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rcasesPatMed" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rcasesPatLo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L69-L70">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPatLo"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPatLo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>A low precedence <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> pattern is a <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPatMed">rcasesPatMed</a></code> optionally followed by <code>: ty</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rcasesPatLo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rcasesPat.one"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L71-L72">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPat.one"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">one</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>x</code> is a pattern which binds <code>x</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPat.one">Lean.Parser.Tactic.rcasesPat.one</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.rcasesPat.one</span> <span class="fn">1022</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rcasesPat.one" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rcasesPat.ignore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L73-L74">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPat.ignore"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">ignore</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>_</code> is a pattern which ignores the value and gives it an inaccessible name</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPat.ignore">Lean.Parser.Tactic.rcasesPat.ignore</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.rcasesPat.ignore</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;_&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rcasesPat.ignore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rcasesPat.clear"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L75-L76">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPat.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">clear</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>-</code> is a pattern which removes the value from the context</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPat.clear">Lean.Parser.Tactic.rcasesPat.clear</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.rcasesPat.clear</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;-&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rcasesPat.clear" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rcasesPat.explicit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L77-L81">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPat.explicit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">explicit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>A <code>@</code> before a tuple pattern as in <code>@⟨p1, p2, p3⟩</code> will bind all arguments in the constructor,
while leaving the <code>@</code> off will only use the patterns on the explicit arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rcasesPat.explicit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rcasesPat.tuple"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L82-L86">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPat.tuple"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">tuple</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>⟨pat, ...⟩</code> is a pattern which matches on a tuple-like constructor
or multi-argument inductive constructor</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rcasesPat.tuple" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rcasesPat.paren"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L87-L88">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rcasesPat.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcasesPat</span>.<span class="name">paren</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>(pat)</code> is a pattern which resets the precedence to low</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rcasesPat.paren" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rintroPat.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L90-L91">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rintroPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rintroPat</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rintroPat.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.rintroPat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L90-L91">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Category.rintroPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">rintroPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p>The syntax category of <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rintro">rintro</a></code> patterns.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/RCases.html#Lean.Parser.Category.rintroPat">Lean.Parser.Category.rintroPat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.rintroPat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rintroPat.one"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L92-L93">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rintroPat.one"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rintroPat</span>.<span class="name">one</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>An <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> pattern is an <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rintro">rintro</a></code> pattern</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/RCases.html#Lean.Parser.Tactic.rintroPat.one">Lean.Parser.Tactic.rintroPat.one</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.rintroPat.one</span> <span class="fn">1022</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`rcasesPat</span> <span class="fn">0</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rintroPat.one" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rintroPat.binder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L94-L98">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rintroPat.binder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rintroPat</span>.<span class="name">binder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>A multi argument binder <code>(pat1 pat2 : ty)</code> binds a list of patterns and gives them all type <code>ty</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rintroPat.binder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rcases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L110-L153">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rcases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rcases</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> is a tactic that will perform <code>cases</code> recursively, according to a pattern. It is used to
destructure hypotheses or expressions composed of inductive types like <code>h1 : a ∧ b ∧ c ∨ d</code> or
<code>h2 : ∃ x y, trans_rel R x y</code>. Usual usage might be <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a> h1 with ⟨ha, hb, hc⟩ | hd</code> or
<code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a> h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩</code> for these examples.</p><p>Each element of an <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> pattern is matched against a particular local hypothesis (most of which
are generated during the execution of <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> and represent individual elements destructured from
the input expression). An <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> pattern has the following grammar:</p><ul><li>A name like <code>x</code>, which names the active hypothesis as <code>x</code>.</li><li>A blank <code>_</code>, which does nothing (letting the automatic naming system used by <code>cases</code> name the
hypothesis).</li><li>A hyphen <code>-</code>, which clears the active hypothesis and any dependents.</li><li>The keyword <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, which expects the hypothesis to be <code>h : a = b</code>, and calls <code>subst</code> on the
hypothesis (which has the effect of replacing <code>b</code> with <code>a</code> everywhere or vice versa).</li><li>A type ascription <code>p : ty</code>, which sets the type of the hypothesis to <code>ty</code> and then matches it
against <code>p</code>. (Of course, <code>ty</code> must unify with the actual type of <code>h</code> for this to work.)</li><li>A tuple pattern <code>⟨p1, p2, p3⟩</code>, which matches a constructor with many arguments, or a series
of nested conjunctions or existentials. For example if the active hypothesis is <code>a ∧ b ∧ c</code>,
then the conjunction will be destructured, and <code>p1</code> will be matched against <code>a</code>, <code>p2</code> against <code>b</code>
and so on.</li><li>A <code>@</code> before a tuple pattern as in <code>@⟨p1, p2, p3⟩</code> will bind all arguments in the constructor,
while leaving the <code>@</code> off will only use the patterns on the explicit arguments.</li><li>An alternation pattern <code>p1 | p2 | p3</code>, which matches an inductive type with multiple constructors,
or a nested disjunction like <code>a ∨ b ∨ c</code>.</li></ul><p>A pattern like <code>⟨a, b, c⟩ | ⟨d, e⟩</code> will do a split over the inductive datatype,
naming the first three parameters of the first constructor as <code>a,b,c</code> and the
first two of the second constructor <code>d,e</code>. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as <code>⟨⟨a⟩, b | c⟩ | d</code> then these will cause more case splits as necessary.
If there are too many arguments, such as <code>⟨a, b, c⟩</code> for splitting on
<code>∃ x, ∃ y, p x</code>, then it will be treated as <code>⟨a, ⟨b, c⟩⟩</code>, splitting the last
parameter as necessary.</p><p><code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> also has special support for quotient types: quotient induction into Prop works like
matching on the constructor <code>quot.mk</code>.</p><p><code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a> h : e with PAT</code> will do the same as <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a> e with PAT</code> with the exception that an
assumption <code>h : e = PAT</code> will be added to the context.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rcases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.obtain"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L155-L172">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.obtain"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">obtain</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.obtain">obtain</a></code> tactic is a combination of <code>have</code> and <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code>. See <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> for
a description of supported patterns.</p><pre><code class="language-lean"><a href=".././Init/RCases.html#Lean.Parser.Tactic.obtain">obtain</a> ⟨patt⟩ : type := proof
</code></pre><p>is equivalent to</p><pre><code class="language-lean">have h : type := proof
<a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a> h with ⟨patt⟩
</code></pre><p>If <code>⟨patt⟩</code> is omitted, <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> will try to infer the pattern.</p><p>If <code>type</code> is omitted, <code>:= proof</code> is required.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.obtain" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rintro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/RCases.lean#L184-L194">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/RCases.html#Lean.Parser.Tactic.rintro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rintro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rintro">rintro</a></code> tactic is a combination of the <code>intros</code> tactic with <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> to
allow for destructuring patterns while introducing variables. See <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code> for
a description of supported patterns. For example, <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rintro">rintro</a> (a | ⟨b, c⟩) ⟨d, e⟩</code>
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables <code>a d e</code> and the other with <code>b c d e</code>.</p><p><code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rintro">rintro</a></code>, unlike <code><a href=".././Init/RCases.html#Lean.Parser.Tactic.rcases">rcases</a></code>, also supports the form <code>(x y : ty)</code> for introducing
and type-ascripting multiple variables at once, similar to binders.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rintro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src=".././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>