<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Init.Control.Basic</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Init.Control.Basic";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Init</span>.<span class="name">Control</span>.<span class="name">Basic</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init/BinderNameHint.html">Init.BinderNameHint</a></li><li><a href="../.././Init/Core.html">Init.Core</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Control.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#instForInOfForIn'"><span class="name">instForInOfForIn'</span></a></div><div class="nav_link"><a class="break_within" href="#forIn'_eq_forIn"><span class="name">forIn'_eq_forIn</span></a></div><div class="nav_link"><a class="break_within" href="#forIn_eq_forIn'"><span class="name">forIn_eq_forIn'</span></a></div><div class="nav_link"><a class="break_within" href="#forIn_eq_forin'"><span class="name">forIn_eq_forin'</span></a></div><div class="nav_link"><a class="break_within" href="#ForInStep.value"><span class="name">ForInStep</span>.<span class="name">value</span></a></div><div class="nav_link"><a class="break_within" href="#ForInStep.value_done"><span class="name">ForInStep</span>.<span class="name">value_done</span></a></div><div class="nav_link"><a class="break_within" href="#ForInStep.value_yield"><span class="name">ForInStep</span>.<span class="name">value_yield</span></a></div><div class="nav_link"><a class="break_within" href="#Functor.mapRev"><span class="name">Functor</span>.<span class="name">mapRev</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;&amp;&gt;_»"><span class="name">«term_&lt;&amp;&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#Functor.discard"><span class="name">Functor</span>.<span class="name">discard</span></a></div><div class="nav_link"><a class="break_within" href="#Alternative"><span class="name">Alternative</span></a></div><div class="nav_link"><a class="break_within" href="#instOrElseOfAlternative"><span class="name">instOrElseOfAlternative</span></a></div><div class="nav_link"><a class="break_within" href="#guard"><span class="name">guard</span></a></div><div class="nav_link"><a class="break_within" href="#optional"><span class="name">optional</span></a></div><div class="nav_link"><a class="break_within" href="#ToBool"><span class="name">ToBool</span></a></div><div class="nav_link"><a class="break_within" href="#instToBoolBool"><span class="name">instToBoolBool</span></a></div><div class="nav_link"><a class="break_within" href="#bool"><span class="name">bool</span></a></div><div class="nav_link"><a class="break_within" href="#orM"><span class="name">orM</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;||&gt;_»"><span class="name">«term_&lt;||&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#andM"><span class="name">andM</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;&amp;&amp;&gt;_»"><span class="name">«term_&lt;&amp;&amp;&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#notM"><span class="name">notM</span></a></div><div class="nav_link"><a class="break_within" href="#MonadControl"><span class="name">MonadControl</span></a></div><div class="nav_link"><a class="break_within" href="#MonadControlT"><span class="name">MonadControlT</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadControlTOfMonadControl"><span class="name">instMonadControlTOfMonadControl</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadControlTOfPure"><span class="name">instMonadControlTOfPure</span></a></div><div class="nav_link"><a class="break_within" href="#controlAt"><span class="name">controlAt</span></a></div><div class="nav_link"><a class="break_within" href="#control"><span class="name">control</span></a></div><div class="nav_link"><a class="break_within" href="#ForM"><span class="name">ForM</span></a></div><div class="nav_link"><a class="break_within" href="#Bind.kleisliRight"><span class="name">Bind</span>.<span class="name">kleisliRight</span></a></div><div class="nav_link"><a class="break_within" href="#Bind.kleisliLeft"><span class="name">Bind</span>.<span class="name">kleisliLeft</span></a></div><div class="nav_link"><a class="break_within" href="#Bind.bindLeft"><span class="name">Bind</span>.<span class="name">bindLeft</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&gt;=&gt;_»"><span class="name">«term_&gt;=&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;=&lt;_»"><span class="name">«term_&lt;=&lt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_=&lt;&lt;_»"><span class="name">«term_=&lt;&lt;_»</span></a></div></nav><main>
<div class="decl" id="instForInOfForIn'"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L16-L26">source</a></div><div class="attributes">@[instance 500]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#instForInOfForIn'"><span class="name">instForInOfForIn'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">d</span> : <span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">ρ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#ForIn'">ForIn'</a> <span class="fn">m</span> <span class="fn">ρ</span> <span class="fn">α</span> <span class="fn">d</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#ForIn">ForIn</a> <span class="fn">m</span> <span class="fn">ρ</span> <span class="fn">α</span></span></div></div><p>A <code><a href="../.././Init/Core.html#ForIn'">ForIn'</a></code> instance, which handles <code>for h : x in c do</code>,
can also handle <code>for x in x do</code> by ignoring <code>h</code>, and so provides a <code><a href="../.././Init/Core.html#ForIn">ForIn</a></code> instance.</p><p>Note that this instance will cause a potentially non-defeq duplication if both <code><a href="../.././Init/Core.html#ForIn">ForIn</a></code> and <code><a href="../.././Init/Core.html#ForIn'">ForIn'</a></code>
instances are provided for the same type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Control/Basic.html#instForInOfForIn'">instForInOfForIn'</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <a href="../.././Init/Core.html#ForIn.mk">{</a>     <span class="fn">forIn</span> := <span class="fn">fun {<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> ?u.10} [<span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>] (<span class="fn">x</span> : <span class="fn">ρ</span>) (<span class="fn">b</span> : <span class="fn">β</span>) (<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">β</span>)</span></span></span></span>) =&gt;
      <span class="fn"><a href="../.././Init/Core.html#ForIn'.forIn'">forIn'</a> <span class="fn">x</span> <span class="fn">b</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">x</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">x</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span></span></span> <a href="../.././Init/Core.html#ForIn.mk">}</a></li></ul></details></div></div><div class="decl" id="forIn'_eq_forIn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L28-L41">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#forIn'_eq_forIn"><span class="name">forIn'_eq_forIn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_3 → <a href="../.././foundational_types.html">Type</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">d</span> : <span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">ρ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#ForIn'">ForIn'</a> <span class="fn">m</span> <span class="fn">ρ</span> <span class="fn">α</span> <span class="fn">d</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">ρ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">x</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">β</span>)</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">β</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">m_1</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">x</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">m_1</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#ForIn'.forIn'">forIn'</a> <span class="fn">x</span> <span class="fn">b</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">x</span> <span class="fn">b</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="forIn_eq_forIn'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L43-L46">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#forIn_eq_forIn'"><span class="name">forIn_eq_forIn'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_3 → <a href="../.././foundational_types.html">Type</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">d</span> : <span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">ρ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#ForIn'">ForIn'</a> <span class="fn">m</span> <span class="fn">ρ</span> <span class="fn">α</span> <span class="fn">d</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">ρ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">β</span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">x</span> <span class="fn">b</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Core.html#ForIn'.forIn'">forIn'</a> <span class="fn">x</span> <span class="fn">b</span> <span class="fn">fun (<span class="fn">x_1</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn">x_1</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">x</span>) =&gt; <span class="fn"><a href="../.././Init/BinderNameHint.html#binderNameHint">binderNameHint</a> <span class="fn">x_1</span> <span class="fn">f</span> <span class="fn">(<a href="../.././Init/BinderNameHint.html#binderNameHint">binderNameHint</a> <span class="fn">h</span> <a href="../.././Init/Prelude.html#Unit.unit">(</a><a href="../.././Init/Prelude.html#Unit.unit">)</a> <span class="fn">(<span class="fn">f</span> <span class="fn">x_1</span>)</span>)</span></span></span></span></div></div></div></div><div class="decl" id="forIn_eq_forin'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L48-L49">source</a></div><div class="attributes">@[reducible, inline, deprecated forIn_eq_forIn' (since := &quot;2025-04-04&quot;)]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#forIn_eq_forin'"><span class="name">forIn_eq_forin'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_3 → <a href="../.././foundational_types.html">Type</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">d</span> : <span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">ρ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#ForIn'">ForIn'</a> <span class="fn">m</span> <span class="fn">ρ</span> <span class="fn">α</span> <span class="fn">d</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">ρ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">β</span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">x</span> <span class="fn">b</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Core.html#ForIn'.forIn'">forIn'</a> <span class="fn">x</span> <span class="fn">b</span> <span class="fn">fun (<span class="fn">x_1</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn">x_1</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">x</span>) =&gt; <span class="fn"><a href="../.././Init/BinderNameHint.html#binderNameHint">binderNameHint</a> <span class="fn">x_1</span> <span class="fn">f</span> <span class="fn">(<a href="../.././Init/BinderNameHint.html#binderNameHint">binderNameHint</a> <span class="fn">h</span> <a href="../.././Init/Prelude.html#Unit.unit">(</a><a href="../.././Init/Prelude.html#Unit.unit">)</a> <span class="fn">(<span class="fn">f</span> <span class="fn">x_1</span>)</span>)</span></span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href="../.././Init/Control/Basic.html#forIn_eq_forin'">forIn_eq_forin'</a> <a href="../.././Init/Prelude.html#Eq">=</a> @<a href="../.././Init/Control/Basic.html#forIn_eq_forIn'">forIn_eq_forIn'</a></li></ul></details><details id="instances-for-list-forIn_eq_forin'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ForInStep.value"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L51-L57">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#ForInStep.value"><span class="name">ForInStep</span>.<span class="name">value</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Extracts the value from a <code><a href="../.././Init/Core.html#ForInStep">ForInStep</a></code>, ignoring whether it is <code><a href="../.././Init/Core.html#ForInStep.done">ForInStep.done</a></code> or <code><a href="../.././Init/Core.html#ForInStep.yield">ForInStep.yield</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../.././Init/Core.html#ForInStep.done">ForInStep.done</a> <span class="fn">b</span>)</span>.<a href="../.././Init/Control/Basic.html#ForInStep.value">value</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../.././Init/Core.html#ForInStep.yield">ForInStep.yield</a> <span class="fn">b</span>)</span>.<a href="../.././Init/Control/Basic.html#ForInStep.value">value</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></li></ul></details><details id="instances-for-list-ForInStep.value" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ForInStep.value_done"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L59-L59">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#ForInStep.value_done"><span class="name">ForInStep</span>.<span class="name">value_done</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Core.html#ForInStep.done">done</a> <span class="fn">b</span>)</span>.<a href="../.././Init/Control/Basic.html#ForInStep.value">value</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="ForInStep.value_yield"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L60-L60">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#ForInStep.value_yield"><span class="name">ForInStep</span>.<span class="name">value_yield</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Core.html#ForInStep.yield">yield</a> <span class="fn">b</span>)</span>.<a href="../.././Init/Control/Basic.html#ForInStep.value">value</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Functor.mapRev"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L62-L69">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#Functor.mapRev"><span class="name">Functor</span>.<span class="name">mapRev</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Functor">Functor</a> <span class="fn">f</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></div></div><p>Maps a function over a functor, with parameters swapped so that the function comes last.</p><p>This function is <code><a href="../.././Init/Prelude.html#Functor.map">Functor.map</a></code> with the parameters reversed, typically used via the <code>&lt;&amp;&gt;</code> operator.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;&amp;&gt;</code> in identifiers is <code><a href="../.././Init/Control/Basic.html#Functor.mapRev">mapRev</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">a</span> <a href="../.././Init/Control/Basic.html#Functor.mapRev">&lt;&amp;&gt;</a> <span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span> <a href="../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">a</span></li></ul></details><details id="instances-for-list-Functor.mapRev" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&lt;&amp;&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L71-L72">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#«term_&lt;&amp;&gt;_»"><span class="name">«term_&lt;&amp;&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Maps a function over a functor, with parameters swapped so that the function comes last.</p><p>This function is <code><a href="../.././Init/Prelude.html#Functor.map">Functor.map</a></code> with the parameters reversed, typically used via the <code>&lt;&amp;&gt;</code> operator.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;&amp;&gt;</code> in identifiers is <code><a href="../.././Init/Control/Basic.html#Functor.mapRev">mapRev</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Control/Basic.html#«term_&lt;&amp;&gt;_»">«term_&lt;&amp;&gt;_»</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;&amp;&gt;_»</span> <span class="fn">100</span> <span class="fn">101</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;&amp;&gt; &quot;</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">100</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;&amp;&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Functor.discard"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L76-L86">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#Functor.discard"><span class="name">Functor</span>.<span class="name">discard</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Functor">Functor</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span></div></div><p>Discards the value in a functor, retaining the functor's structure.</p><p>Discarding values is especially useful when using <code><a href="../.././Init/Prelude.html#Applicative">Applicative</a></code> functors or <code><a href="../.././Init/Prelude.html#Monad">Monad</a></code>s to implement
effects, and some operation should be carried out only for its effects. In <code>do</code>-notation, statements
whose values are discarded must return <code><a href="../.././Init/Prelude.html#Unit">Unit</a></code>, and <code><a href="../.././Init/Control/Basic.html#Functor.discard">discard</a></code> can be used to explicitly discard their
values.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Init/Control/Basic.html#Functor.discard">discard</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Functor.mapConst">Functor.mapConst</a> <a href="../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a> <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Functor.discard" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Alternative"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L90-L113">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#Alternative"><span class="name">Alternative</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../.././Init/Prelude.html#Applicative">Applicative</a> <span class="fn">f</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p>An <code><a href="../.././Init/Control/Basic.html#Alternative">Alternative</a></code> functor is an <code><a href="../.././Init/Prelude.html#Applicative">Applicative</a></code> functor that can &quot;fail&quot; or be &quot;empty&quot;
and a binary operation <code>&lt;|&gt;</code> that “collects values” or finds the “left-most success”.</p><p>Important instances include</p><ul>
<li><code><a href="../.././Init/Prelude.html#Option">Option</a></code>, where <code><a href="../.././Init/Control/Basic.html#Alternative.failure">failure</a> := none</code> and <code>&lt;|&gt;</code> returns the left-most <code>some</code>.</li>
<li>Parser combinators typically provide an <code><a href="../.././Init/Prelude.html#Applicative">Applicative</a></code> instance for error-handling and
backtracking.</li>
</ul><p>Error recovery and state can interact subtly. For example, the implementation of <code><a href="../.././Init/Control/Basic.html#Alternative">Alternative</a></code> for <code><a href="../.././Init/Control/Option.html#OptionT">OptionT</a> (StateT σ Id)</code> keeps modifications made to the state while recovering from failure, while <code><a href="../.././Init/Control/State.html#StateT">StateT</a> σ (OptionT Id)</code> discards them.</p><ul class="structure_fields" id="Alternative.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Init/Prelude.html#Functor.map">map</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Init/Prelude.html#Functor.mapConst">mapConst</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Init/Prelude.html#Pure.pure">pure</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Init/Prelude.html#Seq.seq">seq</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span></span> → <span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span>)</span> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Init/Prelude.html#SeqLeft.seqLeft">seqLeft</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span>)</span> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Init/Prelude.html#SeqRight.seqRight">seqRight</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span>)</span> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></div></li><li id="Alternative.failure" class="structure_field"><div class="structure_field_info">failure<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></div><div class="structure_field_doc"><p>Produces an empty collection or recoverable failure.  The <code>&lt;|&gt;</code> operator collects values or recovers
from failures. See <code><a href="../.././Init/Control/Basic.html#Alternative">Alternative</a></code> for more details.</p></div></li><li id="Alternative.orElse" class="structure_field"><div class="structure_field_info">orElse<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span>)</span> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></span></div><div class="structure_field_doc"><p>Depending on the <code><a href="../.././Init/Control/Basic.html#Alternative">Alternative</a></code> instance, collects values or recovers from <code><a href="../.././Init/Control/Basic.html#Alternative.failure">failure</a></code>s by
returning the leftmost success. Can be written using the <code>&lt;|&gt;</code> operator syntax.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Alternative" class="instances-list"></ul></details></div></div><div class="decl" id="instOrElseOfAlternative"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L115-L115">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#instOrElseOfAlternative"><span class="name">instOrElseOfAlternative</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Control/Basic.html#Alternative">Alternative</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#OrElse">OrElse</a> <span class="fn">(<span class="fn">f</span> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Init/Control/Basic.html#instOrElseOfAlternative">instOrElseOfAlternative</a> <span class="fn">f</span> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#OrElse.mk">{</a> <span class="fn">orElse</span> := <a href="../.././Init/Control/Basic.html#Alternative.orElse">Alternative.orElse</a> <a href="../.././Init/Prelude.html#OrElse.mk">}</a></li></ul></details></div></div><div class="decl" id="guard"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L121-L125">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#guard"><span class="name">guard</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> → <a href="../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Control/Basic.html#Alternative">Alternative</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>If the proposition <code>p</code> is true, does nothing, else fails (using <code><a href="../.././Init/Control/Basic.html#Alternative.failure">failure</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Init/Control/Basic.html#guard">guard</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">p</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Unit.unit">(</a><a href="../.././Init/Prelude.html#Unit.unit">)</a></span> <a href="../.././Init/Prelude.html#ite">else</a> <a href="../.././Init/Control/Basic.html#Alternative.failure">failure</a></li></ul></details><details id="instances-for-list-guard" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="optional"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L127-L131">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#optional"><span class="name">optional</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Control/Basic.html#Alternative">Alternative</a> <span class="fn">f</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span>)</span></span></div></div><p>Returns <code>some x</code> if <code>f</code> succeeds with value <code>x</code>, else returns <code>none</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Init/Control/Basic.html#optional">optional</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../.././Init/Prelude.html#Option.some">some</a> <a href="../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">x</span> &lt;|&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Option.none">none</a></span>)</span></li></ul></details><details id="instances-for-list-optional" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToBool"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L133-L134">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#ToBool"><span class="name">ToBool</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u</div></div><ul class="structure_fields" id="ToBool.mk"><li id="ToBool.toBool" class="structure_field"><div class="structure_field_info">toBool : <span class="fn"><span class="fn">α</span> → <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-ToBool" class="instances-list"></ul></details></div></div><div class="decl" id="instToBoolBool"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L138-L139">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#instToBoolBool"><span class="name">instToBoolBool</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Control/Basic.html#ToBool">ToBool</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Control/Basic.html#instToBoolBool">instToBoolBool</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Control/Basic.html#ToBool.mk">{</a> <span class="fn">toBool</span> := <span class="fn">fun (<span class="fn">b</span> : <a href="../.././Init/Prelude.html#Bool">Bool</a>) =&gt; <span class="fn">b</span></span> <a href="../.././Init/Control/Basic.html#ToBool.mk">}</a></li></ul></details></div></div><div class="decl" id="bool"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L141-L144">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#bool"><span class="name">bool</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Control/Basic.html#ToBool">ToBool</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">t</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Init/Control/Basic.html#bool">bool</a> <span class="fn">f</span> <span class="fn">t</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../.././Init/Control/Basic.html#ToBool.toBool">toBool</a> <span class="fn">b</span></span> with
  | <a href="../.././Init/Prelude.html#Bool.true">true</a> =&gt; <span class="fn">t</span>
  | <a href="../.././Init/Prelude.html#Bool.false">false</a> =&gt; <span class="fn">f</span></span></li></ul></details><details id="instances-for-list-bool" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="orM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L146-L157">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#orM"><span class="name">orM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Control/Basic.html#ToBool">ToBool</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></div></div><p>Converts the result of the monadic action <code>x</code> to a <code><a href="../.././Init/Prelude.html#Bool">Bool</a></code>. If it is <code>true</code>, returns it and ignores
<code>y</code>; otherwise, runs <code>y</code> and returns its result.</p><p>This a monadic counterpart to the short-circuiting <code>||</code> operator, usually accessed via the <code>&lt;||&gt;</code>
operator.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;||&gt;</code> in identifiers is <code><a href="../.././Init/Control/Basic.html#orM">orM</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">(<span class="fn">x</span> <a href="../.././Init/Control/Basic.html#orM">&lt;||&gt;</a> <span class="fn">y</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">b</span> ← <span class="fn">x</span>
  <span class="fn">match <span class="fn"><a href="../.././Init/Control/Basic.html#ToBool.toBool">toBool</a> <span class="fn">b</span></span> with
    | <a href="../.././Init/Prelude.html#Bool.true">true</a> =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">b</span></span>
    | <a href="../.././Init/Prelude.html#Bool.false">false</a> =&gt; <span class="fn">y</span></span></span></li></ul></details><details id="instances-for-list-orM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&lt;||&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L159-L159">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#«term_&lt;||&gt;_»"><span class="name">«term_&lt;||&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Control/Basic.html#«term_&lt;||&gt;_»">«term_&lt;||&gt;_»</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;||&gt;_»</span> <span class="fn">30</span> <span class="fn">31</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;||&gt; &quot;</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">30</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;||&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="andM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L163-L174">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#andM"><span class="name">andM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Control/Basic.html#ToBool">ToBool</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></div></div><p>Converts the result of the monadic action <code>x</code> to a <code><a href="../.././Init/Prelude.html#Bool">Bool</a></code>. If it is <code>true</code>, returns <code>y</code>; otherwise,
returns the original result of <code>x</code>.</p><p>This a monadic counterpart to the short-circuiting <code>&amp;&amp;</code> operator, usually accessed via the <code>&lt;&amp;&amp;&gt;</code>
operator.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;&amp;&amp;&gt;</code> in identifiers is <code><a href="../.././Init/Control/Basic.html#andM">andM</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">(<span class="fn">x</span> <a href="../.././Init/Control/Basic.html#andM">&lt;&amp;&amp;&gt;</a> <span class="fn">y</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">b</span> ← <span class="fn">x</span>
  <span class="fn">match <span class="fn"><a href="../.././Init/Control/Basic.html#ToBool.toBool">toBool</a> <span class="fn">b</span></span> with
    | <a href="../.././Init/Prelude.html#Bool.true">true</a> =&gt; <span class="fn">y</span>
    | <a href="../.././Init/Prelude.html#Bool.false">false</a> =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">b</span></span></span></span></li></ul></details><details id="instances-for-list-andM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&lt;&amp;&amp;&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L176-L176">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#«term_&lt;&amp;&amp;&gt;_»"><span class="name">«term_&lt;&amp;&amp;&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Control/Basic.html#«term_&lt;&amp;&amp;&gt;_»">«term_&lt;&amp;&amp;&gt;_»</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;&amp;&amp;&gt;_»</span> <span class="fn">35</span> <span class="fn">36</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;&amp;&amp;&gt; &quot;</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">35</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;&amp;&amp;&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="notM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L180-L184">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#notM"><span class="name">notM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> → <a href="../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Functor">Functor</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#Bool">Bool</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Runs a monadic action and returns the negation of its result.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Init/Control/Basic.html#notM">notM</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.not">not</a> <a href="../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <span class="fn">x</span></li></ul></details><details id="instances-for-list-notM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="How-MonadControl-works">How <code><a href="../.././Init/Control/Basic.html#MonadControl">MonadControl</a></code> works <a class="hover-link" href="#How-MonadControl-works">#</a></h1><p>There is a <a href="https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/">tutorial by Alexis King</a> that this docstring is based on.</p><p>Suppose we have <code>foo : ∀ α, <a href="../.././Init/System/IO.html#IO">IO</a> α → <a href="../.././Init/System/IO.html#IO">IO</a> α</code> and <code>bar : <a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> β</code> (ie, <code>bar : σ → <a href="../.././Init/System/IO.html#IO">IO</a> (σ × β)</code>).
We might want to 'map' <code>bar</code> by <code>foo</code>. Concretely we would write this as:</p><pre><code class="language-lean">opaque foo : ∀ {α}, <a href="../.././Init/System/IO.html#IO">IO</a> α → <a href="../.././Init/System/IO.html#IO">IO</a> α
opaque bar : <a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> β

def mapped_foo : <a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> β := do
  let s ← get
  let (b, s') ← <a href="../.././Init/Prelude.html#liftM">liftM</a> &lt;| foo &lt;| <a href="../.././Init/Control/State.html#StateT.run">StateT.run</a> bar s
  set s'
  return b
</code></pre><p>This is fine but it's not going to generalise, what if we replace <code><a href="../.././Init/Control/State.html#StateT">StateT</a> <a href="../.././Init/Prelude.html#Nat">Nat</a> <a href="../.././Init/System/IO.html#IO">IO</a></code> with a large tower of monad transformers?
We would have to rewrite the above to handle each of the <code>run</code> functions for each transformer in the stack.</p><p>Is there a way to generalise <code>run</code> as a kind of inverse of <code>lift</code>?
We have <code>lift : m α → <a href="../.././Init/Control/State.html#StateT">StateT</a> σ m α</code> for all <code>m</code>, but we also need to 'unlift' the state.
But <code>unlift : <a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> α → <a href="../.././Init/System/IO.html#IO">IO</a> α</code> can't be implemented. So we need something else.</p><p>If we look at the definition of <code>mapped_foo</code>, we see that <code>lift &lt;| foo &lt;| <a href="../.././Init/Control/State.html#StateT.run">StateT.run</a> bar s</code>
has the type <code><a href="../.././Init/System/IO.html#IO">IO</a> (σ × β)</code>. The key idea is that <code>σ × β</code> contains all of the information needed to reconstruct the state and the new value.</p><p>Now lets define some values to generalise <code>mapped_foo</code>:</p><ul>
<li>Write <code><a href="../.././Init/System/IO.html#IO">IO</a> (σ × β)</code> as <code><a href="../.././Init/System/IO.html#IO">IO</a> (stM β)</code></li>
<li>Write <code><a href="../.././Init/Control/State.html#StateT.run">StateT.run</a> . s</code> as <code>mapInBase : <a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> α → <a href="../.././Init/System/IO.html#IO">IO</a> (stM β)</code></li>
<li>Define <code><a href="../.././Init/Control/Basic.html#MonadControl.restoreM">restoreM</a> : <a href="../.././Init/System/IO.html#IO">IO</a> (stM α) → <a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> α</code> as below</li>
</ul><pre><code class="language-lean">def <a href="../.././Init/Control/Basic.html#MonadControl.stM">stM</a> (α : Type) := α × σ

def <a href="../.././Init/Control/Basic.html#MonadControl.restoreM">restoreM</a> (x : <a href="../.././Init/System/IO.html#IO">IO</a> (stM α)) : <a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> α := do
  let (a,s) ← <a href="../.././Init/Prelude.html#liftM">liftM</a> x
  set s
  return a
</code></pre><p>To get:</p><pre><code class="language-lean">def mapped_foo' : <a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> β := do
  let s ← get
  let mapInBase := fun z =&gt; <a href="../.././Init/Control/State.html#StateT.run">StateT.run</a> z s
  <a href="../.././Init/Control/Basic.html#MonadControl.restoreM">restoreM</a> &lt;| foo &lt;| mapInBase bar
</code></pre><p>and finally define</p><pre><code class="language-lean">def <a href="../.././Init/Control/Basic.html#control">control</a> {α : Type}
  (f : ({β : Type} → <a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> β → <a href="../.././Init/System/IO.html#IO">IO</a> (stM β)) → <a href="../.././Init/System/IO.html#IO">IO</a> (stM α))
  : <a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> α := do
  let s ← get
  let mapInBase := fun {β} (z : <a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> β) =&gt; <a href="../.././Init/Control/State.html#StateT.run">StateT.run</a> z s
  let r : <a href="../.././Init/System/IO.html#IO">IO</a> (stM α) := f mapInBase
  <a href="../.././Init/Control/Basic.html#MonadControl.restoreM">restoreM</a> r
</code></pre><p>Now we can write <code>mapped_foo</code> as:</p><pre><code class="language-lean">def mapped_foo'' : <a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> β :=
  <a href="../.././Init/Control/Basic.html#control">control</a> (fun mapInBase =&gt; foo (mapInBase bar))
</code></pre><p>The core idea of <code>mapInBase</code> is that given any <code>β</code>, it runs an instance of
<code><a href="../.././Init/Control/State.html#StateT">StateT</a> σ <a href="../.././Init/System/IO.html#IO">IO</a> β</code> and 'packages' the result and state as  <code><a href="../.././Init/System/IO.html#IO">IO</a> (stM β)</code> so that it can be piped through <code>foo</code>.
Once it's been through <code>foo</code> we can then unpack the state again with <code><a href="../.././Init/Control/Basic.html#MonadControl.restoreM">restoreM</a></code>.
Hence we can apply <code>foo</code> to <code>bar</code> without losing track of the state.</p><p>Here <code><a href="../.././Init/Control/Basic.html#MonadControl.stM">stM</a> β = σ × β</code> is the 'packaged result state', but we can generalise:
if we have a tower <code><a href="../.././Init/Control/State.html#StateT">StateT</a> σ₁ &lt;| <a href="../.././Init/Control/State.html#StateT">StateT</a> σ₂ &lt;| <a href="../.././Init/System/IO.html#IO">IO</a></code>, then the
composite packaged state is going to be <code>stM₁₂ β := σ₁ × σ₂ × β</code> or <code>stM₁₂ := stM₁ ∘ stM₂</code>.</p><p><code><a href="../.././Init/Control/Basic.html#MonadControl">MonadControl</a> m n</code> means that when programming in the monad <code>n</code>,
we can switch to a base monad <code>m</code> using <code><a href="../.././Init/Control/Basic.html#control">control</a></code>, just like with <code><a href="../.././Init/Prelude.html#liftM">liftM</a></code>.
In contrast to <code><a href="../.././Init/Prelude.html#liftM">liftM</a></code>, however, we also get a function <code>runInBase</code> that
allows us to &quot;lower&quot; actions in <code>n</code> into <code>m</code>.
This is really useful when we have large towers of monad transformers, as we do in the metaprogramming library.</p><p>For example there is a function <code>withNewMCtxDepthImp : MetaM α → MetaM α</code> that runs the input monad instance
in a new nested metavariable context. We can lift this to <code>withNewMctxDepth : n α → n α</code> using <code><a href="../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> MetaM n</code>
(<code><a href="../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a></code> is the transitive closure of <code><a href="../.././Init/Control/Basic.html#MonadControl">MonadControl</a></code>).
Which means that we can also run <code>withNewMctxDepth</code> in the <code>Tactic</code> monad without needing to
faff around with lifts and all the other boilerplate needed in <code>mapped_foo</code>.</p><h2 class="markdown-heading" id="Relationship-to-MonadFunctor">Relationship to <code><a href="../.././Init/Prelude.html#MonadFunctor">MonadFunctor</a></code> <a class="hover-link" href="#Relationship-to-MonadFunctor">#</a></h2><p>A stricter form of <code><a href="../.././Init/Control/Basic.html#MonadControl">MonadControl</a></code> is <code><a href="../.././Init/Prelude.html#MonadFunctor">MonadFunctor</a></code>, which defines
<code>monadMap {α} : (∀ {β}, m β → m β) → n α → n α</code>. Using <code>monadMap</code> it is also possible to define <code>mapped_foo</code> above.
However there are some mappings which can't be derived using <code><a href="../.././Init/Prelude.html#MonadFunctor">MonadFunctor</a></code>. For example:</p><pre><code class="language-lean,ignore"> @[inline] def map1MetaM [MonadControlT MetaM n] [Monad n] (f : forall {α}, (β → MetaM α) → MetaM α) {α} (k : β → n α) : n α :=
   control fun runInBase =&gt; f fun b =&gt; runInBase &lt;| k b

 @[inline] def map2MetaM [MonadControlT MetaM n] [Monad n] (f : forall {α}, (β → γ → MetaM α) → MetaM α) {α} (k : β → γ → n α) : n α :=
   control fun runInBase =&gt; f fun b c =&gt; runInBase &lt;| k b c
</code></pre><p>In <code>monadMap</code>, we can only 'run in base' a single computation in <code>n</code> into the base monad <code>m</code>.
Using <code><a href="../.././Init/Control/Basic.html#control">control</a></code> means that <code>runInBase</code> can be used multiple times.</p></div><div class="decl" id="MonadControl"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L298-L326">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#MonadControl"><span class="name">MonadControl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././Init/Prelude.html#semiOutParam">semiOutParam</a> <span class="fn">(<a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max (max (u + 1) v) w)</div></div><p>A way to lift a computation from one monad to another while providing the lifted computation with a
means of interpreting computations from the outer monad. This provides a means of lifting
higher-order operations automatically.</p><p>Clients should typically use <code><a href="../.././Init/Control/Basic.html#control">control</a></code> or <code><a href="../.././Init/Control/Basic.html#controlAt">controlAt</a></code>, which request an instance of <code><a href="../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a></code>:
the reflexive, transitive closure of <code><a href="../.././Init/Control/Basic.html#MonadControl">MonadControl</a></code>. New instances should be defined for
<code><a href="../.././Init/Control/Basic.html#MonadControl">MonadControl</a></code> itself.</p><ul class="structure_fields" id="MonadControl.mk"><li id="MonadControl.stM" class="structure_field"><div class="structure_field_info">stM : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> u</span></div><div class="structure_field_doc"><p>A type that can be used to reconstruct both a returned value and any state used by the outer
monad.</p></div></li><li id="MonadControl.liftWith" class="structure_field"><div class="structure_field_info">liftWith<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">(<span class="fn">({<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../.././Init/Control/Basic.html#MonadControl.stM">stM</a> <span class="fn">m</span> <span class="fn">n</span> <span class="fn">β</span>)</span></span></span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Lifts an action from the inner monad <code>m</code> to the outer monad <code>n</code>. The inner monad has access to a
reverse lifting operator that can run an <code>n</code> action, returning a value and state together.</p></div></li><li id="MonadControl.restoreM" class="structure_field"><div class="structure_field_info">restoreM<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../.././Init/Control/Basic.html#MonadControl.stM">stM</a> <span class="fn">m</span> <span class="fn">n</span> <span class="fn">α</span>)</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Lifts a monadic action that returns a state and a value in the inner monad to an action in the
outer monad. The extra state information is used to restore the results of effects from the
reverse lift passed to <code><a href="../.././Init/Control/Basic.html#MonadControl.liftWith">liftWith</a></code>'s parameter.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadControl" class="instances-list"></ul></details></div></div><div class="decl" id="MonadControlT"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L328-L353">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#MonadControlT"><span class="name">MonadControlT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max (max (u + 1) v) w)</div></div><p>A way to lift a computation from one monad to another while providing the lifted computation with a
means of interpreting computations from the outer monad. This provides a means of lifting
higher-order operations automatically.</p><p>Clients should typically use <code><a href="../.././Init/Control/Basic.html#control">control</a></code> or <code><a href="../.././Init/Control/Basic.html#controlAt">controlAt</a></code>, which request an instance of <code><a href="../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a></code>:
the reflexive, transitive closure of <code><a href="../.././Init/Control/Basic.html#MonadControl">MonadControl</a></code>. New instances should be defined for
<code><a href="../.././Init/Control/Basic.html#MonadControl">MonadControl</a></code> itself.</p><ul class="structure_fields" id="MonadControlT.mk"><li id="MonadControlT.stM" class="structure_field"><div class="structure_field_info">stM : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> u</span></div><div class="structure_field_doc"><p>A type that can be used to reconstruct both a returned value and any state used by the outer
monad.</p></div></li><li id="MonadControlT.liftWith" class="structure_field"><div class="structure_field_info">liftWith<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">(<span class="fn">({<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../.././Init/Control/Basic.html#MonadControlT.stM">stM</a> <span class="fn">m</span> <span class="fn">n</span> <span class="fn">β</span>)</span></span></span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Lifts an action from the inner monad <code>m</code> to the outer monad <code>n</code>. The inner monad has access to a
reverse lifting operator that can run an <code>n</code> action, returning a value and state together.</p></div></li><li id="MonadControlT.restoreM" class="structure_field"><div class="structure_field_info">restoreM<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Init/Control/Basic.html#MonadControlT.stM">stM</a> <span class="fn">m</span> <span class="fn">n</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Lifts a monadic action that returns a state and a value in the inner monad to an action in the
outer monad. The extra state information is used to restore the results of effects from the
reverse lift passed to <code><a href="../.././Init/Control/Basic.html#MonadControl.liftWith">liftWith</a></code>'s parameter.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadControlT" class="instances-list"></ul></details></div></div><div class="decl" id="instMonadControlTOfMonadControl"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L357-L361">source</a></div><div class="attributes">@[always_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#instMonadControlTOfMonadControl"><span class="name">instMonadControlTOfMonadControl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_3</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_4</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Control/Basic.html#MonadControl">MonadControl</a> <span class="fn">n</span> <span class="fn">o</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <span class="fn">m</span> <span class="fn">o</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="instMonadControlTOfPure"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L363-L366">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#instMonadControlTOfPure"><span class="name">instMonadControlTOfPure</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Pure">Pure</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <span class="fn">m</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="controlAt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L368-L379">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#controlAt"><span class="name">controlAt</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Bind">Bind</a> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">({<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../.././Init/Control/Basic.html#MonadControlT.stM">stM</a> <span class="fn">m</span> <span class="fn">n</span> <span class="fn">β</span>)</span></span></span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../.././Init/Control/Basic.html#MonadControlT.stM">stM</a> <span class="fn">m</span> <span class="fn">n</span> <span class="fn">α</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></div></div><p>Lifts an operation from an inner monad to an outer monad, providing it with a reverse lifting
operator that allows outer monad computations to be run in the inner monad. The lifted operation is
required to return extra information that is required in order to reconstruct the reverse lift's
effects in the outer monad; this extra information is determined by <code><a href="../.././Init/Control/Basic.html#MonadControl.stM">stM</a></code>.</p><p>This function takes the inner monad as an explicit parameter. Use <code><a href="../.././Init/Control/Basic.html#control">control</a></code> to infer the monad.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Init/Control/Basic.html#controlAt">controlAt</a> <span class="fn">m</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Control/Basic.html#MonadControlT.liftWith">liftWith</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Bind.bind">&gt;&gt;=</a> <a href="../.././Init/Control/Basic.html#MonadControlT.restoreM">restoreM</a></li></ul></details><details id="instances-for-list-controlAt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="control"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L381-L393">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#control"><span class="name">control</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Bind">Bind</a> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">({<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../.././Init/Control/Basic.html#MonadControlT.stM">stM</a> <span class="fn">m</span> <span class="fn">n</span> <span class="fn">β</span>)</span></span></span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../.././Init/Control/Basic.html#MonadControlT.stM">stM</a> <span class="fn">m</span> <span class="fn">n</span> <span class="fn">α</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></div></div><p>Lifts an operation from an inner monad to an outer monad, providing it with a reverse lifting
operator that allows outer monad computations to be run in the inner monad. The lifted operation is
required to return extra information that is required in order to reconstruct the reverse lift's
effects in the outer monad; this extra information is determined by <code><a href="../.././Init/Control/Basic.html#MonadControl.stM">stM</a></code>.</p><p>This function takes the inner monad as an implicit parameter. Use <code><a href="../.././Init/Control/Basic.html#controlAt">controlAt</a></code> to specify it
explicitly.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Init/Control/Basic.html#control">control</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Control/Basic.html#controlAt">controlAt</a> <span class="fn">m</span> <span class="fn">f</span></span></li></ul></details><details id="instances-for-list-control" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ForM"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L395-L409">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#ForM"><span class="name">ForM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> w₁)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn"><a href="../.././Init/Prelude.html#outParam">outParam</a> <a href="../.././foundational_types.html">(Type</a> w₂)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max (max (max (u + 1) v) w₁) w₂)</div></div><p>Overloaded monadic iteration over some container type.</p><p>An instance of <code><a href="../.././Init/Control/Basic.html#ForM">ForM</a> m γ α</code> describes how to iterate a monadic operator over a container of type <code>γ</code>
with elements of type <code>α</code> in the monad <code>m</code>. The element type should be uniquely determined by the
monad and the container.</p><p>Use <code><a href="../.././Init/Control/State.html#ForM.forIn">ForM.forIn</a></code> to construct a <code><a href="../.././Init/Core.html#ForIn">ForIn</a></code> instance from a <code><a href="../.././Init/Control/Basic.html#ForM">ForM</a></code> instance, thus enabling the use of
the <code>for</code> operator in <code>do</code>-notation.</p><ul class="structure_fields" id="ForM.mk"><li id="ForM.forM" class="structure_field"><div class="structure_field_info">forM<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">coll</span> : <span class="fn">γ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span></span>)</span></span>
 : <span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span></div><div class="structure_field_doc"><p>Runs the monadic action <code>f</code> on each element of the collection <code>coll</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-ForM" class="instances-list"></ul></details></div></div><div class="decl" id="Bind.kleisliRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L413-L416">source</a></div><div class="attributes">@[always_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#Bind.kleisliRight"><span class="name">Bind</span>.<span class="name">kleisliRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β </span><span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Bind">Bind</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f₁</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f₂</span> : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">γ</span></span></div></div><p>Left-to-right composition of Kleisli arrows.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&gt;=&gt;</code> in identifiers is <code><a href="../.././Init/Control/Basic.html#Bind.kleisliRight">kleisliRight</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn">f₁</span> <a href="../.././Init/Control/Basic.html#Bind.kleisliRight">&gt;=&gt;</a> <span class="fn">f₂</span>) <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f₁</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Bind.bind">&gt;&gt;=</a> <span class="fn">f₂</span></li></ul></details><details id="instances-for-list-Bind.kleisliRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Bind.kleisliLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L418-L421">source</a></div><div class="attributes">@[always_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#Bind.kleisliLeft"><span class="name">Bind</span>.<span class="name">kleisliLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β </span><span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Bind">Bind</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f₂</span> : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f₁</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">γ</span></span></div></div><p>Right-to-left composition of Kleisli arrows.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;=&lt;</code> in identifiers is <code><a href="../.././Init/Control/Basic.html#Bind.kleisliLeft">kleisliLeft</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn">f₂</span> <a href="../.././Init/Control/Basic.html#Bind.kleisliLeft">&lt;=&lt;</a> <span class="fn">f₁</span>) <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f₁</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Bind.bind">&gt;&gt;=</a> <span class="fn">f₂</span></li></ul></details><details id="instances-for-list-Bind.kleisliLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Bind.bindLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L423-L426">source</a></div><div class="attributes">@[always_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#Bind.bindLeft"><span class="name">Bind</span>.<span class="name">bindLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Bind">Bind</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ma</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></div></div><p>Same as <code><a href="../.././Init/Prelude.html#Bind.bind">Bind.bind</a></code> but with arguments swapped.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>=&lt;&lt;</code> in identifiers is <code><a href="../.././Init/Control/Basic.html#Bind.bindLeft">bindLeft</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">f</span> <a href="../.././Init/Control/Basic.html#Bind.bindLeft">=&lt;&lt;</a> <span class="fn">ma</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">ma</span> <a href="../.././Init/Prelude.html#Bind.bind">&gt;&gt;=</a> <span class="fn">f</span></li></ul></details><details id="instances-for-list-Bind.bindLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&gt;=&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L430-L430">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#«term_&gt;=&gt;_»"><span class="name">«term_&gt;=&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Left-to-right composition of Kleisli arrows.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&gt;=&gt;</code> in identifiers is <code><a href="../.././Init/Control/Basic.html#Bind.kleisliRight">kleisliRight</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Control/Basic.html#«term_&gt;=&gt;_»">«term_&gt;=&gt;_»</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&gt;=&gt;_»</span> <span class="fn">55</span> <span class="fn">56</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &gt;=&gt; &quot;</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">55</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&gt;=&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&lt;=&lt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L431-L431">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#«term_&lt;=&lt;_»"><span class="name">«term_&lt;=&lt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Right-to-left composition of Kleisli arrows.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;=&lt;</code> in identifiers is <code><a href="../.././Init/Control/Basic.html#Bind.kleisliLeft">kleisliLeft</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Control/Basic.html#«term_&lt;=&lt;_»">«term_&lt;=&lt;_»</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;=&lt;_»</span> <span class="fn">55</span> <span class="fn">56</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;=&lt; &quot;</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">55</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;=&lt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_=&lt;&lt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Control/Basic.lean#L432-L432">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Control/Basic.html#«term_=&lt;&lt;_»"><span class="name">«term_=&lt;&lt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Same as <code><a href="../.././Init/Prelude.html#Bind.bind">Bind.bind</a></code> but with arguments swapped.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>=&lt;&lt;</code> in identifiers is <code><a href="../.././Init/Control/Basic.html#Bind.bindLeft">bindLeft</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Control/Basic.html#«term_=&lt;&lt;_»">«term_=&lt;&lt;_»</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_=&lt;&lt;_»</span> <span class="fn">55</span> <span class="fn">56</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; =&lt;&lt; &quot;</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">55</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_=&lt;&lt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>