<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="icon" href=".././favicon.svg"></link><link rel="mask-icon" href=".././favicon.svg" color="#000000"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>Init.Prelude</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="Init.Prelude";</script><script type="module" src=".././jump-src.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././expand-nav.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Init</span>.<span class="name">Prelude</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Prelude" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#id"><span class="name">id</span></a></div><div class="nav_link"><a class="break_within" href="#Function.comp"><span class="name">Function</span>.<span class="name">comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.const"><span class="name">Function</span>.<span class="name">const</span></a></div><div class="nav_link"><a class="break_within" href="#letFun"><span class="name">letFun</span></a></div><div class="nav_link"><a class="break_within" href="#inferInstance"><span class="name">inferInstance</span></a></div><div class="nav_link"><a class="break_within" href="#inferInstanceAs"><span class="name">inferInstanceAs</span></a></div><div class="nav_link"><a class="break_within" href="#PUnit"><span class="name">PUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Unit"><span class="name">Unit</span></a></div><div class="nav_link"><a class="break_within" href="#Unit.unit"><span class="name">Unit</span>.<span class="name">unit</span></a></div><div class="nav_link"><a class="break_within" href="#lcErased"><span class="name">lcErased</span></a></div><div class="nav_link"><a class="break_within" href="#lcAny"><span class="name">lcAny</span></a></div><div class="nav_link"><a class="break_within" href="#lcRealWorld"><span class="name">lcRealWorld</span></a></div><div class="nav_link"><a class="break_within" href="#lcProof"><span class="name">lcProof</span></a></div><div class="nav_link"><a class="break_within" href="#lcCast"><span class="name">lcCast</span></a></div><div class="nav_link"><a class="break_within" href="#lcUnreachable"><span class="name">lcUnreachable</span></a></div><div class="nav_link"><a class="break_within" href="#True"><span class="name">True</span></a></div><div class="nav_link"><a class="break_within" href="#False"><span class="name">False</span></a></div><div class="nav_link"><a class="break_within" href="#Empty"><span class="name">Empty</span></a></div><div class="nav_link"><a class="break_within" href="#PEmpty"><span class="name">PEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Not"><span class="name">Not</span></a></div><div class="nav_link"><a class="break_within" href="#False.elim"><span class="name">False</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#absurd"><span class="name">absurd</span></a></div><div class="nav_link"><a class="break_within" href="#Eq"><span class="name">Eq</span></a></div><div class="nav_link"><a class="break_within" href="#rfl"><span class="name">rfl</span></a></div><div class="nav_link"><a class="break_within" href="#id_eq"><span class="name">id_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.subst"><span class="name">Eq</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.symm"><span class="name">Eq</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.trans"><span class="name">Eq</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#cast"><span class="name">cast</span></a></div><div class="nav_link"><a class="break_within" href="#congrArg"><span class="name">congrArg</span></a></div><div class="nav_link"><a class="break_within" href="#congr"><span class="name">congr</span></a></div><div class="nav_link"><a class="break_within" href="#congrFun"><span class="name">congrFun</span></a></div><div class="nav_link"><a class="break_within" href="#Quot"><span class="name">Quot</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.mk"><span class="name">Quot</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.ind"><span class="name">Quot</span>.<span class="name">ind</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.lift"><span class="name">Quot</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.lcInv"><span class="name">Quot</span>.<span class="name">lcInv</span></a></div><div class="nav_link"><a class="break_within" href="#HEq"><span class="name">HEq</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.rfl"><span class="name">HEq</span>.<span class="name">rfl</span></a></div><div class="nav_link"><a class="break_within" href="#eq_of_heq"><span class="name">eq_of_heq</span></a></div><div class="nav_link"><a class="break_within" href="#Prod"><span class="name">Prod</span></a></div><div class="nav_link"><a class="break_within" href="#PProd"><span class="name">PProd</span></a></div><div class="nav_link"><a class="break_within" href="#MProd"><span class="name">MProd</span></a></div><div class="nav_link"><a class="break_within" href="#And"><span class="name">And</span></a></div><div class="nav_link"><a class="break_within" href="#Or"><span class="name">Or</span></a></div><div class="nav_link"><a class="break_within" href="#Or.intro_left"><span class="name">Or</span>.<span class="name">intro_left</span></a></div><div class="nav_link"><a class="break_within" href="#Or.intro_right"><span class="name">Or</span>.<span class="name">intro_right</span></a></div><div class="nav_link"><a class="break_within" href="#Or.elim"><span class="name">Or</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#Or.resolve_left"><span class="name">Or</span>.<span class="name">resolve_left</span></a></div><div class="nav_link"><a class="break_within" href="#Or.resolve_right"><span class="name">Or</span>.<span class="name">resolve_right</span></a></div><div class="nav_link"><a class="break_within" href="#Or.neg_resolve_left"><span class="name">Or</span>.<span class="name">neg_resolve_left</span></a></div><div class="nav_link"><a class="break_within" href="#Or.neg_resolve_right"><span class="name">Or</span>.<span class="name">neg_resolve_right</span></a></div><div class="nav_link"><a class="break_within" href="#Bool"><span class="name">Bool</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype"><span class="name">Subtype</span></a></div><div class="nav_link"><a class="break_within" href="#optParam"><span class="name">optParam</span></a></div><div class="nav_link"><a class="break_within" href="#outParam"><span class="name">outParam</span></a></div><div class="nav_link"><a class="break_within" href="#semiOutParam"><span class="name">semiOutParam</span></a></div><div class="nav_link"><a class="break_within" href="#namedPattern"><span class="name">namedPattern</span></a></div><div class="nav_link"><a class="break_within" href="#sorryAx"><span class="name">sorryAx</span></a></div><div class="nav_link"><a class="break_within" href="#eq_false_of_ne_true"><span class="name">eq_false_of_ne_true</span></a></div><div class="nav_link"><a class="break_within" href="#eq_true_of_ne_false"><span class="name">eq_true_of_ne_false</span></a></div><div class="nav_link"><a class="break_within" href="#ne_false_of_eq_true"><span class="name">ne_false_of_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#ne_true_of_eq_false"><span class="name">ne_true_of_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Inhabited"><span class="name">Inhabited</span></a></div><div class="nav_link"><a class="break_within" href="#Nonempty"><span class="name">Nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choice"><span class="name">Classical</span>.<span class="name">choice</span></a></div><div class="nav_link"><a class="break_within" href="#Nonempty.elim"><span class="name">Nonempty</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyOfInhabited"><span class="name">instNonemptyOfInhabited</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.ofNonempty"><span class="name">Classical</span>.<span class="name">ofNonempty</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyForall"><span class="name">instNonemptyForall</span></a></div><div class="nav_link"><a class="break_within" href="#Pi.instNonempty"><span class="name">Pi</span>.<span class="name">instNonempty</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedSort"><span class="name">instInhabitedSort</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedForall"><span class="name">instInhabitedForall</span></a></div><div class="nav_link"><a class="break_within" href="#Pi.instInhabited"><span class="name">Pi</span>.<span class="name">instInhabited</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedBool.default"><span class="name">instInhabitedBool</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedBool"><span class="name">instInhabitedBool</span></a></div><div class="nav_link"><a class="break_within" href="#PLift"><span class="name">PLift</span></a></div><div class="nav_link"><a class="break_within" href="#PLift.up_down"><span class="name">PLift</span>.<span class="name">up_down</span></a></div><div class="nav_link"><a class="break_within" href="#PLift.down_up"><span class="name">PLift</span>.<span class="name">down_up</span></a></div><div class="nav_link"><a class="break_within" href="#NonemptyType"><span class="name">NonemptyType</span></a></div><div class="nav_link"><a class="break_within" href="#NonemptyType.type"><span class="name">NonemptyType</span>.<span class="name">type</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedNonemptyType"><span class="name">instInhabitedNonemptyType</span></a></div><div class="nav_link"><a class="break_within" href="#ULift"><span class="name">ULift</span></a></div><div class="nav_link"><a class="break_within" href="#ULift.up_down"><span class="name">ULift</span>.<span class="name">up_down</span></a></div><div class="nav_link"><a class="break_within" href="#ULift.down_up"><span class="name">ULift</span>.<span class="name">down_up</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedULift"><span class="name">instInhabitedULift</span></a></div><div class="nav_link"><a class="break_within" href="#PULift"><span class="name">PULift</span></a></div><div class="nav_link"><a class="break_within" href="#PULift.up_down"><span class="name">PULift</span>.<span class="name">up_down</span></a></div><div class="nav_link"><a class="break_within" href="#PULift.down_up"><span class="name">PULift</span>.<span class="name">down_up</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable"><span class="name">Decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.decide"><span class="name">Decidable</span>.<span class="name">decide</span></a></div><div class="nav_link"><a class="break_within" href="#DecidablePred"><span class="name">DecidablePred</span></a></div><div class="nav_link"><a class="break_within" href="#DecidableRel"><span class="name">DecidableRel</span></a></div><div class="nav_link"><a class="break_within" href="#DecidableEq"><span class="name">DecidableEq</span></a></div><div class="nav_link"><a class="break_within" href="#decEq"><span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#decide_eq_true"><span class="name">decide_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#decide_eq_false"><span class="name">decide_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#of_decide_eq_true"><span class="name">of_decide_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#of_decide_eq_false"><span class="name">of_decide_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#of_decide_eq_self_eq_true"><span class="name">of_decide_eq_self_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.decEq"><span class="name">Bool</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqBool"><span class="name">instDecidableEqBool</span></a></div><div class="nav_link"><a class="break_within" href="#BEq"><span class="name">BEq</span></a></div><div class="nav_link"><a class="break_within" href="#instBEqOfDecidableEq"><span class="name">instBEqOfDecidableEq</span></a></div><div class="nav_link"><a class="break_within" href="#dite"><span class="name">dite</span></a></div><div class="nav_link"><a class="break_within" href="#ite"><span class="name">ite</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableAnd"><span class="name">instDecidableAnd</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableOr"><span class="name">instDecidableOr</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableNot"><span class="name">instDecidableNot</span></a></div><div class="nav_link"><a class="break_within" href="#cond"><span class="name">cond</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.dcond"><span class="name">Bool</span>.<span class="name">dcond</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.or"><span class="name">Bool</span>.<span class="name">or</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.and"><span class="name">Bool</span>.<span class="name">and</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.not"><span class="name">Bool</span>.<span class="name">not</span></a></div><div class="nav_link"><a class="break_within" href="#Nat"><span class="name">Nat</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedNat"><span class="name">instInhabitedNat</span></a></div><div class="nav_link"><a class="break_within" href="#OfNat"><span class="name">OfNat</span></a></div><div class="nav_link"><a class="break_within" href="#instOfNatNat"><span class="name">instOfNatNat</span></a></div><div class="nav_link"><a class="break_within" href="#LE"><span class="name">LE</span></a></div><div class="nav_link"><a class="break_within" href="#LT"><span class="name">LT</span></a></div><div class="nav_link"><a class="break_within" href="#GE.ge"><span class="name">GE</span>.<span class="name">ge</span></a></div><div class="nav_link"><a class="break_within" href="#GT.gt"><span class="name">GT</span>.<span class="name">gt</span></a></div><div class="nav_link"><a class="break_within" href="#DecidableLT"><span class="name">DecidableLT</span></a></div><div class="nav_link"><a class="break_within" href="#DecidableLE"><span class="name">DecidableLE</span></a></div><div class="nav_link"><a class="break_within" href="#Max"><span class="name">Max</span></a></div><div class="nav_link"><a class="break_within" href="#maxOfLe"><span class="name">maxOfLe</span></a></div><div class="nav_link"><a class="break_within" href="#Min"><span class="name">Min</span></a></div><div class="nav_link"><a class="break_within" href="#minOfLe"><span class="name">minOfLe</span></a></div><div class="nav_link"><a class="break_within" href="#Trans"><span class="name">Trans</span></a></div><div class="nav_link"><a class="break_within" href="#instTransEq"><span class="name">instTransEq</span></a></div><div class="nav_link"><a class="break_within" href="#instTransEq_1"><span class="name">instTransEq_1</span></a></div><div class="nav_link"><a class="break_within" href="#HAdd"><span class="name">HAdd</span></a></div><div class="nav_link"><a class="break_within" href="#HSub"><span class="name">HSub</span></a></div><div class="nav_link"><a class="break_within" href="#HMul"><span class="name">HMul</span></a></div><div class="nav_link"><a class="break_within" href="#HDiv"><span class="name">HDiv</span></a></div><div class="nav_link"><a class="break_within" href="#HMod"><span class="name">HMod</span></a></div><div class="nav_link"><a class="break_within" href="#HPow"><span class="name">HPow</span></a></div><div class="nav_link"><a class="break_within" href="#HSMul"><span class="name">HSMul</span></a></div><div class="nav_link"><a class="break_within" href="#HAppend"><span class="name">HAppend</span></a></div><div class="nav_link"><a class="break_within" href="#HOrElse"><span class="name">HOrElse</span></a></div><div class="nav_link"><a class="break_within" href="#HAndThen"><span class="name">HAndThen</span></a></div><div class="nav_link"><a class="break_within" href="#HAnd"><span class="name">HAnd</span></a></div><div class="nav_link"><a class="break_within" href="#HXor"><span class="name">HXor</span></a></div><div class="nav_link"><a class="break_within" href="#HOr"><span class="name">HOr</span></a></div><div class="nav_link"><a class="break_within" href="#HShiftLeft"><span class="name">HShiftLeft</span></a></div><div class="nav_link"><a class="break_within" href="#HShiftRight"><span class="name">HShiftRight</span></a></div><div class="nav_link"><a class="break_within" href="#Zero"><span class="name">Zero</span></a></div><div class="nav_link"><a class="break_within" href="#One"><span class="name">One</span></a></div><div class="nav_link"><a class="break_within" href="#Add"><span class="name">Add</span></a></div><div class="nav_link"><a class="break_within" href="#Sub"><span class="name">Sub</span></a></div><div class="nav_link"><a class="break_within" href="#Mul"><span class="name">Mul</span></a></div><div class="nav_link"><a class="break_within" href="#Neg"><span class="name">Neg</span></a></div><div class="nav_link"><a class="break_within" href="#Div"><span class="name">Div</span></a></div><div class="nav_link"><a class="break_within" href="#Inv"><span class="name">Inv</span></a></div><div class="nav_link"><a class="break_within" href="#Mod"><span class="name">Mod</span></a></div><div class="nav_link"><a class="break_within" href="#Dvd"><span class="name">Dvd</span></a></div><div class="nav_link"><a class="break_within" href="#Pow"><span class="name">Pow</span></a></div><div class="nav_link"><a class="break_within" href="#NatPow"><span class="name">NatPow</span></a></div><div class="nav_link"><a class="break_within" href="#HomogeneousPow"><span class="name">HomogeneousPow</span></a></div><div class="nav_link"><a class="break_within" href="#SMul"><span class="name">SMul</span></a></div><div class="nav_link"><a class="break_within" href="#Append"><span class="name">Append</span></a></div><div class="nav_link"><a class="break_within" href="#OrElse"><span class="name">OrElse</span></a></div><div class="nav_link"><a class="break_within" href="#AndThen"><span class="name">AndThen</span></a></div><div class="nav_link"><a class="break_within" href="#AndOp"><span class="name">AndOp</span></a></div><div class="nav_link"><a class="break_within" href="#XorOp"><span class="name">XorOp</span></a></div><div class="nav_link"><a class="break_within" href="#OrOp"><span class="name">OrOp</span></a></div><div class="nav_link"><a class="break_within" href="#Complement"><span class="name">Complement</span></a></div><div class="nav_link"><a class="break_within" href="#ShiftLeft"><span class="name">ShiftLeft</span></a></div><div class="nav_link"><a class="break_within" href="#ShiftRight"><span class="name">ShiftRight</span></a></div><div class="nav_link"><a class="break_within" href="#instHAdd"><span class="name">instHAdd</span></a></div><div class="nav_link"><a class="break_within" href="#instHSub"><span class="name">instHSub</span></a></div><div class="nav_link"><a class="break_within" href="#instHMul"><span class="name">instHMul</span></a></div><div class="nav_link"><a class="break_within" href="#instHDiv"><span class="name">instHDiv</span></a></div><div class="nav_link"><a class="break_within" href="#instHMod"><span class="name">instHMod</span></a></div><div class="nav_link"><a class="break_within" href="#instHPow"><span class="name">instHPow</span></a></div><div class="nav_link"><a class="break_within" href="#instPowNat"><span class="name">instPowNat</span></a></div><div class="nav_link"><a class="break_within" href="#instPowOfHomogeneousPow"><span class="name">instPowOfHomogeneousPow</span></a></div><div class="nav_link"><a class="break_within" href="#instHSMul"><span class="name">instHSMul</span></a></div><div class="nav_link"><a class="break_within" href="#instSMulOfMul"><span class="name">instSMulOfMul</span></a></div><div class="nav_link"><a class="break_within" href="#instHAppendOfAppend"><span class="name">instHAppendOfAppend</span></a></div><div class="nav_link"><a class="break_within" href="#instHOrElseOfOrElse"><span class="name">instHOrElseOfOrElse</span></a></div><div class="nav_link"><a class="break_within" href="#instHAndThenOfAndThen"><span class="name">instHAndThenOfAndThen</span></a></div><div class="nav_link"><a class="break_within" href="#instHAndOfAndOp"><span class="name">instHAndOfAndOp</span></a></div><div class="nav_link"><a class="break_within" href="#instHXorOfXorOp"><span class="name">instHXorOfXorOp</span></a></div><div class="nav_link"><a class="break_within" href="#instHOrOfOrOp"><span class="name">instHOrOfOrOp</span></a></div><div class="nav_link"><a class="break_within" href="#instHShiftLeftOfShiftLeft"><span class="name">instHShiftLeftOfShiftLeft</span></a></div><div class="nav_link"><a class="break_within" href="#instHShiftRightOfShiftRight"><span class="name">instHShiftRightOfShiftRight</span></a></div><div class="nav_link"><a class="break_within" href="#Membership"><span class="name">Membership</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.add"><span class="name">Nat</span>.<span class="name">add</span></a></div><div class="nav_link"><a class="break_within" href="#instAddNat"><span class="name">instAddNat</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.mul"><span class="name">Nat</span>.<span class="name">mul</span></a></div><div class="nav_link"><a class="break_within" href="#instMulNat"><span class="name">instMulNat</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.pow"><span class="name">Nat</span>.<span class="name">pow</span></a></div><div class="nav_link"><a class="break_within" href="#instNatPowNat"><span class="name">instNatPowNat</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.beq"><span class="name">Nat</span>.<span class="name">beq</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.eq_of_beq_eq_true"><span class="name">Nat</span>.<span class="name">eq_of_beq_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.ne_of_beq_eq_false"><span class="name">Nat</span>.<span class="name">ne_of_beq_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#noConfusion_of_Nat"><span class="name">noConfusion_of_Nat</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.decEq"><span class="name">Nat</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqNat"><span class="name">instDecidableEqNat</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.ble"><span class="name">Nat</span>.<span class="name">ble</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.le"><span class="name">Nat</span>.<span class="name">le</span></a></div><div class="nav_link"><a class="break_within" href="#instLENat"><span class="name">instLENat</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.lt"><span class="name">Nat</span>.<span class="name">lt</span></a></div><div class="nav_link"><a class="break_within" href="#instLTNat"><span class="name">instLTNat</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.not_succ_le_zero"><span class="name">Nat</span>.<span class="name">not_succ_le_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.not_lt_zero"><span class="name">Nat</span>.<span class="name">not_lt_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.zero_le"><span class="name">Nat</span>.<span class="name">zero_le</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.succ_le_succ"><span class="name">Nat</span>.<span class="name">succ_le_succ</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.zero_lt_succ"><span class="name">Nat</span>.<span class="name">zero_lt_succ</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.le_step"><span class="name">Nat</span>.<span class="name">le_step</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.le_trans"><span class="name">Nat</span>.<span class="name">le_trans</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_of_lt_of_le"><span class="name">Nat</span>.<span class="name">lt_of_lt_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_trans"><span class="name">Nat</span>.<span class="name">lt_trans</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.le_succ"><span class="name">Nat</span>.<span class="name">le_succ</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.le_succ_of_le"><span class="name">Nat</span>.<span class="name">le_succ_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.le_refl"><span class="name">Nat</span>.<span class="name">le_refl</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.succ_pos"><span class="name">Nat</span>.<span class="name">succ_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.pred"><span class="name">Nat</span>.<span class="name">pred</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.pred_le_pred"><span class="name">Nat</span>.<span class="name">pred_le_pred</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.le_of_succ_le_succ"><span class="name">Nat</span>.<span class="name">le_of_succ_le_succ</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.le_of_lt_succ"><span class="name">Nat</span>.<span class="name">le_of_lt_succ</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.eq_or_lt_of_le"><span class="name">Nat</span>.<span class="name">eq_or_lt_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_or_ge"><span class="name">Nat</span>.<span class="name">lt_or_ge</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.not_succ_le_self"><span class="name">Nat</span>.<span class="name">not_succ_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_irrefl"><span class="name">Nat</span>.<span class="name">lt_irrefl</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_of_le_of_lt"><span class="name">Nat</span>.<span class="name">lt_of_le_of_lt</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.le_antisymm"><span class="name">Nat</span>.<span class="name">le_antisymm</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_of_le_of_ne"><span class="name">Nat</span>.<span class="name">lt_of_le_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.le_of_ble_eq_true"><span class="name">Nat</span>.<span class="name">le_of_ble_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.ble_self_eq_true"><span class="name">Nat</span>.<span class="name">ble_self_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.ble_succ_eq_true"><span class="name">Nat</span>.<span class="name">ble_succ_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.ble_eq_true_of_le"><span class="name">Nat</span>.<span class="name">ble_eq_true_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.not_le_of_not_ble_eq_true"><span class="name">Nat</span>.<span class="name">not_le_of_not_ble_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_succ_of_le"><span class="name">Nat</span>.<span class="name">lt_succ_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_add_one"><span class="name">Nat</span>.<span class="name">lt_add_one</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_succ_self"><span class="name">Nat</span>.<span class="name">lt_succ_self</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_of_not_le"><span class="name">Nat</span>.<span class="name">lt_of_not_le</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.add_pos_right"><span class="name">Nat</span>.<span class="name">add_pos_right</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.mul_pos"><span class="name">Nat</span>.<span class="name">mul_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.pow_pos"><span class="name">Nat</span>.<span class="name">pow_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.decLe"><span class="name">Nat</span>.<span class="name">decLe</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.decLt"><span class="name">Nat</span>.<span class="name">decLt</span></a></div><div class="nav_link"><a class="break_within" href="#instMinNat"><span class="name">instMinNat</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.sub"><span class="name">Nat</span>.<span class="name">sub</span></a></div><div class="nav_link"><a class="break_within" href="#instSubNat"><span class="name">instSubNat</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.succ_sub_succ_eq_sub"><span class="name">Nat</span>.<span class="name">succ_sub_succ_eq_sub</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.pred_le"><span class="name">Nat</span>.<span class="name">pred_le</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.sub_le"><span class="name">Nat</span>.<span class="name">sub_le</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.sub_lt"><span class="name">Nat</span>.<span class="name">sub_lt</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.div_rec_lemma"><span class="name">Nat</span>.<span class="name">div_rec_lemma</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.div_rec_fuel_lemma"><span class="name">Nat</span>.<span class="name">div_rec_fuel_lemma</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.div"><span class="name">Nat</span>.<span class="name">div</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.div.go"><span class="name">Nat</span>.<span class="name">div</span>.<span class="name">go</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.instDiv"><span class="name">Nat</span>.<span class="name">instDiv</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.modCore"><span class="name">Nat</span>.<span class="name">modCore</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.modCore.go"><span class="name">Nat</span>.<span class="name">modCore</span>.<span class="name">go</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.modCoreGo_lt"><span class="name">Nat</span>.<span class="name">modCoreGo_lt</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.modCore_lt"><span class="name">Nat</span>.<span class="name">modCore_lt</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.mod"><span class="name">Nat</span>.<span class="name">mod</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.instMod"><span class="name">Nat</span>.<span class="name">instMod</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.mod_lt"><span class="name">Nat</span>.<span class="name">mod_lt</span></a></div><div class="nav_link"><a class="break_within" href="#System.Platform.getNumBits"><span class="name">System</span>.<span class="name">Platform</span>.<span class="name">getNumBits</span></a></div><div class="nav_link"><a class="break_within" href="#System.Platform.numBits"><span class="name">System</span>.<span class="name">Platform</span>.<span class="name">numBits</span></a></div><div class="nav_link"><a class="break_within" href="#System.Platform.numBits_eq"><span class="name">System</span>.<span class="name">Platform</span>.<span class="name">numBits_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Fin"><span class="name">Fin</span></a></div><div class="nav_link"><a class="break_within" href="#Fin.eq_of_val_eq"><span class="name">Fin</span>.<span class="name">eq_of_val_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Fin.val_eq_of_eq"><span class="name">Fin</span>.<span class="name">val_eq_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqFin"><span class="name">instDecidableEqFin</span></a></div><div class="nav_link"><a class="break_within" href="#instLTFin"><span class="name">instLTFin</span></a></div><div class="nav_link"><a class="break_within" href="#instLEFin"><span class="name">instLEFin</span></a></div><div class="nav_link"><a class="break_within" href="#Fin.decLt"><span class="name">Fin</span>.<span class="name">decLt</span></a></div><div class="nav_link"><a class="break_within" href="#Fin.decLe"><span class="name">Fin</span>.<span class="name">decLe</span></a></div><div class="nav_link"><a class="break_within" href="#Fin.Internal.ofNat"><span class="name">Fin</span>.<span class="name">Internal</span>.<span class="name">ofNat</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec"><span class="name">BitVec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.decEq"><span class="name">BitVec</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqBitVec"><span class="name">instDecidableEqBitVec</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.ofNatLT"><span class="name">BitVec</span>.<span class="name">ofNatLT</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.ofNat"><span class="name">BitVec</span>.<span class="name">ofNat</span></a></div><div class="nav_link"><a class="break_within" href="#BitVec.toNat"><span class="name">BitVec</span>.<span class="name">toNat</span></a></div><div class="nav_link"><a class="break_within" href="#instLTBitVec"><span class="name">instLTBitVec</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableLtBitVec"><span class="name">instDecidableLtBitVec</span></a></div><div class="nav_link"><a class="break_within" href="#instLEBitVec"><span class="name">instLEBitVec</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableLeBitVec"><span class="name">instDecidableLeBitVec</span></a></div><div class="nav_link"><a class="break_within" href="#UInt8.size"><span class="name">UInt8</span>.<span class="name">size</span></a></div><div class="nav_link"><a class="break_within" href="#UInt8"><span class="name">UInt8</span></a></div><div class="nav_link"><a class="break_within" href="#UInt8.ofNatLT"><span class="name">UInt8</span>.<span class="name">ofNatLT</span></a></div><div class="nav_link"><a class="break_within" href="#UInt8.ofNat"><span class="name">UInt8</span>.<span class="name">ofNat</span></a></div><div class="nav_link"><a class="break_within" href="#UInt8.decEq"><span class="name">UInt8</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqUInt8"><span class="name">instDecidableEqUInt8</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedUInt8"><span class="name">instInhabitedUInt8</span></a></div><div class="nav_link"><a class="break_within" href="#UInt8.lt"><span class="name">UInt8</span>.<span class="name">lt</span></a></div><div class="nav_link"><a class="break_within" href="#UInt8.le"><span class="name">UInt8</span>.<span class="name">le</span></a></div><div class="nav_link"><a class="break_within" href="#instLTUInt8"><span class="name">instLTUInt8</span></a></div><div class="nav_link"><a class="break_within" href="#instLEUInt8"><span class="name">instLEUInt8</span></a></div><div class="nav_link"><a class="break_within" href="#UInt8.decLt"><span class="name">UInt8</span>.<span class="name">decLt</span></a></div><div class="nav_link"><a class="break_within" href="#UInt8.decLe"><span class="name">UInt8</span>.<span class="name">decLe</span></a></div><div class="nav_link"><a class="break_within" href="#UInt16.size"><span class="name">UInt16</span>.<span class="name">size</span></a></div><div class="nav_link"><a class="break_within" href="#UInt16"><span class="name">UInt16</span></a></div><div class="nav_link"><a class="break_within" href="#UInt16.ofNatLT"><span class="name">UInt16</span>.<span class="name">ofNatLT</span></a></div><div class="nav_link"><a class="break_within" href="#UInt16.decEq"><span class="name">UInt16</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqUInt16"><span class="name">instDecidableEqUInt16</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedUInt16"><span class="name">instInhabitedUInt16</span></a></div><div class="nav_link"><a class="break_within" href="#UInt32.size"><span class="name">UInt32</span>.<span class="name">size</span></a></div><div class="nav_link"><a class="break_within" href="#UInt32"><span class="name">UInt32</span></a></div><div class="nav_link"><a class="break_within" href="#UInt32.ofNatLT"><span class="name">UInt32</span>.<span class="name">ofNatLT</span></a></div><div class="nav_link"><a class="break_within" href="#UInt32.toNat"><span class="name">UInt32</span>.<span class="name">toNat</span></a></div><div class="nav_link"><a class="break_within" href="#UInt32.decEq"><span class="name">UInt32</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqUInt32"><span class="name">instDecidableEqUInt32</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedUInt32"><span class="name">instInhabitedUInt32</span></a></div><div class="nav_link"><a class="break_within" href="#instLTUInt32"><span class="name">instLTUInt32</span></a></div><div class="nav_link"><a class="break_within" href="#instLEUInt32"><span class="name">instLEUInt32</span></a></div><div class="nav_link"><a class="break_within" href="#UInt32.decLt"><span class="name">UInt32</span>.<span class="name">decLt</span></a></div><div class="nav_link"><a class="break_within" href="#UInt32.decLe"><span class="name">UInt32</span>.<span class="name">decLe</span></a></div><div class="nav_link"><a class="break_within" href="#instMaxUInt32"><span class="name">instMaxUInt32</span></a></div><div class="nav_link"><a class="break_within" href="#instMinUInt32"><span class="name">instMinUInt32</span></a></div><div class="nav_link"><a class="break_within" href="#UInt64.size"><span class="name">UInt64</span>.<span class="name">size</span></a></div><div class="nav_link"><a class="break_within" href="#UInt64"><span class="name">UInt64</span></a></div><div class="nav_link"><a class="break_within" href="#UInt64.ofNatLT"><span class="name">UInt64</span>.<span class="name">ofNatLT</span></a></div><div class="nav_link"><a class="break_within" href="#UInt64.decEq"><span class="name">UInt64</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqUInt64"><span class="name">instDecidableEqUInt64</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedUInt64"><span class="name">instInhabitedUInt64</span></a></div><div class="nav_link"><a class="break_within" href="#USize.size"><span class="name">USize</span>.<span class="name">size</span></a></div><div class="nav_link"><a class="break_within" href="#USize.size_eq"><span class="name">USize</span>.<span class="name">size_eq</span></a></div><div class="nav_link"><a class="break_within" href="#USize.size_pos"><span class="name">USize</span>.<span class="name">size_pos</span></a></div><div class="nav_link"><a class="break_within" href="#USize"><span class="name">USize</span></a></div><div class="nav_link"><a class="break_within" href="#USize.ofNatLT"><span class="name">USize</span>.<span class="name">ofNatLT</span></a></div><div class="nav_link"><a class="break_within" href="#USize.decEq"><span class="name">USize</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqUSize"><span class="name">instDecidableEqUSize</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedUSize"><span class="name">instInhabitedUSize</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.isValidChar"><span class="name">Nat</span>.<span class="name">isValidChar</span></a></div><div class="nav_link"><a class="break_within" href="#UInt32.isValidChar"><span class="name">UInt32</span>.<span class="name">isValidChar</span></a></div><div class="nav_link"><a class="break_within" href="#Char"><span class="name">Char</span></a></div><div class="nav_link"><a class="break_within" href="#Char.ofNatAux"><span class="name">Char</span>.<span class="name">ofNatAux</span></a></div><div class="nav_link"><a class="break_within" href="#Char.ofNat"><span class="name">Char</span>.<span class="name">ofNat</span></a></div><div class="nav_link"><a class="break_within" href="#Char.eq_of_val_eq"><span class="name">Char</span>.<span class="name">eq_of_val_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Char.val_eq_of_eq"><span class="name">Char</span>.<span class="name">val_eq_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Char.ne_of_val_ne"><span class="name">Char</span>.<span class="name">ne_of_val_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Char.val_ne_of_ne"><span class="name">Char</span>.<span class="name">val_ne_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqChar"><span class="name">instDecidableEqChar</span></a></div><div class="nav_link"><a class="break_within" href="#Char.utf8Size"><span class="name">Char</span>.<span class="name">utf8Size</span></a></div><div class="nav_link"><a class="break_within" href="#Option"><span class="name">Option</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedOption"><span class="name">instInhabitedOption</span></a></div><div class="nav_link"><a class="break_within" href="#Option.getD"><span class="name">Option</span>.<span class="name">getD</span></a></div><div class="nav_link"><a class="break_within" href="#Option.map"><span class="name">Option</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#List"><span class="name">List</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedList"><span class="name">instInhabitedList</span></a></div><div class="nav_link"><a class="break_within" href="#List.hasDecEq"><span class="name">List</span>.<span class="name">hasDecEq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqList"><span class="name">instDecidableEqList</span></a></div><div class="nav_link"><a class="break_within" href="#List.length"><span class="name">List</span>.<span class="name">length</span></a></div><div class="nav_link"><a class="break_within" href="#List.lengthTRAux"><span class="name">List</span>.<span class="name">lengthTRAux</span></a></div><div class="nav_link"><a class="break_within" href="#List.lengthTR"><span class="name">List</span>.<span class="name">lengthTR</span></a></div><div class="nav_link"><a class="break_within" href="#List.get"><span class="name">List</span>.<span class="name">get</span></a></div><div class="nav_link"><a class="break_within" href="#List.set"><span class="name">List</span>.<span class="name">set</span></a></div><div class="nav_link"><a class="break_within" href="#List.foldl"><span class="name">List</span>.<span class="name">foldl</span></a></div><div class="nav_link"><a class="break_within" href="#List.concat"><span class="name">List</span>.<span class="name">concat</span></a></div><div class="nav_link"><a class="break_within" href="#List.append"><span class="name">List</span>.<span class="name">append</span></a></div><div class="nav_link"><a class="break_within" href="#List.flatten"><span class="name">List</span>.<span class="name">flatten</span></a></div><div class="nav_link"><a class="break_within" href="#List.map"><span class="name">List</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#List.flatMap"><span class="name">List</span>.<span class="name">flatMap</span></a></div><div class="nav_link"><a class="break_within" href="#Array"><span class="name">Array</span></a></div><div class="nav_link"><a class="break_within" href="#List.toArray"><span class="name">List</span>.<span class="name">toArray</span></a></div><div class="nav_link"><a class="break_within" href="#Array.mkEmpty"><span class="name">Array</span>.<span class="name">mkEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Array.emptyWithCapacity"><span class="name">Array</span>.<span class="name">emptyWithCapacity</span></a></div><div class="nav_link"><a class="break_within" href="#Array.empty"><span class="name">Array</span>.<span class="name">empty</span></a></div><div class="nav_link"><a class="break_within" href="#Array.size"><span class="name">Array</span>.<span class="name">size</span></a></div><div class="nav_link"><a class="break_within" href="#Array.getInternalBorrowed"><span class="name">Array</span>.<span class="name">getInternalBorrowed</span></a></div><div class="nav_link"><a class="break_within" href="#Array.getInternal"><span class="name">Array</span>.<span class="name">getInternal</span></a></div><div class="nav_link"><a class="break_within" href="#Array.getD"><span class="name">Array</span>.<span class="name">getD</span></a></div><div class="nav_link"><a class="break_within" href="#Array.get!InternalBorrowed"><span class="name">Array</span>.<span class="name">get!InternalBorrowed</span></a></div><div class="nav_link"><a class="break_within" href="#Array.get!Internal"><span class="name">Array</span>.<span class="name">get!Internal</span></a></div><div class="nav_link"><a class="break_within" href="#Array.push"><span class="name">Array</span>.<span class="name">push</span></a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray0"><span class="name">Array</span>.<span class="name">mkArray0</span></a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray1"><span class="name">Array</span>.<span class="name">mkArray1</span></a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray2"><span class="name">Array</span>.<span class="name">mkArray2</span></a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray3"><span class="name">Array</span>.<span class="name">mkArray3</span></a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray4"><span class="name">Array</span>.<span class="name">mkArray4</span></a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray5"><span class="name">Array</span>.<span class="name">mkArray5</span></a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray6"><span class="name">Array</span>.<span class="name">mkArray6</span></a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray7"><span class="name">Array</span>.<span class="name">mkArray7</span></a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray8"><span class="name">Array</span>.<span class="name">mkArray8</span></a></div><div class="nav_link"><a class="break_within" href="#Array.appendCore"><span class="name">Array</span>.<span class="name">appendCore</span></a></div><div class="nav_link"><a class="break_within" href="#Array.appendCore.loop"><span class="name">Array</span>.<span class="name">appendCore</span>.<span class="name">loop</span></a></div><div class="nav_link"><a class="break_within" href="#Array.extract"><span class="name">Array</span>.<span class="name">extract</span></a></div><div class="nav_link"><a class="break_within" href="#Array.extract.loop"><span class="name">Array</span>.<span class="name">extract</span>.<span class="name">loop</span></a></div><div class="nav_link"><a class="break_within" href="#ByteArray"><span class="name">ByteArray</span></a></div><div class="nav_link"><a class="break_within" href="#ByteArray.emptyWithCapacity"><span class="name">ByteArray</span>.<span class="name">emptyWithCapacity</span></a></div><div class="nav_link"><a class="break_within" href="#ByteArray.empty"><span class="name">ByteArray</span>.<span class="name">empty</span></a></div><div class="nav_link"><a class="break_within" href="#ByteArray.push"><span class="name">ByteArray</span>.<span class="name">push</span></a></div><div class="nav_link"><a class="break_within" href="#List.toByteArray"><span class="name">List</span>.<span class="name">toByteArray</span></a></div><div class="nav_link"><a class="break_within" href="#List.toByteArray.loop"><span class="name">List</span>.<span class="name">toByteArray</span>.<span class="name">loop</span></a></div><div class="nav_link"><a class="break_within" href="#ByteArray.size"><span class="name">ByteArray</span>.<span class="name">size</span></a></div><div class="nav_link"><a class="break_within" href="#String.utf8EncodeChar"><span class="name">String</span>.<span class="name">utf8EncodeChar</span></a></div><div class="nav_link"><a class="break_within" href="#List.utf8Encode"><span class="name">List</span>.<span class="name">utf8Encode</span></a></div><div class="nav_link"><a class="break_within" href="#ByteArray.IsValidUTF8"><span class="name">ByteArray</span>.<span class="name">IsValidUTF8</span></a></div><div class="nav_link"><a class="break_within" href="#String"><span class="name">String</span></a></div><div class="nav_link"><a class="break_within" href="#String.decEq"><span class="name">String</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqString"><span class="name">instDecidableEqString</span></a></div><div class="nav_link"><a class="break_within" href="#String.Pos.Raw"><span class="name">String</span>.<span class="name">Pos</span>.<span class="name">Raw</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedRaw"><span class="name">instInhabitedRaw</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqRaw"><span class="name">instDecidableEqRaw</span></a></div><div class="nav_link"><a class="break_within" href="#Substring"><span class="name">Substring</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedSubstring"><span class="name">instInhabitedSubstring</span></a></div><div class="nav_link"><a class="break_within" href="#Substring.bsize"><span class="name">Substring</span>.<span class="name">bsize</span></a></div><div class="nav_link"><a class="break_within" href="#String.utf8ByteSize"><span class="name">String</span>.<span class="name">utf8ByteSize</span></a></div><div class="nav_link"><a class="break_within" href="#String.endPos"><span class="name">String</span>.<span class="name">endPos</span></a></div><div class="nav_link"><a class="break_within" href="#String.toSubstring"><span class="name">String</span>.<span class="name">toSubstring</span></a></div><div class="nav_link"><a class="break_within" href="#String.toSubstring'"><span class="name">String</span>.<span class="name">toSubstring'</span></a></div><div class="nav_link"><a class="break_within" href="#unsafeCast"><span class="name">unsafeCast</span></a></div><div class="nav_link"><a class="break_within" href="#panicCore"><span class="name">panicCore</span></a></div><div class="nav_link"><a class="break_within" href="#panic"><span class="name">panic</span></a></div><div class="nav_link"><a class="break_within" href="#Bind"><span class="name">Bind</span></a></div><div class="nav_link"><a class="break_within" href="#Pure"><span class="name">Pure</span></a></div><div class="nav_link"><a class="break_within" href="#Functor"><span class="name">Functor</span></a></div><div class="nav_link"><a class="break_within" href="#Seq"><span class="name">Seq</span></a></div><div class="nav_link"><a class="break_within" href="#SeqLeft"><span class="name">SeqLeft</span></a></div><div class="nav_link"><a class="break_within" href="#SeqRight"><span class="name">SeqRight</span></a></div><div class="nav_link"><a class="break_within" href="#Applicative"><span class="name">Applicative</span></a></div><div class="nav_link"><a class="break_within" href="#Monad"><span class="name">Monad</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedForallOfMonad"><span class="name">instInhabitedForallOfMonad</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedOfMonad"><span class="name">instInhabitedOfMonad</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyOfMonad"><span class="name">instNonemptyOfMonad</span></a></div><div class="nav_link"><a class="break_within" href="#MonadLift"><span class="name">MonadLift</span></a></div><div class="nav_link"><a class="break_within" href="#MonadLiftT"><span class="name">MonadLiftT</span></a></div><div class="nav_link"><a class="break_within" href="#liftM"><span class="name">liftM</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadLiftTOfMonadLift"><span class="name">instMonadLiftTOfMonadLift</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadLiftT"><span class="name">instMonadLiftT</span></a></div><div class="nav_link"><a class="break_within" href="#MonadEval"><span class="name">MonadEval</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadEvalOfMonadLift"><span class="name">instMonadEvalOfMonadLift</span></a></div><div class="nav_link"><a class="break_within" href="#MonadEvalT"><span class="name">MonadEvalT</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadEvalTOfMonadEval"><span class="name">instMonadEvalTOfMonadEval</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadEvalT"><span class="name">instMonadEvalT</span></a></div><div class="nav_link"><a class="break_within" href="#MonadFunctor"><span class="name">MonadFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#MonadFunctorT"><span class="name">MonadFunctorT</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadFunctorTOfMonadFunctor"><span class="name">instMonadFunctorTOfMonadFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#monadFunctorRefl"><span class="name">monadFunctorRefl</span></a></div><div class="nav_link"><a class="break_within" href="#Except"><span class="name">Except</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedExcept"><span class="name">instInhabitedExcept</span></a></div><div class="nav_link"><a class="break_within" href="#MonadExceptOf"><span class="name">MonadExceptOf</span></a></div><div class="nav_link"><a class="break_within" href="#throwThe"><span class="name">throwThe</span></a></div><div class="nav_link"><a class="break_within" href="#tryCatchThe"><span class="name">tryCatchThe</span></a></div><div class="nav_link"><a class="break_within" href="#MonadExcept"><span class="name">MonadExcept</span></a></div><div class="nav_link"><a class="break_within" href="#MonadExcept.ofExcept"><span class="name">MonadExcept</span>.<span class="name">ofExcept</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadExceptOfMonadExceptOf"><span class="name">instMonadExceptOfMonadExceptOf</span></a></div><div class="nav_link"><a class="break_within" href="#MonadExcept.orElse"><span class="name">MonadExcept</span>.<span class="name">orElse</span></a></div><div class="nav_link"><a class="break_within" href="#MonadExcept.instOrElse"><span class="name">MonadExcept</span>.<span class="name">instOrElse</span></a></div><div class="nav_link"><a class="break_within" href="#ReaderT"><span class="name">ReaderT</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedReaderT"><span class="name">instInhabitedReaderT</span></a></div><div class="nav_link"><a class="break_within" href="#ReaderT.run"><span class="name">ReaderT</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#ReaderT.instMonadLift"><span class="name">ReaderT</span>.<span class="name">instMonadLift</span></a></div><div class="nav_link"><a class="break_within" href="#ReaderT.instMonadExceptOf"><span class="name">ReaderT</span>.<span class="name">instMonadExceptOf</span></a></div><div class="nav_link"><a class="break_within" href="#ReaderT.read"><span class="name">ReaderT</span>.<span class="name">read</span></a></div><div class="nav_link"><a class="break_within" href="#ReaderT.pure"><span class="name">ReaderT</span>.<span class="name">pure</span></a></div><div class="nav_link"><a class="break_within" href="#ReaderT.bind"><span class="name">ReaderT</span>.<span class="name">bind</span></a></div><div class="nav_link"><a class="break_within" href="#ReaderT.instFunctorOfMonad"><span class="name">ReaderT</span>.<span class="name">instFunctorOfMonad</span></a></div><div class="nav_link"><a class="break_within" href="#ReaderT.instApplicativeOfMonad"><span class="name">ReaderT</span>.<span class="name">instApplicativeOfMonad</span></a></div><div class="nav_link"><a class="break_within" href="#ReaderT.instMonad"><span class="name">ReaderT</span>.<span class="name">instMonad</span></a></div><div class="nav_link"><a class="break_within" href="#ReaderT.instMonadFunctor"><span class="name">ReaderT</span>.<span class="name">instMonadFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#ReaderT.adapt"><span class="name">ReaderT</span>.<span class="name">adapt</span></a></div><div class="nav_link"><a class="break_within" href="#MonadReaderOf"><span class="name">MonadReaderOf</span></a></div><div class="nav_link"><a class="break_within" href="#MonadReader"><span class="name">MonadReader</span></a></div><div class="nav_link"><a class="break_within" href="#readThe"><span class="name">readThe</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadReaderOfMonadReaderOf"><span class="name">instMonadReaderOfMonadReaderOf</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadReaderOfOfMonadLift"><span class="name">instMonadReaderOfOfMonadLift</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadReaderOfReaderTOfMonad"><span class="name">instMonadReaderOfReaderTOfMonad</span></a></div><div class="nav_link"><a class="break_within" href="#MonadWithReaderOf"><span class="name">MonadWithReaderOf</span></a></div><div class="nav_link"><a class="break_within" href="#withTheReader"><span class="name">withTheReader</span></a></div><div class="nav_link"><a class="break_within" href="#MonadWithReader"><span class="name">MonadWithReader</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadWithReaderOfMonadWithReaderOf"><span class="name">instMonadWithReaderOfMonadWithReaderOf</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadWithReaderOfOfMonadFunctor"><span class="name">instMonadWithReaderOfOfMonadFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadWithReaderOfReaderT"><span class="name">instMonadWithReaderOfReaderT</span></a></div><div class="nav_link"><a class="break_within" href="#MonadStateOf"><span class="name">MonadStateOf</span></a></div><div class="nav_link"><a class="break_within" href="#getThe"><span class="name">getThe</span></a></div><div class="nav_link"><a class="break_within" href="#modifyThe"><span class="name">modifyThe</span></a></div><div class="nav_link"><a class="break_within" href="#modifyGetThe"><span class="name">modifyGetThe</span></a></div><div class="nav_link"><a class="break_within" href="#MonadState"><span class="name">MonadState</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadStateOfMonadStateOf"><span class="name">instMonadStateOfMonadStateOf</span></a></div><div class="nav_link"><a class="break_within" href="#modify"><span class="name">modify</span></a></div><div class="nav_link"><a class="break_within" href="#getModify"><span class="name">getModify</span></a></div><div class="nav_link"><a class="break_within" href="#instMonadStateOfOfMonadLift"><span class="name">instMonadStateOfOfMonadLift</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.Result"><span class="name">EStateM</span>.<span class="name">Result</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.instInhabitedResult"><span class="name">EStateM</span>.<span class="name">instInhabitedResult</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM"><span class="name">EStateM</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.instInhabited"><span class="name">EStateM</span>.<span class="name">instInhabited</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.pure"><span class="name">EStateM</span>.<span class="name">pure</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.set"><span class="name">EStateM</span>.<span class="name">set</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.get"><span class="name">EStateM</span>.<span class="name">get</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.modifyGet"><span class="name">EStateM</span>.<span class="name">modifyGet</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.throw"><span class="name">EStateM</span>.<span class="name">throw</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.Backtrackable"><span class="name">EStateM</span>.<span class="name">Backtrackable</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.tryCatch"><span class="name">EStateM</span>.<span class="name">tryCatch</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.orElse"><span class="name">EStateM</span>.<span class="name">orElse</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.adaptExcept"><span class="name">EStateM</span>.<span class="name">adaptExcept</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.bind"><span class="name">EStateM</span>.<span class="name">bind</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.map"><span class="name">EStateM</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.seqRight"><span class="name">EStateM</span>.<span class="name">seqRight</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.instMonad"><span class="name">EStateM</span>.<span class="name">instMonad</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.instOrElseOfBacktrackable"><span class="name">EStateM</span>.<span class="name">instOrElseOfBacktrackable</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.instMonadStateOf"><span class="name">EStateM</span>.<span class="name">instMonadStateOf</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.instMonadExceptOfOfBacktrackable"><span class="name">EStateM</span>.<span class="name">instMonadExceptOfOfBacktrackable</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.run"><span class="name">EStateM</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.run'"><span class="name">EStateM</span>.<span class="name">run'</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.dummySave"><span class="name">EStateM</span>.<span class="name">dummySave</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.dummyRestore"><span class="name">EStateM</span>.<span class="name">dummyRestore</span></a></div><div class="nav_link"><a class="break_within" href="#EStateM.nonBacktrackable"><span class="name">EStateM</span>.<span class="name">nonBacktrackable</span></a></div><div class="nav_link"><a class="break_within" href="#Hashable"><span class="name">Hashable</span></a></div><div class="nav_link"><a class="break_within" href="#mixHash"><span class="name">mixHash</span></a></div><div class="nav_link"><a class="break_within" href="#instHashableSubtype"><span class="name">instHashableSubtype</span></a></div><div class="nav_link"><a class="break_within" href="#String.hash"><span class="name">String</span>.<span class="name">hash</span></a></div><div class="nav_link"><a class="break_within" href="#instHashableString"><span class="name">instHashableString</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.hash"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">hash</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name"><span class="name">Lean</span>.<span class="name">Name</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instInhabitedName"><span class="name">Lean</span>.<span class="name">instInhabitedName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instHashableName"><span class="name">Lean</span>.<span class="name">instHashableName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkNum"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkNum</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkSimple"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkSimple</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr1"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr1</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr2"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr2</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr3"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr3</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr4"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr4</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr5"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr5</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr6"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr6</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr7"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr7</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr8"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr8</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.beq"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">beq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.instBEq"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">instBEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.appendCore"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">appendCore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.defaultMaxRecDepth"><span class="name">Lean</span>.<span class="name">defaultMaxRecDepth</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.maxRecDepthErrorMessage"><span class="name">Lean</span>.<span class="name">maxRecDepthErrorMessage</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.SourceInfo"><span class="name">Lean</span>.<span class="name">SourceInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instInhabitedSourceInfo"><span class="name">Lean</span>.<span class="name">instInhabitedSourceInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.SourceInfo.getPos?"><span class="name">Lean</span>.<span class="name">SourceInfo</span>.<span class="name">getPos?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.SourceInfo.getTailPos?"><span class="name">Lean</span>.<span class="name">SourceInfo</span>.<span class="name">getTailPos?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.SourceInfo.getTrailing?"><span class="name">Lean</span>.<span class="name">SourceInfo</span>.<span class="name">getTrailing?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.SourceInfo.getTrailingTailPos?"><span class="name">Lean</span>.<span class="name">SourceInfo</span>.<span class="name">getTrailingTailPos?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.SyntaxNodeKind"><span class="name">Lean</span>.<span class="name">SyntaxNodeKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.Preresolved"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">Preresolved</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax"><span class="name">Lean</span>.<span class="name">Syntax</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.node1"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node1</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.node2"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node2</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.node3"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node3</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.node4"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node4</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.node5"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node5</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.node6"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node6</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.node7"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node7</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.node8"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node8</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.SyntaxNodeKinds"><span class="name">Lean</span>.<span class="name">SyntaxNodeKinds</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.TSyntax"><span class="name">Lean</span>.<span class="name">TSyntax</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instInhabitedSyntax"><span class="name">Lean</span>.<span class="name">instInhabitedSyntax</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instInhabitedTSyntax"><span class="name">Lean</span>.<span class="name">instInhabitedTSyntax</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.choiceKind"><span class="name">Lean</span>.<span class="name">choiceKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.nullKind"><span class="name">Lean</span>.<span class="name">nullKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.groupKind"><span class="name">Lean</span>.<span class="name">groupKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.identKind"><span class="name">Lean</span>.<span class="name">identKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.strLitKind"><span class="name">Lean</span>.<span class="name">strLitKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.charLitKind"><span class="name">Lean</span>.<span class="name">charLitKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.numLitKind"><span class="name">Lean</span>.<span class="name">numLitKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.hexnumKind"><span class="name">Lean</span>.<span class="name">hexnumKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.scientificLitKind"><span class="name">Lean</span>.<span class="name">scientificLitKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.nameLitKind"><span class="name">Lean</span>.<span class="name">nameLitKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.fieldIdxKind"><span class="name">Lean</span>.<span class="name">fieldIdxKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.hygieneInfoKind"><span class="name">Lean</span>.<span class="name">hygieneInfoKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.interpolatedStrLitKind"><span class="name">Lean</span>.<span class="name">interpolatedStrLitKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.interpolatedStrKind"><span class="name">Lean</span>.<span class="name">interpolatedStrKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.mkNode"><span class="name">Lean</span>.<span class="name">mkNode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.mkNullNode"><span class="name">Lean</span>.<span class="name">mkNullNode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getKind"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.setKind"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">setKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.isOfKind"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">isOfKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getArg"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getArgs"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getNumArgs"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getNumArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getOptional?"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getOptional?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.isMissing"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">isMissing</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.isNodeOf"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">isNodeOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.isIdent"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">isIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getId"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getId</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getInfo?"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getInfo?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getHeadInfo?"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getHeadInfo?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getHeadInfo"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getHeadInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getPos?"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getPos?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getTailPos?"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getTailPos?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.SepArray"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">SepArray</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.TSepArray"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">TSepArray</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.TSyntaxArray"><span class="name">Lean</span>.<span class="name">TSyntaxArray</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.TSyntaxArray.rawImpl"><span class="name">Lean</span>.<span class="name">TSyntaxArray</span>.<span class="name">rawImpl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.TSyntaxArray.raw"><span class="name">Lean</span>.<span class="name">TSyntaxArray</span>.<span class="name">raw</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.TSyntaxArray.mkImpl"><span class="name">Lean</span>.<span class="name">TSyntaxArray</span>.<span class="name">mkImpl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.TSyntaxArray.mk"><span class="name">Lean</span>.<span class="name">TSyntaxArray</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.SourceInfo.fromRef"><span class="name">Lean</span>.<span class="name">SourceInfo</span>.<span class="name">fromRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.mkAtom"><span class="name">Lean</span>.<span class="name">mkAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.mkAtomFrom"><span class="name">Lean</span>.<span class="name">mkAtomFrom</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.ParserDescr"><span class="name">Lean</span>.<span class="name">ParserDescr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instInhabitedParserDescr"><span class="name">Lean</span>.<span class="name">instInhabitedParserDescr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.TrailingParserDescr"><span class="name">Lean</span>.<span class="name">TrailingParserDescr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MacroScope"><span class="name">Lean</span>.<span class="name">MacroScope</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.reservedMacroScope"><span class="name">Lean</span>.<span class="name">reservedMacroScope</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.firstFrontendMacroScope"><span class="name">Lean</span>.<span class="name">firstFrontendMacroScope</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MonadRef"><span class="name">Lean</span>.<span class="name">MonadRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instMonadRefOfMonadLiftOfMonadFunctor"><span class="name">Lean</span>.<span class="name">instMonadRefOfMonadLiftOfMonadFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.replaceRef"><span class="name">Lean</span>.<span class="name">replaceRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.withRef"><span class="name">Lean</span>.<span class="name">withRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.withRef?"><span class="name">Lean</span>.<span class="name">withRef?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MonadQuotation"><span class="name">Lean</span>.<span class="name">MonadQuotation</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MonadQuotation.getMainModule"><span class="name">Lean</span>.<span class="name">MonadQuotation</span>.<span class="name">getMainModule</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MonadRef.mkInfoFromRefPos"><span class="name">Lean</span>.<span class="name">MonadRef</span>.<span class="name">mkInfoFromRefPos</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instMonadQuotationOfMonadFunctorOfMonadLift"><span class="name">Lean</span>.<span class="name">instMonadQuotationOfMonadFunctorOfMonadLift</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.hasMacroScopes"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">hasMacroScopes</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.eraseMacroScopes"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">eraseMacroScopes</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.simpMacroScopes"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">simpMacroScopes</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MacroScopesView"><span class="name">Lean</span>.<span class="name">MacroScopesView</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instInhabitedMacroScopesView"><span class="name">Lean</span>.<span class="name">instInhabitedMacroScopesView</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MacroScopesView.review"><span class="name">Lean</span>.<span class="name">MacroScopesView</span>.<span class="name">review</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.extractMacroScopes"><span class="name">Lean</span>.<span class="name">extractMacroScopes</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.addMacroScope"><span class="name">Lean</span>.<span class="name">addMacroScope</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.append"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">append</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instAppendName"><span class="name">Lean</span>.<span class="name">instAppendName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MonadQuotation.addMacroScope"><span class="name">Lean</span>.<span class="name">MonadQuotation</span>.<span class="name">addMacroScope</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.matchesNull"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">matchesNull</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.matchesIdent"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">matchesIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.matchesLit"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">matchesLit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.MethodsRefPointed"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">MethodsRefPointed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.MethodsRef"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">MethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instNonemptyMethodsRef"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instNonemptyMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.Context"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.Exception"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">Exception</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.State"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instInhabitedState"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MacroM"><span class="name">Lean</span>.<span class="name">MacroM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro"><span class="name">Lean</span>.<span class="name">Macro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instMonadRefMacroM"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instMonadRefMacroM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.throwUnsupported"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">throwUnsupported</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.throwError"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">throwError</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.throwErrorAt"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">throwErrorAt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.withFreshMacroScope"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">withFreshMacroScope</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.withIncRecDepth"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">withIncRecDepth</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instMonadQuotationMacroM"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instMonadQuotationMacroM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.addMacroScope"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">addMacroScope</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.Methods"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">Methods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instInhabitedMethods.default"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instInhabitedMethods</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instInhabitedMethods"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instInhabitedMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.mkMethodsImp"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">mkMethodsImp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.mkMethods"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">mkMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instInhabitedMethodsRef"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instInhabitedMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.getMethodsImp"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">getMethodsImp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.getMethods"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">getMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.expandMacro?"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">expandMacro?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.hasDecl"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">hasDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.getCurrNamespace"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">getCurrNamespace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.resolveNamespace"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">resolveNamespace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.resolveGlobalName"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">resolveGlobalName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.trace"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">trace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.PrettyPrinter.UnexpandM"><span class="name">Lean</span>.<span class="name">PrettyPrinter</span>.<span class="name">UnexpandM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.PrettyPrinter.Unexpander"><span class="name">Lean</span>.<span class="name">PrettyPrinter</span>.<span class="name">Unexpander</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.PrettyPrinter.instMonadQuotationUnexpandM"><span class="name">Lean</span>.<span class="name">PrettyPrinter</span>.<span class="name">instMonadQuotationUnexpandM</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Init-Prelude">Init.Prelude <a class="hover-link" href="#Init-Prelude">#</a></h1><p>This is the first file in the Lean import hierarchy. It is responsible for setting
up basic definitions, most of which Lean already has &quot;built in knowledge&quot; about,
so it is important that they be set up in exactly this way. (For example, Lean will
use <code><a href=".././Init/Prelude.html#PUnit">PUnit</a></code> in the desugaring of <code>do</code> notation, or in the pattern match compiler.)</p></div><div class="decl" id="id"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L26-L38">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#id"><span class="name">id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>The identity function. <code><a href=".././Init/Prelude.html#id">id</a></code> takes an implicit argument <code>α : Sort u</code>
(a type in any universe), and an argument <code>a : α</code>, and returns <code>a</code>.</p><p>Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If <code>e</code> has type <code>T</code>,
and <code>T'</code> is definitionally equal to <code>T</code>, then <code>@id T' e</code> typechecks, and Lean
knows that this expression has type <code>T'</code> rather than <code>T</code>. This can make a
difference for typeclass inference, since <code>T</code> and <code>T'</code> may have different
typeclass instances on them. <code>show T' from e</code> is sugar for an <code>@id T' e</code>
expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#id">id</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></li></ul></details><details id="instances-for-list-id" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.comp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L40-L49">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Function.comp"><span class="name">Function</span>.<span class="name">comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href=".././foundational_types.html">Sort</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">δ</span></span></div></div><p>Function composition, usually written with the infix operator <code>∘</code>. A new function is created from
two existing functions, where one function's output is used as input to the other.</p><p>Examples:</p><ul>
<li><code><a href=".././Init/Prelude.html#Function.comp">Function.comp</a> <a href=".././Init/Data/List/Basic.html#List.reverse">List.reverse</a> (List.drop 2) [3, 2, 4, 1] = [1, 4]</code></li>
<li><code>(List.reverse ∘ <a href=".././Init/Data/List/Basic.html#List.drop">List.drop</a> 2) [3, 2, 4, 1] = [1, 4]</code></li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∘</code> in identifiers is <code><a href=".././Init/Prelude.html#Function.comp">comp</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn">f</span> <a href=".././Init/Prelude.html#Function.comp">∘</a> <span class="fn">g</span>) <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">g</span> <span class="fn">x</span>)</span></span></li></ul></details><details id="instances-for-list-Function.comp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.const"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L51-L63">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Function.const"><span class="name">Function</span>.<span class="name">const</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></div></div><p>The constant function that ignores its argument.</p><p>If <code>a : α</code>, then <code><a href=".././Init/Prelude.html#Function.const">Function.const</a> β a : β → α</code> is the “constant function with value <code>a</code>”. For all
arguments <code>b : β</code>, <code><a href=".././Init/Prelude.html#Function.const">Function.const</a> β a b = a</code>.</p><p>Examples:</p><ul>
<li><code><a href=".././Init/Prelude.html#Function.const">Function.const</a> <a href=".././Init/Prelude.html#Bool">Bool</a> 10 <a href=".././Init/Prelude.html#Bool.true">true</a> = 10</code></li>
<li><code><a href=".././Init/Prelude.html#Function.const">Function.const</a> <a href=".././Init/Prelude.html#Bool">Bool</a> 10 <a href=".././Init/Prelude.html#Bool.false">false</a> = 10</code></li>
<li><code><a href=".././Init/Prelude.html#Function.const">Function.const</a> <a href=".././Init/Prelude.html#String">String</a> 10 &quot;any string&quot; = 10</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Function.const">Function.const</a> <span class="fn">β</span> <span class="fn">a</span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></li></ul></details><details id="instances-for-list-Function.const" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="letFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L65-L73">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#letFun"><span class="name">letFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">v</span></span></div></div><p><code><a href=".././Init/Prelude.html#letFun">letFun</a> v (fun x =&gt; b)</code> is a function version of <code>have x := v; b</code>.
This is equal to <code>(fun x =&gt; b) v</code>, so the value of <code>x</code> is not accessible to <code>b</code>.
This is in contrast to <code>let x := v; b</code>, where the value of <code>x</code> is accessible to <code>b</code>.</p><p>This used to be the way <code>have</code>/<code>let_fun</code> syntax was encoded,
and there used to be special support for <code><a href=".././Init/Prelude.html#letFun">letFun</a></code> in WHNF and <code>simp</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#letFun">letFun</a> <span class="fn">v</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">v</span></span></li></ul></details><details id="instances-for-list-letFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="inferInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L76-L92">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#inferInstance"><span class="name">inferInstance</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">i</span> : <span class="fn">α</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code><a href=".././Init/Prelude.html#inferInstance">inferInstance</a></code> synthesizes a value of any target type by typeclass
inference. This function has the same type signature as the identity
function, but the square brackets on the <code>[i : α]</code> argument means that it will
attempt to construct this argument by typeclass inference. (This will fail if
<code>α</code> is not a <code>class</code>.) Example:</p><pre><code>#check (inferInstance : <a href=".././Init/Prelude.html#Inhabited">Inhabited</a> Nat) -- <a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Nat">Nat</a>

def foo : <a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (Nat × Nat) :=
  <a href=".././Init/Prelude.html#inferInstance">inferInstance</a>

example : foo.<a href=".././Init/Prelude.html#Inhabited.default">default</a> = (default, default) :=
  <a href=".././Init/Prelude.html#rfl">rfl</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#inferInstance">inferInstance</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">i</span></li></ul></details><details id="instances-for-list-inferInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="inferInstanceAs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L95-L106">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#inferInstanceAs"><span class="name">inferInstanceAs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">i</span> : <span class="fn">α</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> α</code> synthesizes a value of any target type by typeclass
inference. This is just like <code><a href=".././Init/Prelude.html#inferInstance">inferInstance</a></code> except that <code>α</code> is given
explicitly instead of being inferred from the target type. It is especially
useful when the target type is some <code>α'</code> which is definitionally equal to <code>α</code>,
but the instance we are looking for is only registered for <code>α</code> (because
typeclass search does not unfold most definitions, but definitional equality
does.) Example:</p><pre><code>#check <a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> (Inhabited Nat) -- <a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Nat">Nat</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">i</span></li></ul></details><details id="instances-for-list-inferInstanceAs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PUnit"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L109-L117">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PUnit"><span class="name">PUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> u</div></div><p>The canonical universe-polymorphic type with just one element.</p><p>It should be used in contexts that require a type to be universe polymorphic, thus disallowing
<code><a href=".././Init/Prelude.html#Unit">Unit</a></code>.</p><ul class="constructors"><li class="constructor" id="PUnit.unit">unit : <a href=".././Init/Prelude.html#PUnit">PUnit</a><div class="inductive_ctor_doc"><p>The only element of the universe-polymorphic unit type.</p></div></li></ul><details id="instances-for-list-PUnit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Unit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L119-L129">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Unit"><span class="name">Unit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>The canonical type with one element. This element is written <code>()</code>.</p><p><code><a href=".././Init/Prelude.html#Unit">Unit</a></code> has a number of uses:</p><ul>
<li>It can be used to model control flow that returns from a function call without providing other
information.</li>
<li>Monadic actions that return <code><a href=".././Init/Prelude.html#Unit">Unit</a></code> have side effects without computing values.</li>
<li>In polymorphic types, it can be used to indicate that no data is to be stored in a particular
field.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Unit">Unit</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></li></ul></details><details id="instances-for-list-Unit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Unit.unit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L131-L136">source</a></div><div class="attributes">@[reducible, match_pattern, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Unit.unit"><span class="name">Unit</span>.<span class="name">unit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Unit">Unit</a></div></div><p>The only element of the unit type.</p><p>It can be written as an empty tuple: <code>()</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Unit.unit">(</a><a href=".././Init/Prelude.html#Unit.unit">)</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a></li></ul></details><details id="instances-for-list-Unit.unit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="lcErased"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L138-L139">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#lcErased"><span class="name">lcErased</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Marker for information that has been erased by the code generator.</p></div></div><div class="decl" id="lcAny"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L141-L142">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#lcAny"><span class="name">lcAny</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Marker for type dependency that has been erased by the code generator.</p></div></div><div class="decl" id="lcRealWorld"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L144-L145">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#lcRealWorld"><span class="name">lcRealWorld</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Internal representation of <code><a href=".././Init/System/IO.html#IO.RealWorld">IO.RealWorld</a></code> in the compiler.</p></div></div><div class="decl" id="lcProof"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L147-L156">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#lcProof"><span class="name">lcProof</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Auxiliary unsafe constant used by the Compiler when erasing proofs from code.</p><p>It may look strange to have an axiom that says &quot;every proposition is true&quot;,
since this is obviously unsound, but the <code>unsafe</code> marker ensures that the
kernel will not let this through into regular proofs. The lower levels of the
code generator don't need proofs in terms, so this is used to stub the proofs
out.</p></div></div><div class="decl" id="lcCast"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L158-L161">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#lcCast"><span class="name">lcCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Auxiliary unsafe constant used by the Compiler when erasing casts.</p></div></div><div class="decl" id="lcUnreachable"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L164-L176">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#lcUnreachable"><span class="name">lcUnreachable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Auxiliary unsafe constant used by the Compiler to mark unreachable code.</p><p>Like <code><a href=".././Init/Prelude.html#lcProof">lcProof</a></code>, this is an <code>unsafe axiom</code>, which means that even though it is
not sound, the kernel will not let us use it for regular proofs.</p><p>Executing this expression to actually synthesize a value of type <code>α</code> causes
<strong>immediate undefined behavior</strong>, and the compiler does take advantage of this
to optimize the code assuming that it is not called. If it is not optimized out,
it is likely to appear as a print message saying &quot;unreachable code&quot;, but this
behavior is not guaranteed or stable in any way.</p></div></div><div class="decl" id="True"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L178-L186">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#True"><span class="name">True</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Prelude.html#True">True</a></code> is a proposition and has only an introduction rule, <code><a href=".././Init/Prelude.html#True.intro">True.intro</a> : <a href=".././Init/Prelude.html#True">True</a></code>.
In other words, <code><a href=".././Init/Prelude.html#True">True</a></code> is simply true, and has a canonical proof, <code><a href=".././Init/Prelude.html#True.intro">True.intro</a></code>
For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic">Propositional Logic</a></p><ul class="constructors"><li class="constructor" id="True.intro">intro : <a href=".././Init/Prelude.html#True">True</a><div class="inductive_ctor_doc"><p><code><a href=".././Init/Prelude.html#True">True</a></code> is true, and <code><a href=".././Init/Prelude.html#True.intro">True.intro</a></code> (or more commonly, <code><a href=".././Init/Core.html#trivial">trivial</a></code>)
is the proof.</p></div></li></ul><details id="instances-for-list-True" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="False"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L188-L196">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#False"><span class="name">False</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Prelude.html#False">False</a></code> is the empty proposition. Thus, it has no introduction rules.
It represents a contradiction. <code><a href=".././Init/Prelude.html#False">False</a></code> elimination rule, <code><a href=".././Init/Prelude.html#False.rec">False.rec</a></code>,
expresses the fact that anything follows from a contradiction.
This rule is sometimes called ex falso (short for ex falso sequitur quodlibet),
or the principle of explosion.
For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic">Propositional Logic</a></p><ul class="constructors"></ul><details id="instances-for-list-False" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Empty"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L198-L203">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Empty"><span class="name">Empty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>The empty type. It has no constructors.</p><p>Use <code><a href=".././Init/Core.html#Empty.elim">Empty.elim</a></code> in contexts where a value of type <code><a href=".././Init/Prelude.html#Empty">Empty</a></code> is in scope.</p><ul class="constructors"></ul><details id="instances-for-list-Empty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PEmpty"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L206-L213">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PEmpty"><span class="name">PEmpty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> u</div></div><p>The universe-polymorphic empty type, with no constructors.</p><p><code><a href=".././Init/Prelude.html#PEmpty">PEmpty</a></code> can be used in any universe, but this flexibility can lead to worse error messages and more
challenges with universe level unification. Prefer the type <code><a href=".././Init/Prelude.html#Empty">Empty</a></code> or the proposition <code><a href=".././Init/Prelude.html#False">False</a></code> when
possible.</p><ul class="constructors"></ul><details id="instances-for-list-PEmpty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Not"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L215-L222">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Not"><span class="name">Not</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Prelude.html#Not">Not</a> p</code>, or <code>¬p</code>, is the negation of <code>p</code>. It is defined to be <code>p → <a href=".././Init/Prelude.html#False">False</a></code>,
so if your goal is <code>¬p</code> you can use <code><a href=".././Init/Prelude.html#True.intro">intro</a> h</code> to turn the goal into
<code>h : p ⊢ <a href=".././Init/Prelude.html#False">False</a></code>, and if you have <code>hn : ¬p</code> and <code>h : p</code> then <code>hn h : <a href=".././Init/Prelude.html#False">False</a></code>
and <code>(hn h).<a href=".././Init/Prelude.html#False.elim">elim</a></code> will prove anything.
For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic">Propositional Logic</a></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>¬</code> in identifiers is <code><a href=".././Init/Prelude.html#Bool.not">not</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">(<a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span>) <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">a</span> → <a href=".././Init/Prelude.html#False">False</a>)</span></li></ul></details><details id="instances-for-list-Not" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="False.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L224-L235">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#False.elim"><span class="name">False</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href=".././Init/Prelude.html#False">False</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href=".././Init/Prelude.html#False.elim">False.elim</a> : <a href=".././Init/Prelude.html#False">False</a> → C</code> says that from <code><a href=".././Init/Prelude.html#False">False</a></code>, any desired proposition
<code>C</code> holds. Also known as ex falso quodlibet (EFQ) or the principle of explosion.</p><p>The target type is actually <code>C : Sort u</code> which means it works for both
propositions and types. When executed, this acts like an &quot;unreachable&quot;
instruction: it is <strong>undefined behavior</strong> to run, but it will probably print
&quot;unreachable code&quot;. (You would need to construct a proof of false to run it
anyway, which you can only do using <code>sorry</code> or unsound axioms.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">h</span>.<a href=".././Init/Prelude.html#False.elim">elim</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#False.rec">False.rec</a> <span class="fn">(fun (<span class="fn">x</span> : <a href=".././Init/Prelude.html#False">False</a>) =&gt; <span class="fn">C</span>)</span> <span class="fn">h</span></span></li></ul></details><details id="instances-for-list-False.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="absurd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L237-L245">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#absurd"><span class="name">absurd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span></div></div><p>Anything follows from two contradictory hypotheses. Example:</p><pre><code>example (hp : p) (hnp : ¬p) : q := <a href=".././Init/Prelude.html#absurd">absurd</a> hp hnp
</code></pre><p>For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic">Propositional Logic</a></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#absurd">absurd</a> <span class="fn">h₁</span> <span class="fn">h₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#False.rec">False.rec</a> <span class="fn">(fun (<span class="fn">x</span> : <a href=".././Init/Prelude.html#False">False</a>) =&gt; <span class="fn">b</span>)</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-absurd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Eq"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L247-L277">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Eq"><span class="name">Eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div></div><p>The equality relation. It has one introduction rule, <code><a href=".././Init/Prelude.html#Eq.refl">Eq.refl</a></code>.
We use <code>a = b</code> as notation for <code><a href=".././Init/Prelude.html#Eq">Eq</a> a b</code>.
A fundamental property of equality is that it is an equivalence relation.</p><pre><code>variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  <a href=".././Init/Prelude.html#Eq.trans">Eq.trans</a> (Eq.<a href=".././Init/Prelude.html#Eq.trans">trans</a> hab (Eq.<a href=".././Init/Prelude.html#Eq.symm">symm</a> hcb)) hcd
</code></pre><p>Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given <code>h1 : a = b</code> and <code>h2 : p a</code>, we can construct a proof for <code>p b</code> using substitution: <code><a href=".././Init/Prelude.html#Eq.subst">Eq.subst</a> h1 h2</code>.
Example:</p><pre><code>example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  <a href=".././Init/Prelude.html#Eq.subst">Eq.subst</a> h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
</code></pre><p>The triangle in the second presentation is a macro built on top of <code><a href=".././Init/Prelude.html#Eq.subst">Eq.subst</a></code> and <code><a href=".././Init/Prelude.html#Eq.symm">Eq.symm</a></code>, and you can enter it by typing <code>\t</code>.
For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>=</code> in identifiers is <code>eq</code>.</li>
</ul><ul class="constructors"><li class="constructor" id="Eq.refl">refl<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Prelude.html#Eq.refl">Eq.refl</a> a : a = a</code> is reflexivity, the unique constructor of the
equality type. See also <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, which is usually used instead.</p></div></li></ul><details id="instances-for-list-Eq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="rfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L283-L292">source</a></div><div class="attributes">@[match_pattern]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#rfl"><span class="name">rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div><p><code><a href=".././Init/Prelude.html#rfl">rfl</a> : a = a</code> is the unique constructor of the equality type. This is the
same as <code><a href=".././Init/Prelude.html#Eq.refl">Eq.refl</a></code> except that it takes <code>a</code> implicitly instead of explicitly.</p><p>This is a more powerful theorem than it may appear at first, because although
the statement of the theorem is <code>a = a</code>, Lean will allow anything that is
definitionally equal to that type. So, for instance, <code>2 + 2 = 4</code> is proven in
Lean by <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, because both sides are the same up to definitional equality.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></li></ul></details><details id="instances-for-list-rfl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="id_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L294-L295">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#id_eq"><span class="name">id_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#id">id</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div><p><code><a href=".././Init/Prelude.html#id">id</a> x = x</code>, as a <code>@[simp]</code> lemma.</p></div></div><div class="decl" id="Eq.subst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L297-L311">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Eq.subst"><span class="name">Eq</span>.<span class="name">subst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">b</span></span></div></div><p>The substitution principle for equality. If <code>a = b </code> and <code>P a</code> holds,
then <code>P b</code> also holds. We conventionally use the name <code>motive</code> for <code>P</code> here,
so that you can specify it explicitly using e.g.
<code><a href=".././Init/Prelude.html#Eq.subst">Eq.subst</a> (motive := fun x =&gt; x &lt; 5)</code> if it is not otherwise inferred correctly.</p><p>This theorem is the underlying mechanism behind the <code>rw</code> tactic, which is
essentially a fancy algorithm for finding good <code>motive</code> arguments to usefully
apply this theorem to replace occurrences of <code>a</code> with <code>b</code> in the goal or
hypotheses.</p><p>For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p></div></div><div class="decl" id="Eq.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L313-L322">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Eq.symm"><span class="name">Eq</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div><p>Equality is symmetric: if <code>a = b</code> then <code>b = a</code>.</p><p>Because this is in the <code><a href=".././Init/Prelude.html#Eq">Eq</a></code> namespace, if you have a variable <code>h : a = b</code>,
<code>h.<a href=".././Init/Prelude.html#Eq.symm">symm</a></code> can be used as shorthand for <code><a href=".././Init/Prelude.html#Eq.symm">Eq.symm</a> h</code> as a proof of <code>b = a</code>.</p><p>For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p></div></div><div class="decl" id="Eq.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L324-L334">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Eq.trans"><span class="name">Eq</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div><p>Equality is transitive: if <code>a = b</code> and <code>b = c</code> then <code>a = c</code>.</p><p>Because this is in the <code><a href=".././Init/Prelude.html#Eq">Eq</a></code> namespace, if you have variables or expressions
<code>h₁ : a = b</code> and <code>h₂ : b = c</code>, you can use <code>h₁.<a href=".././Init/Prelude.html#Eq.trans">trans</a> h₂ : a = c</code> as shorthand
for <code><a href=".././Init/Prelude.html#Eq.trans">Eq.trans</a> h₁ h₂</code>.</p><p>For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p></div></div><div class="decl" id="cast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L336-L348">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#cast"><span class="name">cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Cast across a type equality. If <code>h : α = β</code> is an equality of types, and
<code>a : α</code>, then <code>a : β</code> will usually not typecheck directly, but this function
will allow you to work around this and embed <code>a</code> in type <code>β</code> as <code><a href=".././Init/Prelude.html#cast">cast</a> h a : β</code>.</p><p>It is best to avoid this function if you can, because it is more complicated
to reason about terms containing casts, but if the types don't match up
definitionally sometimes there isn't anything better you can do.</p><p>For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#cast">cast</a> <span class="fn">h</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">h</span> <a href=".././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">a</span></li></ul></details><details id="instances-for-list-cast" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="congrArg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L350-L361">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#congrArg"><span class="name">congrArg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">a₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a₂</span></span></div></div><p>Congruence in the function argument: if <code>a₁ = a₂</code> then <code>f a₁ = f a₂</code> for
any (nondependent) function <code>f</code>. This is more powerful than it might look at first, because
you can also use a lambda expression for <code>f</code> to prove that
<code>&lt;something containing a₁&gt; = &lt;something containing a₂&gt;</code>. This function is used
internally by tactics like <code><a href=".././Init/Prelude.html#congr">congr</a></code> and <code>simp</code> to apply equalities inside
subterms.</p><p>For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p></div></div><div class="decl" id="congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L363-L371">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#congr"><span class="name">congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f₁ </span><span class="fn">f₂</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">f₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">f₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">a₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f₁</span> <span class="fn">a₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f₂</span> <span class="fn">a₂</span></span></div></div><p>Congruence in both function and argument. If <code>f₁ = f₂</code> and <code>a₁ = a₂</code> then
<code>f₁ a₁ = f₂ a₂</code>. This only works for nondependent functions; the theorem
statement is more complex in the dependent case.</p><p>For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p></div></div><div class="decl" id="congrFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L373-L375">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#congrFun"><span class="name">congrFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">f</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">g</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">a</span></span></div></div><p>Congruence in the function part of an application: If <code>f = g</code> then <code>f a = g a</code>.</p></div></div><div class="mod_doc"><p>Initialize the Quotient Module, which effectively adds the following definitions:</p><pre><code>opaque <a href=".././Init/Prelude.html#Quot">Quot</a> {α : Sort u} (r : α → α → Prop) : Sort u

opaque <a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> {α : Sort u} (r : α → α → Prop) (a : α) : <a href=".././Init/Prelude.html#Quot">Quot</a> r

opaque <a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β) :
  (∀ a b : α, r a b → <a href=".././Init/Prelude.html#Eq">Eq</a> (f a) (f b)) → <a href=".././Init/Prelude.html#Quot">Quot</a> r → β

opaque <a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a> {α : Sort u} {r : α → α → Prop} {β : <a href=".././Init/Prelude.html#Quot">Quot</a> r → Prop} :
  (∀ a : α, β (Quot.<a href=".././Init/Prelude.html#Quot.mk">mk</a> r a)) → ∀ q : <a href=".././Init/Prelude.html#Quot">Quot</a> r, β q
</code></pre></div><div class="decl" id="Quot"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L393-L413">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Quot"><span class="name">Quot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> u</div></div><p>Low-level quotient types. Quotient types coarsen the propositional equality for a type <code>α</code>, so that
terms related by some relation <code>r</code> are considered equal in <code><a href=".././Init/Prelude.html#Quot">Quot</a> r</code>.</p><p>Set-theoretically, <code><a href=".././Init/Prelude.html#Quot">Quot</a> r</code> can seen as the set of equivalence classes of <code>α</code> modulo <code>r</code>. Functions
from <code><a href=".././Init/Prelude.html#Quot">Quot</a> r</code> must prove that they respect <code>r</code>: to define a function <code>f : <a href=".././Init/Prelude.html#Quot">Quot</a> r → β</code>, it is
necessary to provide <code>f' : α → β</code> and prove that for all <code>x : α</code> and <code>y : α</code>, <code>r x y → f' x = f' y</code>.</p><p><code><a href=".././Init/Prelude.html#Quot">Quot</a></code> is a built-in primitive:</p><ul>
<li><code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a></code> places elements of the underlying type <code>α</code> into the quotient.</li>
<li><code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code> allows the definition of functions from the quotient to some other type.</li>
<li><code><a href=".././Init/Core.html#Quot.sound">Quot.sound</a></code> asserts the equality of elements related by <code>r</code>.</li>
<li><code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code> is used to write proofs about quotients by assuming that all elements are constructed
with <code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a></code>.</li>
</ul><p>The relation <code>r</code> is not required to be an equivalence relation; the resulting quotient type's
equality extends <code>r</code> to an equivalence as a consequence of the rules for equality and quotients.
When <code>r</code> is an equivalence relation, it can be more convenient to use the higher-level type
<code><a href=".././Init/Core.html#Quotient">Quotient</a></code>.</p></div></div><div class="decl" id="Quot.mk"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L415-L428">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Quot.mk"><span class="name">Quot</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span></div></div><p>Places an element of a type into the quotient that equates terms according to the provided relation.</p><p>Given <code>v : α</code> and relation <code>r : α → α → Prop</code>, <code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> r v : <a href=".././Init/Prelude.html#Quot">Quot</a> r</code> is like <code>v</code>, except all
observations of <code>v</code>'s value must respect <code>r</code>.</p><p><code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a></code> is a built-in primitive:</p><ul>
<li><code><a href=".././Init/Prelude.html#Quot">Quot</a></code> is the built-in quotient type.</li>
<li><code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code> allows the definition of functions from the quotient to some other type.</li>
<li><code><a href=".././Init/Core.html#Quot.sound">Quot.sound</a></code> asserts the equality of elements related by <code>r</code>.</li>
<li><code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code> is used to write proofs about quotients by assuming that all elements are constructed
with <code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a></code>.</li>
</ul></div></div><div class="decl" id="Quot.ind"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L430-L443">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Quot.ind"><span class="name">Quot</span>.<span class="name">ind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mk</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">β</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">q</span></span></div></div><p>A reasoning principle for quotients that allows proofs about quotients to assume that all values are
constructed with <code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a></code>.</p><p><code><a href=".././Init/Core.html#Quot.rec">Quot.rec</a></code> is analogous to the <a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=recursors">recursor</a> for a structure, and can
be used when the resulting type is not necessarily a proposition.</p><p><code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code> is a built-in primitive:</p><ul>
<li><code><a href=".././Init/Prelude.html#Quot">Quot</a></code> is the built-in quotient type.</li>
<li><code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a></code> places elements of the underlying type <code>α</code> into the quotient.</li>
<li><code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code> allows the definition of functions from the quotient to some other type.</li>
<li><code><a href=".././Init/Core.html#Quot.sound">Quot.sound</a></code> asserts the equality of elements related by <code>r</code>.</li>
</ul></div></div><div class="decl" id="Quot.lift"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L445-L464">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Quot.lift"><span class="name">Quot</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <span class="fn">β</span></span></div></div><p>Lifts a function from an underlying type to a function on a quotient, requiring that it respects the
quotient's relation.</p><p>Given a relation <code>r : α → α → Prop</code> and a quotient <code><a href=".././Init/Prelude.html#Quot">Quot</a> r</code>, applying a function <code>f : α → β</code>
requires a proof <code>a</code> that <code>f</code> respects <code>r</code>. In this case, <code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> f a : <a href=".././Init/Prelude.html#Quot">Quot</a> r → β</code> computes the
same values as <code>f</code>.</p><p>Lean's type theory includes a <a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=type-theory">definitional reduction</a> from
<code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> f h (Quot.<a href=".././Init/Prelude.html#Quot.mk">mk</a> r v)</code> to <code>f v</code>.</p><p><code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code> is a built-in primitive:</p><ul>
<li><code><a href=".././Init/Prelude.html#Quot">Quot</a></code> is the built-in quotient type.</li>
<li><code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a></code> places elements of the underlying type <code>α</code> into the quotient.</li>
<li><code><a href=".././Init/Core.html#Quot.sound">Quot.sound</a></code> asserts the equality of elements related by <code>r</code></li>
<li><code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code> is used to write proofs about quotients by assuming that all elements are constructed
with <code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a></code>; it is analogous to the <a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=recursors">recursor</a> for a
structure.</li>
</ul></div></div><div class="decl" id="Quot.lcInv"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L466-L469">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Quot.lcInv"><span class="name">Quot</span>.<span class="name">lcInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Unsafe auxiliary constant used by the compiler to erase <code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code>.</p></div></div><div class="decl" id="HEq"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L471-L485">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HEq"><span class="name">HEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u} → <span class="fn"><span class="fn">β</span> → <a href=".././foundational_types.html">Prop</a></span></span></span></div></div><p>Heterogeneous equality. <code>a ≍ b</code> asserts that <code>a</code> and <code>b</code> have the same
type, and casting <code>a</code> across the equality yields <code>b</code>, and vice versa.</p><p>You should avoid using this type if you can. Heterogeneous equality does not
have all the same properties as <code><a href=".././Init/Prelude.html#Eq">Eq</a></code>, because the assumption that the types of
<code>a</code> and <code>b</code> are equal is often too weak to prove theorems of interest. One
public important non-theorem is the analogue of <code><a href=".././Init/Prelude.html#congr">congr</a></code>: If <code>f ≍ g</code> and <code>x ≍ y</code>
and <code>f x</code> and <code>g y</code> are well typed it does not follow that <code>f x ≍ g y</code>.
(This does follow if you have <code>f = g</code> instead.) However if <code>a</code> and <code>b</code> have
the same type then <code>a = b</code> and <code>a ≍ b</code> are equivalent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>≍</code> in identifiers is <code>heq</code>.</li>
</ul><ul class="constructors"><li class="constructor" id="HEq.refl">refl<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href=".././Init/Prelude.html#HEq">≍</a> <span class="fn">a</span><div class="inductive_ctor_doc"><p>Reflexivity of heterogeneous equality.</p></div></li></ul><details id="instances-for-list-HEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="HEq.rfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L487-L489">source</a></div><div class="attributes">@[match_pattern]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HEq.rfl"><span class="name">HEq</span>.<span class="name">rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#HEq">≍</a> <span class="fn">a</span></div></div><p>A version of <code><a href=".././Init/Prelude.html#HEq.refl">HEq.refl</a></code> with an implicit argument.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></li></ul></details><details id="instances-for-list-HEq.rfl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="eq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L491-L496">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#eq_of_heq"><span class="name">eq_of_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#HEq">≍</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></div></div><p>If two heterogeneously equal terms have the same type, then they are propositionally equal.</p></div></div><div class="decl" id="Prod"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L498-L513">source</a></div><div class="attributes">@[unbox]</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Prod"><span class="name">Prod</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>The product type, usually written <code>α × β</code>. Product types are also called pair or tuple types.
Elements of this type are pairs in which the first element is an <code>α</code> and the second element is a
<code>β</code>.</p><p>Products nest to the right, so <code>(x, y, z) : α × β × γ</code> is equivalent to <code>(x, (y, z)) : α × (β × γ)</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>×</code> in identifiers is <code><a href=".././Init/Prelude.html#Prod">Prod</a></code>.</li>
</ul><ul class="structure_fields" id="Prod.mk"><li id="Prod.fst" class="structure_field"><div class="structure_field_info">fst : <span class="fn">α</span></div><div class="structure_field_doc"><p>The first element of a pair.</p></div></li><li id="Prod.snd" class="structure_field"><div class="structure_field_info">snd : <span class="fn">β</span></div><div class="structure_field_doc"><p>The second element of a pair.</p></div></li></ul><details id="instances-for-list-Prod" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PProd"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L517-L527">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PProd"><span class="name">PProd</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max (max 1 u) v)</div></div><p>A product type in which the types may be propositions, usually written <code>α ×' β</code>.</p><p>This type is primarily used internally and as an implementation detail of proof automation. It is
rarely useful in hand-written code.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>×'</code> in identifiers is <code><a href=".././Init/Prelude.html#PProd">PProd</a></code>.</li>
</ul><ul class="structure_fields" id="PProd.mk"><li id="PProd.fst" class="structure_field"><div class="structure_field_info">fst : <span class="fn">α</span></div><div class="structure_field_doc"><p>The first element of a pair.</p></div></li><li id="PProd.snd" class="structure_field"><div class="structure_field_info">snd : <span class="fn">β</span></div><div class="structure_field_doc"><p>The second element of a pair.</p></div></li></ul><details id="instances-for-list-PProd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="MProd"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L529-L538">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MProd"><span class="name">MProd</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>A product type in which both <code>α</code> and <code>β</code> are in the same universe.</p><p>It is called <code><a href=".././Init/Prelude.html#MProd">MProd</a></code> is because it is the <em>universe-monomorphic</em> product type.</p><ul class="structure_fields" id="MProd.mk"><li id="MProd.fst" class="structure_field"><div class="structure_field_info">fst : <span class="fn">α</span></div><div class="structure_field_doc"><p>The first element of a pair.</p></div></li><li id="MProd.snd" class="structure_field"><div class="structure_field_info">snd : <span class="fn">β</span></div><div class="structure_field_doc"><p>The second element of a pair.</p></div></li></ul><details id="instances-for-list-MProd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="And"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L540-L554">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#And"><span class="name">And</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Prelude.html#And">And</a> a b</code>, or <code>a ∧ b</code>, is the conjunction of propositions. It can be
constructed and destructed like a pair: if <code>ha : a</code> and <code>hb : b</code> then
<code>⟨ha, hb⟩ : a ∧ b</code>, and if <code>h : a ∧ b</code> then <code>h.<a href=".././Init/Prelude.html#And.left">left</a> : a</code> and <code>h.<a href=".././Init/Prelude.html#And.right">right</a> : b</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li><p>The recommended spelling of <code>∧</code> in identifiers is <code><a href=".././Init/Prelude.html#Bool.and">and</a></code>.</p>
</li>
<li><p>The recommended spelling of <code>/\</code> in identifiers is <code><a href=".././Init/Prelude.html#Bool.and">and</a></code> (prefer <code>∧</code> over <code>/\</code>).</p>
</li>
</ul><ul class="structure_ext"><li id="And.intro" class="structure_ext_ctor">intro :: (</li><ul class="structure_ext_fields"><li id="And.left" class="structure_field"><div class="structure_field_info">left : <span class="fn">a</span></div><div class="structure_field_doc"><p>Extract the left conjunct from a conjunction. <code>h : a ∧ b</code> then
<code>h.<a href=".././Init/Prelude.html#And.left">left</a></code>, also notated as <code>h.1</code>, is a proof of <code>a</code>.</p></div></li><li id="And.right" class="structure_field"><div class="structure_field_info">right : <span class="fn">b</span></div><div class="structure_field_doc"><p>Extract the right conjunct from a conjunction. <code>h : a ∧ b</code> then
<code>h.<a href=".././Init/Prelude.html#And.right">right</a></code>, also notated as <code>h.2</code>, is a proof of <code>b</code>.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-And" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Or"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L556-L566">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Or"><span class="name">Or</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Prelude.html#Or">Or</a> a b</code>, or <code>a ∨ b</code>, is the disjunction of propositions. There are two
constructors for <code><a href=".././Init/Prelude.html#Or">Or</a></code>, called <code><a href=".././Init/Prelude.html#Or.inl">Or.inl</a> : a → a ∨ b</code> and <code><a href=".././Init/Prelude.html#Or.inr">Or.inr</a> : b → a ∨ b</code>,
and you can use <code>match</code> or <code>cases</code> to destruct an <code><a href=".././Init/Prelude.html#Or">Or</a></code> assumption into the
two cases.</p><p>Conventions for notations in identifiers:</p><ul>
<li><p>The recommended spelling of <code>∨</code> in identifiers is <code><a href=".././Init/Prelude.html#Bool.or">or</a></code>.</p>
</li>
<li><p>The recommended spelling of <code>\/</code> in identifiers is <code><a href=".././Init/Prelude.html#Bool.or">or</a></code> (prefer <code>∨</code> over <code>\/</code>).</p>
</li>
</ul><ul class="constructors"><li class="constructor" id="Or.inl">inl<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span>)</span></span>
 : <span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Prelude.html#Or.inl">Or.inl</a></code> is &quot;left injection&quot; into an <code><a href=".././Init/Prelude.html#Or">Or</a></code>. If <code>h : a</code> then <code><a href=".././Init/Prelude.html#Or.inl">Or.inl</a> h : a ∨ b</code>.</p></div></li><li class="constructor" id="Or.inr">inr<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">b</span>)</span></span>
 : <span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Prelude.html#Or.inr">Or.inr</a></code> is &quot;right injection&quot; into an <code><a href=".././Init/Prelude.html#Or">Or</a></code>. If <code>h : b</code> then <code><a href=".././Init/Prelude.html#Or.inr">Or.inr</a> h : a ∨ b</code>.</p></div></li></ul><details id="instances-for-list-Or" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Or.intro_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L568-L570">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Or.intro_left"><span class="name">Or</span>.<span class="name">intro_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></div></div><p>Alias for <code><a href=".././Init/Prelude.html#Or.inl">Or.inl</a></code>.</p></div></div><div class="decl" id="Or.intro_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L572-L574">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Or.intro_right"><span class="name">Or</span>.<span class="name">intro_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></div></div><p>Alias for <code><a href=".././Init/Prelude.html#Or.inr">Or.inr</a></code>.</p></div></div><div class="decl" id="Or.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L576-L583">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Or.elim"><span class="name">Or</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">left</span> : <span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">right</span> : <span class="fn"><span class="fn">b</span> → <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">c</span></div></div><p>Proof by cases on an <code><a href=".././Init/Prelude.html#Or">Or</a></code>. If <code>a ∨ b</code>, and both <code>a</code> and <code>b</code> imply
proposition <code>c</code>, then <code>c</code> is true.</p></div></div><div class="decl" id="Or.resolve_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L585-L585">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Or.resolve_left"><span class="name">Or</span>.<span class="name">resolve_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">na</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span></div></div></div></div><div class="decl" id="Or.resolve_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L586-L586">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Or.resolve_right"><span class="name">Or</span>.<span class="name">resolve_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">nb</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span></div></div></div></div><div class="decl" id="Or.neg_resolve_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L587-L587">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Or.neg_resolve_left"><span class="name">Or</span>.<span class="name">neg_resolve_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span></div></div></div></div><div class="decl" id="Or.neg_resolve_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L588-L588">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Or.neg_resolve_right"><span class="name">Or</span>.<span class="name">neg_resolve_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">nb</span> : <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span></div></div></div></div><div class="decl" id="Bool"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L590-L602">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Bool"><span class="name">Bool</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>The Boolean values, <code><a href=".././Init/Prelude.html#Bool.true">true</a></code> and <code><a href=".././Init/Prelude.html#Bool.false">false</a></code>.</p><p>Logically speaking, this is equivalent to <code>Prop</code> (the type of propositions). The distinction is
public important for programming: both propositions and their proofs are erased in the code generator,
while <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> corresponds to the Boolean type in most programming languages and carries precisely one
bit of run-time information.</p><ul class="constructors"><li class="constructor" id="Bool.false">false : <a href=".././Init/Prelude.html#Bool">Bool</a><div class="inductive_ctor_doc"><p>The Boolean value <code><a href=".././Init/Prelude.html#Bool.false">false</a></code>, not to be confused with the proposition <code><a href=".././Init/Prelude.html#False">False</a></code>.</p></div></li><li class="constructor" id="Bool.true">true : <a href=".././Init/Prelude.html#Bool">Bool</a><div class="inductive_ctor_doc"><p>The Boolean value <code><a href=".././Init/Prelude.html#Bool.true">true</a></code>, not to be confused with the proposition <code><a href=".././Init/Prelude.html#True">True</a></code>.</p></div></li></ul><details id="instances-for-list-Bool" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Subtype"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L606-L631">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Subtype"><span class="name">Subtype</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max 1 u)</div></div><p>All the elements of a type that satisfy a predicate.</p><p><code><a href=".././Init/Prelude.html#Subtype">Subtype</a> p</code>, usually written <code>{ x : α // p x }</code> or <code>{ x // p x }</code>, contains all elements <code>x : α</code> for
which <code>p x</code> is true. Its constructor is a pair of the value and the proof that it satisfies the
predicate. In run-time code, <code>{ x : α // p x }</code> is represented identically to <code>α</code>.</p><p>There is a coercion from <code>{ x : α // p x }</code> to <code>α</code>, so elements of a subtype may be used where the
underlying type is expected.</p><p>Examples:</p><ul>
<li><code>{ n : <a href=".././Init/Prelude.html#Nat">Nat</a> // n % 2 = 0 }</code> is the type of even numbers.</li>
<li><code>{ xs : <a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#String">String</a> // xs.<a href=".././Init/Prelude.html#UInt8.size">size</a> = 5 }</code> is the type of arrays with five <code><a href=".././Init/Prelude.html#String">String</a></code>s.</li>
<li>Given <code>xs : <a href=".././Init/Prelude.html#List">List</a> α</code>, <code><a href=".././Init/Prelude.html#List">List</a> { x : α // x ∈ xs }</code> is the type of lists in which all elements are
contained in <code>xs</code>.</li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>{ x // p x }</code> in identifiers is <code>subtype</code>.</li>
</ul><ul class="structure_fields" id="Subtype.mk"><li id="Subtype.val" class="structure_field"><div class="structure_field_info">val : <span class="fn">α</span></div><div class="structure_field_doc"><p>The value in the underlying type that satisfies the predicate.</p></div></li><li id="Subtype.property" class="structure_field"><div class="structure_field_info">property : <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">self</span>.<a href=".././Init/Prelude.html#Subtype.val">val</a></span></span></div><div class="structure_field_doc"><p>The proof that <code><a href=".././Init/Prelude.html#Subtype.val">val</a></code> satisfies the predicate <code>p</code>.</p></div></li></ul><details id="instances-for-list-Subtype" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="optParam"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L634-L641">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#optParam"><span class="name">optParam</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">default</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> u</div></div><p>Gadget for optional parameter support.</p><p>A binder like <code>(x : α := default)</code> in a declaration is syntax sugar for
<code>x : <a href=".././Init/Prelude.html#optParam">optParam</a> α <a href=".././Init/Prelude.html#Inhabited.default">default</a></code>, and triggers the elaborator to attempt to use
<code><a href=".././Init/Prelude.html#Inhabited.default">default</a></code> to supply the argument if it is not supplied.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <span class="fn">α</span> <span class="fn">default</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></li></ul></details><details id="instances-for-list-optParam" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="outParam"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L643-L659">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#outParam"><span class="name">outParam</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> u</div></div><p>Gadget for marking output parameters in type classes.</p><p>For example, the <code><a href=".././Init/Prelude.html#Membership">Membership</a></code> class is defined as:</p><pre><code>class <a href=".././Init/Prelude.html#Membership">Membership</a> (α : <a href=".././Init/Prelude.html#outParam">outParam</a> (Type u)) (γ : Type v)
</code></pre><p>This means that whenever a typeclass goal of the form <code><a href=".././Init/Prelude.html#Membership">Membership</a> ?α ?γ</code> comes
up, Lean will wait to solve it until <code>?γ</code> is known, but then it will run
typeclass inference, and take the first solution it finds, for any value of <code>?α</code>,
which thereby determines what <code>?α</code> should be.</p><p>This expresses that in a term like <code>a ∈ s</code>, <code>s</code> might be a <code>Set α</code> or
<code><a href=".././Init/Prelude.html#List">List</a> α</code> or some other type with a membership operation, and in each case
the &quot;member&quot; type <code>α</code> is determined by looking at the container type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></li></ul></details><details id="instances-for-list-outParam" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="semiOutParam"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L661-L682">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#semiOutParam"><span class="name">semiOutParam</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> u</div></div><p>Gadget for marking semi output parameters in type classes.</p><p>Semi-output parameters influence the order in which arguments to type class
instances are processed.  Lean determines an order where all non-(semi-)output
parameters to the instance argument have to be figured out before attempting to
synthesize an argument (that is, they do not contain assignable metavariables
created during TC synthesis). This rules out instances such as <code>[Mul β] : <a href=".././Init/Prelude.html#Add">Add</a> α</code> (because <code>β</code> could be anything). Marking a parameter as semi-output is a
promise that instances of the type class will always fill in a value for that
parameter.</p><p>For example, the <code><a href=".././Init/Coe.html#Coe">Coe</a></code> class is defined as:</p><pre><code>class <a href=".././Init/Coe.html#Coe">Coe</a> (α : <a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a> (Sort u)) (β : Sort v)
</code></pre><p>This means that all <code><a href=".././Init/Coe.html#Coe">Coe</a></code> instances should provide a concrete value for <code>α</code>
(i.e., not an assignable metavariable). An instance like <code><a href=".././Init/Coe.html#Coe">Coe</a> <a href=".././Init/Prelude.html#Nat">Nat</a> <a href=".././Init/Data/Int/Basic.html#Int">Int</a></code> or <code><a href=".././Init/Coe.html#Coe">Coe</a> α (Option α)</code> is fine, but <code><a href=".././Init/Coe.html#Coe">Coe</a> α <a href=".././Init/Prelude.html#Nat">Nat</a></code> is not since it does not provide a value
for <code>α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></li></ul></details><details id="instances-for-list-semiOutParam" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="namedPattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L685-L686">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#namedPattern"><span class="name">namedPattern</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Auxiliary declaration used to implement named patterns like <code>x@h:p</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></li></ul></details><details id="instances-for-list-namedPattern" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="sorryAx"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L688-L704">source</a></div><div class="attributes">@[never_extract, extern lean_sorry]</div>
<div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#sorryAx"><span class="name">sorryAx</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">synthetic</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Auxiliary axiom used to implement the <code>sorry</code> term and tactic.</p><p>The <code>sorry</code> term/tactic expands to <code><a href=".././Init/Prelude.html#sorryAx">sorryAx</a> _ (synthetic := false)</code>.
It is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.
Lean will give a warning whenever a declaration uses <code>sorry</code>, so you aren't likely to miss it,
but you can check if a declaration depends on <code>sorry</code> either directly or indirectly by looking for <code><a href=".././Init/Prelude.html#sorryAx">sorryAx</a></code> in the output
of the <code>#print axioms my_thm</code> command.</p><p>The <code><a href=".././Init/Prelude.html#Lean.SourceInfo.synthetic">synthetic</a></code> flag is false when a <code>sorry</code> is written explicitly by the user, but it is
set to <code><a href=".././Init/Prelude.html#Bool.true">true</a></code> when a tactic fails to prove a goal, or if there is a type error
in the expression. A synthetic <code>sorry</code> acts like a regular one, except that it
suppresses follow-up errors in order to prevent an error from causing a cascade
of other errors because the desired term was not constructed.</p></div></div><div class="decl" id="eq_false_of_ne_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L706-L708">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#eq_false_of_ne_true"><span class="name">eq_false_of_ne_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a> → <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="eq_true_of_ne_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L710-L712">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#eq_true_of_ne_false"><span class="name">eq_true_of_ne_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a> → <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="ne_false_of_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L714-L716">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ne_false_of_eq_true"><span class="name">ne_false_of_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a> → <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="ne_true_of_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L718-L720">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ne_true_of_eq_false"><span class="name">ne_true_of_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a> → <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Inhabited"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L722-L737">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Inhabited"><span class="name">Inhabited</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max 1 u)</div></div><p><code><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> α</code> is a typeclass that says that <code>α</code> has a designated element,
called <code>(default : α)</code>. This is sometimes referred to as a &quot;pointed type&quot;.</p><p>This class is used by functions that need to return a value of the type
when called &quot;out of domain&quot;. For example, <code>Array.get! arr i : α</code> returns
a value of type <code>α</code> when <code>arr : <a href=".././Init/Prelude.html#Array">Array</a> α</code>, but if <code>i</code> is not in range of
the array, it reports a panic message, but this does not halt the program,
so it must still return a value of type <code>α</code> (and in fact this is required
for logical consistency), so in this case it returns <code><a href=".././Init/Prelude.html#Inhabited.default">default</a></code>.</p><ul class="structure_fields" id="Inhabited.mk"><li id="Inhabited.default" class="structure_field"><div class="structure_field_info">default : <span class="fn">α</span></div><div class="structure_field_doc"><p><code><a href=".././Init/Prelude.html#Inhabited.default">default</a></code> is a function that produces a &quot;default&quot; element of any
<code><a href=".././Init/Prelude.html#Inhabited">Inhabited</a></code> type. This element does not have any particular specified
properties, but it is often an all-zeroes value.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Inhabited" class="instances-list"></ul></details></div></div><div class="decl" id="Nonempty"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L741-L751">source</a></div><div class="decl_header"><span class="decl_kind">class inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nonempty"><span class="name">Nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code> is a typeclass that says that <code>α</code> is not an empty type,
that is, there exists an element in the type. It differs from <code><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> α</code>
in that <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code> is a <code>Prop</code>, which means that it does not actually carry
an element of <code>α</code>, only a proof that <em>there exists</em> such an element.
Given <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code>, you can construct an element of <code>α</code> <em>nonconstructively</em>
using <code><a href=".././Init/Prelude.html#Classical.choice">Classical.choice</a></code>.</p><ul class="constructors"><li class="constructor" id="Nonempty.intro">intro<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span><div class="inductive_ctor_doc"><p>If <code><a href=".././Init/Prelude.html#Subtype.val">val</a> : α</code>, then <code>α</code> is nonempty.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Nonempty" class="instances-list"></ul></details></div></div><div class="decl" id="Classical.choice"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L753-L775">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Classical.choice"><span class="name">Classical</span>.<span class="name">choice</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span> → <span class="fn">α</span></span></div></div><p><strong>The axiom of choice</strong>. <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code> is a proof that <code>α</code> has an element,
but the element itself is erased. The axiom <code><a href=".././Init/Prelude.html#Classical.choice">choice</a></code> supplies a particular
element of <code>α</code> given only this proof.</p><p>The textbook axiom of choice normally makes a family of choices all at once,
but that is implied from this formulation, because if <code>α : ι → Type</code> is a
family of types and <code>h : ∀ i, <a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (α i)</code> is a proof that they are all
nonempty, then <code>fun i =&gt; <a href=".././Init/Prelude.html#Classical.choice">Classical.choice</a> (h i) : ∀ i, α i</code> is a family of
chosen elements. This is actually a bit stronger than the ZFC choice axiom;
this is sometimes called &quot;<a href="https://en.wikipedia.org/wiki/Axiom_of_global_choice">global choice</a>&quot;.</p><p>In Lean, we use the axiom of choice to derive the law of excluded middle
(see <code><a href=".././Init/Classical.html#Classical.em">Classical.em</a></code>), so it will often show up in axiom listings where you
may not expect. You can use <code>#print axioms my_thm</code> to find out if a given
theorem depends on this or other axioms.</p><p>This axiom can be used to construct &quot;data&quot;, but obviously there is no algorithm
to compute it, so Lean will require you to mark any definition that would
involve executing <code><a href=".././Init/Prelude.html#Classical.choice">Classical.choice</a></code> or other axioms as <code>noncomputable</code>, and
will not produce any executable code for such definitions.</p></div></div><div class="decl" id="Nonempty.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L777-L785">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nonempty.elim"><span class="name">Nonempty</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div><p>The elimination principle for <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code>. If <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code>, and we can
prove <code>p</code> given any element <code>x : α</code>, then <code>p</code> holds. Note that it is essential
that <code>p</code> is a <code>Prop</code> here; the version with <code>p</code> being a <code>Sort u</code> is equivalent
to <code><a href=".././Init/Prelude.html#Classical.choice">Classical.choice</a></code>.</p></div></div><div class="decl" id="instNonemptyOfInhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L787-L788">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instNonemptyOfInhabited"><span class="name">instNonemptyOfInhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="Classical.ofNonempty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L790-L795">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Classical.ofNonempty"><span class="name">Classical</span>.<span class="name">ofNonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A variation on <code><a href=".././Init/Prelude.html#Classical.choice">Classical.choice</a></code> that uses typeclass inference to
infer the proof of <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Classical.ofNonempty">Classical.ofNonempty</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Classical.choice">Classical.choice</a> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Classical.ofNonempty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instNonemptyForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L797-L798">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instNonemptyForall"><span class="name">instNonemptyForall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span></span></div></div></div></div><div class="decl" id="Pi.instNonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L800-L802">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Pi.instNonempty"><span class="name">Pi</span>.<span class="name">instNonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div></div></div><div class="decl" id="instInhabitedSort"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L804-L805">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedSort"><span class="name">instInhabitedSort</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././foundational_types.html">(Sort</a> u)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedSort">instInhabitedSort</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#PUnit">PUnit</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instInhabitedForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L807-L808">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedForall"><span class="name">instInhabitedForall</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedForall">instInhabitedForall</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Pi.instInhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L810-L812">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Pi.instInhabited"><span class="name">Pi</span>.<span class="name">instInhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Pi.instInhabited">Pi.instInhabited</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instInhabitedBool.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L814-L814">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedBool.default"><span class="name">instInhabitedBool</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedBool.default">instInhabitedBool.default</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-instInhabitedBool.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedBool"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L814-L814">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedBool"><span class="name">instInhabitedBool</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedBool">instInhabitedBool</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#instInhabitedBool.default">instInhabitedBool.default</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="PLift"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L816-L835">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PLift"><span class="name">PLift</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Lifts a proposition or type to a higher universe level.</p><p><code><a href=".././Init/Prelude.html#PLift">PLift</a> α</code> wraps a proof or value of type <code>α</code>. The resulting type is in the next largest universe
after that of <code>α</code>. In particular, propositions become data.</p><p>The related type <code><a href=".././Init/Prelude.html#ULift">ULift</a></code> can be used to lift a non-proposition type by any number of levels.</p><p>Examples:</p><ul>
<li><code>(False : Prop)</code></li>
<li><code>(PLift <a href=".././Init/Prelude.html#False">False</a> : Type)</code></li>
<li><code>([.<a href=".././Init/Prelude.html#PLift.up">up</a> (by trivial), .<a href=".././Init/Prelude.html#PLift.up">up</a> (by simp), .<a href=".././Init/Prelude.html#PLift.up">up</a> (by decide)] : <a href=".././Init/Prelude.html#List">List</a> (PLift True))</code></li>
<li><code>(Nat : Type 0)</code></li>
<li><code>(PLift <a href=".././Init/Prelude.html#Nat">Nat</a> : Type 1)</code></li>
</ul><ul class="structure_ext"><li id="PLift.up" class="structure_ext_ctor">up :: (</li><ul class="structure_ext_fields"><li id="PLift.down" class="structure_field"><div class="structure_field_info">down : <span class="fn">α</span></div><div class="structure_field_doc"><p>Extracts a wrapped proof or value from a universe-lifted proposition or type.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-PLift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PLift.up_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L837-L838">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PLift.up_down"><span class="name">PLift</span>.<span class="name">up_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href=".././Init/Prelude.html#PLift">PLift</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#PLift.up">{</a> <span class="fn">down</span> := <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#PLift.down">down</a></span> <a href=".././Init/Prelude.html#PLift.up">}</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div><p>Bijection between <code>α</code> and <code><a href=".././Init/Prelude.html#PLift">PLift</a> α</code></p></div></div><div class="decl" id="PLift.down_up"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L840-L841">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PLift.down_up"><span class="name">PLift</span>.<span class="name">down_up</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#PLift.up">{</a> <span class="fn">down</span> := <span class="fn">a</span> <a href=".././Init/Prelude.html#PLift.up">}</a>.<a href=".././Init/Prelude.html#PLift.down">down</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div><p>Bijection between <code>α</code> and <code><a href=".././Init/Prelude.html#PLift">PLift</a> α</code></p></div></div><div class="decl" id="NonemptyType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L843-L849">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#NonemptyType"><span class="name">NonemptyType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (u + 1)</div></div><p><code>NonemptyType.{u}</code> is the type of nonempty types in universe <code>u</code>.
It is mainly used in constant declarations where we wish to introduce a type
and simultaneously assert that it is nonempty, but otherwise make the type
opaque.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#NonemptyType">NonemptyType</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Subtype">{</a> <span class="fn">α</span> <a href=".././Init/Prelude.html#Subtype">:</a> <a href=".././foundational_types.html">Type</a> ?u.3 <a href=".././Init/Prelude.html#Subtype">//</a> <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Subtype">}</a></li></ul></details><details id="instances-for-list-NonemptyType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="NonemptyType.type"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L851-L853">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#NonemptyType.type"><span class="name">NonemptyType</span>.<span class="name">type</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">type</span> : <a href=".././Init/Prelude.html#NonemptyType">NonemptyType</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The underlying type of a <code><a href=".././Init/Prelude.html#NonemptyType">NonemptyType</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">type</span>.<a href=".././Init/Prelude.html#NonemptyType.type">type</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">type</span>.<a href=".././Init/Prelude.html#Subtype.val">val</a></span></li></ul></details><details id="instances-for-list-NonemptyType.type" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedNonemptyType"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L855-L857">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedNonemptyType"><span class="name">instInhabitedNonemptyType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#NonemptyType">NonemptyType</a></span></div></div><p><code><a href=".././Init/Prelude.html#NonemptyType">NonemptyType</a></code> is inhabited, because <code><a href=".././Init/Prelude.html#PUnit">PUnit</a></code> is a nonempty type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedNonemptyType">instInhabitedNonemptyType</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Subtype.mk">⟨</a><a href=".././Init/Prelude.html#PUnit">PUnit</a>, <span class="fn">⋯</span><a href=".././Init/Prelude.html#Subtype.mk">⟩</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="ULift"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L859-L884">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ULift"><span class="name">ULift</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> s)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max s r)</div></div><p>Lifts a type to a higher universe level.</p><p><code><a href=".././Init/Prelude.html#ULift">ULift</a> α</code> wraps a value of type <code>α</code>. Instead of occupying the same universe as <code>α</code>, which would be
the minimal level, it takes a further level parameter and occupies their maximum. The resulting type
may occupy any universe that's at least as large as that of <code>α</code>.</p><p>The resulting universe of the lifting operator is the first parameter, and may be written explicitly
while allowing <code>α</code>'s level to be inferred.</p><p>The related type <code><a href=".././Init/Prelude.html#PLift">PLift</a></code> can be used to lift a proposition or type by one level.</p><p>Examples:</p><ul>
<li><code>(Nat : Type 0)</code></li>
<li><code>(ULift <a href=".././Init/Prelude.html#Nat">Nat</a> : Type 0)</code></li>
<li><code>(ULift <a href=".././Init/Prelude.html#Nat">Nat</a> : Type 1)</code></li>
<li><code>(ULift <a href=".././Init/Prelude.html#Nat">Nat</a> : Type 5)</code></li>
<li><code>(ULift.{7} (PUnit : Type 3) : Type 7)</code></li>
</ul><ul class="structure_ext"><li id="ULift.up" class="structure_ext_ctor">up :: (</li><ul class="structure_ext_fields"><li id="ULift.down" class="structure_field"><div class="structure_field_info">down : <span class="fn">α</span></div><div class="structure_field_doc"><p>Extracts a wrapped value from a universe-lifted type.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-ULift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ULift.up_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L886-L887">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ULift.up_down"><span class="name">ULift</span>.<span class="name">up_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href=".././Init/Prelude.html#ULift">ULift</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#ULift.up">{</a> <span class="fn">down</span> := <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#ULift.down">down</a></span> <a href=".././Init/Prelude.html#ULift.up">}</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div><p>Bijection between <code>α</code> and <code>ULift.{v} α</code></p></div></div><div class="decl" id="ULift.down_up"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L889-L890">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ULift.down_up"><span class="name">ULift</span>.<span class="name">down_up</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#ULift.up">{</a> <span class="fn">down</span> := <span class="fn">a</span> <a href=".././Init/Prelude.html#ULift.up">}</a>.<a href=".././Init/Prelude.html#ULift.down">down</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div><p>Bijection between <code>α</code> and <code>ULift.{v} α</code></p></div></div><div class="decl" id="instInhabitedULift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L892-L893">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedULift"><span class="name">instInhabitedULift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Prelude.html#ULift">ULift</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedULift">instInhabitedULift</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#ULift.up">{</a> <span class="fn">down</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a> <a href=".././Init/Prelude.html#ULift.up">}</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="PULift"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L895-L908">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PULift"><span class="name">PULift</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> s)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max s r 1)</div></div><p>Lifts a type or proposition to a higher universe level.</p><p><code><a href=".././Init/Prelude.html#PULift">PULift</a> α</code> wraps a value of type <code>α</code>. It is a generalization of
<code><a href=".././Init/Prelude.html#PLift">PLift</a></code> that allows lifting values who's type may live in <code>Sort s</code>.
It also subsumes <code><a href=".././Init/Prelude.html#PLift">PLift</a></code>.</p><ul class="structure_ext"><li id="PULift.up" class="structure_ext_ctor">up :: (</li><ul class="structure_ext_fields"><li id="PULift.down" class="structure_field"><div class="structure_field_info">down : <span class="fn">α</span></div><div class="structure_field_doc"><p>Extracts a wrapped value from a universe-lifted type.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-PULift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PULift.up_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L910-L911">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PULift.up_down"><span class="name">PULift</span>.<span class="name">up_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href=".././Init/Prelude.html#PULift">PULift</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#PULift.up">{</a> <span class="fn">down</span> := <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#PULift.down">down</a></span> <a href=".././Init/Prelude.html#PULift.up">}</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div><p>Bijection between <code>α</code> and <code>PULift.{v} α</code></p></div></div><div class="decl" id="PULift.down_up"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L913-L914">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PULift.down_up"><span class="name">PULift</span>.<span class="name">down_up</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#PULift.up">{</a> <span class="fn">down</span> := <span class="fn">a</span> <a href=".././Init/Prelude.html#PULift.up">}</a>.<a href=".././Init/Prelude.html#PULift.down">down</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div><p>Bijection between <code>α</code> and <code>PULift.{v} α</code></p></div></div><div class="decl" id="Decidable"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L916-L934">source</a></div><div class="decl_header"><span class="decl_kind">class inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Decidable"><span class="name">Decidable</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Either a proof that <code>p</code> is true or a proof that <code>p</code> is false. This is equivalent to a <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> paired
with a proof that the <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> is <code><a href=".././Init/Prelude.html#Bool.true">true</a></code> if and only if <code>p</code> is true.</p><p><code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code> instances are primarily used via <code>if</code>-expressions and the tactic <code><a href=".././Init/Prelude.html#Decidable.decide">decide</a></code>. In
conditional expressions, the <code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code> instance for the proposition is used to select a branch. At
run time, this case distinction code is identical to that which would be generated for a
<code><a href=".././Init/Prelude.html#Bool">Bool</a></code>-based conditional. In proofs, the tactic <code><a href=".././Init/Prelude.html#Decidable.decide">decide</a></code> synthesizes an instance of <code><a href=".././Init/Prelude.html#Decidable">Decidable</a> p</code>,
attempts to reduce it to <code><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> h</code>, and then succeeds with the proof <code>h</code> if it can.</p><p>Because <code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code> carries data, when writing <code>@[simp]</code> lemmas which include a <code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code> instance
on the LHS, it is best to use <code>{_ : <a href=".././Init/Prelude.html#Decidable">Decidable</a> p}</code> rather than <code>[Decidable p]</code> so that non-canonical
instances can be found via unification rather than instance synthesis.</p><ul class="constructors"><li class="constructor" id="Decidable.isFalse">isFalse<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span>)</span></span>
 : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span><div class="inductive_ctor_doc"><p>Proves that <code>p</code> is decidable by supplying a proof of <code>¬p</code></p></div></li><li class="constructor" id="Decidable.isTrue">isTrue<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">p</span>)</span></span>
 : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span><div class="inductive_ctor_doc"><p>Proves that <code>p</code> is decidable by supplying a proof of <code>p</code></p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Decidable" class="instances-list"></ul></details></div></div><div class="decl" id="Decidable.decide"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L936-L943">source</a></div><div class="attributes">@[inline_if_reduce]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Decidable.decide"><span class="name">Decidable</span>.<span class="name">decide</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Converts a decidable proposition into a <code><a href=".././Init/Prelude.html#Bool">Bool</a></code>.</p><p>If <code>p : Prop</code> is decidable, then <code><a href=".././Init/Prelude.html#Decidable.decide">decide</a> p : <a href=".././Init/Prelude.html#Bool">Bool</a></code> is the Boolean value
that is <code><a href=".././Init/Prelude.html#Bool.true">true</a></code> if <code>p</code> is true and <code><a href=".././Init/Prelude.html#Bool.false">false</a></code> if <code>p</code> is false.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">h</span> <span class="fn">(fun (<span class="fn">x</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span>) =&gt; <a href=".././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">p</span>) =&gt; <a href=".././Init/Prelude.html#Bool.true">true</a></span></span></li></ul></details><details id="instances-for-list-Decidable.decide" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="DecidablePred"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L947-L953">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#DecidablePred"><span class="name">DecidablePred</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max 1 u)</div></div><p>A decidable predicate.</p><p>A predicate is decidable if the corresponding proposition is <code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code> for each possible argument.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">r</span> <span class="fn">a</span>)</span></span>)</span></li></ul></details><details id="instances-for-list-DecidablePred" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="DecidableRel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L955-L961">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#DecidableRel"><span class="name">DecidableRel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href=".././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max (max 1 u) v)</div></div><p>A decidable relation.</p><p>A relation is decidable if the corresponding proposition is <code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code> for all possible arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span>)</span></span></span>)</span></li></ul></details><details id="instances-for-list-DecidableRel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="DecidableEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L963-L970">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#DecidableEq"><span class="name">DecidableEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max 1 u)</div></div><p>Propositional equality is <code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code> for all elements of a type.</p><p>In other words, an instance of <code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> α</code> is a means of deciding the proposition <code>a = b</code> is
for all <code>a b : α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">((<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span>)</span></li></ul></details><details id="instances-for-list-DecidableEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L972-L976">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#decEq"><span class="name">decEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></div></div><p>Checks whether two terms of a type are equal using the type's <code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a></code> instance.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#decEq">decEq</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">inst</span> <span class="fn">a</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="decide_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L979-L981">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#decide_eq_true"><span class="name">decide_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> → <span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="decide_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L983-L985">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#decide_eq_false"><span class="name">decide_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="of_decide_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L987-L990">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#of_decide_eq_true"><span class="name">of_decide_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a> → <span class="fn">p</span></span></div></div></div></div><div class="decl" id="of_decide_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L992-L995">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#of_decide_eq_false"><span class="name">of_decide_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a> → <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></div></div></div></div><div class="decl" id="of_decide_eq_self_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L997-L1000">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#of_decide_eq_self_eq_true"><span class="name">of_decide_eq_self_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Bool.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1002-L1013">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Bool.decEq"><span class="name">Bool</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></div></div><p>Decides whether two Booleans are equal.</p><p>This function should normally be called via the <code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#Bool">Bool</a></code> instance that it exists to
support.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Bool.false">false</a>.<a href=".././Init/Prelude.html#Bool.decEq">decEq</a></span> <a href=".././Init/Prelude.html#Bool.false">false</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Bool.false">false</a>.<a href=".././Init/Prelude.html#Bool.decEq">decEq</a></span> <a href=".././Init/Prelude.html#Bool.true">true</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Bool.true">true</a>.<a href=".././Init/Prelude.html#Bool.decEq">decEq</a></span> <a href=".././Init/Prelude.html#Bool.false">false</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Bool.true">true</a>.<a href=".././Init/Prelude.html#Bool.decEq">decEq</a></span> <a href=".././Init/Prelude.html#Bool.true">true</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Bool.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqBool"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1015-L1016">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqBool"><span class="name">instDecidableEqBool</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableEqBool">instDecidableEqBool</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.decEq">Bool.decEq</a></li></ul></details></div></div><div class="decl" id="BEq"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1018-L1031">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#BEq"><span class="name">BEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p><code><a href=".././Init/Prelude.html#BEq">BEq</a> α</code> is a typeclass for supplying a boolean-valued equality relation on
<code>α</code>, notated as <code>a == b</code>. Unlike <code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> α</code> (which uses <code>a = b</code>), this
is <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> valued instead of <code>Prop</code> valued, and it also does not have any
axioms like being reflexive or agreeing with <code>=</code>. It is mainly intended for
programming applications. See <code><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a></code> for a version that requires that
<code>==</code> and <code>=</code> coincide.</p><p>Typically we prefer to put the &quot;more variable&quot; term on the left,
and the &quot;more constant&quot; term on the right.</p><ul class="structure_fields" id="BEq.mk"><li id="BEq.beq" class="structure_field"><div class="structure_field_info">beq : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div><div class="structure_field_doc"><p>Boolean equality, notated as <code>a == b</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>==</code> in identifiers is <code><a href=".././Init/Prelude.html#BEq.beq">beq</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-BEq" class="instances-list"></ul></details></div></div><div class="decl" id="instBEqOfDecidableEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1035-L1036">source</a></div><div class="attributes">@[instance 500]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instBEqOfDecidableEq"><span class="name">instBEqOfDecidableEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instBEqOfDecidableEq">instBEqOfDecidableEq</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span> <a href=".././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="dite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1039-L1054">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#dite"><span class="name">dite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><span class="fn">c</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>&quot;Dependent&quot; if-then-else, normally written via the notation <code>if h : c then t(h) else e(h)</code>,
is sugar for <code><a href=".././Init/Prelude.html#dite">dite</a> c (fun h =&gt; t(h)) (fun h =&gt; e(h))</code>, and it is the same as
<code>if c then t else e</code> except that <code>t</code> is allowed to depend on a proof <code>h : c</code>,
and <code>e</code> can depend on <code>h : ¬c</code>. (Both branches use the same name for the hypothesis,
even though it has different types in the two cases.)</p><p>We use this to be able to communicate the if-then-else condition to the branches.
For example, <code>Array.<a href=".././Init/Prelude.html#List.get">get</a> arr i h</code> expects a proof <code>h : i &lt; arr.<a href=".././Init/Prelude.html#UInt8.size">size</a></code> in order to
avoid a bounds check, so you can write <code>if h : i &lt; arr.<a href=".././Init/Prelude.html#UInt8.size">size</a> then arr.<a href=".././Init/Prelude.html#List.get">get</a> i h else ...</code>
to avoid the bounds check inside the if branch. (Of course in this case we have only
lifted the check into an explicit <code>if</code>, but we could also use this proof multiple times
or derive <code>i &lt; arr.<a href=".././Init/Prelude.html#UInt8.size">size</a></code> from some other proposition that we are checking in the <code>if</code>.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#dite">dite</a> <span class="fn">c</span> <span class="fn">t</span> <span class="fn">e</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">h</span> <span class="fn">e</span> <span class="fn">t</span></span></li></ul></details><details id="instances-for-list-dite" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="if-then-else">if-then-else <a class="hover-link" href="#if-then-else">#</a></h1></div><div class="decl" id="ite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1058-L1079">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ite"><span class="name">ite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t </span><span class="fn">e</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code>if c then t else e</code> is notation for <code><a href=".././Init/Prelude.html#ite">ite</a> c t e</code>, &quot;if-then-else&quot;, which decides to
return <code>t</code> or <code>e</code> depending on whether <code>c</code> is true or false. The explicit argument
<code>c : Prop</code> does not have any actual computational content, but there is an additional
<code>[Decidable c]</code> argument synthesized by typeclass inference which actually
determines how to evaluate <code>c</code> to true or false. Write <code>if h : c then t else e</code>
instead for a &quot;dependent if-then-else&quot; <code><a href=".././Init/Prelude.html#dite">dite</a></code>, which allows <code>t</code>/<code>e</code> to use the fact
that <code>c</code> is true/false.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">(<a href=".././Init/Prelude.html#ite">if</a> <span class="fn">c</span> <a href=".././Init/Prelude.html#ite">then</a> <span class="fn">t</span> <a href=".././Init/Prelude.html#ite">else</a> <span class="fn">e</span>) <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">h</span> <span class="fn">(fun (<span class="fn">x</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span>) =&gt; <span class="fn">e</span>)</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">c</span>) =&gt; <span class="fn">t</span></span></span></li></ul></details><details id="instances-for-list-ite" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableAnd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1081-L1088">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableAnd"><span class="name">instDecidableAnd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dp</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dq</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">p</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">q</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableAnd">instDecidableAnd</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></li><li class="equation"><a href=".././Init/Prelude.html#instDecidableAnd">instDecidableAnd</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></li><li class="equation"><a href=".././Init/Prelude.html#instDecidableAnd">instDecidableAnd</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instDecidableOr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1090-L1099">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableOr"><span class="name">instDecidableOr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dp</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dq</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">p</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">q</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableOr">instDecidableOr</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></li><li class="equation"><a href=".././Init/Prelude.html#instDecidableOr">instDecidableOr</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></li><li class="equation"><a href=".././Init/Prelude.html#instDecidableOr">instDecidableOr</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instDecidableNot"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1101-L1104">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableNot"><span class="name">instDecidableNot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">dp</span> : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableNot">instDecidableNot</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></li><li class="equation"><a href=".././Init/Prelude.html#instDecidableNot">instDecidableNot</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">hq</span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Boolean-operators">Boolean operators <a class="hover-link" href="#Boolean-operators">#</a></h1></div><div class="decl" id="cond"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1108-L1121">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#cond"><span class="name">cond</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>The conditional function.</p><p><code><a href=".././Init/Prelude.html#cond">cond</a> c x y</code> is the same as <code>if c then x else y</code>, but optimized for a Boolean condition rather than
a decidable proposition. It can also be written using the notation <code>bif c then x else y</code>.</p><p>Just like <code><a href=".././Init/Prelude.html#ite">ite</a></code>, <code><a href=".././Init/Prelude.html#cond">cond</a></code> is declared <code>@[macro_inline]</code>, which causes applications of <code><a href=".././Init/Prelude.html#cond">cond</a></code> to be
unfolded. As a result, <code>x</code> and <code>y</code> are not evaluated at runtime until one of them is selected, and
only the selected branch is evaluated.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(bif <a href=".././Init/Prelude.html#Bool.true">true</a> then <span class="fn">x</span> else <span class="fn">y</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></li><li class="equation"><span class="fn">(bif <a href=".././Init/Prelude.html#Bool.false">false</a> then <span class="fn">x</span> else <span class="fn">y</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></li></ul></details><details id="instances-for-list-cond" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Bool.dcond"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1124-L1142">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Bool.dcond"><span class="name">Bool</span>.<span class="name">dcond</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">c</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">y</span> : <span class="fn"><span class="fn">c</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>The dependent conditional function, in which each branch is provided with a local assumption about
the condition's value. This allows the value to be used in proofs as well as for control flow.</p><p><code><a href=".././Init/Prelude.html#Bool.dcond">dcond</a> c (fun h =&gt; x) (fun h =&gt; y)</code> is the same as <code>if h : c then x else y</code>, but optimized for a
Boolean condition rather than a decidable proposition. Unlike the non-dependent version <code><a href=".././Init/Prelude.html#cond">cond</a></code>,
there is no special notation for <code><a href=".././Init/Prelude.html#Bool.dcond">dcond</a></code>.</p><p>Just like <code><a href=".././Init/Prelude.html#ite">ite</a></code>, <code><a href=".././Init/Prelude.html#dite">dite</a></code>, and <code><a href=".././Init/Prelude.html#cond">cond</a></code>, <code><a href=".././Init/Prelude.html#Bool.dcond">dcond</a></code> is declared <code>@[macro_inline]</code>, which causes
applications of <code><a href=".././Init/Prelude.html#Bool.dcond">dcond</a></code> to be unfolded. As a result, <code>x</code> and <code>y</code> are not evaluated at runtime until
one of them is selected, and only the selected branch is evaluated. <code><a href=".././Init/Prelude.html#Bool.dcond">dcond</a></code> is intended for
metaprogramming use, rather than for use in verified programs, so behavioral lemmas are not
provided.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Bool.true">true</a>.<a href=".././Init/Prelude.html#Bool.dcond">dcond</a></span> <span class="fn">x_2</span> <span class="fn">y_2</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x_2</span> <span class="fn">⋯</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Bool.false">false</a>.<a href=".././Init/Prelude.html#Bool.dcond">dcond</a></span> <span class="fn">x_2</span> <span class="fn">y_2</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y_2</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Bool.dcond" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Bool.or"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1144-L1156">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Bool.or"><span class="name">Bool</span>.<span class="name">or</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Boolean “or”, also known as disjunction. <code><a href=".././Init/Prelude.html#Bool.or">or</a> x y</code> can be written <code>x || y</code>.</p><p>The corresponding propositional connective is <code><a href=".././Init/Prelude.html#Or">Or</a> : Prop → Prop → Prop</code>, written with the <code>∨</code>
operator.</p><p>The Boolean <code><a href=".././Init/Prelude.html#Bool.or">or</a></code> is a <code>@[macro_inline]</code> function in order to give it short-circuiting evaluation:
if <code>x</code> is <code><a href=".././Init/Prelude.html#Bool.true">true</a></code> then <code>y</code> is not evaluated at runtime.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">(<a href=".././Init/Prelude.html#Bool.true">true</a> <a href=".././Init/Prelude.html#Bool.or">||</a> <span class="fn">y</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></li><li class="equation">(<a href=".././Init/Prelude.html#Bool.false">false</a> <a href=".././Init/Prelude.html#Bool.or">||</a> <span class="fn">y</span>) <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></li></ul></details><details id="instances-for-list-Bool.or" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Bool.and"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1158-L1170">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Bool.and"><span class="name">Bool</span>.<span class="name">and</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Boolean “and”, also known as conjunction. <code><a href=".././Init/Prelude.html#Bool.and">and</a> x y</code> can be written <code>x &amp;&amp; y</code>.</p><p>The corresponding propositional connective is <code><a href=".././Init/Prelude.html#And">And</a> : Prop → Prop → Prop</code>, written with the <code>∧</code>
operator.</p><p>The Boolean <code><a href=".././Init/Prelude.html#Bool.and">and</a></code> is a <code>@[macro_inline]</code> function in order to give it short-circuiting evaluation:
if <code>x</code> is <code><a href=".././Init/Prelude.html#Bool.false">false</a></code> then <code>y</code> is not evaluated at runtime.</p><p>Conventions for notations in identifiers:</p><ul>
<li><p>The recommended spelling of <code>&amp;&amp;</code> in identifiers is <code><a href=".././Init/Prelude.html#Bool.and">and</a></code>.</p>
</li>
<li><p>The recommended spelling of <code>||</code> in identifiers is <code><a href=".././Init/Prelude.html#Bool.or">or</a></code>.</p>
</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">(<a href=".././Init/Prelude.html#Bool.false">false</a> <a href=".././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">y</span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></li><li class="equation">(<a href=".././Init/Prelude.html#Bool.true">true</a> <a href=".././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">y</span>) <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></li></ul></details><details id="instances-for-list-Bool.and" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Bool.not"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1172-L1180">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Bool.not"><span class="name">Bool</span>.<span class="name">not</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Bool">Bool</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Boolean negation, also known as Boolean complement. <code><a href=".././Init/Prelude.html#Bool.not">not</a> x</code> can be written <code>!x</code>.</p><p>This is a function that maps the value <code><a href=".././Init/Prelude.html#Bool.true">true</a></code> to <code><a href=".././Init/Prelude.html#Bool.false">false</a></code> and the value <code><a href=".././Init/Prelude.html#Bool.false">false</a></code> to <code><a href=".././Init/Prelude.html#Bool.true">true</a></code>. The
propositional connective is <code><a href=".././Init/Prelude.html#Not">Not</a> : Prop → Prop</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>!</code> in identifiers is <code><a href=".././Init/Prelude.html#Bool.not">not</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">(<a href=".././Init/Prelude.html#Bool.not">!</a><a href=".././Init/Prelude.html#Bool.true">true</a>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></li><li class="equation">(<a href=".././Init/Prelude.html#Bool.not">!</a><a href=".././Init/Prelude.html#Bool.false">false</a>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></li></ul></details><details id="instances-for-list-Bool.not" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1185-L1206">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat"><span class="name">Nat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>The natural numbers, starting at zero.</p><p>This type is special-cased by both the kernel and the compiler, and overridden with an efficient
implementation. Both use a fast arbitrary-precision arithmetic library (usually
<a href="https://gmplib.org/">GMP</a>); at runtime, <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> values that are sufficiently small are unboxed.</p><ul class="constructors"><li class="constructor" id="Nat.zero">zero : <a href=".././Init/Prelude.html#Nat">Nat</a><div class="inductive_ctor_doc"><p>Zero, the smallest natural number.</p><p>Using <code><a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a></code> explicitly should usually be avoided in favor of the literal <code>0</code>, which is the
<a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=simp-normal-forms">simp normal form</a>.</p></div></li><li class="constructor" id="Nat.succ">succ<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
 : <a href=".././Init/Prelude.html#Nat">Nat</a><div class="inductive_ctor_doc"><p>The successor of a natural number <code>n</code>.</p><p>Using <code><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> n</code> should usually be avoided in favor of <code>n + 1</code>, which is the <a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=simp-normal-forms">simp normal
form</a>.</p></div></li></ul><details id="instances-for-list-Nat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1208-L1209">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedNat"><span class="name">instInhabitedNat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedNat">instInhabitedNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="OfNat"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1211-L1228">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#OfNat"><span class="name">OfNat</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././foundational_types.html">Type</a> u</span></div></div><p>The class <code><a href=".././Init/Prelude.html#OfNat">OfNat</a> α n</code> powers the numeric literal parser. If you write
<code>37 : α</code>, Lean will attempt to synthesize <code><a href=".././Init/Prelude.html#OfNat">OfNat</a> α 37</code>, and will generate
the term <code>(OfNat.<a href=".././Init/Prelude.html#OfNat.ofNat">ofNat</a> 37 : α)</code>.</p><p>There is a bit of infinite regress here since the desugaring apparently
still contains a literal <code>37</code> in it. The type of expressions contains a
primitive constructor for &quot;raw natural number literals&quot;, which you can directly
access using the macro <code>nat_lit 37</code>. Raw number literals are always of type <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.
So it would be more correct to say that Lean looks for an instance of
<code><a href=".././Init/Prelude.html#OfNat">OfNat</a> α (nat_lit 37)</code>, and it generates the term <code>(OfNat.<a href=".././Init/Prelude.html#OfNat.ofNat">ofNat</a> (nat_lit 37) : α)</code>.</p><ul class="structure_fields" id="OfNat.mk"><li id="OfNat.ofNat" class="structure_field"><div class="structure_field_info">ofNat : <span class="fn">α</span></div><div class="structure_field_doc"><p>The <code><a href=".././Init/Prelude.html#OfNat.ofNat">OfNat.ofNat</a></code> function is automatically inserted by the parser when
the user writes a numeric literal like <code>1 : α</code>. Implementations of this
typeclass can therefore customize the behavior of <code>n : α</code> based on <code>n</code> and
<code>α</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-OfNat" class="instances-list"></ul></details></div></div><div class="decl" id="instOfNatNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1230-L1232">source</a></div><div class="attributes">@[defaultInstance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instOfNatNat"><span class="name">instOfNatNat</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#OfNat">OfNat</a> <a href=".././Init/Prelude.html#Nat">Nat</a> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instOfNatNat">instOfNatNat</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#OfNat.mk">{</a> <span class="fn">ofNat</span> := <span class="fn">n</span> <a href=".././Init/Prelude.html#OfNat.mk">}</a></li></ul></details></div></div><div class="decl" id="LE"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1234-L1237">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#LE"><span class="name">LE</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p><code><a href=".././Init/Prelude.html#LE">LE</a> α</code> is the typeclass which supports the notation <code>x ≤ y</code> where <code>x y : α</code>.</p><ul class="structure_fields" id="LE.mk"><li id="LE.le" class="structure_field"><div class="structure_field_info">le : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p>The less-equal relation: <code>x ≤ y</code></p><p>Conventions for notations in identifiers:</p><ul>
<li><p>The recommended spelling of <code>≤</code> in identifiers is <code><a href=".././Init/Prelude.html#LE.le">le</a></code>.</p>
</li>
<li><p>The recommended spelling of <code>&lt;=</code> in identifiers is <code><a href=".././Init/Prelude.html#LE.le">le</a></code> (prefer <code>≤</code> over <code>&lt;=</code>).</p>
</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-LE" class="instances-list"></ul></details></div></div><div class="decl" id="LT"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1239-L1242">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#LT"><span class="name">LT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p><code><a href=".././Init/Prelude.html#LT">LT</a> α</code> is the typeclass which supports the notation <code>x &lt; y</code> where <code>x y : α</code>.</p><ul class="structure_fields" id="LT.mk"><li id="LT.lt" class="structure_field"><div class="structure_field_info">lt : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p>The less-than relation: <code>x &lt; y</code></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;</code> in identifiers is <code><a href=".././Init/Prelude.html#LT.lt">lt</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-LT" class="instances-list"></ul></details></div></div><div class="decl" id="GE.ge"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1244-L1245">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#GE.ge"><span class="name">GE</span>.<span class="name">ge</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>a ≥ b</code> is an abbreviation for <code>b ≤ a</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li><p>The recommended spelling of <code>≥</code> in identifiers is <code><a href=".././Init/Prelude.html#GE.ge">ge</a></code>.</p>
</li>
<li><p>The recommended spelling of <code>&gt;=</code> in identifiers is <code><a href=".././Init/Prelude.html#GE.ge">ge</a></code> (prefer <code>≥</code> over <code>&gt;=</code>).</p>
</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">(<span class="fn">a</span> <a href=".././Init/Prelude.html#GE.ge">≥</a> <span class="fn">b</span>) <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">b</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span>)</li></ul></details><details id="instances-for-list-GE.ge" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="GT.gt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1246-L1247">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#GT.gt"><span class="name">GT</span>.<span class="name">gt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>a &gt; b</code> is an abbreviation for <code>b &lt; a</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&gt;</code> in identifiers is <code><a href=".././Init/Prelude.html#GT.gt">gt</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">(<span class="fn">a</span> <a href=".././Init/Prelude.html#GT.gt">&gt;</a> <span class="fn">b</span>) <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">b</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a</span>)</li></ul></details><details id="instances-for-list-GT.gt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="DecidableLT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1249-L1250">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#DecidableLT"><span class="name">DecidableLT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Abbreviation for <code><a href=".././Init/Prelude.html#DecidableRel">DecidableRel</a> (· &lt; · : α → α → Prop)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#DecidableRel">DecidableRel</a> <a href=".././Init/Prelude.html#LT.lt">LT.lt</a></span></li></ul></details><details id="instances-for-list-DecidableLT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="DecidableLE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1251-L1252">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#DecidableLE"><span class="name">DecidableLE</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Abbreviation for <code><a href=".././Init/Prelude.html#DecidableRel">DecidableRel</a> (· ≤ · : α → α → Prop)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#DecidableRel">DecidableRel</a> <a href=".././Init/Prelude.html#LE.le">LE.le</a></span></li></ul></details><details id="instances-for-list-DecidableLE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Max"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1254-L1259">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Max"><span class="name">Max</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>An overloaded operation to find the greater of two values of type <code>α</code>.</p><ul class="structure_fields" id="Max.mk"><li id="Max.max" class="structure_field"><div class="structure_field_info">max : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p>Returns the greater of its two arguments.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Max" class="instances-list"></ul></details></div></div><div class="decl" id="maxOfLe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1263-L1269">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#maxOfLe"><span class="name">maxOfLe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableRel">DecidableRel</a> <a href=".././Init/Prelude.html#LE.le">LE.le</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Max">Max</a> <span class="fn">α</span></span></div></div><p>Constructs a <code><a href=".././Init/Prelude.html#Max">Max</a></code> instance from a decidable <code>≤</code> operation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#maxOfLe">maxOfLe</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Max.mk">{</a> <span class="fn">max</span> := <span class="fn">fun (<span class="fn">x</span> <span class="fn">y</span> : <span class="fn">α</span>) =&gt; <a href=".././Init/Prelude.html#ite">if</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">y</span> <a href=".././Init/Prelude.html#ite">then</a> <span class="fn">y</span> <a href=".././Init/Prelude.html#ite">else</a> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Max.mk">}</a></li></ul></details><details id="instances-for-list-maxOfLe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Min"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1271-L1276">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Min"><span class="name">Min</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>An overloaded operation to find the lesser of two values of type <code>α</code>.</p><ul class="structure_fields" id="Min.mk"><li id="Min.min" class="structure_field"><div class="structure_field_info">min : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p>Returns the lesser of its two arguments.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Min" class="instances-list"></ul></details></div></div><div class="decl" id="minOfLe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1280-L1286">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#minOfLe"><span class="name">minOfLe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableRel">DecidableRel</a> <a href=".././Init/Prelude.html#LE.le">LE.le</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Min">Min</a> <span class="fn">α</span></span></div></div><p>Constructs a <code><a href=".././Init/Prelude.html#Min">Min</a></code> instance from a decidable <code>≤</code> operation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#minOfLe">minOfLe</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Min.mk">{</a> <span class="fn">min</span> := <span class="fn">fun (<span class="fn">x</span> <span class="fn">y</span> : <span class="fn">α</span>) =&gt; <a href=".././Init/Prelude.html#ite">if</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">y</span> <a href=".././Init/Prelude.html#ite">then</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#ite">else</a> <span class="fn">y</span></span> <a href=".././Init/Prelude.html#Min.mk">}</a></li></ul></details><details id="instances-for-list-minOfLe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Trans"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1288-L1299">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Trans"><span class="name">Trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href=".././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href=".././foundational_types.html">Sort</a> u</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <a href=".././foundational_types.html">Sort</a> v</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">(<span class="fn">α</span> → <span class="fn"><span class="fn">γ</span> → <a href=".././foundational_types.html">Sort</a> w</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)</div></div><p>Transitive chaining of proofs, used e.g. by <code>calc</code>.</p><p>It takes two relations <code>r</code> and <code>s</code> as &quot;input&quot;, and produces an &quot;output&quot;
relation <code>t</code>, with the property that <code>r a b</code> and <code>s b c</code> implies <code>t a c</code>.
The <code>calc</code> tactic uses this so that when it sees a chain with <code>a ≤ b</code> and <code>b &lt; c</code>
it knows that this should be a proof of <code>a &lt; c</code> because there is an instance
<code><a href=".././Init/Prelude.html#Trans">Trans</a> (·≤·) (·&lt;·) (·&lt;·)</code>.</p><ul class="structure_fields" id="Trans.mk"><li id="Trans.trans" class="structure_field"><div class="structure_field_info">trans<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">γ</span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">t</span> <span class="fn">a</span> <span class="fn">c</span></span></span></span></div><div class="structure_field_doc"><p>Compose two proofs by transitivity, generalized over the relations involved.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Trans" class="instances-list"></ul></details></div></div><div class="decl" id="instTransEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1303-L1304">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instTransEq"><span class="name">instTransEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">γ</span> → <a href=".././foundational_types.html">Sort</a> u</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Trans">Trans</a> <a href=".././Init/Prelude.html#Eq">Eq</a> <span class="fn">r</span> <span class="fn">r</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instTransEq">instTransEq</a> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Trans.mk">{</a> <span class="fn">trans</span> := <span class="fn">fun {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} {<span class="fn">c</span> : <span class="fn">γ</span>} (<span class="fn">heq</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>) (<span class="fn">h'</span> : <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>) =&gt; <span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">h'</span></span> <a href=".././Init/Prelude.html#Trans.mk">}</a></li></ul></details></div></div><div class="decl" id="instTransEq_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1306-L1307">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instTransEq_1"><span class="name">instTransEq_1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href=".././foundational_types.html">Sort</a> u</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Trans">Trans</a> <span class="fn">r</span> <a href=".././Init/Prelude.html#Eq">Eq</a> <span class="fn">r</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instTransEq_1">instTransEq_1</a> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Trans.mk">{</a> <span class="fn">trans</span> := <span class="fn">fun {<span class="fn">a</span> : <span class="fn">α</span>} {<span class="fn">b </span><span class="fn">c</span> : <span class="fn">β</span>} (<span class="fn">h'</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>) (<span class="fn">heq</span> : <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>) =&gt; <span class="fn">heq</span> <a href=".././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">h'</span></span> <a href=".././Init/Prelude.html#Trans.mk">}</a></li></ul></details></div></div><div class="decl" id="HAdd"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1309-L1316">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HAdd"><span class="name">HAdd</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The notation typeclass for heterogeneous addition.
This enables the notation <code>a + b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><ul class="structure_fields" id="HAdd.mk"><li id="HAdd.hAdd" class="structure_field"><div class="structure_field_info">hAdd : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a + b</code> computes the sum of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>+</code> in identifiers is <code><a href=".././Init/Prelude.html#Add.add">add</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HAdd" class="instances-list"></ul></details></div></div><div class="decl" id="HSub"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1318-L1326">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HSub"><span class="name">HSub</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The notation typeclass for heterogeneous subtraction.
This enables the notation <code>a - b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><ul class="structure_fields" id="HSub.mk"><li id="HSub.hSub" class="structure_field"><div class="structure_field_info">hSub : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a - b</code> computes the difference of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><ul>
<li>For natural numbers, this operator saturates at 0: <code>a - b = 0</code> when <code>a ≤ b</code>.</li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>-</code> in identifiers is <code><a href=".././Init/Prelude.html#Sub.sub">sub</a></code> (when used as a binary operator).</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HSub" class="instances-list"></ul></details></div></div><div class="decl" id="HMul"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1328-L1335">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HMul"><span class="name">HMul</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The notation typeclass for heterogeneous multiplication.
This enables the notation <code>a * b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><ul class="structure_fields" id="HMul.mk"><li id="HMul.hMul" class="structure_field"><div class="structure_field_info">hMul : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a * b</code> computes the product of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>*</code> in identifiers is <code><a href=".././Init/Prelude.html#Mul.mul">mul</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HMul" class="instances-list"></ul></details></div></div><div class="decl" id="HDiv"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1337-L1353">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HDiv"><span class="name">HDiv</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The notation typeclass for heterogeneous division.
This enables the notation <code>a / b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><ul class="structure_fields" id="HDiv.mk"><li id="HDiv.hDiv" class="structure_field"><div class="structure_field_info">hDiv : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a / b</code> computes the result of dividing <code>a</code> by <code>b</code>.
The meaning of this notation is type-dependent.</p><ul>
<li>For most types like <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>, <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code>, <code><a href=".././Init/Data/Rat/Basic.html#Rat">Rat</a></code>, <code>Real</code>, <code>a / 0</code> is defined to be <code>0</code>.</li>
<li>For <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>, <code>a / b</code> rounds downwards.</li>
<li>For <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code>, <code>a / b</code> rounds downwards if <code>b</code> is positive or upwards if <code>b</code> is negative.
It is implemented as <code><a href=".././Init/Data/Int/DivMod/Basic.html#Int.ediv">Int.ediv</a></code>, the unique function satisfying
<code>a % b + b * (a / b) = a</code> and <code>0 ≤ a % b &lt; natAbs b</code> for <code>b ≠ 0</code>.
Other rounding conventions are available using the functions
<code><a href=".././Init/Data/Int/DivMod/Basic.html#Int.fdiv">Int.fdiv</a></code> (floor rounding) and <code><a href=".././Init/Data/Int/DivMod/Basic.html#Int.tdiv">Int.tdiv</a></code> (truncation rounding).</li>
<li>For <code><a href=".././Init/Data/Float.html#Float">Float</a></code>, <code>a / 0</code> follows the IEEE 754 semantics for division,
usually resulting in <code>inf</code> or <code>nan</code>.</li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>/</code> in identifiers is <code><a href=".././Init/Prelude.html#Div.div">div</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HDiv" class="instances-list"></ul></details></div></div><div class="decl" id="HMod"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1355-L1364">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HMod"><span class="name">HMod</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The notation typeclass for heterogeneous modulo / remainder.
This enables the notation <code>a % b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><ul class="structure_fields" id="HMod.mk"><li id="HMod.hMod" class="structure_field"><div class="structure_field_info">hMod : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a % b</code> computes the remainder upon dividing <code>a</code> by <code>b</code>.
The meaning of this notation is type-dependent.</p><ul>
<li>For <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> and <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code> it satisfies <code>a % b + b * (a / b) = a</code>,
and <code>a % 0</code> is defined to be <code>a</code>.</li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>%</code> in identifiers is <code><a href=".././Init/Prelude.html#Mod.mod">mod</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HMod" class="instances-list"></ul></details></div></div><div class="decl" id="HPow"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1366-L1373">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HPow"><span class="name">HPow</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The notation typeclass for heterogeneous exponentiation.
This enables the notation <code>a ^ b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><ul class="structure_fields" id="HPow.mk"><li id="HPow.hPow" class="structure_field"><div class="structure_field_info">hPow : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a ^ b</code> computes <code>a</code> to the power of <code>b</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>^</code> in identifiers is <code><a href=".././Init/Prelude.html#Pow.pow">pow</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HPow" class="instances-list"></ul></details></div></div><div class="decl" id="HSMul"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1375-L1390">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HSMul"><span class="name">HSMul</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The notation typeclass for heterogeneous scalar multiplication.
This enables the notation <code>a • b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><p>It is assumed to represent a left action in some sense.
The notation <code>a • b</code> is augmented with a macro (below) to have it elaborate as a left action.
Only the <code>b</code> argument participates in the elaboration algorithm: the algorithm uses the type of <code>b</code>
when calculating the type of the surrounding arithmetic expression
and it tries to insert coercions into <code>b</code> to get some <code>b'</code>
such that <code>a • b'</code> has the same type as <code>b'</code>.
See the module documentation near the macro for more details.</p><ul class="structure_fields" id="HSMul.mk"><li id="HSMul.hSMul" class="structure_field"><div class="structure_field_info">hSMul : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a • b</code> computes the product of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent, but it is intended to be used for left actions.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>•</code> in identifiers is <code><a href=".././Init/Prelude.html#SMul.smul">smul</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HSMul" class="instances-list"></ul></details></div></div><div class="decl" id="HAppend"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1392-L1399">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HAppend"><span class="name">HAppend</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The notation typeclass for heterogeneous append.
This enables the notation <code>a ++ b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><ul class="structure_fields" id="HAppend.mk"><li id="HAppend.hAppend" class="structure_field"><div class="structure_field_info">hAppend : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a ++ b</code> is the result of concatenation of <code>a</code> and <code>b</code>, usually read &quot;append&quot;.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>++</code> in identifiers is <code><a href=".././Init/Prelude.html#Append.append">append</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HAppend" class="instances-list"></ul></details></div></div><div class="decl" id="HOrElse"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1401-L1411">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HOrElse"><span class="name">HOrElse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The typeclass behind the notation <code>a &lt;|&gt; b : γ</code> where <code>a : α</code>, <code>b : β</code>.
Because <code>b</code> is &quot;lazy&quot; in this notation, it is passed as <code><a href=".././Init/Prelude.html#Unit">Unit</a> → β</code> to the
implementation so it can decide when to evaluate it.</p><ul class="structure_fields" id="HOrElse.mk"><li id="HOrElse.hOrElse" class="structure_field"><div class="structure_field_info">hOrElse : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">β</span>)</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a &lt;|&gt; b</code> executes <code>a</code> and returns the result, unless it fails in which
case it executes and returns <code>b</code>. Because <code>b</code> is not always executed, it
is passed as a thunk so it can be forced only when needed.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;|&gt;</code> in identifiers is <code><a href=".././Init/Prelude.html#OrElse.orElse">orElse</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HOrElse" class="instances-list"></ul></details></div></div><div class="decl" id="HAndThen"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1413-L1423">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HAndThen"><span class="name">HAndThen</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The typeclass behind the notation <code>a &gt;&gt; b : γ</code> where <code>a : α</code>, <code>b : β</code>.
Because <code>b</code> is &quot;lazy&quot; in this notation, it is passed as <code><a href=".././Init/Prelude.html#Unit">Unit</a> → β</code> to the
implementation so it can decide when to evaluate it.</p><ul class="structure_fields" id="HAndThen.mk"><li id="HAndThen.hAndThen" class="structure_field"><div class="structure_field_info">hAndThen : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">β</span>)</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a &gt;&gt; b</code> executes <code>a</code>, ignores the result, and then executes <code>b</code>.
If <code>a</code> fails then <code>b</code> is not executed. Because <code>b</code> is not always executed, it
is passed as a thunk so it can be forced only when needed.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&gt;&gt;</code> in identifiers is <code><a href=".././Init/Prelude.html#AndThen.andThen">andThen</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HAndThen" class="instances-list"></ul></details></div></div><div class="decl" id="HAnd"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1425-L1429">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HAnd"><span class="name">HAnd</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The typeclass behind the notation <code>a &amp;&amp;&amp; b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><ul class="structure_fields" id="HAnd.mk"><li id="HAnd.hAnd" class="structure_field"><div class="structure_field_info">hAnd : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a &amp;&amp;&amp; b</code> computes the bitwise AND of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&amp;&amp;&amp;</code> in identifiers is <code><a href=".././Init/Prelude.html#Bool.and">and</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HAnd" class="instances-list"></ul></details></div></div><div class="decl" id="HXor"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1431-L1435">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HXor"><span class="name">HXor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The typeclass behind the notation <code>a ^^^ b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><ul class="structure_fields" id="HXor.mk"><li id="HXor.hXor" class="structure_field"><div class="structure_field_info">hXor : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a ^^^ b</code> computes the bitwise XOR of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>^^^</code> in identifiers is <code><a href=".././Init/Prelude.html#XorOp.xor">xor</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HXor" class="instances-list"></ul></details></div></div><div class="decl" id="HOr"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1437-L1441">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HOr"><span class="name">HOr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The typeclass behind the notation <code>a ||| b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><ul class="structure_fields" id="HOr.mk"><li id="HOr.hOr" class="structure_field"><div class="structure_field_info">hOr : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a ||| b</code> computes the bitwise OR of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>|||</code> in identifiers is <code><a href=".././Init/Prelude.html#Bool.or">or</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HOr" class="instances-list"></ul></details></div></div><div class="decl" id="HShiftLeft"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1443-L1450">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HShiftLeft"><span class="name">HShiftLeft</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The typeclass behind the notation <code>a &lt;&lt;&lt; b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><ul class="structure_fields" id="HShiftLeft.mk"><li id="HShiftLeft.hShiftLeft" class="structure_field"><div class="structure_field_info">hShiftLeft : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a &lt;&lt;&lt; b</code> computes <code>a</code> shifted to the left by <code>b</code> places.
The meaning of this notation is type-dependent.</p><ul>
<li>On <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>, this is equivalent to <code>a * 2 ^ b</code>.</li>
<li>On <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code> and other fixed width unsigned types, this is the same but
truncated to the bit width.</li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;&lt;&lt;</code> in identifiers is <code><a href=".././Init/Prelude.html#ShiftLeft.shiftLeft">shiftLeft</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HShiftLeft" class="instances-list"></ul></details></div></div><div class="decl" id="HShiftRight"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1452-L1458">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HShiftRight"><span class="name">HShiftRight</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> w)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u v) w)</div></div><p>The typeclass behind the notation <code>a &gt;&gt;&gt; b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><ul class="structure_fields" id="HShiftRight.mk"><li id="HShiftRight.hShiftRight" class="structure_field"><div class="structure_field_info">hShiftRight : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code>a &gt;&gt;&gt; b</code> computes <code>a</code> shifted to the right by <code>b</code> places.
The meaning of this notation is type-dependent.</p><ul>
<li>On <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> and fixed width unsigned types like <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code>,
this is equivalent to <code>a / 2 ^ b</code>.</li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&gt;&gt;&gt;</code> in identifiers is <code><a href=".././Init/Prelude.html#ShiftRight.shiftRight">shiftRight</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HShiftRight" class="instances-list"></ul></details></div></div><div class="decl" id="Zero"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1460-L1463">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Zero"><span class="name">Zero</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>A type with a zero element.</p><ul class="structure_fields" id="Zero.mk"><li id="Zero.zero" class="structure_field"><div class="structure_field_info">zero : <span class="fn">α</span></div><div class="structure_field_doc"><p>The zero element of the type.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Zero" class="instances-list"></ul></details></div></div><div class="decl" id="One"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1465-L1468">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#One"><span class="name">One</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>A type with a &quot;one&quot; element.</p><ul class="structure_fields" id="One.mk"><li id="One.one" class="structure_field"><div class="structure_field_info">one : <span class="fn">α</span></div><div class="structure_field_doc"><p>The &quot;one&quot; element of the type.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-One" class="instances-list"></ul></details></div></div><div class="decl" id="Add"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1470-L1473">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Add"><span class="name">Add</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HAdd">HAdd</a></code>: <code>a + b : α</code> where <code>a b : α</code>.</p><ul class="structure_fields" id="Add.mk"><li id="Add.add" class="structure_field"><div class="structure_field_info">add : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a + b</code> computes the sum of <code>a</code> and <code>b</code>. See <code><a href=".././Init/Prelude.html#HAdd">HAdd</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Add" class="instances-list"></ul></details></div></div><div class="decl" id="Sub"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1475-L1478">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Sub"><span class="name">Sub</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HSub">HSub</a></code>: <code>a - b : α</code> where <code>a b : α</code>.</p><ul class="structure_fields" id="Sub.mk"><li id="Sub.sub" class="structure_field"><div class="structure_field_info">sub : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a - b</code> computes the difference of <code>a</code> and <code>b</code>. See <code><a href=".././Init/Prelude.html#HSub">HSub</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Sub" class="instances-list"></ul></details></div></div><div class="decl" id="Mul"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1480-L1483">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Mul"><span class="name">Mul</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HMul">HMul</a></code>: <code>a * b : α</code> where <code>a b : α</code>.</p><ul class="structure_fields" id="Mul.mk"><li id="Mul.mul" class="structure_field"><div class="structure_field_info">mul : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a * b</code> computes the product of <code>a</code> and <code>b</code>. See <code><a href=".././Init/Prelude.html#HMul">HMul</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Mul" class="instances-list"></ul></details></div></div><div class="decl" id="Neg"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1485-L1492">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Neg"><span class="name">Neg</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The notation typeclass for negation.
This enables the notation <code>-a : α</code> where <code>a : α</code>.</p><ul class="structure_fields" id="Neg.mk"><li id="Neg.neg" class="structure_field"><div class="structure_field_info">neg : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>-a</code> computes the negative or opposite of <code>a</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>-</code> in identifiers is <code><a href=".././Init/Prelude.html#Neg.neg">neg</a></code> (when used as a unary operator).</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Neg" class="instances-list"></ul></details></div></div><div class="decl" id="Div"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1494-L1497">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Div"><span class="name">Div</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HDiv">HDiv</a></code>: <code>a / b : α</code> where <code>a b : α</code>.</p><ul class="structure_fields" id="Div.mk"><li id="Div.div" class="structure_field"><div class="structure_field_info">div : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a / b</code> computes the result of dividing <code>a</code> by <code>b</code>. See <code><a href=".././Init/Prelude.html#HDiv">HDiv</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Div" class="instances-list"></ul></details></div></div><div class="decl" id="Inv"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1499-L1506">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Inv"><span class="name">Inv</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The notation typeclass for inverses.
This enables the notation <code>a⁻¹ : α</code> where <code>a : α</code>.</p><ul class="structure_fields" id="Inv.mk"><li id="Inv.inv" class="structure_field"><div class="structure_field_info">inv : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a⁻¹</code> computes the inverse of <code>a</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>⁻¹</code> in identifiers is <code><a href=".././Init/Prelude.html#Inv.inv">inv</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Inv" class="instances-list"></ul></details></div></div><div class="decl" id="Mod"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1508-L1511">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Mod"><span class="name">Mod</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HMod">HMod</a></code>: <code>a % b : α</code> where <code>a b : α</code>.</p><ul class="structure_fields" id="Mod.mk"><li id="Mod.mod" class="structure_field"><div class="structure_field_info">mod : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a % b</code> computes the remainder upon dividing <code>a</code> by <code>b</code>. See <code><a href=".././Init/Prelude.html#HMod">HMod</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Mod" class="instances-list"></ul></details></div></div><div class="decl" id="Dvd"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1513-L1516">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Dvd"><span class="name">Dvd</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u_1</div></div><p>Notation typeclass for the <code>∣</code> operation (typed as <code>\|</code>), which represents divisibility.</p><ul class="structure_fields" id="Dvd.mk"><li id="Dvd.dvd" class="structure_field"><div class="structure_field_info">dvd : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p>Divisibility. <code>a ∣ b</code> (typed as <code>\|</code>) means that there is some <code>c</code> such that <code>b = a * c</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∣</code> in identifiers is <code><a href=".././Init/Prelude.html#Dvd.dvd">dvd</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Dvd" class="instances-list"></ul></details></div></div><div class="decl" id="Pow"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1518-L1530">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Pow"><span class="name">Pow</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HPow">HPow</a></code>: <code>a ^ b : α</code> where <code>a : α</code>, <code>b : β</code>.
(The right argument is not the same as the left since we often want this even
in the homogeneous case.)</p><p>Types can choose to subscribe to particular defaulting behavior by providing
an instance to either <code><a href=".././Init/Prelude.html#NatPow">NatPow</a></code> or <code><a href=".././Init/Prelude.html#HomogeneousPow">HomogeneousPow</a></code>:</p><ul>
<li><code><a href=".././Init/Prelude.html#NatPow">NatPow</a></code> is for types whose exponents is preferentially a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.</li>
<li><code><a href=".././Init/Prelude.html#HomogeneousPow">HomogeneousPow</a></code> is for types whose base and exponent are preferentially the same.</li>
</ul><ul class="structure_fields" id="Pow.mk"><li id="Pow.pow" class="structure_field"><div class="structure_field_info">pow : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p><code>a ^ b</code> computes <code>a</code> to the power of <code>b</code>. See <code><a href=".././Init/Prelude.html#HPow">HPow</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Pow" class="instances-list"></ul></details></div></div><div class="decl" id="NatPow"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1532-L1540">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#NatPow"><span class="name">NatPow</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#Pow">Pow</a></code> where the exponent is a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.
The purpose of this class is that it provides a default <code><a href=".././Init/Prelude.html#Pow">Pow</a></code> instance,
which can be used to specialize the exponent to <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> during elaboration.</p><p>For example, if <code>x ^ 2</code> should preferentially elaborate with <code>2 : <a href=".././Init/Prelude.html#Nat">Nat</a></code> then <code>x</code>'s type should
provide an instance for this class.</p><ul class="structure_fields" id="NatPow.mk"><li id="NatPow.pow" class="structure_field"><div class="structure_field_info">pow : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p><code>a ^ n</code> computes <code>a</code> to the power of <code>n</code> where <code>n : <a href=".././Init/Prelude.html#Nat">Nat</a></code>. See <code><a href=".././Init/Prelude.html#Pow">Pow</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-NatPow" class="instances-list"></ul></details></div></div><div class="decl" id="HomogeneousPow"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1542-L1552">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HomogeneousPow"><span class="name">HomogeneousPow</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The completely homogeneous version of <code><a href=".././Init/Prelude.html#Pow">Pow</a></code> where the exponent has the same type as the base.
The purpose of this class is that it provides a default <code><a href=".././Init/Prelude.html#Pow">Pow</a></code> instance,
which can be used to specialize the exponent to have the same type as the base's type during elaboration.
This is to say, a type should provide an instance for this class in case <code>x ^ y</code> should be elaborated
with both <code>x</code> and <code>y</code> having the same type.</p><p>For example, the <code><a href=".././Init/Data/Float.html#Float">Float</a></code> type provides an instance of this class, which causes expressions
such as <code>(2.2 ^ 2.2 : Float)</code> to elaborate.</p><ul class="structure_fields" id="HomogeneousPow.mk"><li id="HomogeneousPow.pow" class="structure_field"><div class="structure_field_info">pow : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a ^ b</code> computes <code>a</code> to the power of <code>b</code> where <code>a</code> and <code>b</code> both have the same type.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HomogeneousPow" class="instances-list"></ul></details></div></div><div class="decl" id="SMul"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1554-L1558">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#SMul"><span class="name">SMul</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">M</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>Typeclass for types with a scalar multiplication operation, denoted <code>•</code> (<code>\bu</code>)</p><ul class="structure_fields" id="SMul.mk"><li id="SMul.smul" class="structure_field"><div class="structure_field_info">smul : <span class="fn"><span class="fn">M</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p><code>a • b</code> computes the product of <code>a</code> and <code>b</code>. The meaning of this notation is type-dependent,
but it is intended to be used for left actions.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-SMul" class="instances-list"></ul></details></div></div><div class="decl" id="Append"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1560-L1563">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Append"><span class="name">Append</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HAppend">HAppend</a></code>: <code>a ++ b : α</code> where <code>a b : α</code>.</p><ul class="structure_fields" id="Append.mk"><li id="Append.append" class="structure_field"><div class="structure_field_info">append : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a ++ b</code> is the result of concatenation of <code>a</code> and <code>b</code>. See <code><a href=".././Init/Prelude.html#HAppend">HAppend</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Append" class="instances-list"></ul></details></div></div><div class="decl" id="OrElse"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1565-L1572">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#OrElse"><span class="name">OrElse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HOrElse">HOrElse</a></code>: <code>a &lt;|&gt; b : α</code> where <code>a b : α</code>.
Because <code>b</code> is &quot;lazy&quot; in this notation, it is passed as <code><a href=".././Init/Prelude.html#Unit">Unit</a> → α</code> to the
implementation so it can decide when to evaluate it.</p><ul class="structure_fields" id="OrElse.mk"><li id="OrElse.orElse" class="structure_field"><div class="structure_field_info">orElse : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">α</span>)</span> → <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>The implementation of <code>a &lt;|&gt; b : α</code>. See <code><a href=".././Init/Prelude.html#HOrElse">HOrElse</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-OrElse" class="instances-list"></ul></details></div></div><div class="decl" id="AndThen"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1574-L1581">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#AndThen"><span class="name">AndThen</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HAndThen">HAndThen</a></code>: <code>a &gt;&gt; b : α</code> where <code>a b : α</code>.
Because <code>b</code> is &quot;lazy&quot; in this notation, it is passed as <code><a href=".././Init/Prelude.html#Unit">Unit</a> → α</code> to the
implementation so it can decide when to evaluate it.</p><ul class="structure_fields" id="AndThen.mk"><li id="AndThen.andThen" class="structure_field"><div class="structure_field_info">andThen : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">α</span>)</span> → <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>The implementation of <code>a &gt;&gt; b : α</code>. See <code><a href=".././Init/Prelude.html#HAndThen">HAndThen</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-AndThen" class="instances-list"></ul></details></div></div><div class="decl" id="AndOp"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1583-L1589">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#AndOp"><span class="name">AndOp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HAnd">HAnd</a></code>: <code>a &amp;&amp;&amp; b : α</code> where <code>a b : α</code>.
(It is called <code><a href=".././Init/Prelude.html#AndOp">AndOp</a></code> because <code><a href=".././Init/Prelude.html#And">And</a></code> is taken for the propositional connective.)</p><ul class="structure_fields" id="AndOp.mk"><li id="AndOp.and" class="structure_field"><div class="structure_field_info">and : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p>The implementation of <code>a &amp;&amp;&amp; b : α</code>. See <code><a href=".././Init/Prelude.html#HAnd">HAnd</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-AndOp" class="instances-list"></ul></details></div></div><div class="decl" id="XorOp"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1591-L1594">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#XorOp"><span class="name">XorOp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HXor">HXor</a></code>: <code>a ^^^ b : α</code> where <code>a b : α</code>.</p><ul class="structure_fields" id="XorOp.mk"><li id="XorOp.xor" class="structure_field"><div class="structure_field_info">xor : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p>The implementation of <code>a ^^^ b : α</code>. See <code><a href=".././Init/Prelude.html#HXor">HXor</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-XorOp" class="instances-list"></ul></details></div></div><div class="decl" id="OrOp"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1596-L1602">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#OrOp"><span class="name">OrOp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HOr">HOr</a></code>: <code>a ||| b : α</code> where <code>a b : α</code>.
(It is called <code><a href=".././Init/Prelude.html#OrOp">OrOp</a></code> because <code><a href=".././Init/Prelude.html#Or">Or</a></code> is taken for the propositional connective.)</p><ul class="structure_fields" id="OrOp.mk"><li id="OrOp.or" class="structure_field"><div class="structure_field_info">or : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p>The implementation of <code>a ||| b : α</code>. See <code><a href=".././Init/Prelude.html#HOr">HOr</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-OrOp" class="instances-list"></ul></details></div></div><div class="decl" id="Complement"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1604-L1607">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Complement"><span class="name">Complement</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The typeclass behind the notation <code>~~~a : α</code> where <code>a : α</code>.</p><ul class="structure_fields" id="Complement.mk"><li id="Complement.complement" class="structure_field"><div class="structure_field_info">complement : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p>The implementation of <code>~~~a : α</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>~~~</code> in identifiers is <code><a href=".././Init/Prelude.html#Bool.not">not</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Complement" class="instances-list"></ul></details></div></div><div class="decl" id="ShiftLeft"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1609-L1612">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ShiftLeft"><span class="name">ShiftLeft</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HShiftLeft">HShiftLeft</a></code>: <code>a &lt;&lt;&lt; b : α</code> where <code>a b : α</code>.</p><ul class="structure_fields" id="ShiftLeft.mk"><li id="ShiftLeft.shiftLeft" class="structure_field"><div class="structure_field_info">shiftLeft : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p>The implementation of <code>a &lt;&lt;&lt; b : α</code>. See <code><a href=".././Init/Prelude.html#HShiftLeft">HShiftLeft</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-ShiftLeft" class="instances-list"></ul></details></div></div><div class="decl" id="ShiftRight"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1614-L1617">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ShiftRight"><span class="name">ShiftRight</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HShiftRight">HShiftRight</a></code>: <code>a &gt;&gt;&gt; b : α</code> where <code>a b : α</code>.</p><ul class="structure_fields" id="ShiftRight.mk"><li id="ShiftRight.shiftRight" class="structure_field"><div class="structure_field_info">shiftRight : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p>The implementation of <code>a &gt;&gt;&gt; b : α</code>. See <code><a href=".././Init/Prelude.html#HShiftRight">HShiftRight</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-ShiftRight" class="instances-list"></ul></details></div></div><div class="decl" id="instHAdd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1619-L1621">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHAdd"><span class="name">instHAdd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Add">Add</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HAdd">HAdd</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHAdd">instHAdd</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HAdd.mk">{</a> <span class="fn">hAdd</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#Add.add">Add.add</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HAdd.mk">}</a></li></ul></details></div></div><div class="decl" id="instHSub"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1623-L1625">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHSub"><span class="name">instHSub</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Sub">Sub</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HSub">HSub</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHSub">instHSub</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HSub.mk">{</a> <span class="fn">hSub</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#Sub.sub">Sub.sub</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HSub.mk">}</a></li></ul></details></div></div><div class="decl" id="instHMul"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1627-L1629">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHMul"><span class="name">instHMul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Mul">Mul</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HMul">HMul</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHMul">instHMul</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HMul.mk">{</a> <span class="fn">hMul</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#Mul.mul">Mul.mul</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HMul.mk">}</a></li></ul></details></div></div><div class="decl" id="instHDiv"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1631-L1633">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHDiv"><span class="name">instHDiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Div">Div</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HDiv">HDiv</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHDiv">instHDiv</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HDiv.mk">{</a> <span class="fn">hDiv</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#Div.div">Div.div</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HDiv.mk">}</a></li></ul></details></div></div><div class="decl" id="instHMod"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1635-L1637">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHMod"><span class="name">instHMod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Mod">Mod</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HMod">HMod</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHMod">instHMod</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HMod.mk">{</a> <span class="fn">hMod</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#Mod.mod">Mod.mod</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HMod.mk">}</a></li></ul></details></div></div><div class="decl" id="instHPow"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1639-L1641">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHPow"><span class="name">instHPow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Pow">Pow</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HPow">HPow</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHPow">instHPow</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HPow.mk">{</a> <span class="fn">hPow</span> := <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#Pow.pow">Pow.pow</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HPow.mk">}</a></li></ul></details></div></div><div class="decl" id="instPowNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1643-L1645">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instPowNat"><span class="name">instPowNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#NatPow">NatPow</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Pow">Pow</a> <span class="fn">α</span> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instPowNat">instPowNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Pow.mk">{</a> <span class="fn">pow</span> := <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#NatPow.pow">NatPow.pow</a> <span class="fn">a</span> <span class="fn">n</span></span></span> <a href=".././Init/Prelude.html#Pow.mk">}</a></li></ul></details></div></div><div class="decl" id="instPowOfHomogeneousPow"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1647-L1649">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instPowOfHomogeneousPow"><span class="name">instPowOfHomogeneousPow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#HomogeneousPow">HomogeneousPow</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Pow">Pow</a> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instPowOfHomogeneousPow">instPowOfHomogeneousPow</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Pow.mk">{</a> <span class="fn">pow</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#HomogeneousPow.pow">HomogeneousPow.pow</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#Pow.mk">}</a></li></ul></details></div></div><div class="decl" id="instHSMul"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1651-L1653">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHSMul"><span class="name">instHSMul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#SMul">SMul</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HSMul">HSMul</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">β</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHSMul">instHSMul</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HSMul.mk">{</a> <span class="fn">hSMul</span> := <a href=".././Init/Prelude.html#SMul.smul">SMul.smul</a> <a href=".././Init/Prelude.html#HSMul.mk">}</a></li></ul></details></div></div><div class="decl" id="instSMulOfMul"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1655-L1656">source</a></div><div class="attributes">@[instance 910]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instSMulOfMul"><span class="name">instSMulOfMul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Mul">Mul</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#SMul">SMul</a> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instSMulOfMul">instSMulOfMul</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#SMul.mk">{</a> <span class="fn">smul</span> := <span class="fn">fun (<span class="fn">x</span> <span class="fn">y</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#Mul.mul">Mul.mul</a> <span class="fn">x</span> <span class="fn">y</span></span></span> <a href=".././Init/Prelude.html#SMul.mk">}</a></li></ul></details></div></div><div class="decl" id="instHAppendOfAppend"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1658-L1660">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHAppendOfAppend"><span class="name">instHAppendOfAppend</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Append">Append</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HAppend">HAppend</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHAppendOfAppend">instHAppendOfAppend</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HAppend.mk">{</a> <span class="fn">hAppend</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#Append.append">Append.append</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HAppend.mk">}</a></li></ul></details></div></div><div class="decl" id="instHOrElseOfOrElse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1662-L1664">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHOrElseOfOrElse"><span class="name">instHOrElseOfOrElse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#OrElse">OrElse</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HOrElse">HOrElse</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHOrElseOfOrElse">instHOrElseOfOrElse</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HOrElse.mk">{</a> <span class="fn">hOrElse</span> := <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">α</span></span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#OrElse.orElse">OrElse.orElse</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HOrElse.mk">}</a></li></ul></details></div></div><div class="decl" id="instHAndThenOfAndThen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1666-L1668">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHAndThenOfAndThen"><span class="name">instHAndThenOfAndThen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#AndThen">AndThen</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HAndThen">HAndThen</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHAndThenOfAndThen">instHAndThenOfAndThen</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HAndThen.mk">{</a> <span class="fn">hAndThen</span> := <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">α</span></span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#AndThen.andThen">AndThen.andThen</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HAndThen.mk">}</a></li></ul></details></div></div><div class="decl" id="instHAndOfAndOp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1670-L1672">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHAndOfAndOp"><span class="name">instHAndOfAndOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#AndOp">AndOp</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HAnd">HAnd</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHAndOfAndOp">instHAndOfAndOp</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HAnd.mk">{</a> <span class="fn">hAnd</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#AndOp.and">AndOp.and</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HAnd.mk">}</a></li></ul></details></div></div><div class="decl" id="instHXorOfXorOp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1674-L1676">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHXorOfXorOp"><span class="name">instHXorOfXorOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#XorOp">XorOp</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HXor">HXor</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHXorOfXorOp">instHXorOfXorOp</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HXor.mk">{</a> <span class="fn">hXor</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#XorOp.xor">XorOp.xor</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HXor.mk">}</a></li></ul></details></div></div><div class="decl" id="instHOrOfOrOp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1678-L1680">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHOrOfOrOp"><span class="name">instHOrOfOrOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#OrOp">OrOp</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HOr">HOr</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHOrOfOrOp">instHOrOfOrOp</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HOr.mk">{</a> <span class="fn">hOr</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#OrOp.or">OrOp.or</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HOr.mk">}</a></li></ul></details></div></div><div class="decl" id="instHShiftLeftOfShiftLeft"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1682-L1684">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHShiftLeftOfShiftLeft"><span class="name">instHShiftLeftOfShiftLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#ShiftLeft">ShiftLeft</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HShiftLeft">HShiftLeft</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHShiftLeftOfShiftLeft">instHShiftLeftOfShiftLeft</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HShiftLeft.mk">{</a> <span class="fn">hShiftLeft</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#ShiftLeft.shiftLeft">ShiftLeft.shiftLeft</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HShiftLeft.mk">}</a></li></ul></details></div></div><div class="decl" id="instHShiftRightOfShiftRight"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1686-L1688">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHShiftRightOfShiftRight"><span class="name">instHShiftRightOfShiftRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#ShiftRight">ShiftRight</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HShiftRight">HShiftRight</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHShiftRightOfShiftRight">instHShiftRightOfShiftRight</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HShiftRight.mk">{</a> <span class="fn">hShiftRight</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#ShiftRight.shiftRight">ShiftRight.shiftRight</a> <span class="fn">a</span> <span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#HShiftRight.mk">}</a></li></ul></details></div></div><div class="decl" id="Membership"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1696-L1703">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Membership"><span class="name">Membership</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">γ</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>The typeclass behind the notation <code>a ∈ s : Prop</code> where <code>a : α</code>, <code>s : γ</code>.
Because <code>α</code> is an <code><a href=".././Init/Prelude.html#outParam">outParam</a></code>, the &quot;container type&quot; <code>γ</code> determines the type
of the elements of the container.</p><ul class="structure_fields" id="Membership.mk"><li id="Membership.mem" class="structure_field"><div class="structure_field_info">mem : <span class="fn"><span class="fn">γ</span> → <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></span></div><div class="structure_field_doc"><p>The membership relation <code>a ∈ s : Prop</code> where <code>a : α</code>, <code>s : γ</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∈</code> in identifiers is <code><a href=".././Init/Prelude.html#Membership.mem">mem</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Membership" class="instances-list"></ul></details></div></div><div class="decl" id="Nat.add"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1706-L1715">source</a></div><div class="attributes">@[match_pattern, extern lean_nat_add]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.add"><span class="name">Nat</span>.<span class="name">add</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Addition of natural numbers, typically used via the <code>+</code> operator.</p><p>This function is overridden in both the kernel and the compiler to efficiently evaluate using the
arbitrary-precision arithmetic library. The definition provided here is the logical model.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Nat.add">add</a></span> <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Nat.add">add</a></span> <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Nat.add">add</a></span> <span class="fn">b</span>)</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></li></ul></details><details id="instances-for-list-Nat.add" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instAddNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1717-L1718">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instAddNat"><span class="name">instAddNat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Add">Add</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instAddNat">instAddNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Add.mk">{</a> <span class="fn">add</span> := <a href=".././Init/Prelude.html#Nat.add">Nat.add</a> <a href=".././Init/Prelude.html#Add.mk">}</a></li></ul></details></div></div><div class="decl" id="Nat.mul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1725-L1734">source</a></div><div class="attributes">@[extern lean_nat_mul]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.mul"><span class="name">Nat</span>.<span class="name">mul</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Multiplication of natural numbers, usually accessed via the <code>*</code> operator.</p><p>This function is overridden in both the kernel and the compiler to efficiently evaluate using the
arbitrary-precision arithmetic library. The definition provided here is the logical model.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Nat.mul">mul</a></span> <span class="fn">0</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Nat.mul">mul</a></span> <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Nat.mul">mul</a></span> <span class="fn">b</span>)</span>.<a href=".././Init/Prelude.html#Nat.add">add</a></span> <span class="fn">x✝</span></span></li></ul></details><details id="instances-for-list-Nat.mul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instMulNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1736-L1737">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMulNat"><span class="name">instMulNat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Mul">Mul</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instMulNat">instMulNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Mul.mk">{</a> <span class="fn">mul</span> := <a href=".././Init/Prelude.html#Nat.mul">Nat.mul</a> <a href=".././Init/Prelude.html#Mul.mk">}</a></li></ul></details></div></div><div class="decl" id="Nat.pow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1740-L1749">source</a></div><div class="attributes">@[extern lean_nat_pow]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.pow"><span class="name">Nat</span>.<span class="name">pow</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>The power operation on natural numbers, usually accessed via the <code>^</code> operator.</p><p>This function is overridden in both the kernel and the compiler to efficiently evaluate using the
arbitrary-precision arithmetic library. The definition provided here is the logical model.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.pow">pow</a></span> <span class="fn">0</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">1</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.pow">pow</a></span> <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.pow">pow</a></span> <span class="fn">n</span>)</span>.<a href=".././Init/Prelude.html#Nat.mul">mul</a></span> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Nat.pow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instNatPowNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1751-L1751">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instNatPowNat"><span class="name">instNatPowNat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#NatPow">NatPow</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instNatPowNat">instNatPowNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#NatPow.mk">{</a> <span class="fn">pow</span> := <a href=".././Init/Prelude.html#Nat.pow">Nat.pow</a> <a href=".././Init/Prelude.html#NatPow.mk">}</a></li></ul></details></div></div><div class="decl" id="Nat.beq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1754-L1765">source</a></div><div class="attributes">@[extern lean_nat_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.beq"><span class="name">Nat</span>.<span class="name">beq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Boolean equality of natural numbers, usually accessed via the <code>==</code> operator.</p><p>This function is overridden in both the kernel and the compiler to efficiently evaluate using the
arbitrary-precision arithmetic library. The definition provided here is the logical model.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a>.<a href=".././Init/Prelude.html#Nat.beq">beq</a></span> <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a>.<a href=".././Init/Prelude.html#Nat.beq">beq</a></span> <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span>.<a href=".././Init/Prelude.html#Nat.beq">beq</a></span> <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span>.<a href=".././Init/Prelude.html#Nat.beq">beq</a></span> <span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.beq">beq</a></span> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Nat.beq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.eq_of_beq_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1767-L1774">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.eq_of_beq_eq_true"><span class="name">Nat</span>.<span class="name">eq_of_beq_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.beq">beq</a></span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a> → <span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span></div></div></div></div><div class="decl" id="Nat.ne_of_beq_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1776-L1782">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.ne_of_beq_eq_false"><span class="name">Nat</span>.<span class="name">ne_of_beq_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.beq">beq</a></span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a> → <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span></div></div></div></div><div class="decl" id="noConfusion_of_Nat"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1789-L1795">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#noConfusion_of_Nat"><span class="name">noConfusion_of_Nat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href=".././Init/Prelude.html#Nat">Nat</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Bool.rec">Bool.rec</a> <a href=".././Init/Prelude.html#False">False</a> <a href=".././Init/Prelude.html#True">True</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span>.<a href=".././Init/Prelude.html#Nat.beq">beq</a></span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span>)</span></span></div></div><p>A helper theorem to deduce <code><a href=".././Init/Prelude.html#False">False</a></code> from <code>a = b</code> when <code>f a ≠ f b</code> for some function <code>f : α → <a href=".././Init/Prelude.html#Nat">Nat</a></code>
(typically <code>.ctorIdx</code>). Used as a simpler alternative to the no-confusion theorems.</p></div></div><div class="decl" id="Nat.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1798-L1814">source</a></div><div class="attributes">@[reducible, extern lean_nat_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.decEq"><span class="name">Nat</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span>)</span></div></div><p>A decision procedure for equality of natural numbers, usually accessed via the <code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#Nat">Nat</a></code>
instance.</p><p>This function is overridden in both the kernel and the compiler to efficiently evaluate using the
arbitrary-precision arithmetic library. The definition provided here is the logical model.</p><p>Examples:</p><ul>
<li><code><a href=".././Init/Prelude.html#Nat.decEq">Nat.decEq</a> 5 5 = <a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <a href=".././Init/Prelude.html#rfl">rfl</a></code></li>
<li><code>(if 3 = 4 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>show 12 = 12 by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.decEq">decEq</a></span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match h : <span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.beq">beq</a></span> <span class="fn">m</span></span> with
  | <a href=".././Init/Prelude.html#Bool.true">true</a> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span>
  | <a href=".././Init/Prelude.html#Bool.false">false</a> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Nat.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1816-L1816">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqNat"><span class="name">instDecidableEqNat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableEqNat">instDecidableEqNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Nat.decEq">Nat.decEq</a></li></ul></details></div></div><div class="decl" id="Nat.ble"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1819-L1835">source</a></div><div class="attributes">@[extern lean_nat_dec_le]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.ble"><span class="name">Nat</span>.<span class="name">ble</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>The Boolean less-than-or-equal-to comparison on natural numbers.</p><p>This function is overridden in both the kernel and the compiler to efficiently evaluate using the
arbitrary-precision arithmetic library. The definition provided here is the logical model.</p><p>Examples:</p><ul>
<li><code><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> 2 5 = <a href=".././Init/Prelude.html#Bool.true">true</a></code></li>
<li><code><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> 5 2 = <a href=".././Init/Prelude.html#Bool.false">false</a></code></li>
<li><code><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> 5 5 = <a href=".././Init/Prelude.html#Bool.true">true</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a>.<a href=".././Init/Prelude.html#Nat.ble">ble</a></span> <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a>.<a href=".././Init/Prelude.html#Nat.ble">ble</a></span> <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span>.<a href=".././Init/Prelude.html#Nat.ble">ble</a></span> <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span>.<a href=".././Init/Prelude.html#Nat.ble">ble</a></span> <span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.ble">ble</a></span> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Nat.ble" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.le"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1837-L1844">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le"><span class="name">Nat</span>.<span class="name">le</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././foundational_types.html">Prop</a></span></div></div><p>Non-strict, or weak, inequality of natural numbers, usually accessed via the <code>≤</code> operator.</p><ul class="constructors"><li class="constructor" id="Nat.le.refl">refl<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.le">le</a></span> <span class="fn">n</span></span><div class="inductive_ctor_doc"><p>Non-strict inequality is reflexive: <code>n ≤ n</code></p></div></li><li class="constructor" id="Nat.le.step">step<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.le">le</a></span> <span class="fn">m</span></span> → <span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.le">le</a></span> <span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span></span><div class="inductive_ctor_doc"><p>If <code>n ≤ m</code>, then <code>n ≤ m + 1</code>.</p></div></li></ul><details id="instances-for-list-Nat.le" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instLENat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1846-L1847">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLENat"><span class="name">instLENat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instLENat">instLENat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#LE.mk">{</a> <span class="fn">le</span> := <a href=".././Init/Prelude.html#Nat.le">Nat.le</a> <a href=".././Init/Prelude.html#LE.mk">}</a></li></ul></details></div></div><div class="decl" id="Nat.lt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1849-L1855">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt"><span class="name">Nat</span>.<span class="name">lt</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>Strict inequality of natural numbers, usually accessed via the <code>&lt;</code> operator.</p><p>It is defined as <code>n &lt; m = n + 1 ≤ m</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.lt">lt</a></span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span>.<a href=".././Init/Prelude.html#Nat.le">le</a></span> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Nat.lt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instLTNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1857-L1858">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLTNat"><span class="name">instLTNat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instLTNat">instLTNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#LT.mk">{</a> <span class="fn">lt</span> := <a href=".././Init/Prelude.html#Nat.lt">Nat.lt</a> <a href=".././Init/Prelude.html#LT.mk">}</a></li></ul></details></div></div><div class="decl" id="Nat.not_succ_le_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1860-L1862">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.not_succ_le_zero"><span class="name">Nat</span>.<span class="name">not_succ_le_zero</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">0</span> → <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="Nat.not_lt_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1864-L1865">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.not_lt_zero"><span class="name">Nat</span>.<span class="name">not_lt_zero</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Nat.zero_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1867-L1869">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.zero_le"><span class="name">Nat</span>.<span class="name">zero_le</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></div></div></div></div><div class="decl" id="Nat.succ_le_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1871-L1873">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.succ_le_succ"><span class="name">Nat</span>.<span class="name">succ_le_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span> → <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span></div></div></div></div><div class="decl" id="Nat.zero_lt_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1875-L1876">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.zero_lt_succ"><span class="name">Nat</span>.<span class="name">zero_lt_succ</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></div></div></div></div><div class="decl" id="Nat.le_step"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1878-L1879">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_step"><span class="name">Nat</span>.<span class="name">le_step</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></div></div></div></div><div class="decl" id="Nat.le_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1881-L1883">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_trans"><span class="name">Nat</span>.<span class="name">le_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m </span><span class="fn">k</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span> → <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">k</span> → <span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">k</span></span></span></div></div></div></div><div class="decl" id="Nat.lt_of_lt_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1885-L1886">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_of_lt_of_le"><span class="name">Nat</span>.<span class="name">lt_of_lt_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m </span><span class="fn">k</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">m</span> → <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">k</span> → <span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">k</span></span></span></div></div></div></div><div class="decl" id="Nat.lt_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1888-L1889">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_trans"><span class="name">Nat</span>.<span class="name">lt_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m </span><span class="fn">k</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">k</span> → <span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Nat.le_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1891-L1892">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_succ"><span class="name">Nat</span>.<span class="name">le_succ</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></div></div></div></div><div class="decl" id="Nat.le_succ_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1894-L1895">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_succ_of_le"><span class="name">Nat</span>.<span class="name">le_succ_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></div></div></div></div><div class="decl" id="Nat.le_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1897-L1898">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_refl"><span class="name">Nat</span>.<span class="name">le_refl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></div></div></div></div><div class="decl" id="Nat.succ_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1900-L1901">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.succ_pos"><span class="name">Nat</span>.<span class="name">succ_pos</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></div></div></div></div><div class="decl" id="Nat.pred"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1904-L1914">source</a></div><div class="attributes">@[extern lean_nat_pred]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.pred"><span class="name">Nat</span>.<span class="name">pred</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>The predecessor of a natural number is one less than it. The predecessor of <code>0</code> is defined to be
<code>0</code>.</p><p>This definition is overridden in the compiler with an efficient implementation. This definition is
the logical model.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Nat.pred">Nat.pred</a> <span class="fn">0</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span>.<a href=".././Init/Prelude.html#Nat.pred">pred</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">n</span></li></ul></details><details id="instances-for-list-Nat.pred" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.pred_le_pred"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1916-L1919">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.pred_le_pred"><span class="name">Nat</span>.<span class="name">pred_le_pred</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span> → <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.pred">pred</a></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.pred">pred</a></span></span></div></div></div></div><div class="decl" id="Nat.le_of_succ_le_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1921-L1922">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_of_succ_le_succ"><span class="name">Nat</span>.<span class="name">le_of_succ_le_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> → <span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span></div></div></div></div><div class="decl" id="Nat.le_of_lt_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1924-L1925">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_of_lt_succ"><span class="name">Nat</span>.<span class="name">le_of_lt_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> → <span class="fn">m</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></span></div></div></div></div><div class="decl" id="Nat.eq_or_lt_of_le"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1929-L1937">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.eq_or_lt_of_le"><span class="name">Nat</span>.<span class="name">eq_or_lt_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span> → <span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></li></ul></details><details id="instances-for-list-Nat.eq_or_lt_of_le" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.lt_or_ge"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1939-L1948">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_or_ge"><span class="name">Nat</span>.<span class="name">lt_or_ge</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">m</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">n</span> <a href=".././Init/Prelude.html#GE.ge">≥</a> <span class="fn">m</span></div></div></div></div><div class="decl" id="Nat.not_succ_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1950-L1952">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.not_succ_le_self"><span class="name">Nat</span>.<span class="name">not_succ_le_self</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></div></div></div></div><div class="decl" id="Nat.lt_irrefl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1954-L1955">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_irrefl"><span class="name">Nat</span>.<span class="name">lt_irrefl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">n</span></div></div></div></div><div class="decl" id="Nat.lt_of_le_of_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1957-L1958">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_of_le_of_lt"><span class="name">Nat</span>.<span class="name">lt_of_le_of_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m </span><span class="fn">k</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">m</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">k</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Nat.le_antisymm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1960-L1963">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_antisymm"><span class="name">Nat</span>.<span class="name">le_antisymm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">m</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></div></div></div></div><div class="decl" id="Nat.lt_of_le_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1965-L1968">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_of_le_of_ne"><span class="name">Nat</span>.<span class="name">lt_of_le_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">m</span></div></div></div></div><div class="decl" id="Nat.le_of_ble_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1970-L1973">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_of_ble_eq_true"><span class="name">Nat</span>.<span class="name">le_of_ble_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.ble">ble</a></span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></div></div></div></div><div class="decl" id="Nat.ble_self_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1975-L1977">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.ble_self_eq_true"><span class="name">Nat</span>.<span class="name">ble_self_eq_true</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.ble">ble</a></span> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Nat.ble_succ_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1979-L1981">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.ble_succ_eq_true"><span class="name">Nat</span>.<span class="name">ble_succ_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.ble">ble</a></span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.ble">ble</a></span> <span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Nat.ble_eq_true_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1983-L1986">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.ble_eq_true_of_le"><span class="name">Nat</span>.<span class="name">ble_eq_true_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.ble">ble</a></span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Nat.not_le_of_not_ble_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1988-L1989">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.not_le_of_not_ble_eq_true"><span class="name">Nat</span>.<span class="name">not_le_of_not_ble_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.ble">ble</a></span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></div></div></div></div><div class="decl" id="Nat.lt_succ_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1991-L1991">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_succ_of_le"><span class="name">Nat</span>.<span class="name">lt_succ_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span> → <span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span></div></div></div></div><div class="decl" id="Nat.lt_add_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1993-L1993">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_add_one"><span class="name">Nat</span>.<span class="name">lt_add_one</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">n</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Nat.lt_succ_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1995-L1995">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_succ_self"><span class="name">Nat</span>.<span class="name">lt_succ_self</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></div></div></div></div><div class="decl" id="Nat.lt_of_not_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L1997-L1998">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_of_not_le"><span class="name">Nat</span>.<span class="name">lt_of_not_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Nat.add_pos_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2000-L2002">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.add_pos_right"><span class="name">Nat</span>.<span class="name">add_pos_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Nat.mul_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2004-L2006">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.mul_pos"><span class="name">Nat</span>.<span class="name">mul_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hn</span> : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">n</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hm</span> : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">n</span> <a href=".././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">m</span></div></div></div></div><div class="decl" id="Nat.pow_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2008-L2010">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.pow_pos"><span class="name">Nat</span>.<span class="name">pow_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a</span> <a href=".././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">n</span></div></div></div></div><div class="decl" id="Nat.decLe"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2012-L2024">source</a></div><div class="attributes">@[extern lean_nat_dec_le]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.decLe"><span class="name">Nat</span>.<span class="name">decLe</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span>)</span></div></div><p>A decision procedure for non-strict inequality of natural numbers, usually accessed via the
<code><a href=".././Init/Prelude.html#DecidableLE">DecidableLE</a> <a href=".././Init/Prelude.html#Nat">Nat</a></code> instance.</p><p>Examples:</p><ul>
<li><code>(if 3 ≤ 4 then &quot;yes&quot; else &quot;no&quot;) = &quot;yes&quot;</code></li>
<li><code>(if 6 ≤ 4 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>show 12 ≤ 12 by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
<li><code>show 5 ≤ 12 by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.decLe">decLe</a></span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.ble">ble</a></span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="Nat.decLt"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2026-L2038">source</a></div><div class="attributes">@[extern lean_nat_dec_lt]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.decLt"><span class="name">Nat</span>.<span class="name">decLt</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">m</span>)</span></div></div><p>A decision procedure for strict inequality of natural numbers, usually accessed via the
<code><a href=".././Init/Prelude.html#DecidableLT">DecidableLT</a> <a href=".././Init/Prelude.html#Nat">Nat</a></code> instance.</p><p>Examples:</p><ul>
<li><code>(if 3 &lt; 4 then &quot;yes&quot; else &quot;no&quot;) = &quot;yes&quot;</code></li>
<li><code>(if 4 &lt; 4 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>(if 6 &lt; 4 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>show 5 &lt; 12 by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.decLt">decLt</a></span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span>.<a href=".././Init/Prelude.html#Nat.decLe">decLe</a></span> <span class="fn">m</span></span></li></ul></details></div></div><div class="decl" id="instMinNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2040-L2040">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMinNat"><span class="name">instMinNat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Min">Min</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instMinNat">instMinNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#minOfLe">minOfLe</a></li></ul></details></div></div><div class="decl" id="Nat.sub"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2043-L2060">source</a></div><div class="attributes">@[extern lean_nat_sub]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.sub"><span class="name">Nat</span>.<span class="name">sub</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Subtraction of natural numbers, truncated at <code>0</code>. Usually used via the <code>-</code> operator.</p><p>If a result would be less than zero, then the result is zero.</p><p>This definition is overridden in both the kernel and the compiler to efficiently evaluate using the
arbitrary-precision arithmetic library. The definition provided here is the logical model.</p><p>Examples:</p><ul>
<li><code>5 - 3 = 2</code></li>
<li><code>8 - 2 = 6</code></li>
<li><code>8 - 8 = 0</code></li>
<li><code>8 - 20 = 0</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Nat.sub">sub</a></span> <span class="fn">0</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Nat.sub">sub</a></span> <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Nat.sub">sub</a></span> <span class="fn">b</span>)</span>.<a href=".././Init/Prelude.html#Nat.pred">pred</a></span></li></ul></details><details id="instances-for-list-Nat.sub" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instSubNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2062-L2063">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instSubNat"><span class="name">instSubNat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Sub">Sub</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instSubNat">instSubNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Sub.mk">{</a> <span class="fn">sub</span> := <a href=".././Init/Prelude.html#Nat.sub">Nat.sub</a> <a href=".././Init/Prelude.html#Sub.mk">}</a></li></ul></details></div></div><div class="decl" id="Nat.succ_sub_succ_eq_sub"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2065-L2066">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.succ_sub_succ_eq_sub"><span class="name">Nat</span>.<span class="name">succ_sub_succ_eq_sub</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">n</span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">m</span></div></div></div></div><div class="decl" id="Nat.pred_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2068-L2070">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.pred_le"><span class="name">Nat</span>.<span class="name">pred_le</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.pred">pred</a></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></div></div></div></div><div class="decl" id="Nat.sub_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2072-L2073">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.sub_le"><span class="name">Nat</span>.<span class="name">sub_le</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">m</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></div></div></div></div><div class="decl" id="Nat.sub_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2075-L2081">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.sub_lt"><span class="name">Nat</span>.<span class="name">sub_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">n</span> → <span class="fn"><span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">m</span> → <span class="fn">n</span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">m</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">n</span></span></span></div></div></div></div><div class="decl" id="Nat.div_rec_lemma"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2083-L2085">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.div_rec_lemma"><span class="name">Nat</span>.<span class="name">div_rec_lemma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">y</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span> → <span class="fn">x</span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">y</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="Nat.div_rec_fuel_lemma"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2087-L2089">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.div_rec_fuel_lemma"><span class="name">Nat</span>.<span class="name">div_rec_fuel_lemma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y </span><span class="fn">fuel</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hy</span> : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hle</span> : <span class="fn">y</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hfuel</span> : <span class="fn">x</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">fuel</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">y</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">fuel</span></div></div></div></div><div class="decl" id="Nat.div"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2092-L2119">source</a></div><div class="attributes">@[irreducible, extern lean_nat_div]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.div"><span class="name">Nat</span>.<span class="name">div</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Division of natural numbers, discarding the remainder. Division by <code>0</code> returns <code>0</code>. Usually accessed
via the <code>/</code> operator.</p><p>This operation is sometimes called “floor division.”</p><p>This function is overridden at runtime with an efficient implementation. This definition is
the logical model.</p><p>Examples:</p><ul>
<li><code>21 / 3 = 7</code></li>
<li><code>21 / 5 = 4</code></li>
<li><code>0 / 22 = 0</code></li>
<li><code>5 / 0 = 0</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#Nat.div">div</a></span> <span class="fn">y</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if hy : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span> then <span class="fn"><a href=".././Init/Prelude.html#Nat.div.go">Nat.div.go</a> <span class="fn">y</span> <span class="fn">hy</span> <span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <span class="fn">x</span> <span class="fn">⋯</span></span> else <span class="fn">0</span></span></li></ul></details><details id="instances-for-list-Nat.div" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.div.go"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2111-L2116">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.div.go"><span class="name">Nat</span>.<span class="name">div</span>.<span class="name">go</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">y</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hy</span> : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fuel </span><span class="fn">x</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hfuel</span> : <span class="fn">x</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">fuel</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Nat.div.go">Nat.div.go</a> <span class="fn">y</span> <span class="fn">hy</span> <span class="fn"><span class="fn">fuel_2</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <span class="fn">x</span> <span class="fn">hfuel_2</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">y</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span> then <span class="fn"><a href=".././Init/Prelude.html#Nat.div.go">Nat.div.go</a> <span class="fn">y</span> <span class="fn">hy</span> <span class="fn">fuel_2</span> (<span class="fn">x</span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">y</span>) <span class="fn">⋯</span></span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> else <span class="fn">0</span></span></li></ul></details><details id="instances-for-list-Nat.div.go" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.instDiv"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2121-L2121">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.instDiv"><span class="name">Nat</span>.<span class="name">instDiv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Div">Div</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Nat.instDiv">Nat.instDiv</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Div.mk">{</a> <span class="fn">div</span> := <a href=".././Init/Prelude.html#Nat.div">Nat.div</a> <a href=".././Init/Prelude.html#Div.mk">}</a></li></ul></details></div></div><div class="decl" id="Nat.modCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2124-L2150">source</a></div><div class="attributes">@[irreducible, extern lean_nat_mod]</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.modCore"><span class="name">Nat</span>.<span class="name">modCore</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The modulo operator, which computes the remainder when dividing one natural number by another.
Usually accessed via the <code>%</code> operator. When the divisor is <code>0</code>, the result is the dividend rather
than an error.</p><p>This is the core implementation of <code><a href=".././Init/Prelude.html#Nat.mod">Nat.mod</a></code>. It computes the correct result for any two closed
natural numbers, but it does not have some convenient <a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=type-system">definitional
reductions</a> when the <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>s contain free variables. The wrapper
<code><a href=".././Init/Prelude.html#Nat.mod">Nat.mod</a></code> handles those cases specially and then calls <code><a href=".././Init/Prelude.html#Nat.modCore">Nat.modCore</a></code>.</p><p>This function is overridden at runtime with an efficient implementation. This definition is the
logical model.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#Nat.modCore">modCore</a></span> <span class="fn">y</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if hy : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span> then <span class="fn"><a href=".././Init/Prelude.html#Nat.modCore.go">Nat.modCore.go</a> <span class="fn">y</span> <span class="fn">hy</span> <span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <span class="fn">x</span> <span class="fn">⋯</span></span> else <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Nat.modCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.modCore.go"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2142-L2147">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.modCore.go"><span class="name">Nat</span>.<span class="name">modCore</span>.<span class="name">go</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">y</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hy</span> : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fuel </span><span class="fn">x</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hfuel</span> : <span class="fn">x</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">fuel</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Nat.modCore.go">Nat.modCore.go</a> <span class="fn">y</span> <span class="fn">hy</span> <span class="fn"><span class="fn">fuel_2</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <span class="fn">x</span> <span class="fn">hfuel_2</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">y</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span> then <span class="fn"><a href=".././Init/Prelude.html#Nat.modCore.go">Nat.modCore.go</a> <span class="fn">y</span> <span class="fn">hy</span> <span class="fn">fuel_2</span> (<span class="fn">x</span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">y</span>) <span class="fn">⋯</span></span> else <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Nat.modCore.go" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.modCoreGo_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2152-L2159">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.modCoreGo_lt"><span class="name">Nat</span>.<span class="name">modCoreGo_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fuel </span><span class="fn">y</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hy</span> : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hfuel</span> : <span class="fn">x</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">fuel</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat.modCore.go">modCore.go</a> <span class="fn">y</span> <span class="fn">hy</span> <span class="fn">fuel</span> <span class="fn">x</span> <span class="fn">hfuel</span></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="Nat.modCore_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2161-L2165">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.modCore_lt"><span class="name">Nat</span>.<span class="name">modCore_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hy</span> : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#Nat.modCore">modCore</a></span> <span class="fn">y</span></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="Nat.mod"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2170-L2207">source</a></div><div class="attributes">@[extern lean_nat_mod]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.mod"><span class="name">Nat</span>.<span class="name">mod</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>The modulo operator, which computes the remainder when dividing one natural number by another.
Usually accessed via the <code>%</code> operator. When the divisor is <code>0</code>, the result is the dividend rather
than an error.</p><p><code><a href=".././Init/Prelude.html#Nat.mod">Nat.mod</a></code> is a wrapper around <code><a href=".././Init/Prelude.html#Nat.modCore">Nat.modCore</a></code> that special-cases two situations, giving better
definitional reductions:</p><ul>
<li><code><a href=".././Init/Prelude.html#Nat.mod">Nat.mod</a> 0 m</code> should reduce to <code>m</code>, for all terms <code>m : <a href=".././Init/Prelude.html#Nat">Nat</a></code>.</li>
<li><code><a href=".././Init/Prelude.html#Nat.mod">Nat.mod</a> n (m + n + 1)</code> should reduce to <code>n</code> for concrete <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> literals <code>n</code>.</li>
</ul><p>These reductions help <code><a href=".././Init/Prelude.html#Fin">Fin</a> n</code> literals work well, because the <code><a href=".././Init/Prelude.html#OfNat">OfNat</a></code> instance for <code><a href=".././Init/Prelude.html#Fin">Fin</a></code> uses
<code><a href=".././Init/Prelude.html#Nat.mod">Nat.mod</a></code>. In particular, <code>(0 : <a href=".././Init/Prelude.html#Fin">Fin</a> (n + 1)).<a href=".././Init/Prelude.html#Subtype.val">val</a></code> should reduce definitionally to <code>0</code>. <code><a href=".././Init/Prelude.html#Nat.modCore">Nat.modCore</a></code>
can handle all numbers, but its definitional reductions are not as convenient.</p><p>This function is overridden at runtime with an efficient implementation. This definition is the
logical model.</p><p>Examples:</p><ul>
<li><code>7 % 2 = 1</code></li>
<li><code>9 % 3 = 0</code></li>
<li><code>5 % 7 = 5</code></li>
<li><code>5 % 0 = 5</code></li>
<li><code>show ∀ (n : Nat), 0 % n = 0 from fun _ =&gt; <a href=".././Init/Prelude.html#rfl">rfl</a></code></li>
<li><code>show ∀ (m : Nat), 5 % (m + 6) = 5 from fun _ =&gt; <a href=".././Init/Prelude.html#rfl">rfl</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Nat.mod">Nat.mod</a> <span class="fn">0</span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span>.<a href=".././Init/Prelude.html#Nat.mod">mod</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#ite">if</a> <span class="fn">x✝</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <a href=".././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span>.<a href=".././Init/Prelude.html#Nat.modCore">modCore</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></li></ul></details><details id="instances-for-list-Nat.mod" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.instMod"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2209-L2209">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.instMod"><span class="name">Nat</span>.<span class="name">instMod</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Mod">Mod</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Nat.instMod">Nat.instMod</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Mod.mk">{</a> <span class="fn">mod</span> := <a href=".././Init/Prelude.html#Nat.mod">Nat.mod</a> <a href=".././Init/Prelude.html#Mod.mk">}</a></li></ul></details></div></div><div class="decl" id="Nat.mod_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2211-L2217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.mod_lt"><span class="name">Nat</span>.<span class="name">mod_lt</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hy</span> : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href=".././Init/Prelude.html#HMod.hMod">%</a> <span class="fn">y</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="System.Platform.getNumBits"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2221-L2230">source</a></div><div class="attributes">@[extern lean_system_platform_nbits]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#System.Platform.getNumBits"><span class="name">System</span>.<span class="name">Platform</span>.<span class="name">getNumBits</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <a href=".././Init/Prelude.html#Subtype">{</a> <span class="fn">n</span> <a href=".././Init/Prelude.html#Subtype">:</a> <a href=".././Init/Prelude.html#Nat">Nat</a> <a href=".././Init/Prelude.html#Subtype">//</a> <span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">32</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">64</span> <a href=".././Init/Prelude.html#Subtype">}</a></span></div></div><p>Gets the word size of the current platform. The word size may be 64 or 32 bits.</p><p>This function is opaque because there is no guarantee at compile time that the target will have the
same word size as the host. It also helps avoid having type checking be architecture-dependent.</p><p>Lean only works on 64 and 32 bit systems. This fact is visible in the return type.</p></div></div><div class="decl" id="System.Platform.numBits"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2232-L2236">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#System.Platform.numBits"><span class="name">System</span>.<span class="name">Platform</span>.<span class="name">numBits</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The word size of the current platform, which may be 64 or 32 bits.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#System.Platform.numBits">System.Platform.numBits</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#System.Platform.getNumBits">System.Platform.getNumBits</a> <a href=".././Init/Prelude.html#Unit.unit">(</a><a href=".././Init/Prelude.html#Unit.unit">)</a>)</span>.<a href=".././Init/Prelude.html#Subtype.val">val</a></span></li></ul></details><details id="instances-for-list-System.Platform.numBits" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="System.Platform.numBits_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2238-L2242">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#System.Platform.numBits_eq"><span class="name">System</span>.<span class="name">Platform</span>.<span class="name">numBits_eq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#System.Platform.numBits">numBits</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">32</span> <a href=".././Init/Prelude.html#Or">∨</a> <a href=".././Init/Prelude.html#System.Platform.numBits">numBits</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">64</span></div></div><p>The word size of the current platform may be 64 or 32 bits.</p></div></div><div class="decl" id="Fin"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2244-L2263">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Fin"><span class="name">Fin</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Natural numbers less than some upper bound.</p><p>In particular, a <code><a href=".././Init/Prelude.html#Fin">Fin</a> n</code> is a natural number <code>i</code> with the constraint that <code>i &lt; n</code>. It is the
canonical type with <code>n</code> elements.</p><ul class="structure_fields" id="Fin.mk"><li id="Fin.val" class="structure_field"><div class="structure_field_info">val : <a href=".././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>The number that is strictly less than <code>n</code>.</p><p><code><a href=".././Init/Prelude.html#Fin.val">Fin.val</a></code> is a coercion, so any <code><a href=".././Init/Prelude.html#Fin">Fin</a> n</code> can be used in a position where a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> is expected.</p></div></li><li id="Fin.isLt" class="structure_field"><div class="structure_field_info">isLt : <span class="fn">↑<span class="fn">self</span></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">n</span></div><div class="structure_field_doc"><p>The number <code><a href=".././Init/Prelude.html#Subtype.val">val</a></code> is strictly less than the bound <code>n</code>.</p></div></li></ul><details id="instances-for-list-Fin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Fin.eq_of_val_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2267-L2268">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Fin.eq_of_val_eq"><span class="name">Fin</span>.<span class="name">eq_of_val_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i </span><span class="fn">j</span> : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn">i</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">↑<span class="fn">j</span></span> → <span class="fn">i</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span></div></div></div></div><div class="decl" id="Fin.val_eq_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2270-L2271">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Fin.val_eq_of_eq"><span class="name">Fin</span>.<span class="name">val_eq_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i </span><span class="fn">j</span> : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">i</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">j</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">↑<span class="fn">i</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">↑<span class="fn">j</span></span></div></div></div></div><div class="decl" id="instDecidableEqFin"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2273-L2277">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqFin"><span class="name">instDecidableEqFin</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">(<a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instDecidableEqFin">instDecidableEqFin</a> <span class="fn">n</span> <span class="fn">i</span> <span class="fn">j</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href=".././Init/Prelude.html#decEq">decEq</a> <span class="fn">↑<span class="fn">i</span></span> <span class="fn">↑<span class="fn">j</span></span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">h</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="instLTFin"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2279-L2280">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLTFin"><span class="name">instLTFin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">(<a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instLTFin">instLTFin</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#LT.mk">{</a> <span class="fn">lt</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>) =&gt; <span class="fn">↑<span class="fn">a</span></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">↑<span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#LT.mk">}</a></li></ul></details></div></div><div class="decl" id="instLEFin"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2282-L2283">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLEFin"><span class="name">instLEFin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">(<a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instLEFin">instLEFin</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#LE.mk">{</a> <span class="fn">le</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>) =&gt; <span class="fn">↑<span class="fn">a</span></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑<span class="fn">b</span></span></span> <a href=".././Init/Prelude.html#LE.mk">}</a></li></ul></details></div></div><div class="decl" id="Fin.decLt"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2285-L2285">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Fin.decLt"><span class="name">Fin</span>.<span class="name">decLt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Fin.decLt">decLt</a></span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(↑<span class="fn">a</span>)</span>.<a href=".././Init/Prelude.html#Nat.decLt">decLt</a></span> <span class="fn">↑<span class="fn">b</span></span></span></li></ul></details></div></div><div class="decl" id="Fin.decLe"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2286-L2286">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Fin.decLe"><span class="name">Fin</span>.<span class="name">decLe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Fin.decLe">decLe</a></span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(↑<span class="fn">a</span>)</span>.<a href=".././Init/Prelude.html#Nat.decLe">decLe</a></span> <span class="fn">↑<span class="fn">b</span></span></span></li></ul></details></div></div><div class="decl" id="Fin.Internal.ofNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2288-L2294">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Fin.Internal.ofNat"><span class="name">Fin</span>.<span class="name">Internal</span>.<span class="name">ofNat</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hn</span> : <span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">n</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span></div></div><p>Returns <code>a</code> modulo <code>n</code> as a <code><a href=".././Init/Prelude.html#Fin">Fin</a> n</code>.</p><p>This function exists for bootstrapping purposes. Use <code><a href=".././Init/Data/Fin/Basic.html#Fin.ofNat">Fin.ofNat</a></code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Fin.Internal.ofNat">Fin.Internal.ofNat</a> <span class="fn">n</span> <span class="fn">hn</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Fin.mk">⟨</a><span class="fn">a</span> <a href=".././Init/Prelude.html#HMod.hMod">%</a> <span class="fn">n</span>, <span class="fn">⋯</span><a href=".././Init/Prelude.html#Fin.mk">⟩</a></li></ul></details><details id="instances-for-list-Fin.Internal.ofNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2296-L2308">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#BitVec"><span class="name">BitVec</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>A bitvector of the specified width.</p><p>This is represented as the underlying <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> number in both the runtime
and the kernel, inheriting all the special support for <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.</p><ul class="structure_ext"><li id="BitVec.ofFin" class="structure_ext_ctor">ofFin :: (</li><ul class="structure_ext_fields"><li id="BitVec.toFin" class="structure_field"><div class="structure_field_info">toFin : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> (<span class="fn">2</span> <a href=".././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">w</span>)</span></div><div class="structure_field_doc"><p>Interpret a bitvector as a number less than <code>2^w</code>.
O(1), because we use <code><a href=".././Init/Prelude.html#Fin">Fin</a></code> as the internal representation of a bitvector.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-BitVec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2310-L2323">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#BitVec.decEq"><span class="name">BitVec</span>.<span class="name">decEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">w</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">x</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span></div></div><p>Bitvectors have decidable equality.</p><p>This should be used via the instance <code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> (BitVec w)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#BitVec.ofFin">{</a> <span class="fn">toFin</span> := <span class="fn">n</span> <a href=".././Init/Prelude.html#BitVec.ofFin">}</a>.<a href=".././Init/Prelude.html#BitVec.decEq">decEq</a></span> <a href=".././Init/Prelude.html#BitVec.ofFin">{</a> <span class="fn">toFin</span> := <span class="fn">m</span> <a href=".././Init/Prelude.html#BitVec.ofFin">}</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-BitVec.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqBitVec"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2325-L2325">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqBitVec"><span class="name">instDecidableEqBitVec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">w</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">(<a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableEqBitVec">instDecidableEqBitVec</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#BitVec.decEq">BitVec.decEq</a></li></ul></details></div></div><div class="decl" id="BitVec.ofNatLT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2327-L2330">source</a></div><div class="attributes">@[match_pattern]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#BitVec.ofNatLT"><span class="name">BitVec</span>.<span class="name">ofNatLT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">w</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">i</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">2</span> <a href=".././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span></div></div><p>The <code><a href=".././Init/Prelude.html#BitVec">BitVec</a></code> with value <code>i</code>, given a proof that <code>i &lt; 2^w</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">i</span><a href=".././Init/Prelude.html#BitVec.ofNatLT">#'</a><span class="fn">p</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#BitVec.ofFin">{</a> <span class="fn">toFin</span> := <a href=".././Init/Prelude.html#Fin.mk">⟨</a><span class="fn">i</span>, <span class="fn">p</span><a href=".././Init/Prelude.html#Fin.mk">⟩</a> <a href=".././Init/Prelude.html#BitVec.ofFin">}</a></li></ul></details><details id="instances-for-list-BitVec.ofNatLT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.ofNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2332-L2337">source</a></div><div class="attributes">@[match_pattern]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#BitVec.ofNat"><span class="name">BitVec</span>.<span class="name">ofNat</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">i</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">n</span></span></div></div><p>The bitvector with value <code>i <a href=".././Init/Prelude.html#Mod.mod">mod</a> 2^n</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li><p>The recommended spelling of <code>0#n</code> in identifiers is <code><a href=".././Init/Prelude.html#Nat.zero">zero</a></code> (not <code>ofNat_zero</code>).</p>
</li>
<li><p>The recommended spelling of <code>1#n</code> in identifiers is <code><a href=".././Init/Prelude.html#One.one">one</a></code> (not <code>ofNat_one</code>).</p>
</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#BitVec.ofNat">BitVec.ofNat</a> <span class="fn">n</span> <span class="fn">i</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#BitVec.ofFin">{</a> <span class="fn">toFin</span> := <span class="fn"><a href=".././Init/Prelude.html#Fin.Internal.ofNat">Fin.Internal.ofNat</a> (<span class="fn">2</span> <a href=".././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">n</span>) <span class="fn">⋯</span> <span class="fn">i</span></span> <a href=".././Init/Prelude.html#BitVec.ofFin">}</a></li></ul></details><details id="instances-for-list-BitVec.ofNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="BitVec.toNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2339-L2345">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#BitVec.toNat"><span class="name">BitVec</span>.<span class="name">toNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">w</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Return the underlying <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> that represents a bitvector.</p><p>This is O(1) because <code><a href=".././Init/Prelude.html#BitVec">BitVec</a></code> is a (zero-cost) wrapper around a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#BitVec.toNat">toNat</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">↑<span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#BitVec.toFin">toFin</a></span></span></li></ul></details><details id="instances-for-list-BitVec.toNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instLTBitVec"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2347-L2347">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLTBitVec"><span class="name">instLTBitVec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">w</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">(<a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instLTBitVec">instLTBitVec</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#LT.mk">{</a> <span class="fn">lt</span> := <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>) =&gt; <span class="fn"><span class="fn">x1</span>.<a href=".././Init/Prelude.html#BitVec.toNat">toNat</a></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">x2</span>.<a href=".././Init/Prelude.html#BitVec.toNat">toNat</a></span></span> <a href=".././Init/Prelude.html#LT.mk">}</a></li></ul></details></div></div><div class="decl" id="instDecidableLtBitVec"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2348-L2349">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableLtBitVec"><span class="name">instDecidableLtBitVec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">w</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">x</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instDecidableLtBitVec">instDecidableLtBitVec</a> <span class="fn">x</span> <span class="fn">y</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#BitVec.toNat">toNat</a></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">y</span>.<a href=".././Init/Prelude.html#BitVec.toNat">toNat</a></span>))</span></span></li></ul></details></div></div><div class="decl" id="instLEBitVec"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2351-L2351">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLEBitVec"><span class="name">instLEBitVec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">w</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">(<a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instLEBitVec">instLEBitVec</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#LE.mk">{</a> <span class="fn">le</span> := <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>) =&gt; <span class="fn"><span class="fn">x1</span>.<a href=".././Init/Prelude.html#BitVec.toNat">toNat</a></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">x2</span>.<a href=".././Init/Prelude.html#BitVec.toNat">toNat</a></span></span> <a href=".././Init/Prelude.html#LE.mk">}</a></li></ul></details></div></div><div class="decl" id="instDecidableLeBitVec"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2352-L2353">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableLeBitVec"><span class="name">instDecidableLeBitVec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">w</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">x</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">y</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instDecidableLeBitVec">instDecidableLeBitVec</a> <span class="fn">x</span> <span class="fn">y</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#BitVec.toNat">toNat</a></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">y</span>.<a href=".././Init/Prelude.html#BitVec.toNat">toNat</a></span>))</span></span></li></ul></details></div></div><div class="decl" id="UInt8.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2355-L2356">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8.size"><span class="name">UInt8</span>.<span class="name">size</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The number of distinct values representable by <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code>, that is, <code>2^8 = 256</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#UInt8.size">UInt8.size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">256</span></li></ul></details><details id="instances-for-list-UInt8.size" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt8"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2358-L2372">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8"><span class="name">UInt8</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Unsigned 8-bit integers.</p><p>This type has special support in the compiler so it can be represented by an unboxed 8-bit value
rather than wrapping a <code><a href=".././Init/Prelude.html#BitVec">BitVec</a> 8</code>.</p><ul class="structure_ext"><li id="UInt8.ofBitVec" class="structure_ext_ctor">ofBitVec :: (</li><ul class="structure_ext_fields"><li id="UInt8.toBitVec" class="structure_field"><div class="structure_field_info">toBitVec : <span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">8</span></span></div><div class="structure_field_doc"><p>Unpacks a <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code> into a <code><a href=".././Init/Prelude.html#BitVec">BitVec</a> 8</code>. This function is overridden with a native implementation.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-UInt8" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt8.ofNatLT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2377-L2385">source</a></div><div class="attributes">@[extern lean_uint8_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8.ofNatLT"><span class="name">UInt8</span>.<span class="name">ofNatLT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <a href=".././Init/Prelude.html#UInt8.size">size</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt8">UInt8</a></div></div><p>Converts a natural number to an 8-bit unsigned integer. Requires a proof that the number is small
enough to be representable without overflow; it must be smaller than <code>2^8</code>.</p><p>This function is overridden at runtime with an efficient implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#UInt8.ofNatLT">UInt8.ofNatLT</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt8.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">n</span><a href=".././Init/Prelude.html#BitVec.ofNatLT">#'</a><span class="fn">h</span> <a href=".././Init/Prelude.html#UInt8.ofBitVec">}</a></li></ul></details><details id="instances-for-list-UInt8.ofNatLT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt8.ofNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2387-L2400">source</a></div><div class="attributes">@[extern lean_uint8_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8.ofNat"><span class="name">UInt8</span>.<span class="name">ofNat</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt8">UInt8</a></div></div><p>Converts a natural number to an 8-bit unsigned integer, wrapping on overflow.</p><p>This function is overridden at runtime with an efficient implementation.</p><p>Examples:</p><ul>
<li><code><a href=".././Init/Prelude.html#UInt8.ofNat">UInt8.ofNat</a> 5 = 5</code></li>
<li><code><a href=".././Init/Prelude.html#UInt8.ofNat">UInt8.ofNat</a> 255 = 255</code></li>
<li><code><a href=".././Init/Prelude.html#UInt8.ofNat">UInt8.ofNat</a> 256 = 0</code></li>
<li><code><a href=".././Init/Prelude.html#UInt8.ofNat">UInt8.ofNat</a> 259 = 3</code></li>
<li><code><a href=".././Init/Prelude.html#UInt8.ofNat">UInt8.ofNat</a> 32770 = 2</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#UInt8.ofNat">UInt8.ofNat</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt8.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn"><a href=".././Init/Prelude.html#BitVec.ofNat">BitVec.ofNat</a> <span class="fn">8</span> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#UInt8.ofBitVec">}</a></li></ul></details><details id="instances-for-list-UInt8.ofNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt8.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2403-L2420">source</a></div><div class="attributes">@[extern lean_uint8_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8.decEq"><span class="name">UInt8</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#UInt8">UInt8</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></div></div><p>Decides whether two 8-bit unsigned integers are equal. Usually accessed via the <code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></code>
instance.</p><p>This function is overridden at runtime with an efficient implementation.</p><p>Examples:</p><ul>
<li><code><a href=".././Init/Prelude.html#UInt8.decEq">UInt8.decEq</a> 123 123 = .<a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <a href=".././Init/Prelude.html#rfl">rfl</a></code></li>
<li><code>(if (6 : UInt8) = 7 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>show (7 : UInt8) = 7 by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt8.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">n</span> <a href=".././Init/Prelude.html#UInt8.ofBitVec">}</a>.<a href=".././Init/Prelude.html#UInt8.decEq">decEq</a></span> <a href=".././Init/Prelude.html#UInt8.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">m</span> <a href=".././Init/Prelude.html#UInt8.ofBitVec">}</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-UInt8.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqUInt8"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2422-L2422">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqUInt8"><span class="name">instDecidableEqUInt8</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableEqUInt8">instDecidableEqUInt8</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt8.decEq">UInt8.decEq</a></li></ul></details></div></div><div class="decl" id="instInhabitedUInt8"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2424-L2425">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedUInt8"><span class="name">instInhabitedUInt8</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedUInt8">instInhabitedUInt8</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#UInt8.ofNatLT">UInt8.ofNatLT</a> <span class="fn">0</span> <a href=".././Init/Prelude.html#instInhabitedUInt8._proof_1">instInhabitedUInt8._proof_1</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="UInt8.lt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2427-L2431">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8.lt"><span class="name">UInt8</span>.<span class="name">lt</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#UInt8">UInt8</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>Strict inequality of 8-bit unsigned integers, defined as inequality of the corresponding
natural numbers. Usually accessed via the <code>&lt;</code> operator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt8.lt">lt</a></span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt8.toBitVec">toBitVec</a></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#UInt8.toBitVec">toBitVec</a></span>)</li></ul></details><details id="instances-for-list-UInt8.lt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt8.le"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2432-L2436">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8.le"><span class="name">UInt8</span>.<span class="name">le</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#UInt8">UInt8</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>Non-strict inequality of 8-bit unsigned integers, defined as inequality of the corresponding
natural numbers. Usually accessed via the <code>≤</code> operator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt8.le">le</a></span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt8.toBitVec">toBitVec</a></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#UInt8.toBitVec">toBitVec</a></span>)</li></ul></details><details id="instances-for-list-UInt8.le" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instLTUInt8"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2437-L2437">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLTUInt8"><span class="name">instLTUInt8</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instLTUInt8">instLTUInt8</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#LT.mk">{</a> <span class="fn">lt</span> := <a href=".././Init/Prelude.html#UInt8.lt">UInt8.lt</a> <a href=".././Init/Prelude.html#LT.mk">}</a></li></ul></details></div></div><div class="decl" id="instLEUInt8"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2438-L2438">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLEUInt8"><span class="name">instLEUInt8</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instLEUInt8">instLEUInt8</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#LE.mk">{</a> <span class="fn">le</span> := <a href=".././Init/Prelude.html#UInt8.le">UInt8.le</a> <a href=".././Init/Prelude.html#LE.mk">}</a></li></ul></details></div></div><div class="decl" id="UInt8.decLt"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2440-L2453">source</a></div><div class="attributes">@[extern lean_uint8_dec_lt]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8.decLt"><span class="name">UInt8</span>.<span class="name">decLt</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#UInt8">UInt8</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></div></div><p>Decides whether one 8-bit unsigned integer is strictly less than another. Usually accessed via the
<code><a href=".././Init/Prelude.html#DecidableLT">DecidableLT</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></code> instance.</p><p>This function is overridden at runtime with an efficient implementation.</p><p>Examples:</p><ul>
<li><code>(if (6 : UInt8) &lt; 7 then &quot;yes&quot; else &quot;no&quot;) = &quot;yes&quot;</code></li>
<li><code>(if (5 : UInt8) &lt; 5 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>show ¬((7 : UInt8) &lt; 7) by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt8.decLt">decLt</a></span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt8.toBitVec">toBitVec</a></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#UInt8.toBitVec">toBitVec</a></span>))</span></span></li></ul></details></div></div><div class="decl" id="UInt8.decLe"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2455-L2469">source</a></div><div class="attributes">@[extern lean_uint8_dec_le]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8.decLe"><span class="name">UInt8</span>.<span class="name">decLe</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#UInt8">UInt8</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span>)</span></div></div><p>Decides whether one 8-bit unsigned integer is less than or equal to another. Usually accessed via the
<code><a href=".././Init/Prelude.html#DecidableLE">DecidableLE</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></code> instance.</p><p>This function is overridden at runtime with an efficient implementation.</p><p>Examples:</p><ul>
<li><code>(if (15 : UInt8) ≤ 15 then &quot;yes&quot; else &quot;no&quot;) = &quot;yes&quot;</code></li>
<li><code>(if (15 : UInt8) ≤ 5 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>(if (5 : UInt8) ≤ 15 then &quot;yes&quot; else &quot;no&quot;) = &quot;yes&quot;</code></li>
<li><code>show (7 : UInt8) ≤ 7 by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt8.decLe">decLe</a></span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt8.toBitVec">toBitVec</a></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#UInt8.toBitVec">toBitVec</a></span>))</span></span></li></ul></details></div></div><div class="decl" id="UInt16.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2473-L2474">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt16.size"><span class="name">UInt16</span>.<span class="name">size</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The number of distinct values representable by <code><a href=".././Init/Prelude.html#UInt16">UInt16</a></code>, that is, <code>2^16 = 65536</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#UInt16.size">UInt16.size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">65536</span></li></ul></details><details id="instances-for-list-UInt16.size" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt16"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2476-L2490">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt16"><span class="name">UInt16</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Unsigned 16-bit integers.</p><p>This type has special support in the compiler so it can be represented by an unboxed 16-bit value
rather than wrapping a <code><a href=".././Init/Prelude.html#BitVec">BitVec</a> 16</code>.</p><ul class="structure_ext"><li id="UInt16.ofBitVec" class="structure_ext_ctor">ofBitVec :: (</li><ul class="structure_ext_fields"><li id="UInt16.toBitVec" class="structure_field"><div class="structure_field_info">toBitVec : <span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">16</span></span></div><div class="structure_field_doc"><p>Unpacks a <code><a href=".././Init/Prelude.html#UInt16">UInt16</a></code> into a <code><a href=".././Init/Prelude.html#BitVec">BitVec</a> 16</code>. This function is overridden with a native implementation.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-UInt16" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt16.ofNatLT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2495-L2503">source</a></div><div class="attributes">@[extern lean_uint16_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt16.ofNatLT"><span class="name">UInt16</span>.<span class="name">ofNatLT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <a href=".././Init/Prelude.html#UInt16.size">size</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt16">UInt16</a></div></div><p>Converts a natural number to a 16-bit unsigned integer. Requires a proof that the number is small
enough to be representable without overflow; it must be smaller than <code>2^16</code>.</p><p>This function is overridden at runtime with an efficient implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#UInt16.ofNatLT">UInt16.ofNatLT</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt16.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">n</span><a href=".././Init/Prelude.html#BitVec.ofNatLT">#'</a><span class="fn">h</span> <a href=".././Init/Prelude.html#UInt16.ofBitVec">}</a></li></ul></details><details id="instances-for-list-UInt16.ofNatLT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt16.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2507-L2524">source</a></div><div class="attributes">@[extern lean_uint16_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt16.decEq"><span class="name">UInt16</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#UInt16">UInt16</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></div></div><p>Decides whether two 16-bit unsigned integers are equal. Usually accessed via the
<code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#UInt16">UInt16</a></code> instance.</p><p>This function is overridden at runtime with an efficient implementation.</p><p>Examples:</p><ul>
<li><code><a href=".././Init/Prelude.html#UInt16.decEq">UInt16.decEq</a> 123 123 = .<a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <a href=".././Init/Prelude.html#rfl">rfl</a></code></li>
<li><code>(if (6 : UInt16) = 7 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>show (7 : UInt16) = 7 by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt16.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">n</span> <a href=".././Init/Prelude.html#UInt16.ofBitVec">}</a>.<a href=".././Init/Prelude.html#UInt16.decEq">decEq</a></span> <a href=".././Init/Prelude.html#UInt16.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">m</span> <a href=".././Init/Prelude.html#UInt16.ofBitVec">}</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-UInt16.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqUInt16"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2526-L2526">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqUInt16"><span class="name">instDecidableEqUInt16</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#UInt16">UInt16</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableEqUInt16">instDecidableEqUInt16</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt16.decEq">UInt16.decEq</a></li></ul></details></div></div><div class="decl" id="instInhabitedUInt16"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2528-L2529">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedUInt16"><span class="name">instInhabitedUInt16</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#UInt16">UInt16</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedUInt16">instInhabitedUInt16</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#UInt16.ofNatLT">UInt16.ofNatLT</a> <span class="fn">0</span> <a href=".././Init/Prelude.html#instInhabitedUInt16._proof_1">instInhabitedUInt16._proof_1</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="UInt32.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2531-L2532">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.size"><span class="name">UInt32</span>.<span class="name">size</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The number of distinct values representable by <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code>, that is, <code>2^32 = 4294967296</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#UInt32.size">UInt32.size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">4294967296</span></li></ul></details><details id="instances-for-list-UInt32.size" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt32"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2534-L2548">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32"><span class="name">UInt32</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Unsigned 32-bit integers.</p><p>This type has special support in the compiler so it can be represented by an unboxed 32-bit value
rather than wrapping a <code><a href=".././Init/Prelude.html#BitVec">BitVec</a> 32</code>.</p><ul class="structure_ext"><li id="UInt32.ofBitVec" class="structure_ext_ctor">ofBitVec :: (</li><ul class="structure_ext_fields"><li id="UInt32.toBitVec" class="structure_field"><div class="structure_field_info">toBitVec : <span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">32</span></span></div><div class="structure_field_doc"><p>Unpacks a <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code> into a <code><a href=".././Init/Prelude.html#BitVec">BitVec</a> 32</code>. This function is overridden with a native implementation.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-UInt32" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt32.ofNatLT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2553-L2561">source</a></div><div class="attributes">@[extern lean_uint32_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.ofNatLT"><span class="name">UInt32</span>.<span class="name">ofNatLT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <a href=".././Init/Prelude.html#UInt32.size">size</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt32">UInt32</a></div></div><p>Converts a natural number to a 32-bit unsigned integer. Requires a proof that the number is small
enough to be representable without overflow; it must be smaller than <code>2^32</code>.</p><p>This function is overridden at runtime with an efficient implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#UInt32.ofNatLT">UInt32.ofNatLT</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt32.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">n</span><a href=".././Init/Prelude.html#BitVec.ofNatLT">#'</a><span class="fn">h</span> <a href=".././Init/Prelude.html#UInt32.ofBitVec">}</a></li></ul></details><details id="instances-for-list-UInt32.ofNatLT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt32.toNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2563-L2569">source</a></div><div class="attributes">@[extern lean_uint32_to_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.toNat"><span class="name">UInt32</span>.<span class="name">toNat</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Converts a 32-bit unsigned integer to an arbitrary-precision natural number.</p><p>This function is overridden at runtime with an efficient implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#UInt32.toNat">toNat</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#UInt32.toBitVec">toBitVec</a></span>.<a href=".././Init/Prelude.html#BitVec.toNat">toNat</a></span></li></ul></details><details id="instances-for-list-UInt32.toNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt32.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2572-L2587">source</a></div><div class="attributes">@[extern lean_uint32_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.decEq"><span class="name">UInt32</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></div></div><p>Decides whether two 32-bit unsigned integers are equal. Usually accessed via the
<code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></code> instance.</p><p>This function is overridden at runtime with an efficient implementation.</p><p>Examples:</p><ul>
<li><code><a href=".././Init/Prelude.html#UInt32.decEq">UInt32.decEq</a> 123 123 = .<a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <a href=".././Init/Prelude.html#rfl">rfl</a></code></li>
<li><code>(if (6 : UInt32) = 7 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>show (7 : UInt32) = 7 by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt32.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">n</span> <a href=".././Init/Prelude.html#UInt32.ofBitVec">}</a>.<a href=".././Init/Prelude.html#UInt32.decEq">decEq</a></span> <a href=".././Init/Prelude.html#UInt32.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">m</span> <a href=".././Init/Prelude.html#UInt32.ofBitVec">}</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-UInt32.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqUInt32"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2589-L2589">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqUInt32"><span class="name">instDecidableEqUInt32</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableEqUInt32">instDecidableEqUInt32</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt32.decEq">UInt32.decEq</a></li></ul></details></div></div><div class="decl" id="instInhabitedUInt32"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2591-L2592">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedUInt32"><span class="name">instInhabitedUInt32</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedUInt32">instInhabitedUInt32</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#UInt32.ofNatLT">UInt32.ofNatLT</a> <span class="fn">0</span> <a href=".././Init/Prelude.html#instInhabitedUInt32._proof_1">instInhabitedUInt32._proof_1</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instLTUInt32"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2594-L2595">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLTUInt32"><span class="name">instLTUInt32</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instLTUInt32">instLTUInt32</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#LT.mk">{</a> <span class="fn">lt</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <a href=".././Init/Prelude.html#UInt32">UInt32</a>) =&gt; <span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt32.toBitVec">toBitVec</a></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#UInt32.toBitVec">toBitVec</a></span></span> <a href=".././Init/Prelude.html#LT.mk">}</a></li></ul></details></div></div><div class="decl" id="instLEUInt32"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2597-L2598">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLEUInt32"><span class="name">instLEUInt32</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instLEUInt32">instLEUInt32</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#LE.mk">{</a> <span class="fn">le</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <a href=".././Init/Prelude.html#UInt32">UInt32</a>) =&gt; <span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt32.toBitVec">toBitVec</a></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#UInt32.toBitVec">toBitVec</a></span></span> <a href=".././Init/Prelude.html#LE.mk">}</a></li></ul></details></div></div><div class="decl" id="UInt32.decLt"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2600-L2613">source</a></div><div class="attributes">@[extern lean_uint32_dec_lt]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.decLt"><span class="name">UInt32</span>.<span class="name">decLt</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></div></div><p>Decides whether one 8-bit unsigned integer is strictly less than another. Usually accessed via the
<code><a href=".././Init/Prelude.html#DecidableLT">DecidableLT</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></code> instance.</p><p>This function is overridden at runtime with an efficient implementation.</p><p>Examples:</p><ul>
<li><code>(if (6 : UInt32) &lt; 7 then &quot;yes&quot; else &quot;no&quot;) = &quot;yes&quot;</code></li>
<li><code>(if (5 : UInt32) &lt; 5 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>show ¬((7 : UInt32) &lt; 7) by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt32.decLt">decLt</a></span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt32.toBitVec">toBitVec</a></span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#UInt32.toBitVec">toBitVec</a></span>))</span></span></li></ul></details></div></div><div class="decl" id="UInt32.decLe"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2615-L2629">source</a></div><div class="attributes">@[extern lean_uint32_dec_le]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.decLe"><span class="name">UInt32</span>.<span class="name">decLe</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span>)</span></div></div><p>Decides whether one 32-bit signed integer is less than or equal to another. Usually accessed via the
<code><a href=".././Init/Prelude.html#DecidableLE">DecidableLE</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></code> instance.</p><p>This function is overridden at runtime with an efficient implementation.</p><p>Examples:</p><ul>
<li><code>(if (15 : UInt32) ≤ 15 then &quot;yes&quot; else &quot;no&quot;) = &quot;yes&quot;</code></li>
<li><code>(if (15 : UInt32) ≤ 5 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>(if (5 : UInt32) ≤ 15 then &quot;yes&quot; else &quot;no&quot;) = &quot;yes&quot;</code></li>
<li><code>show (7 : UInt32) ≤ 7 by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt32.decLe">decLe</a></span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#UInt32.toBitVec">toBitVec</a></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#UInt32.toBitVec">toBitVec</a></span>))</span></span></li></ul></details></div></div><div class="decl" id="instMaxUInt32"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2633-L2633">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMaxUInt32"><span class="name">instMaxUInt32</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Max">Max</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instMaxUInt32">instMaxUInt32</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#maxOfLe">maxOfLe</a></li></ul></details></div></div><div class="decl" id="instMinUInt32"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2634-L2634">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMinUInt32"><span class="name">instMinUInt32</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Min">Min</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instMinUInt32">instMinUInt32</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#minOfLe">minOfLe</a></li></ul></details></div></div><div class="decl" id="UInt64.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2636-L2637">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt64.size"><span class="name">UInt64</span>.<span class="name">size</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The number of distinct values representable by <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code>, that is, <code>2^64 = 18446744073709551616</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#UInt64.size">UInt64.size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">18446744073709551616</span></li></ul></details><details id="instances-for-list-UInt64.size" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt64"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2639-L2653">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt64"><span class="name">UInt64</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Unsigned 64-bit integers.</p><p>This type has special support in the compiler so it can be represented by an unboxed 64-bit value
rather than wrapping a <code><a href=".././Init/Prelude.html#BitVec">BitVec</a> 64</code>.</p><ul class="structure_ext"><li id="UInt64.ofBitVec" class="structure_ext_ctor">ofBitVec :: (</li><ul class="structure_ext_fields"><li id="UInt64.toBitVec" class="structure_field"><div class="structure_field_info">toBitVec : <span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <span class="fn">64</span></span></div><div class="structure_field_doc"><p>Unpacks a <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code> into a <code><a href=".././Init/Prelude.html#BitVec">BitVec</a> 64</code>. This function is overridden with a native implementation.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-UInt64" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt64.ofNatLT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2658-L2666">source</a></div><div class="attributes">@[extern lean_uint64_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt64.ofNatLT"><span class="name">UInt64</span>.<span class="name">ofNatLT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <a href=".././Init/Prelude.html#UInt64.size">size</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt64">UInt64</a></div></div><p>Converts a natural number to a 64-bit unsigned integer. Requires a proof that the number is small
enough to be representable without overflow; it must be smaller than <code>2^64</code>.</p><p>This function is overridden at runtime with an efficient implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#UInt64.ofNatLT">UInt64.ofNatLT</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt64.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">n</span><a href=".././Init/Prelude.html#BitVec.ofNatLT">#'</a><span class="fn">h</span> <a href=".././Init/Prelude.html#UInt64.ofBitVec">}</a></li></ul></details><details id="instances-for-list-UInt64.ofNatLT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt64.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2670-L2687">source</a></div><div class="attributes">@[extern lean_uint64_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt64.decEq"><span class="name">UInt64</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#UInt64">UInt64</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></div></div><p>Decides whether two 64-bit unsigned integers are equal. Usually accessed via the
<code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#UInt64">UInt64</a></code> instance.</p><p>This function is overridden at runtime with an efficient implementation.</p><p>Examples:</p><ul>
<li><code><a href=".././Init/Prelude.html#UInt64.decEq">UInt64.decEq</a> 123 123 = .<a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <a href=".././Init/Prelude.html#rfl">rfl</a></code></li>
<li><code>(if (6 : UInt64) = 7 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>show (7 : UInt64) = 7 by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt64.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">n</span> <a href=".././Init/Prelude.html#UInt64.ofBitVec">}</a>.<a href=".././Init/Prelude.html#UInt64.decEq">decEq</a></span> <a href=".././Init/Prelude.html#UInt64.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">m</span> <a href=".././Init/Prelude.html#UInt64.ofBitVec">}</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-UInt64.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqUInt64"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2689-L2689">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqUInt64"><span class="name">instDecidableEqUInt64</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#UInt64">UInt64</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableEqUInt64">instDecidableEqUInt64</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt64.decEq">UInt64.decEq</a></li></ul></details></div></div><div class="decl" id="instInhabitedUInt64"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2691-L2692">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedUInt64"><span class="name">instInhabitedUInt64</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#UInt64">UInt64</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedUInt64">instInhabitedUInt64</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#UInt64.ofNatLT">UInt64.ofNatLT</a> <span class="fn">0</span> <a href=".././Init/Prelude.html#instInhabitedUInt64._proof_1">instInhabitedUInt64._proof_1</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="USize.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2694-L2695">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#USize.size"><span class="name">USize</span>.<span class="name">size</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The number of distinct values representable by <code><a href=".././Init/Prelude.html#USize">USize</a></code>, that is, <code>2^System.Platform.<a href=".././Init/Prelude.html#System.Platform.numBits">numBits</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#USize.size">USize.size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">2</span> <a href=".././Init/Prelude.html#HPow.hPow">^</a> <a href=".././Init/Prelude.html#System.Platform.numBits">System.Platform.numBits</a></li></ul></details><details id="instances-for-list-USize.size" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="USize.size_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2697-L2701">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#USize.size_eq"><span class="name">USize</span>.<span class="name">size_eq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#USize.size">size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">4294967296</span> <a href=".././Init/Prelude.html#Or">∨</a> <a href=".././Init/Prelude.html#USize.size">size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">18446744073709551616</span></div></div></div></div><div class="decl" id="USize.size_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2703-L2706">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#USize.size_pos"><span class="name">USize</span>.<span class="name">size_pos</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <a href=".././Init/Prelude.html#USize.size">size</a></div></div></div></div><div class="decl" id="USize"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2708-L2724">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#USize"><span class="name">USize</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Unsigned integers that are the size of a word on the platform's architecture.</p><p>On a 32-bit architecture, <code><a href=".././Init/Prelude.html#USize">USize</a></code> is equivalent to <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code>. On a 64-bit machine, it is equivalent
to <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code>.</p><ul class="structure_ext"><li id="USize.ofBitVec" class="structure_ext_ctor">ofBitVec :: (</li><ul class="structure_ext_fields"><li id="USize.toBitVec" class="structure_field"><div class="structure_field_info">toBitVec : <span class="fn"><a href=".././Init/Prelude.html#BitVec">BitVec</a> <a href=".././Init/Prelude.html#System.Platform.numBits">System.Platform.numBits</a></span></div><div class="structure_field_doc"><p>Unpacks a <code><a href=".././Init/Prelude.html#USize">USize</a></code> into a <code><a href=".././Init/Prelude.html#BitVec">BitVec</a> <a href=".././Init/Prelude.html#System.Platform.numBits">System.Platform.numBits</a></code>. This function is overridden with a native
implementation.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-USize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="USize.ofNatLT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2729-L2737">source</a></div><div class="attributes">@[extern lean_usize_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#USize.ofNatLT"><span class="name">USize</span>.<span class="name">ofNatLT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <a href=".././Init/Prelude.html#USize.size">size</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#USize">USize</a></div></div><p>Converts a natural number to a <code><a href=".././Init/Prelude.html#USize">USize</a></code>. Requires a proof that the number is small enough to be
representable without overflow.</p><p>This function is overridden at runtime with an efficient implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#USize.ofNatLT">USize.ofNatLT</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#USize.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">n</span><a href=".././Init/Prelude.html#BitVec.ofNatLT">#'</a><span class="fn">h</span> <a href=".././Init/Prelude.html#USize.ofBitVec">}</a></li></ul></details><details id="instances-for-list-USize.ofNatLT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="USize.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2740-L2757">source</a></div><div class="attributes">@[extern lean_usize_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#USize.decEq"><span class="name">USize</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#USize">USize</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></div></div><p>Decides whether two word-sized unsigned integers are equal. Usually accessed via the
<code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#USize">USize</a></code> instance.</p><p>This function is overridden at runtime with an efficient implementation.</p><p>Examples:</p><ul>
<li><code><a href=".././Init/Prelude.html#USize.decEq">USize.decEq</a> 123 123 = .<a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <a href=".././Init/Prelude.html#rfl">rfl</a></code></li>
<li><code>(if (6 : USize) = 7 then &quot;yes&quot; else &quot;no&quot;) = &quot;no&quot;</code></li>
<li><code>show (7 : USize) = 7 by <a href=".././Init/Prelude.html#Decidable.decide">decide</a></code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#USize.decEq">decEq</a></span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">a</span>, <span class="fn">b</span> with
  | <a href=".././Init/Prelude.html#USize.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">n</span> <a href=".././Init/Prelude.html#USize.ofBitVec">}</a>, <a href=".././Init/Prelude.html#USize.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">m</span> <a href=".././Init/Prelude.html#USize.ofBitVec">}</a> =&gt; <span class="fn">if h : <span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></span></li></ul></details><details id="instances-for-list-USize.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqUSize"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2759-L2759">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqUSize"><span class="name">instDecidableEqUSize</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#USize">USize</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableEqUSize">instDecidableEqUSize</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#USize.decEq">USize.decEq</a></li></ul></details></div></div><div class="decl" id="instInhabitedUSize"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2761-L2762">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedUSize"><span class="name">instInhabitedUSize</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#USize">USize</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedUSize">instInhabitedUSize</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#USize.ofNatLT">USize.ofNatLT</a> <span class="fn">0</span> <a href=".././Init/Prelude.html#USize.size_pos">USize.size_pos</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Nat.isValidChar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2764-L2769">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.isValidChar"><span class="name">Nat</span>.<span class="name">isValidChar</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>A <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> denotes a valid Unicode code point if it is less than <code>0x110000</code> and it is also not a
surrogate code point (the range <code>0xd800</code> to <code>0xdfff</code> inclusive).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.isValidChar">isValidChar</a></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">55296</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">57343</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">n</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">1114112</span>)</li></ul></details><details id="instances-for-list-Nat.isValidChar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UInt32.isValidChar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2771-L2776">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.isValidChar"><span class="name">UInt32</span>.<span class="name">isValidChar</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>A <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code> denotes a valid Unicode code point if it is less than <code>0x110000</code> and it is also not a
surrogate code point (the range <code>0xd800</code> to <code>0xdfff</code> inclusive).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#UInt32.isValidChar">isValidChar</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#UInt32.toNat">toNat</a></span>.<a href=".././Init/Prelude.html#Nat.isValidChar">isValidChar</a></span></li></ul></details><details id="instances-for-list-UInt32.isValidChar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Char"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2778-L2785">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char"><span class="name">Char</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Characters are Unicode <a href="http://www.unicode.org/glossary/#unicode_scalar_value">scalar values</a>.</p><ul class="structure_fields" id="Char.mk"><li id="Char.val" class="structure_field"><div class="structure_field_info">val : <a href=".././Init/Prelude.html#UInt32">UInt32</a></div><div class="structure_field_doc"><p>The underlying Unicode scalar value as a <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code>.</p></div></li><li id="Char.valid" class="structure_field"><div class="structure_field_info">valid : <span class="fn"><span class="fn"><span class="fn">self</span>.<a href=".././Init/Prelude.html#Char.val">val</a></span>.<a href=".././Init/Prelude.html#UInt32.isValidChar">isValidChar</a></span></div><div class="structure_field_doc"><p>The value must be a legal scalar value.</p></div></li></ul><details id="instances-for-list-Char" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Char.ofNatAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2792-L2802">source</a></div><div class="attributes">@[extern lean_uint32_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.ofNatAux"><span class="name">Char</span>.<span class="name">ofNatAux</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.isValidChar">isValidChar</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Char">Char</a></div></div><p>Pack a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> encoding a valid codepoint into a <code><a href=".././Init/Prelude.html#Char">Char</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Char.ofNatAux">Char.ofNatAux</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Char.mk">{</a> <span class="fn">val</span> := <a href=".././Init/Prelude.html#UInt32.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">n</span><a href=".././Init/Prelude.html#BitVec.ofNatLT">#'</a><span class="fn">⋯</span> <a href=".././Init/Prelude.html#UInt32.ofBitVec">}</a>, <span class="fn">valid</span> := <span class="fn">h</span> <a href=".././Init/Prelude.html#Char.mk">}</a></li></ul></details><details id="instances-for-list-Char.ofNatAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Char.ofNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2804-L2812">source</a></div><div class="attributes">@[match_pattern, noinline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.ofNat"><span class="name">Char</span>.<span class="name">ofNat</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Char">Char</a></div></div><p>Converts a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> into a <code><a href=".././Init/Prelude.html#Char">Char</a></code>. If the <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> does not encode a valid Unicode scalar value, <code>'\0'</code> is
returned instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Char.ofNat">Char.ofNat</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.isValidChar">isValidChar</a></span> then <span class="fn"><a href=".././Init/Prelude.html#Char.ofNatAux">Char.ofNatAux</a> <span class="fn">n</span> <span class="fn">h</span></span>
  else <a href=".././Init/Prelude.html#Char.mk">{</a> <span class="fn">val</span> := <a href=".././Init/Prelude.html#UInt32.ofBitVec">{</a> <span class="fn">toBitVec</span> := <span class="fn">0</span><a href=".././Init/Prelude.html#BitVec.ofNatLT">#'</a><a href=".././Init/Prelude.html#Char.ofNat._proof_1">Char.ofNat._proof_1</a> <a href=".././Init/Prelude.html#UInt32.ofBitVec">}</a>, <span class="fn">valid</span> := <a href=".././Init/Prelude.html#Char.ofNat._proof_2">Char.ofNat._proof_2</a> <a href=".././Init/Prelude.html#Char.mk">}</a></span></li></ul></details><details id="instances-for-list-Char.ofNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Char.eq_of_val_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2814-L2815">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.eq_of_val_eq"><span class="name">Char</span>.<span class="name">eq_of_val_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">d</span> : <a href=".././Init/Prelude.html#Char">Char</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href=".././Init/Prelude.html#Char.val">val</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">d</span>.<a href=".././Init/Prelude.html#Char.val">val</a></span> → <span class="fn">c</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></div></div></div></div><div class="decl" id="Char.val_eq_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2817-L2818">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.val_eq_of_eq"><span class="name">Char</span>.<span class="name">val_eq_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">d</span> : <a href=".././Init/Prelude.html#Char">Char</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">c</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">d</span> → <span class="fn"><span class="fn">c</span>.<a href=".././Init/Prelude.html#Char.val">val</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">d</span>.<a href=".././Init/Prelude.html#Char.val">val</a></span></span></div></div></div></div><div class="decl" id="Char.ne_of_val_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2820-L2821">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.ne_of_val_ne"><span class="name">Char</span>.<span class="name">ne_of_val_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">d</span> : <a href=".././Init/Prelude.html#Char">Char</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">c</span>.<a href=".././Init/Prelude.html#Char.val">val</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">d</span>.<a href=".././Init/Prelude.html#Char.val">val</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></div></div></div></div><div class="decl" id="Char.val_ne_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2823-L2824">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.val_ne_of_ne"><span class="name">Char</span>.<span class="name">val_ne_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">d</span> : <a href=".././Init/Prelude.html#Char">Char</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">d</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">c</span>.<a href=".././Init/Prelude.html#Char.val">val</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">d</span>.<a href=".././Init/Prelude.html#Char.val">val</a></span></div></div></div></div><div class="decl" id="instDecidableEqChar"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2826-L2830">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqChar"><span class="name">instDecidableEqChar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#Char">Char</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instDecidableEqChar">instDecidableEqChar</a> <span class="fn">c</span> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href=".././Init/Prelude.html#decEq">decEq</a> <span class="fn"><span class="fn">c</span>.<a href=".././Init/Prelude.html#Char.val">val</a></span> <span class="fn"><span class="fn">d</span>.<a href=".././Init/Prelude.html#Char.val">val</a></span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">h</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="Char.utf8Size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2832-L2837">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.utf8Size"><span class="name">Char</span>.<span class="name">utf8Size</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href=".././Init/Prelude.html#Char">Char</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Returns the number of bytes required to encode this <code><a href=".././Init/Prelude.html#Char">Char</a></code> in UTF-8.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Char.utf8Size" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Option"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2839-L2849">source</a></div><div class="attributes">@[unbox]</div>
<div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Option"><span class="name">Option</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Optional values, which are either <code><a href=".././Init/Prelude.html#Option.some">some</a></code> around a value from the underlying type or <code><a href=".././Init/Prelude.html#Option.none">none</a></code>.</p><p><code><a href=".././Init/Prelude.html#Option">Option</a></code> can represent nullable types or computations that might fail. In the codomain of a function
type, it can also represent partiality.</p><ul class="constructors"><li class="constructor" id="Option.none">none<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span><div class="inductive_ctor_doc"><p>No value.</p></div></li><li class="constructor" id="Option.some">some<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span><div class="inductive_ctor_doc"><p>Some value of type <code>α</code>.</p></div></li></ul><details id="instances-for-list-Option" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedOption"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2855-L2856">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedOption"><span class="name">instInhabitedOption</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedOption">instInhabitedOption</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Option.none">none</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Option.getD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2858-L2871">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Option.getD"><span class="name">Option</span>.<span class="name">getD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">opt</span> : <span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">dflt</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Gets an optional value, returning a given default on <code><a href=".././Init/Prelude.html#Option.none">none</a></code>.</p><p>This function is <code>@[macro_inline]</code>, so <code>dflt</code> will not be evaluated unless <code>opt</code> turns out to be
<code><a href=".././Init/Prelude.html#Option.none">none</a></code>.</p><p>Examples:</p><ul>
<li><code>(some &quot;hello&quot;).<a href=".././Init/Prelude.html#Option.getD">getD</a> &quot;goodbye&quot; = &quot;hello&quot;</code></li>
<li><code>none.<a href=".././Init/Prelude.html#Option.getD">getD</a> &quot;goodbye&quot; = &quot;goodbye&quot;</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span>)</span>.<a href=".././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">dflt</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Option.none">none</a>.<a href=".././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">dflt</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">dflt</span></li></ul></details><details id="instances-for-list-Option.getD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Option.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2873-L2885">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Option.map"><span class="name">Option</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span></div></div><p>Apply a function to an optional value, if present.</p><p>From the perspective of <code><a href=".././Init/Prelude.html#Option">Option</a></code> as a container with at most one value, this is analogous to
<code><a href=".././Init/Prelude.html#List.map">List.map</a></code>. It can also be accessed via the <code><a href=".././Init/Prelude.html#Functor">Functor</a> <a href=".././Init/Prelude.html#Option">Option</a></code> instance.</p><p>Examples:</p><ul>
<li><code>(none : <a href=".././Init/Prelude.html#Option">Option</a> Nat).<a href=".././Init/Prelude.html#Option.map">map</a> (· + 1) = <a href=".././Init/Prelude.html#Option.none">none</a></code></li>
<li><code>(some 3).<a href=".././Init/Prelude.html#Option.map">map</a> (· + 1) = <a href=".././Init/Prelude.html#Option.some">some</a> 4</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span></li><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <a href=".././Init/Prelude.html#Option.none">none</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Option.none">none</a></li></ul></details><details id="instances-for-list-Option.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2887-L2906">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List"><span class="name">List</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Linked lists: ordered lists, in which each element has a reference to the next element.</p><p>Most operations on linked lists take time proportional to the length of the list, because each
element must be traversed to find the next element.</p><p><code><a href=".././Init/Prelude.html#List">List</a> α</code> is isomorphic to <code><a href=".././Init/Prelude.html#Array">Array</a> α</code>, but they are useful for different things:</p><ul>
<li><code><a href=".././Init/Prelude.html#List">List</a> α</code> is easier for reasoning, and <code><a href=".././Init/Prelude.html#Array">Array</a> α</code> is modeled as a wrapper around <code><a href=".././Init/Prelude.html#List">List</a> α</code>.</li>
<li><code><a href=".././Init/Prelude.html#List">List</a> α</code> works well as a persistent data structure, when many copies of the tail are shared. When
the value is not shared, <code><a href=".././Init/Prelude.html#Array">Array</a> α</code> will have better performance because it can do destructive
updates.</li>
</ul><ul class="constructors"><li class="constructor" id="List.nil">nil<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span><div class="inductive_ctor_doc"><p>The empty list, usually written <code>[]</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>[]</code> in identifiers is <code><a href=".././Init/Prelude.html#List.nil">nil</a></code>.</li>
</ul></div></li><li class="constructor" id="List.cons">cons<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">head</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tail</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
 : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span><div class="inductive_ctor_doc"><p>The list whose first element is <code>head</code>, where <code>tail</code> is the rest of the list.
Usually written <code>head :: tail</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li><p>The recommended spelling of <code>::</code> in identifiers is <code><a href=".././Init/Prelude.html#List.cons">cons</a></code>.</p>
</li>
<li><p>The recommended spelling of <code>[a]</code> in identifiers is <code>singleton</code>.</p>
</li>
</ul></div></li></ul><details id="instances-for-list-List" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedList"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2908-L2909">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedList"><span class="name">instInhabitedList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedList">instInhabitedList</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="List.hasDecEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2911-L2922">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.hasDecEq"><span class="name">List</span>.<span class="name">hasDecEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></div></div><p>Implements decidable equality for <code><a href=".././Init/Prelude.html#List">List</a> α</code>, assuming <code>α</code> has decidable equality.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a>.<a href=".././Init/Prelude.html#List.hasDecEq">hasDecEq</a></span> <a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></li><li class="equation"><span class="fn"><span class="fn">(<span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span>).<a href=".././Init/Prelude.html#List.hasDecEq">hasDecEq</a></span> <a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a>.<a href=".././Init/Prelude.html#List.hasDecEq">hasDecEq</a></span> (<span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></li><li class="equation"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span>).<a href=".././Init/Prelude.html#List.hasDecEq">hasDecEq</a></span> (<span class="fn">b</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">bs</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href=".././Init/Prelude.html#decEq">decEq</a> <span class="fn">a</span> <span class="fn">b</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">hab</span></span> =&gt;
    <span class="fn">match <span class="fn"><span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#List.hasDecEq">hasDecEq</a></span> <span class="fn">bs</span></span> with
    | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">habs</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span>
    | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">nabs</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">nab</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-List.hasDecEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqList"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2924-L2924">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqList"><span class="name">instDecidableEqList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">(<a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableEqList">instDecidableEqList</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#List.hasDecEq">List.hasDecEq</a></li></ul></details></div></div><div class="decl" id="List.length"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2926-L2937">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.length"><span class="name">List</span>.<span class="name">length</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>The length of a list.</p><p>This function is overridden in the compiler to <code><a href=".././Init/Prelude.html#List.lengthTR">lengthTR</a></code>, which uses constant stack space.</p><p>Examples:</p><ul>
<li><code>([] : <a href=".././Init/Prelude.html#List">List</a> String).<a href=".././Init/Prelude.html#List.length">length</a> = 0</code></li>
<li><code>[&quot;green&quot;, &quot;brown&quot;].<a href=".././Init/Prelude.html#List.length">length</a> = 2</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a>.<a href=".././Init/Prelude.html#List.length">length</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></li><li class="equation"><span class="fn">(<span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span>).<a href=".././Init/Prelude.html#List.length">length</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#List.length">length</a></span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></li></ul></details><details id="instances-for-list-List.length" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.lengthTRAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2939-L2942">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.lengthTRAux"><span class="name">List</span>.<span class="name">lengthTRAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></span></div></div><p>Auxiliary function for <code><a href=".././Init/Prelude.html#List.lengthTR">List.lengthTR</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a>.<a href=".././Init/Prelude.html#List.lengthTRAux">lengthTRAux</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><span class="fn">(<span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span>).<a href=".././Init/Prelude.html#List.lengthTRAux">lengthTRAux</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#List.lengthTRAux">lengthTRAux</a></span> <span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span></span></li></ul></details><details id="instances-for-list-List.lengthTRAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.lengthTR"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2944-L2955">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.lengthTR"><span class="name">List</span>.<span class="name">lengthTR</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">as</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The length of a list.</p><p>This is a tail-recursive version of <code><a href=".././Init/Prelude.html#List.length">List.length</a></code>, used to implement <code><a href=".././Init/Prelude.html#List.length">List.length</a></code> without running
out of stack space.</p><p>Examples:</p><ul>
<li><code>([] : <a href=".././Init/Prelude.html#List">List</a> String).<a href=".././Init/Prelude.html#List.lengthTR">lengthTR</a> = 0</code></li>
<li><code>[&quot;green&quot;, &quot;brown&quot;].<a href=".././Init/Prelude.html#List.lengthTR">lengthTR</a> = 2</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#List.lengthTR">lengthTR</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#List.lengthTRAux">lengthTRAux</a></span> <span class="fn">0</span></span></li></ul></details><details id="instances-for-list-List.lengthTR" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.get"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2957-L2969">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.get"><span class="name">List</span>.<span class="name">get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">as</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#List.length">length</a></span></span> → <span class="fn">α</span></span></div></div><p>Returns the element at the provided index, counting from <code>0</code>.</p><p>In other words, for <code>i : <a href=".././Init/Prelude.html#Fin">Fin</a> as.<a href=".././Init/Prelude.html#List.length">length</a></code>, <code>as.<a href=".././Init/Prelude.html#List.get">get</a> i</code> returns the <code>i</code>'th element of the list <code>as</code>.
Because the index is a <code><a href=".././Init/Prelude.html#Fin">Fin</a></code> bounded by the list's length, the index will never be out of bounds.</p><p>Examples:</p><ul>
<li><code>[&quot;spring&quot;, &quot;summer&quot;, &quot;fall&quot;, &quot;winter&quot;].<a href=".././Init/Prelude.html#List.get">get</a> (2 : <a href=".././Init/Prelude.html#Fin">Fin</a> 4) = &quot;fall&quot;</code></li>
<li><code>[&quot;spring&quot;, &quot;summer&quot;, &quot;fall&quot;, &quot;winter&quot;].<a href=".././Init/Prelude.html#List.get">get</a> (0 : <a href=".././Init/Prelude.html#Fin">Fin</a> 4) = &quot;spring&quot;</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span>).<a href=".././Init/Prelude.html#List.get">get</a></span> <a href=".././Init/Prelude.html#Fin.mk">⟨</a><span class="fn">0</span>, <span class="fn">isLt</span><a href=".././Init/Prelude.html#Fin.mk">⟩</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></li><li class="equation"><span class="fn"><span class="fn">(<span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span>).<a href=".././Init/Prelude.html#List.get">get</a></span> <a href=".././Init/Prelude.html#Fin.mk">⟨</a><span class="fn"><span class="fn">i</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span>, <span class="fn">h</span><a href=".././Init/Prelude.html#Fin.mk">⟩</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#List.get">get</a></span> <a href=".././Init/Prelude.html#Fin.mk">⟨</a><span class="fn">i</span>, <span class="fn">⋯</span><a href=".././Init/Prelude.html#Fin.mk">⟩</a></span></li></ul></details><details id="instances-for-list-List.get" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.set"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2971-L2982">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.set"><span class="name">List</span>.<span class="name">set</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></div></div><p>Replaces the value at (zero-based) index <code>n</code> in <code>l</code> with <code>a</code>. If the index is out of bounds, then
the list is returned unmodified.</p><p>Examples:</p><ul>
<li><code>[&quot;water&quot;, &quot;coffee&quot;, &quot;soda&quot;, &quot;juice&quot;].<a href=".././Init/Prelude.html#List.set">set</a> 1 &quot;tea&quot; = [&quot;water&quot;, &quot;tea&quot;, &quot;soda&quot;, &quot;juice&quot;]</code></li>
<li><code>[&quot;water&quot;, &quot;coffee&quot;, &quot;soda&quot;, &quot;juice&quot;].<a href=".././Init/Prelude.html#List.set">set</a> 4 &quot;tea&quot; = [&quot;water&quot;, &quot;coffee&quot;, &quot;soda&quot;, &quot;juice&quot;]</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span>).<a href=".././Init/Prelude.html#List.set">set</a></span> <span class="fn">0</span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span></li><li class="equation"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span>).<a href=".././Init/Prelude.html#List.set">set</a></span> <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn"><span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#List.set">set</a></span> <span class="fn">n</span> <span class="fn">x✝</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a>.<a href=".././Init/Prelude.html#List.set">set</a></span> <span class="fn">x✝¹</span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a></li></ul></details><details id="instances-for-list-List.set" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.foldl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2984-L2996">source</a></div><div class="attributes">@[specialize #[]]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.foldl"><span class="name">List</span>.<span class="name">foldl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">init</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">β</span></span> → <span class="fn">α</span></span></div></div><p>Folds a function over a list from the left, accumulating a value starting with <code>init</code>. The
accumulated value is combined with the each element of the list in order, using <code>f</code>.</p><p>Examples:</p><ul>
<li><code>[a, b, c].<a href=".././Init/Prelude.html#List.foldl">foldl</a> f z  = f (f (f z a) b) c</code></li>
<li><code>[1, 2, 3].<a href=".././Init/Prelude.html#List.foldl">foldl</a> (· ++ toString ·) &quot;&quot; = &quot;123&quot;</code></li>
<li><code>[1, 2, 3].<a href=".././Init/Prelude.html#List.foldl">foldl</a> (s!&quot;({·} {·})&quot;) &quot;&quot; = &quot;((( 1) 2) 3)&quot;</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">f</span> <span class="fn">x✝</span> <a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">f</span> <span class="fn">x✝</span> (<span class="fn">b</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">f</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x✝</span> <span class="fn">b</span>)</span> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-List.foldl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.concat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L2998-L3010">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.concat"><span class="name">List</span>.<span class="name">concat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></span></span></div></div><p>Adds an element to the <em>end</em> of a list.</p><p>The added element is the last element of the resulting list.</p><p>Examples:</p><ul>
<li><code><a href=".././Init/Prelude.html#List.concat">List.concat</a> [&quot;red&quot;, &quot;yellow&quot;] &quot;green&quot; = [&quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;]</code></li>
<li><code><a href=".././Init/Prelude.html#List.concat">List.concat</a> [1, 2, 3] 4 = [1, 2, 3, 4]</code></li>
<li><code><a href=".././Init/Prelude.html#List.concat">List.concat</a> [] () = [()]</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a>.<a href=".././Init/Prelude.html#List.concat">concat</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#List.cons">[</a><span class="fn">x✝</span><a href=".././Init/Prelude.html#List.cons">]</a></li><li class="equation"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span>).<a href=".././Init/Prelude.html#List.concat">concat</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn"><span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#List.concat">concat</a></span> <span class="fn">x✝</span></span></li></ul></details><details id="instances-for-list-List.concat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.append"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3012-L3024">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.append"><span class="name">List</span>.<span class="name">append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs </span><span class="fn">ys</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></div></div><p>Appends two lists. Normally used via the <code>++</code> operator.</p><p>Appending lists takes time proportional to the length of the first list: <code>O(|xs|)</code>.</p><p>Examples:</p><ul>
<li><code>[1, 2, 3] ++ [4, 5] = [1, 2, 3, 4, 5]</code>.</li>
<li><code>[] ++ [4, 5] = [4, 5]</code>.</li>
<li><code>[1, 2, 3] ++ [] = [1, 2, 3]</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a>.<a href=".././Init/Prelude.html#List.append">append</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span>).<a href=".././Init/Prelude.html#List.append">append</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn"><span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#List.append">append</a></span> <span class="fn">x✝</span></span></li></ul></details><details id="instances-for-list-List.append" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.flatten"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3026-L3037">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.flatten"><span class="name">List</span>.<span class="name">flatten</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">(<a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span>)</span></span> → <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></span></div></div><p>Concatenates a list of lists into a single list, preserving the order of the elements.</p><p><code>O(|flatten L|)</code>.</p><p>Examples:</p><ul>
<li><code>[[&quot;a&quot;], [&quot;b&quot;, &quot;c&quot;]].<a href=".././Init/Prelude.html#List.flatten">flatten</a> = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></li>
<li><code>[[&quot;a&quot;], [], [&quot;b&quot;, &quot;c&quot;], [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]].<a href=".././Init/Prelude.html#List.flatten">flatten</a> = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a>.<a href=".././Init/Prelude.html#List.flatten">flatten</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a></li><li class="equation"><span class="fn">(<span class="fn">l</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">L</span>).<a href=".././Init/Prelude.html#List.flatten">flatten</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">l</span>.<a href=".././Init/Prelude.html#List.append">append</a></span> <span class="fn"><span class="fn">L</span>.<a href=".././Init/Prelude.html#List.flatten">flatten</a></span></span></li></ul></details><details id="instances-for-list-List.flatten" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3039-L3052">source</a></div><div class="attributes">@[specialize #[]]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.map"><span class="name">List</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">β</span></span></div></div><p>Applies a function to each element of the list, returning the resulting list of values.</p><p><code>O(|l|)</code>.</p><p>Examples:</p><ul>
<li><code>[a, b, c].<a href=".././Init/Prelude.html#Option.map">map</a> f = [f a, f b, f c]</code></li>
<li><code>[].<a href=".././Init/Prelude.html#Option.map">map</a> <a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> = []</code></li>
<li><code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;].<a href=".././Init/Prelude.html#Option.map">map</a> (·.length) = [3, 3, 5]</code></li>
<li><code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;].<a href=".././Init/Prelude.html#Option.map">map</a> (·.reverse) = [&quot;eno&quot;, &quot;owt&quot;, &quot;eerht&quot;]</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#List.map">List.map</a> <span class="fn">f</span> <a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a></li><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#List.map">List.map</a> <span class="fn">f</span> (<span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">head</span></span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href=".././Init/Prelude.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">as</span></span></li></ul></details><details id="instances-for-list-List.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.flatMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3054-L3062">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.flatMap"><span class="name">List</span>.<span class="name">flatMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">as</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">β</span></span></div></div><p>Applies a function that returns a list to each element of a list, and concatenates the resulting
lists.</p><p>Examples:</p><ul>
<li><code>[2, 3, 2].<a href=".././Init/Prelude.html#List.flatMap">flatMap</a> <a href=".././Init/Data/List/Basic.html#List.range">List.range</a> = [0, 1, 0, 1, 2, 0, 1]</code></li>
<li><code>[&quot;red&quot;, &quot;blue&quot;].<a href=".././Init/Prelude.html#List.flatMap">flatMap</a> <a href=".././Init/Data/String/Basic.html#String.toList">String.toList</a> = ['r', 'e', 'd', 'b', 'l', 'u', 'e']</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#List.flatMap">List.flatMap</a> <span class="fn">b</span> <span class="fn">as</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#List.map">List.map</a> <span class="fn">b</span> <span class="fn">as</span>)</span>.<a href=".././Init/Prelude.html#List.flatten">flatten</a></span></li></ul></details><details id="instances-for-list-List.flatMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3064-L3096">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array"><span class="name">Array</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p><code><a href=".././Init/Prelude.html#Array">Array</a> α</code> is the type of <a href="https://en.wikipedia.org/wiki/Dynamic_array">dynamic arrays</a> with elements
from <code>α</code>. This type has special support in the runtime.</p><p>Arrays perform best when unshared. As long as there is never more than one reference to an array,
all updates will be performed <em>destructively</em>. This results in performance comparable to mutable
arrays in imperative programming languages.</p><p>An array has a size and a capacity. The size is the number of elements present in the array, while
the capacity is the amount of memory currently allocated for elements. The size is accessible via
<code><a href=".././Init/Prelude.html#Array.size">Array.size</a></code>, but the capacity is not observable from Lean code. <code><a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> n</code> creates
an array which is equal to <code>#[]</code>, but internally allocates an array of capacity <code>n</code>. When the size
exceeds the capacity, allocation is required to grow the array.</p><p>From the point of view of proofs, <code><a href=".././Init/Prelude.html#Array">Array</a> α</code> is just a wrapper around <code><a href=".././Init/Prelude.html#List">List</a> α</code>.</p><ul class="structure_fields" id="Array.mk"><li id="Array.toList" class="structure_field"><div class="structure_field_info">toList : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></div><div class="structure_field_doc"><p>Converts an <code><a href=".././Init/Prelude.html#Array">Array</a> α</code> into a <code><a href=".././Init/Prelude.html#List">List</a> α</code> that contains the same elements in the same order.</p><p>At runtime, this is implemented by <code><a href=".././Init/Data/Array/Basic.html#Array.toListImpl">Array.toListImpl</a></code> and is <code>O(n)</code> in the length of the
array.</p></div></li></ul><details id="instances-for-list-Array" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.toArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3101-L3112">source</a></div><div class="attributes">@[reducible, match_pattern, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.toArray"><span class="name">List</span>.<span class="name">toArray</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Converts a <code><a href=".././Init/Prelude.html#List">List</a> α</code> into an <code><a href=".././Init/Prelude.html#Array">Array</a> α</code>.</p><p><code>O(|xs|)</code>. At runtime, this operation is implemented by <code><a href=".././Init/Data/List/ToArrayImpl.html#List.toArrayImpl">List.toArrayImpl</a></code> and takes time linear in
the length of the list. <code><a href=".././Init/Prelude.html#List.toArray">List.toArray</a></code> should be used instead of <code><a href=".././Init/Prelude.html#Array.mk">Array.mk</a></code>.</p><p>Examples:</p><ul>
<li><code>[1, 2, 3].<a href=".././Init/Prelude.html#List.toArray">toArray</a> = #[1, 2, 3]</code></li>
<li><code>[&quot;monday&quot;, &quot;wednesday&quot;, friday&quot;].<a href=".././Init/Prelude.html#List.toArray">toArray</a> = #[&quot;monday&quot;, &quot;wednesday&quot;, friday&quot;].</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">xs</span>.<a href=".././Init/Prelude.html#List.toArray">toArray</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Array.mk">{</a> <span class="fn">toList</span> := <span class="fn">xs</span> <a href=".././Init/Prelude.html#Array.mk">}</a></li></ul></details><details id="instances-for-list-List.toArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.mkEmpty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3114-L3121">source</a></div><div class="attributes">@[extern lean_mk_empty_array_with_capacity]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkEmpty"><span class="name">Array</span>.<span class="name">mkEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Constructs a new empty array with initial capacity <code>c</code>.</p><p>This will be deprecated in favor of <code><a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a></code> in the future.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Array.mk">{</a> <span class="fn">toList</span> := <a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a> <a href=".././Init/Prelude.html#Array.mk">}</a></li></ul></details><details id="instances-for-list-Array.mkEmpty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.emptyWithCapacity"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3123-L3128">source</a></div><div class="attributes">@[extern lean_mk_empty_array_with_capacity]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.emptyWithCapacity"><span class="name">Array</span>.<span class="name">emptyWithCapacity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Constructs a new empty array with initial capacity <code>c</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Array.mk">{</a> <span class="fn">toList</span> := <a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a> <a href=".././Init/Prelude.html#Array.mk">}</a></li></ul></details><details id="instances-for-list-Array.emptyWithCapacity" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.empty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3130-L3136">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.empty"><span class="name">Array</span>.<span class="name">empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Constructs a new empty array with initial capacity <code>0</code>.</p><p>Use <code><a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a></code> to create an array with a greater initial capacity.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Array.empty">#[</a><a href=".././Init/Prelude.html#Array.empty">]</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn">0</span></span></li></ul></details><details id="instances-for-list-Array.empty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3138-L3147">source</a></div><div class="attributes">@[extern lean_array_get_size]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.size"><span class="name">Array</span>.<span class="name">size</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Gets the number of elements stored in an array.</p><p>This is a cached value, so it is <code>O(1)</code> to access. The space allocated for an array, referred to as
its <em>capacity</em>, is at least as large as its size, but may be larger. The capacity of an array is an
internal detail that's not observable by Lean code.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.toList">toList</a></span>.<a href=".././Init/Prelude.html#List.length">length</a></span></li></ul></details><details id="instances-for-list-Array.size" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.getInternalBorrowed"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3149-L3156">source</a></div><div class="attributes">@[extern lean_array_fget_borrowed]</div>
<div class="decl_header"><span class="decl_kind">unsafe opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.getInternalBorrowed"><span class="name">Array</span>.<span class="name">getInternalBorrowed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">i</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Version of <code><a href=".././Init/Prelude.html#Array.getInternal">Array.getInternal</a></code> that does not increment the reference count of its result.</p><p>This is only intended for direct use by the compiler.</p></div></div><div class="decl" id="Array.getInternal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3158-L3170">source</a></div><div class="attributes">@[extern lean_array_fget]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.getInternal"><span class="name">Array</span>.<span class="name">getInternal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">i</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Use the indexing notation <code>a[i]</code> instead.</p><p>Access an element from an array without needing a runtime bounds checks,
using a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> index and a proof that it is in bounds.</p><p>This function does not use <code>get_elem_tactic</code> to automatically find the proof that
the index is in bounds. This is because the tactic itself needs to look up values in
arrays.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.getInternal">getInternal</a></span> <span class="fn">i</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.toList">toList</a></span>.<a href=".././Init/Prelude.html#List.get">get</a></span> <a href=".././Init/Prelude.html#Fin.mk">⟨</a><span class="fn">i</span>, <span class="fn">h</span><a href=".././Init/Prelude.html#Fin.mk">⟩</a></span></li></ul></details><details id="instances-for-list-Array.getInternal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.getD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3172-L3185">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.getD"><span class="name">Array</span>.<span class="name">getD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v₀</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Returns the element at the provided index, counting from <code>0</code>. Returns the fallback value <code>v₀</code> if the
index is out of bounds.</p><p>To return an <code><a href=".././Init/Prelude.html#Option">Option</a></code> depending on whether the index is in bounds, use <code>a[i]?</code>. To panic if the
index is out of bounds, use <code>a[i]!</code>.</p><p>Examples:</p><ul>
<li><code>#[&quot;spring&quot;, &quot;summer&quot;, &quot;fall&quot;, &quot;winter&quot;].<a href=".././Init/Prelude.html#Option.getD">getD</a> 2 &quot;never&quot; = &quot;fall&quot;</code></li>
<li><code>#[&quot;spring&quot;, &quot;summer&quot;, &quot;fall&quot;, &quot;winter&quot;].<a href=".././Init/Prelude.html#Option.getD">getD</a> 0 &quot;never&quot; = &quot;spring&quot;</code></li>
<li><code>#[&quot;spring&quot;, &quot;summer&quot;, &quot;fall&quot;, &quot;winter&quot;].<a href=".././Init/Prelude.html#Option.getD">getD</a> 4 &quot;never&quot; = &quot;never&quot;</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.getD">getD</a></span> <span class="fn">i</span> <span class="fn">v₀</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">i</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span> then <span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.getInternal">getInternal</a></span> <span class="fn">i</span> <span class="fn">h</span></span> else <span class="fn">v₀</span></span></li></ul></details><details id="instances-for-list-Array.getD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.get!InternalBorrowed"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3187-L3193">source</a></div><div class="attributes">@[extern lean_array_get_borrowed]</div>
<div class="decl_header"><span class="decl_kind">unsafe opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.get!InternalBorrowed"><span class="name">Array</span>.<span class="name">get!InternalBorrowed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Version of <code><a href=".././Init/Prelude.html#Array.get!Internal">Array.get!Internal</a></code> that does not increment the reference count of its result.</p><p>This is only intended for direct use by the compiler.</p></div></div><div class="decl" id="Array.get!Internal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3195-L3202">source</a></div><div class="attributes">@[extern lean_array_get]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.get!Internal"><span class="name">Array</span>.<span class="name">get!Internal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Use the indexing notation <code>a[i]!</code> instead.</p><p>Access an element from an array, or panic if the index is out of bounds.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.get!Internal">get!Internal</a></span> <span class="fn">i</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.getD">getD</a></span> <span class="fn">i</span> <a href=".././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Array.get!Internal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.push"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3204-L3216">source</a></div><div class="attributes">@[extern lean_array_push]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.push"><span class="name">Array</span>.<span class="name">push</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Adds an element to the end of an array. The resulting array's size is one greater than the input
array. If there are no other references to the array, then it is modified in-place.</p><p>This takes amortized <code>O(1)</code> time because <code><a href=".././Init/Prelude.html#Array">Array</a> α</code> is represented by a dynamic array.</p><p>Examples:</p><ul>
<li><code>#[].<a href=".././Init/Prelude.html#Array.push">push</a> &quot;apple&quot; = #[&quot;apple&quot;]</code></li>
<li><code>#[&quot;apple&quot;].<a href=".././Init/Prelude.html#Array.push">push</a> &quot;orange&quot; = #[&quot;apple&quot;, &quot;orange&quot;]</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">v</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Array.mk">{</a> <span class="fn">toList</span> := <span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Array.toList">toList</a></span>.<a href=".././Init/Prelude.html#List.concat">concat</a></span> <span class="fn">v</span></span> <a href=".././Init/Prelude.html#Array.mk">}</a></li></ul></details><details id="instances-for-list-Array.push" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.mkArray0"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3218-L3220">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray0"><span class="name">Array</span>.<span class="name">mkArray0</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Array.mkArray0">#[</a><a href=".././Init/Prelude.html#Array.mkArray0">]</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn">0</span></span></li></ul></details><details id="instances-for-list-Array.mkArray0" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.mkArray1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3222-L3224">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray1"><span class="name">Array</span>.<span class="name">mkArray1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Array.mkArray1">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray1">]</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn">1</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₁</span></span></li></ul></details><details id="instances-for-list-Array.mkArray1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.mkArray2"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3226-L3228">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray2"><span class="name">Array</span>.<span class="name">mkArray2</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Array.mkArray2">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray2">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray2">]</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn">2</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₁</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₂</span></span></li></ul></details><details id="instances-for-list-Array.mkArray2" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.mkArray3"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3230-L3232">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray3"><span class="name">Array</span>.<span class="name">mkArray3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">a₃</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂, a₃]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Array.mkArray3">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray3">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray3">,</a> <span class="fn">a₃</span><a href=".././Init/Prelude.html#Array.mkArray3">]</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn">3</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₁</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₂</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₃</span></span></li></ul></details><details id="instances-for-list-Array.mkArray3" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.mkArray4"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3234-L3236">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray4"><span class="name">Array</span>.<span class="name">mkArray4</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">a₃ </span><span class="fn">a₄</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂, a₃, a₄]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Array.mkArray4">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray4">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray4">,</a> <span class="fn">a₃</span><a href=".././Init/Prelude.html#Array.mkArray4">,</a> <span class="fn">a₄</span><a href=".././Init/Prelude.html#Array.mkArray4">]</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn">4</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₁</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₂</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₃</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₄</span></span></li></ul></details><details id="instances-for-list-Array.mkArray4" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.mkArray5"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3238-L3240">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray5"><span class="name">Array</span>.<span class="name">mkArray5</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">a₃ </span><span class="fn">a₄ </span><span class="fn">a₅</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂, a₃, a₄, a₅]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Array.mkArray5">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray5">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray5">,</a> <span class="fn">a₃</span><a href=".././Init/Prelude.html#Array.mkArray5">,</a> <span class="fn">a₄</span><a href=".././Init/Prelude.html#Array.mkArray5">,</a> <span class="fn">a₅</span><a href=".././Init/Prelude.html#Array.mkArray5">]</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn">5</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₁</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₂</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₃</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₄</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₅</span></span></li></ul></details><details id="instances-for-list-Array.mkArray5" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.mkArray6"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3242-L3244">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray6"><span class="name">Array</span>.<span class="name">mkArray6</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">a₃ </span><span class="fn">a₄ </span><span class="fn">a₅ </span><span class="fn">a₆</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂, a₃, a₄, a₅, a₆]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Array.mkArray6">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray6">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray6">,</a> <span class="fn">a₃</span><a href=".././Init/Prelude.html#Array.mkArray6">,</a> <span class="fn">a₄</span><a href=".././Init/Prelude.html#Array.mkArray6">,</a> <span class="fn">a₅</span><a href=".././Init/Prelude.html#Array.mkArray6">,</a> <span class="fn">a₆</span><a href=".././Init/Prelude.html#Array.mkArray6">]</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn">6</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₁</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₂</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₃</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₄</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₅</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₆</span></span></li></ul></details><details id="instances-for-list-Array.mkArray6" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.mkArray7"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3246-L3248">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray7"><span class="name">Array</span>.<span class="name">mkArray7</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">a₃ </span><span class="fn">a₄ </span><span class="fn">a₅ </span><span class="fn">a₆ </span><span class="fn">a₇</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂, a₃, a₄, a₅, a₆, a₇]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Array.mkArray7">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray7">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray7">,</a> <span class="fn">a₃</span><a href=".././Init/Prelude.html#Array.mkArray7">,</a> <span class="fn">a₄</span><a href=".././Init/Prelude.html#Array.mkArray7">,</a> <span class="fn">a₅</span><a href=".././Init/Prelude.html#Array.mkArray7">,</a> <span class="fn">a₆</span><a href=".././Init/Prelude.html#Array.mkArray7">,</a> <span class="fn">a₇</span><a href=".././Init/Prelude.html#Array.mkArray7">]</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn">7</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₁</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₂</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₃</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₄</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₅</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₆</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₇</span></span></li></ul></details><details id="instances-for-list-Array.mkArray7" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.mkArray8"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3250-L3252">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray8"><span class="name">Array</span>.<span class="name">mkArray8</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">a₃ </span><span class="fn">a₄ </span><span class="fn">a₅ </span><span class="fn">a₆ </span><span class="fn">a₇ </span><span class="fn">a₈</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂, a₃, a₄, a₅, a₆, a₇, a₈]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Array.mkArray8">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₃</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₄</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₅</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₆</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₇</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₈</span><a href=".././Init/Prelude.html#Array.mkArray8">]</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn">8</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₁</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₂</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₃</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₄</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₅</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₆</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₇</span>)</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">a₈</span></span></li></ul></details><details id="instances-for-list-Array.mkArray8" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.appendCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3254-L3263">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.appendCore"><span class="name">Array</span>.<span class="name">appendCore</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">as </span><span class="fn">bs</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Slower <code><a href=".././Init/Data/Array/Basic.html#Array.append">Array.append</a></code> used in quotations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#Array.appendCore">appendCore</a></span> <span class="fn">bs</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.appendCore.loop">Array.appendCore.loop</a> <span class="fn">bs</span> <span class="fn"><span class="fn">bs</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span> <span class="fn">0</span> <span class="fn">as</span></span></li></ul></details><details id="instances-for-list-Array.appendCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.appendCore.loop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3256-L3262">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.appendCore.loop"><span class="name">Array</span>.<span class="name">appendCore</span>.<span class="name">loop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">bs</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i </span><span class="fn">j</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">as</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Array.appendCore.loop">Array.appendCore.loop</a> <span class="fn">bs</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">as</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">if hlt : <span class="fn">j</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">bs</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span> then
    <span class="fn">match <span class="fn">i</span> with
    | <span class="fn">0</span> =&gt; <span class="fn">as</span>
    | <span class="fn"><span class="fn">i'</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Array.appendCore.loop">Array.appendCore.loop</a> <span class="fn">bs</span> <span class="fn">i'</span> (<span class="fn">j</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>) <span class="fn">(<span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">(<span class="fn"><span class="fn">bs</span>.<a href=".././Init/Prelude.html#Array.getInternal">getInternal</a></span> <span class="fn">j</span> <span class="fn">hlt</span>)</span>)</span></span></span>
  else <span class="fn">as</span></span></li></ul></details><details id="instances-for-list-Array.appendCore.loop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.extract"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3265-L3291">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.extract"><span class="name">Array</span>.<span class="name">extract</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">as</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">start</span> : <a href=".././Init/Prelude.html#Nat">Nat</a> := <span class="fn">0</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">stop</span> : <a href=".././Init/Prelude.html#Nat">Nat</a> := <span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Returns the slice of <code>as</code> from indices <code>start</code> to <code>stop</code> (exclusive). The resulting array has size
<code>(min stop as.size) - start</code>.</p><p>If <code>start</code> is greater or equal to <code>stop</code>, the result is empty. If <code>stop</code> is greater than the size of
<code>as</code>, the size is used instead.</p><p>Examples:</p><ul>
<li><code>#[0, 1, 2, 3, 4].<a href=".././Init/Prelude.html#Array.extract">extract</a> 1 3 = #[1, 2]</code></li>
<li><code>#[0, 1, 2, 3, 4].<a href=".././Init/Prelude.html#Array.extract">extract</a> 1 30 = #[1, 2, 3, 4]</code></li>
<li><code>#[0, 1, 2, 3, 4].<a href=".././Init/Prelude.html#Array.extract">extract</a> 0 0 = #[]</code></li>
<li><code>#[0, 1, 2, 3, 4].<a href=".././Init/Prelude.html#Array.extract">extract</a> 2 1 = #[]</code></li>
<li><code>#[0, 1, 2, 3, 4].<a href=".././Init/Prelude.html#Array.extract">extract</a> 2 2 = #[]</code></li>
<li><code>#[0, 1, 2, 3, 4].<a href=".././Init/Prelude.html#Array.extract">extract</a> 2 3 = #[2]</code></li>
<li><code>#[0, 1, 2, 3, 4].<a href=".././Init/Prelude.html#Array.extract">extract</a> 2 4 = #[2, 3]</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#Array.extract">extract</a></span> <span class="fn">start</span> <span class="fn">stop</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Array.extract.loop">Array.extract.loop</a> <span class="fn">as</span> <span class="fn">(<span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Min.min">min</a> <span class="fn">stop</span> <span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span>)</span>.<a href=".././Init/Prelude.html#Nat.sub">sub</a></span> <span class="fn">start</span>)</span> <span class="fn">start</span> <span class="fn">(<a href=".././Init/Prelude.html#Array.emptyWithCapacity">Array.emptyWithCapacity</a> <span class="fn">(<span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Min.min">min</a> <span class="fn">stop</span> <span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span>)</span>.<a href=".././Init/Prelude.html#Nat.sub">sub</a></span> <span class="fn">start</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Array.extract" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Array.extract.loop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3283-L3289">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.extract.loop"><span class="name">Array</span>.<span class="name">extract</span>.<span class="name">loop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">as</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i </span><span class="fn">j</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">bs</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Array.extract.loop">Array.extract.loop</a> <span class="fn">as</span> <span class="fn">i</span> <span class="fn">j</span> <span class="fn">bs</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">if hlt : <span class="fn">j</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span> then
    <span class="fn">match <span class="fn">i</span> with
    | <span class="fn">0</span> =&gt; <span class="fn">bs</span>
    | <span class="fn"><span class="fn">i'</span>.<a href=".././Init/Prelude.html#Nat.succ">succ</a></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Array.extract.loop">Array.extract.loop</a> <span class="fn">as</span> <span class="fn">i'</span> (<span class="fn">j</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>) <span class="fn">(<span class="fn"><span class="fn">bs</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">(<span class="fn"><span class="fn">as</span>.<a href=".././Init/Prelude.html#Array.getInternal">getInternal</a></span> <span class="fn">j</span> <span class="fn">hlt</span>)</span>)</span></span></span>
  else <span class="fn">bs</span></span></li></ul></details><details id="instances-for-list-Array.extract.loop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ByteArray"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3293-L3309">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ByteArray"><span class="name">ByteArray</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p><code><a href=".././Init/Prelude.html#ByteArray">ByteArray</a></code> is like <code><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></code>, but with an efficient run-time representation as a packed
byte buffer.</p><ul class="structure_fields" id="ByteArray.mk"><li id="ByteArray.data" class="structure_field"><div class="structure_field_info">data : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></span></div><div class="structure_field_doc"><p>The data contained in the byte array.</p><p>Converting between <code><a href=".././Init/Prelude.html#Array">Array</a></code> and <code><a href=".././Init/Prelude.html#ByteArray">ByteArray</a></code> takes linear time.</p></div></li></ul><details id="instances-for-list-ByteArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ByteArray.emptyWithCapacity"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3314-L3319">source</a></div><div class="attributes">@[extern lean_mk_empty_byte_array]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ByteArray.emptyWithCapacity"><span class="name">ByteArray</span>.<span class="name">emptyWithCapacity</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#ByteArray">ByteArray</a></div></div><p>Constructs a new empty byte array with initial capacity <code>c</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#ByteArray.emptyWithCapacity">ByteArray.emptyWithCapacity</a> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#ByteArray.mk">{</a> <span class="fn">data</span> := <a href=".././Init/Prelude.html#Array.empty">#[</a><a href=".././Init/Prelude.html#Array.empty">]</a> <a href=".././Init/Prelude.html#ByteArray.mk">}</a></li></ul></details><details id="instances-for-list-ByteArray.emptyWithCapacity" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ByteArray.empty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3321-L3326">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ByteArray.empty"><span class="name">ByteArray</span>.<span class="name">empty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#ByteArray">ByteArray</a></div></div><p>Constructs a new empty byte array with initial capacity <code>0</code>.</p><p>Use <code><a href=".././Init/Prelude.html#ByteArray.emptyWithCapacity">ByteArray.emptyWithCapacity</a></code> to create an array with a greater initial capacity.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#ByteArray.empty">ByteArray.empty</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#ByteArray.emptyWithCapacity">ByteArray.emptyWithCapacity</a> <span class="fn">0</span></span></li></ul></details><details id="instances-for-list-ByteArray.empty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ByteArray.push"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3328-L3336">source</a></div><div class="attributes">@[extern lean_byte_array_push]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ByteArray.push"><span class="name">ByteArray</span>.<span class="name">push</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#ByteArray">ByteArray</a> → <span class="fn"><a href=".././Init/Prelude.html#UInt8">UInt8</a> → <a href=".././Init/Prelude.html#ByteArray">ByteArray</a></span></span></div></div><p>Adds an element to the end of an array. The resulting array's size is one greater than the input
array. If there are no other references to the array, then it is modified in-place.</p><p>This takes amortized <code>O(1)</code> time because <code><a href=".././Init/Prelude.html#ByteArray">ByteArray</a></code> is represented by a dynamic array.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#ByteArray.mk">{</a> <span class="fn">data</span> := <span class="fn">bs</span> <a href=".././Init/Prelude.html#ByteArray.mk">}</a>.<a href=".././Init/Prelude.html#ByteArray.push">push</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#ByteArray.mk">{</a> <span class="fn">data</span> := <span class="fn"><span class="fn"><span class="fn">bs</span>.<a href=".././Init/Prelude.html#Array.push">push</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#ByteArray.mk">}</a></li></ul></details><details id="instances-for-list-ByteArray.push" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.toByteArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3338-L3345">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.toByteArray"><span class="name">List</span>.<span class="name">toByteArray</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">bs</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#ByteArray">ByteArray</a></div></div><p>Converts a list of bytes into a <code><a href=".././Init/Prelude.html#ByteArray">ByteArray</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">bs</span>.<a href=".././Init/Prelude.html#List.toByteArray">toByteArray</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#List.toByteArray.loop">List.toByteArray.loop</a> <span class="fn">bs</span> <a href=".././Init/Prelude.html#ByteArray.empty">ByteArray.empty</a></span></li></ul></details><details id="instances-for-list-List.toByteArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.toByteArray.loop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3342-L3344">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.toByteArray.loop"><span class="name">List</span>.<span class="name">toByteArray</span>.<span class="name">loop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></span> → <span class="fn"><a href=".././Init/Prelude.html#ByteArray">ByteArray</a> → <a href=".././Init/Prelude.html#ByteArray">ByteArray</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#List.toByteArray.loop">List.toByteArray.loop</a> <a href=".././Init/Prelude.html#List.nil">[</a><a href=".././Init/Prelude.html#List.nil">]</a> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#List.toByteArray.loop">List.toByteArray.loop</a> (<span class="fn">b</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">bs</span>) <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#List.toByteArray.loop">List.toByteArray.loop</a> <span class="fn">bs</span> <span class="fn">(<span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#ByteArray.push">push</a></span> <span class="fn">b</span>)</span></span></li></ul></details><details id="instances-for-list-List.toByteArray.loop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ByteArray.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3347-L3355">source</a></div><div class="attributes">@[extern lean_byte_array_size]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ByteArray.size"><span class="name">ByteArray</span>.<span class="name">size</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#ByteArray">ByteArray</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Returns the number of bytes in the byte array.</p><p>This is the number of bytes actually in the array, as distinct from its capacity, which is the
amount of memory presently allocated for the array.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#ByteArray.mk">{</a> <span class="fn">data</span> := <span class="fn">bs</span> <a href=".././Init/Prelude.html#ByteArray.mk">}</a>.<a href=".././Init/Prelude.html#ByteArray.size">size</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">bs</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span></li></ul></details><details id="instances-for-list-ByteArray.size" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String.utf8EncodeChar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3357-L3386">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.utf8EncodeChar"><span class="name">String</span>.<span class="name">utf8EncodeChar</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href=".././Init/Prelude.html#Char">Char</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></span></div></div><p>Returns the sequence of bytes in a character's UTF-8 encoding.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-String.utf8EncodeChar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.utf8Encode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3388-L3391">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.utf8Encode"><span class="name">List</span>.<span class="name">utf8Encode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Char">Char</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#ByteArray">ByteArray</a></div></div><p>Encode a list of characters (Unicode scalar value) in UTF-8. This is an inefficient model
implementation. Use <code><a href=".././Init/Data/String/Bootstrap.html#List.asString">List.asString</a></code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">l</span>.<a href=".././Init/Prelude.html#List.utf8Encode">utf8Encode</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#List.flatMap">List.flatMap</a> <a href=".././Init/Prelude.html#String.utf8EncodeChar">String.utf8EncodeChar</a> <span class="fn">l</span>)</span>.<a href=".././Init/Prelude.html#List.toByteArray">toByteArray</a></span></li></ul></details><details id="instances-for-list-List.utf8Encode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ByteArray.IsValidUTF8"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3393-L3400">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ByteArray.IsValidUTF8"><span class="name">ByteArray</span>.<span class="name">IsValidUTF8</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <a href=".././Init/Prelude.html#ByteArray">ByteArray</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>A byte array is valid UTF-8 if it is of the form <code>List.Internal.<a href=".././Init/Prelude.html#List.utf8Encode">utf8Encode</a> m</code> for some <code>m</code>.</p><p>Note that in order for this definition to be well-behaved it is necessary to know that this <code>m</code>
is unique. To show this, one defines UTF-8 decoding and shows that encoding and decoding are
mutually inverse.</p><ul class="constructors"><li class="constructor" id="ByteArray.IsValidUTF8.intro">intro<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href=".././Init/Prelude.html#ByteArray">ByteArray</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Char">Char</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hm</span> : <span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">m</span>.<a href=".././Init/Prelude.html#List.utf8Encode">utf8Encode</a></span>)</span></span>
 : <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#ByteArray.IsValidUTF8">IsValidUTF8</a></span><div class="inductive_ctor_doc"><p>Show that a byte</p></div></li></ul><details id="instances-for-list-ByteArray.IsValidUTF8" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3402-L3416">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String"><span class="name">String</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>A string is a sequence of Unicode scalar values.</p><p>At runtime, strings are represented by <a href="https://en.wikipedia.org/wiki/Dynamic_array">dynamic arrays</a>
of bytes using the UTF-8 encoding. Both the size in bytes (<code><a href=".././Init/Prelude.html#String.utf8ByteSize">String.utf8ByteSize</a></code>) and in characters
(<code><a href=".././Init/Data/String/Basic.html#String.length">String.length</a></code>) are cached and take constant time. Many operations on strings perform in-place
modifications when the reference to the string is unique.</p><ul class="structure_ext"><li id="String.ofByteArray" class="structure_ext_ctor">ofByteArray :: (</li><ul class="structure_ext_fields"><li id="String.bytes" class="structure_field"><div class="structure_field_info">bytes : <a href=".././Init/Prelude.html#ByteArray">ByteArray</a></div><div class="structure_field_doc"><p>The bytes of the UTF-8 encoding of the string. Since strings have a special representation in
the runtime, this function actually takes linear time and space at runtime. For efficient access
to the string's bytes, use <code><a href=".././Init/Prelude.html#String.utf8ByteSize">String.utf8ByteSize</a></code> and <code><a href=".././Init/Data/String/Basic.html#String.getUTF8Byte">String.getUTF8Byte</a></code>.</p></div></li><li id="String.isValidUTF8" class="structure_field"><div class="structure_field_info">isValidUTF8 : <span class="fn"><span class="fn"><span class="fn">self</span>.<a href=".././Init/Prelude.html#String.bytes">bytes</a></span>.<a href=".././Init/Prelude.html#ByteArray.IsValidUTF8">IsValidUTF8</a></span></div><div class="structure_field_doc"><p>The bytes of the string form valid UTF-8.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-String" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3421-L3433">source</a></div><div class="attributes">@[extern lean_string_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.decEq"><span class="name">String</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s₁ </span><span class="fn">s₂</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">s₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">s₂</span>)</span></div></div><p>Decides whether two strings are equal. Normally used via the <code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#String">String</a></code> instance and the
<code>=</code> operator.</p><p>At runtime, this function is overridden with an efficient native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-String.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqString"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3435-L3435">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqString"><span class="name">instDecidableEqString</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#String">String</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instDecidableEqString">instDecidableEqString</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#String.decEq">String.decEq</a></li></ul></details></div></div><div class="decl" id="String.Pos.Raw"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3437-L3452">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.Pos.Raw"><span class="name">String</span>.<span class="name">Pos</span>.<span class="name">Raw</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>A byte position in a <code><a href=".././Init/Prelude.html#String">String</a></code>, according to its UTF-8 encoding.</p><p>Character positions (counting the Unicode code points rather than bytes) are represented by plain
<code><a href=".././Init/Prelude.html#Nat">Nat</a></code>s. Indexing a <code><a href=".././Init/Prelude.html#String">String</a></code> by a <code><a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></code> takes constant time, while character positions need to
be translated internally to byte positions, which takes linear time.</p><p>A byte position <code>p</code> is <em>valid</em> for a string <code>s</code> if <code>0 ≤ p ≤ s.<a href=".././Init/Prelude.html#String.endPos">endPos</a></code> and <code>p</code> lies on a UTF-8
character boundary, see <code>String.Pos.IsValid</code>.</p><p>There is another type, <code><a href=".././Init/Data/String/Basic.html#String.ValidPos">String.ValidPos</a></code>, which bundles the validity predicate. Using <code><a href=".././Init/Data/String/Basic.html#String.ValidPos">String.ValidPos</a></code>
instead of <code><a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></code> is recommended because it will lead to less error handling and fewer edge cases.</p><ul class="structure_fields" id="String.Pos.Raw.mk"><li id="String.Pos.Raw.byteIdx" class="structure_field"><div class="structure_field_info">byteIdx : <a href=".././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Get the underlying byte index of a <code><a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></code></p></div></li></ul><details id="instances-for-list-String.Pos.Raw" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedRaw"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3454-L3455">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedRaw"><span class="name">instInhabitedRaw</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedRaw">instInhabitedRaw</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#String.Pos.Raw.mk">{</a> <a href=".././Init/Prelude.html#String.Pos.Raw.mk">}</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instDecidableEqRaw"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3457-L3460">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqRaw"><span class="name">instDecidableEqRaw</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instDecidableEqRaw">instDecidableEqRaw</a> <a href=".././Init/Prelude.html#String.Pos.Raw.mk">{</a> <span class="fn">byteIdx</span> := <span class="fn">b</span> <a href=".././Init/Prelude.html#String.Pos.Raw.mk">}</a> <a href=".././Init/Prelude.html#String.Pos.Raw.mk">{</a> <span class="fn">byteIdx</span> := <span class="fn">b_1</span> <a href=".././Init/Prelude.html#String.Pos.Raw.mk">}</a></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href=".././Init/Prelude.html#decEq">decEq</a> <span class="fn">b</span> <span class="fn">b_1</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">h</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="Substring"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3462-L3481">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Substring"><span class="name">Substring</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>A region or slice of some underlying string.</p><p>A substring contains an string together with the start and end byte positions of a region of
interest. Actually extracting a substring requires copying and memory allocation, while many
substrings of the same underlying string may exist with very little overhead, and they are more
convenient than tracking the bounds by hand.</p><p>Using its constructor explicitly, it is possible to construct a <code><a href=".././Init/Prelude.html#Substring">Substring</a></code> in which one or both of
the positions is invalid for the string. Many operations will return unexpected or confusing results
if the start and stop positions are not valid. For this reason, <code><a href=".././Init/Prelude.html#Substring">Substring</a></code> will be deprecated in
favor of <code><a href=".././Init/Data/String/Basic.html#String.Slice">String.Slice</a></code>, which always represents a valid substring.</p><ul class="structure_fields" id="Substring.mk"><li id="Substring.str" class="structure_field"><div class="structure_field_info">str : <a href=".././Init/Prelude.html#String">String</a></div><div class="structure_field_doc"><p>The underlying string.</p></div></li><li id="Substring.startPos" class="structure_field"><div class="structure_field_info">startPos : <a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></div><div class="structure_field_doc"><p>The byte position of the start of the string slice.</p></div></li><li id="Substring.stopPos" class="structure_field"><div class="structure_field_info">stopPos : <a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></div><div class="structure_field_doc"><p>The byte position of the end of the string slice.</p></div></li></ul><details id="instances-for-list-Substring" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedSubstring"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3483-L3484">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedSubstring"><span class="name">instInhabitedSubstring</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Substring">Substring</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedSubstring">instInhabitedSubstring</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Substring.mk">{</a> <span class="fn">str</span> := <span class="fn">&quot;&quot;</span>, <span class="fn">startPos</span> := <a href=".././Init/Prelude.html#String.Pos.Raw.mk">{</a> <a href=".././Init/Prelude.html#String.Pos.Raw.mk">}</a>, <span class="fn">stopPos</span> := <a href=".././Init/Prelude.html#String.Pos.Raw.mk">{</a> <a href=".././Init/Prelude.html#String.Pos.Raw.mk">}</a> <a href=".././Init/Prelude.html#Substring.mk">}</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Substring.bsize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3486-L3490">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Substring.bsize"><span class="name">Substring</span>.<span class="name">bsize</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Substring">Substring</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>The number of bytes used by the string's UTF-8 encoding.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Substring.mk">{</a> <span class="fn">str</span> := <span class="fn">str</span>, <span class="fn">startPos</span> := <span class="fn">b</span>, <span class="fn">stopPos</span> := <span class="fn">e</span> <a href=".././Init/Prelude.html#Substring.mk">}</a>.<a href=".././Init/Prelude.html#Substring.bsize">bsize</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href=".././Init/Prelude.html#String.Pos.Raw.byteIdx">byteIdx</a></span>.<a href=".././Init/Prelude.html#Nat.sub">sub</a></span> <span class="fn"><span class="fn">b</span>.<a href=".././Init/Prelude.html#String.Pos.Raw.byteIdx">byteIdx</a></span></span></li></ul></details><details id="instances-for-list-Substring.bsize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String.utf8ByteSize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3492-L3499">source</a></div><div class="attributes">@[extern lean_string_utf8_byte_size]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.utf8ByteSize"><span class="name">String</span>.<span class="name">utf8ByteSize</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The number of bytes used by the string's UTF-8 encoding.</p><p>At runtime, this function takes constant time because the byte length of strings is cached.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#String.utf8ByteSize">utf8ByteSize</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#String.bytes">bytes</a></span>.<a href=".././Init/Prelude.html#ByteArray.size">size</a></span></li></ul></details><details id="instances-for-list-String.utf8ByteSize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String.endPos"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3501-L3508">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.endPos"><span class="name">String</span>.<span class="name">endPos</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#String.Pos.Raw">Pos.Raw</a></div></div><p>A UTF-8 byte position that points at the end of a string, just after the last character.</p><ul>
<li><code>&quot;abc&quot;.<a href=".././Init/Prelude.html#String.endPos">endPos</a> = ⟨3⟩</code></li>
<li><code>&quot;L∃∀N&quot;.<a href=".././Init/Prelude.html#String.endPos">endPos</a> = ⟨8⟩</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#String.endPos">endPos</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#String.Pos.Raw.mk">{</a> <span class="fn">byteIdx</span> := <span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#String.utf8ByteSize">utf8ByteSize</a></span> <a href=".././Init/Prelude.html#String.Pos.Raw.mk">}</a></li></ul></details><details id="instances-for-list-String.endPos" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String.toSubstring"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3510-L3516">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.toSubstring"><span class="name">String</span>.<span class="name">toSubstring</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Substring">Substring</a></div></div><p>Converts a <code><a href=".././Init/Prelude.html#String">String</a></code> into a <code><a href=".././Init/Prelude.html#Substring">Substring</a></code> that denotes the entire string.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#String.toSubstring">toSubstring</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Substring.mk">{</a> <span class="fn">str</span> := <span class="fn">s</span>, <span class="fn">startPos</span> := <a href=".././Init/Prelude.html#String.Pos.Raw.mk">{</a> <a href=".././Init/Prelude.html#String.Pos.Raw.mk">}</a>, <span class="fn">stopPos</span> := <span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#String.endPos">endPos</a></span> <a href=".././Init/Prelude.html#Substring.mk">}</a></li></ul></details><details id="instances-for-list-String.toSubstring" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String.toSubstring'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3518-L3524">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.toSubstring'"><span class="name">String</span>.<span class="name">toSubstring'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Substring">Substring</a></div></div><p>Converts a <code><a href=".././Init/Prelude.html#String">String</a></code> into a <code><a href=".././Init/Prelude.html#Substring">Substring</a></code> that denotes the entire string.</p><p>This is a version of <code><a href=".././Init/Prelude.html#String.toSubstring">String.toSubstring</a></code> that doesn't have an <code>@[inline]</code> annotation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#String.toSubstring'">toSubstring'</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#String.toSubstring">toSubstring</a></span></li></ul></details><details id="instances-for-list-String.toSubstring'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="unsafeCast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3526-L3551">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#unsafeCast"><span class="name">unsafeCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>This function will cast a value of type <code>α</code> to type <code>β</code>, and is a no-op in the
compiler. This function is <strong>extremely dangerous</strong> because there is no guarantee
that types <code>α</code> and <code>β</code> have the same data representation, and this can lead to
memory unsafety. It is also logically unsound, since you could just cast
<code><a href=".././Init/Prelude.html#True">True</a></code> to <code><a href=".././Init/Prelude.html#False">False</a></code>. For all those reasons this function is marked as <code>unsafe</code>.</p><p>It is implemented by lifting both <code>α</code> and <code>β</code> into a common universe, and then
using <code><a href=".././Init/Prelude.html#cast">cast</a> (lcProof : <a href=".././Init/Prelude.html#ULift">ULift</a> (PLift α) = <a href=".././Init/Prelude.html#ULift">ULift</a> (PLift β))</code> to actually perform
the cast. All these operations are no-ops in the compiler.</p><p>Using this function correctly requires some knowledge of the data representation
of the source and target types. Some general classes of casts which are safe in
the current runtime:</p><ul>
<li><code><a href=".././Init/Prelude.html#Array">Array</a> α</code> to <code><a href=".././Init/Prelude.html#Array">Array</a> β</code> where <code>α</code> and <code>β</code> have compatible representations,
or more generally for other inductive types.</li>
<li><code><a href=".././Init/Prelude.html#Quot">Quot</a> α r</code> and <code>α</code>.</li>
<li><code>@Subtype α p</code> and <code>α</code>, or generally any structure containing only one
non-<code>Prop</code> field of type <code>α</code>.</li>
<li>Casting <code>α</code> to/from <code><a href=".././Init/Core.html#NonScalar">NonScalar</a></code> when <code>α</code> is a boxed generic type
(i.e. a function that accepts an arbitrary type <code>α</code> and is not specialized to
a scalar type like <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code>).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <a href=".././Init/Prelude.html#ULift.up">{</a> <span class="fn">down</span> := <a href=".././Init/Prelude.html#PLift.up">{</a> <span class="fn">down</span> := <span class="fn">a</span> <a href=".././Init/Prelude.html#PLift.up">}</a> <a href=".././Init/Prelude.html#ULift.up">}</a>)</span>.<a href=".././Init/Prelude.html#ULift.down">down</a></span>.<a href=".././Init/Prelude.html#PLift.down">down</a></span></li></ul></details><details id="instances-for-list-unsafeCast" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="panicCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3554-L3566">source</a></div><div class="attributes">@[never_extract, extern lean_panic_fn]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#panicCore"><span class="name">panicCore</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">msg</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Auxiliary definition for <code><a href=".././Init/Prelude.html#panic">panic</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#panicCore">panicCore</a> <span class="fn">msg</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a></li></ul></details><details id="instances-for-list-panicCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="panic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3568-L3581">source</a></div><div class="attributes">@[never_extract, noinline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#panic"><span class="name">panic</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">msg</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code>(panic &quot;msg&quot; : α)</code> has a built-in implementation which prints <code>msg</code> to
the error buffer. It <em>does not</em> terminate execution, and because it is a safe
function, it still has to return an element of <code>α</code>, so it takes <code>[Inhabited α]</code>
and returns <code><a href=".././Init/Prelude.html#Inhabited.default">default</a></code>. It is primarily intended for debugging in pure contexts,
and assertion failures.</p><p>Because this is a pure function with side effects, it is marked as
<code>@[never_extract]</code> so that the compiler will not perform common sub-expression
elimination and other optimizations that assume that the expression is pure.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#panic">panic</a> <span class="fn">msg</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#panicCore">panicCore</a> <span class="fn">msg</span></span></li></ul></details><details id="instances-for-list-panic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Bind"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3586-L3598">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Bind"><span class="name">Bind</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p>The <code>&gt;&gt;=</code> operator is overloaded via instances of <code><a href=".././Init/Prelude.html#Bind.bind">bind</a></code>.</p><p><code><a href=".././Init/Prelude.html#Bind">Bind</a></code> is typically used via <code><a href=".././Init/Prelude.html#Monad">Monad</a></code>, which extends it.</p><ul class="structure_fields" id="Bind.mk"><li id="Bind.bind" class="structure_field"><div class="structure_field_info">bind<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">(<span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span></div><div class="structure_field_doc"><p>Sequences two computations, allowing the second to depend on the value computed by the first.</p><p>If <code>x : m α</code> and <code>f : α → m β</code>, then <code>x &gt;&gt;= f : m β</code> represents the result of executing <code>x</code> to get
a value of type <code>α</code> and then passing it to <code>f</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&gt;&gt;=</code> in identifiers is <code><a href=".././Init/Prelude.html#Bind.bind">bind</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Bind" class="instances-list"></ul></details></div></div><div class="decl" id="Pure"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3602-L3616">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Pure"><span class="name">Pure</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p>The <code><a href=".././Init/Prelude.html#Pure.pure">pure</a></code> function is overloaded via <code><a href=".././Init/Prelude.html#Pure">Pure</a></code> instances.</p><p><code><a href=".././Init/Prelude.html#Pure">Pure</a></code> is typically accessed via <code><a href=".././Init/Prelude.html#Monad">Monad</a></code> or <code><a href=".././Init/Prelude.html#Applicative">Applicative</a></code> instances.</p><ul class="structure_fields" id="Pure.mk"><li id="Pure.pure" class="structure_field"><div class="structure_field_info">pure<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Given <code>a : α</code>, then <code><a href=".././Init/Prelude.html#Pure.pure">pure</a> a : f α</code> represents an action that does nothing and returns <code>a</code>.</p><p>Examples:</p><ul>
<li><code>(pure &quot;hello&quot; : <a href=".././Init/Prelude.html#Option">Option</a> String) = <a href=".././Init/Prelude.html#Option.some">some</a> &quot;hello&quot;</code></li>
<li><code>(pure &quot;hello&quot; : <a href=".././Init/Prelude.html#Except">Except</a> (Array String) String) = <a href=".././Init/Prelude.html#Except.ok">Except.ok</a> &quot;hello&quot;</code></li>
<li><code>(pure &quot;hello&quot; : <a href=".././Init/Control/State.html#StateM">StateM</a> <a href=".././Init/Prelude.html#Nat">Nat</a> String).<a href=".././Init/Prelude.html#ReaderT.run">run</a> 105 = (&quot;hello&quot;, 105)</code></li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Pure" class="instances-list"></ul></details></div></div><div class="decl" id="Functor"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3620-L3654">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Functor"><span class="name">Functor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p>A functor in the sense used in functional programming, which means a function <code>f : Type u → Type v</code>
has a way of mapping a function over its contents. This <code><a href=".././Init/Prelude.html#Option.map">map</a></code> operator is written <code>&lt;$&gt;</code>, and
overloaded via <code><a href=".././Init/Prelude.html#Functor">Functor</a></code> instances.</p><p>This <code><a href=".././Init/Prelude.html#Option.map">map</a></code> function should respect identity and function composition. In other words, for all terms
<code>v : f α</code>, it should be the case that:</p><ul>
<li><p><code><a href=".././Init/Prelude.html#id">id</a> &lt;$&gt; v = v</code></p>
</li>
<li><p>For all functions <code>h : β → γ</code> and <code>g : α → β</code>, <code>(h ∘ g) &lt;$&gt; v = h &lt;$&gt; g &lt;$&gt; v</code></p>
</li>
</ul><p>While all <code><a href=".././Init/Prelude.html#Functor">Functor</a></code> instances should live up to these requirements, they are not required to <em>prove</em>
that they do. Proofs may be required or provided via the <code><a href=".././Init/Control/Lawful/Basic.html#LawfulFunctor">LawfulFunctor</a></code> class.</p><p>Assuming that instances are lawful, this definition corresponds to the category-theoretic notion of
<a href="https://en.wikipedia.org/wiki/Functor">functor</a> in the special case where the category is the
category of types and functions between them.</p><ul class="structure_fields" id="Functor.mk"><li id="Functor.map" class="structure_field"><div class="structure_field_info">map<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></div><div class="structure_field_doc"><p>Applies a function inside a functor. This is used to overload the <code>&lt;$&gt;</code> operator.</p><p>When mapping a constant function, use <code><a href=".././Init/Prelude.html#Functor.mapConst">Functor.mapConst</a></code> instead, because it may be more
efficient.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;$&gt;</code> in identifiers is <code><a href=".././Init/Prelude.html#Option.map">map</a></code>.</li>
</ul></div></li><li id="Functor.mapConst" class="structure_field"><div class="structure_field_info">mapConst<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></span></div><div class="structure_field_doc"><p>Mapping a constant function.</p><p>Given <code>a : α</code> and <code>v : f α</code>, <code><a href=".././Init/Prelude.html#Functor.mapConst">mapConst</a> a v</code> is equivalent to <code><a href=".././Init/Prelude.html#Function.const">Function.const</a> _ a &lt;$&gt; v</code>. For some
functors, this can be implemented more efficiently; for all other functors, the default
implementation may be used.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Functor" class="instances-list"></ul></details></div></div><div class="decl" id="Seq"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3656-L3675">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Seq"><span class="name">Seq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p>The <code>&lt;*&gt;</code> operator is overloaded using the function <code><a href=".././Init/Prelude.html#Seq.seq">Seq.seq</a></code>.</p><p>While <code>&lt;$&gt;</code> from the class <code><a href=".././Init/Prelude.html#Functor">Functor</a></code> allows an ordinary function to be mapped over its contents,
<code>&lt;*&gt;</code> allows a function that's “inside” the functor to be applied. When thinking about <code>f</code> as
possible side effects, this captures evaluation order: <code><a href=".././Init/Prelude.html#Seq.seq">seq</a></code> arranges for the effects that produce
the function to occur prior to those that produce the argument value.</p><p>For most applications, <code><a href=".././Init/Prelude.html#Applicative">Applicative</a></code> or <code><a href=".././Init/Prelude.html#Monad">Monad</a></code> should be used rather than <code><a href=".././Init/Prelude.html#Seq">Seq</a></code> itself.</p><ul class="structure_fields" id="Seq.mk"><li id="Seq.seq" class="structure_field"><div class="structure_field_info">seq<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span></span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span>)</span> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></div><div class="structure_field_doc"><p>The implementation of the <code>&lt;*&gt;</code> operator.</p><p>In a monad, <code>mf &lt;*&gt; mx</code> is the same as <code>do let f ← mf; x ← mx; <a href=".././Init/Prelude.html#Pure.pure">pure</a> (f x)</code>: it evaluates the
function first, then the argument, and applies one to the other.</p><p>To avoid surprising evaluation semantics, <code>mx</code> is taken &quot;lazily&quot;, using a <code><a href=".././Init/Prelude.html#Unit">Unit</a> → f α</code> function.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;*&gt;</code> in identifiers is <code><a href=".././Init/Prelude.html#Seq.seq">seq</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Seq" class="instances-list"></ul></details></div></div><div class="decl" id="SeqLeft"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3677-L3697">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#SeqLeft"><span class="name">SeqLeft</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p>The <code>&lt;*</code> operator is overloaded using <code><a href=".././Init/Prelude.html#SeqLeft.seqLeft">seqLeft</a></code>.</p><p>When thinking about <code>f</code> as potential side effects, <code>&lt;*</code> evaluates first the left and then the right
argument for their side effects, discarding the value of the right argument and returning the value
of the left argument.</p><p>For most applications, <code><a href=".././Init/Prelude.html#Applicative">Applicative</a></code> or <code><a href=".././Init/Prelude.html#Monad">Monad</a></code> should be used rather than <code><a href=".././Init/Prelude.html#SeqLeft">SeqLeft</a></code> itself.</p><ul class="structure_fields" id="SeqLeft.mk"><li id="SeqLeft.seqLeft" class="structure_field"><div class="structure_field_info">seqLeft<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span>)</span> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></span></div><div class="structure_field_doc"><p>Sequences the effects of two terms, discarding the value of the second. This function is usually
invoked via the <code>&lt;*</code> operator.</p><p>Given <code>x : f α</code> and <code>y : f β</code>, <code>x &lt;* y</code> runs <code>x</code>, then runs <code>y</code>, and finally returns the result of
<code>x</code>.</p><p>The evaluation of the second argument is delayed by wrapping it in a function, enabling
“short-circuiting” behavior from <code>f</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;*</code> in identifiers is <code><a href=".././Init/Prelude.html#SeqLeft.seqLeft">seqLeft</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-SeqLeft" class="instances-list"></ul></details></div></div><div class="decl" id="SeqRight"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3699-L3719">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#SeqRight"><span class="name">SeqRight</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p>The <code>*&gt;</code> operator is overloaded using <code><a href=".././Init/Prelude.html#SeqRight.seqRight">seqRight</a></code>.</p><p>When thinking about <code>f</code> as potential side effects, <code>*&gt;</code> evaluates first the left and then the right
argument for their side effects, discarding the value of the left argument and returning the value
of the right argument.</p><p>For most applications, <code><a href=".././Init/Prelude.html#Applicative">Applicative</a></code> or <code><a href=".././Init/Prelude.html#Monad">Monad</a></code> should be used rather than <code><a href=".././Init/Prelude.html#SeqLeft">SeqLeft</a></code> itself.</p><ul class="structure_fields" id="SeqRight.mk"><li id="SeqRight.seqRight" class="structure_field"><div class="structure_field_info">seqRight<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span>)</span> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></div><div class="structure_field_doc"><p>Sequences the effects of two terms, discarding the value of the first. This function is usually
invoked via the <code>*&gt;</code> operator.</p><p>Given <code>x : f α</code> and <code>y : f β</code>, <code>x *&gt; y</code> runs <code>x</code>, then runs <code>y</code>, and finally returns the result of
<code>y</code>.</p><p>The evaluation of the second argument is delayed by wrapping it in a function, enabling
“short-circuiting” behavior from <code>f</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>*&gt;</code> in identifiers is <code><a href=".././Init/Prelude.html#SeqRight.seqRight">seqRight</a></code>.</li>
</ul></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-SeqRight" class="instances-list"></ul></details></div></div><div class="decl" id="Applicative"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3721-L3735">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Applicative"><span class="name">Applicative</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href=".././Init/Prelude.html#Functor">Functor</a> <span class="fn">f</span></span>, <span class="fn"><a href=".././Init/Prelude.html#Pure">Pure</a> <span class="fn">f</span></span>, <span class="fn"><a href=".././Init/Prelude.html#Seq">Seq</a> <span class="fn">f</span></span>, <span class="fn"><a href=".././Init/Prelude.html#SeqLeft">SeqLeft</a> <span class="fn">f</span></span>, <span class="fn"><a href=".././Init/Prelude.html#SeqRight">SeqRight</a> <span class="fn">f</span></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p>An <a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=monads-and-do">applicative functor</a> is more powerful than a <code><a href=".././Init/Prelude.html#Functor">Functor</a></code>, but
less powerful than a <code><a href=".././Init/Prelude.html#Monad">Monad</a></code>.</p><p>Applicative functors capture sequencing of effects with the <code>&lt;*&gt;</code> operator, overloaded as <code><a href=".././Init/Prelude.html#Seq.seq">seq</a></code>, but
not data-dependent effects. The results of earlier computations cannot be used to control later
effects.</p><p>Applicative functors should satisfy four laws. Instances of <code><a href=".././Init/Prelude.html#Applicative">Applicative</a></code> are not required to prove
that they satisfy these laws, which are part of the <code><a href=".././Init/Control/Lawful/Basic.html#LawfulApplicative">LawfulApplicative</a></code> class.</p><ul class="structure_fields" id="Applicative.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#Functor.map">map</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#Functor.mapConst">mapConst</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#Pure.pure">pure</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#Seq.seq">seq</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span></span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span>)</span> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#SeqLeft.seqLeft">seqLeft</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span>)</span> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#SeqRight.seqRight">seqRight</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span>)</span> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Applicative" class="instances-list"></ul></details></div></div><div class="decl" id="Monad"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3737-L3755">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Monad"><span class="name">Monad</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href=".././Init/Prelude.html#Applicative">Applicative</a> <span class="fn">m</span></span>, <span class="fn"><a href=".././Init/Prelude.html#Bind">Bind</a> <span class="fn">m</span></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p><a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">Monads</a> are an abstraction of
sequential control flow and side effects used in functional programming. Monads allow both
sequencing of effects and data-dependent effects: the values that result from an early step may
influence the effects carried out in a later step.</p><p>The <code><a href=".././Init/Prelude.html#Monad">Monad</a></code> API may be used directly. However, it is most commonly accessed through
<a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=do-notation"><code>do</code>-notation</a>.</p><p>Most <code><a href=".././Init/Prelude.html#Monad">Monad</a></code> instances provide implementations of <code><a href=".././Init/Prelude.html#Pure.pure">pure</a></code> and <code><a href=".././Init/Prelude.html#Bind.bind">bind</a></code>, and use default implementations
for the other methods inherited from <code><a href=".././Init/Prelude.html#Applicative">Applicative</a></code>. Monads should satisfy certain laws, but
instances are not required to prove this. An instance of <code><a href=".././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a></code> expresses that a given
monad's operations are lawful.</p><ul class="structure_fields" id="Monad.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#Functor.map">map</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span> → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#Functor.mapConst">mapConst</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#Pure.pure">pure</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#Seq.seq">seq</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span></span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#SeqLeft.seqLeft">seqLeft</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#SeqRight.seqRight">seqRight</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#Bind.bind">bind</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">(<span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Monad" class="instances-list"></ul></details></div></div><div class="decl" id="instInhabitedForallOfMonad"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3757-L3758">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedForallOfMonad"><span class="name">instInhabitedForallOfMonad</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedForallOfMonad">instInhabitedForallOfMonad</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Pure.pure">pure</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instInhabitedOfMonad"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3760-L3761">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedOfMonad"><span class="name">instInhabitedOfMonad</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">m</span> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedOfMonad">instInhabitedOfMonad</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="instNonemptyOfMonad"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3763-L3764">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instNonemptyOfMonad"><span class="name">instNonemptyOfMonad</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn">m</span> <span class="fn">α</span>)</span></span></div></div></div></div><div class="decl" id="MonadLift"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3766-L3784">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadLift"><span class="name">MonadLift</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a> <span class="fn">(<a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max (u + 1) v) w)</div></div><p>Computations in the monad <code>m</code> can be run in the monad <code>n</code>. These translations are inserted
automatically by the compiler.</p><p>Usually, <code>n</code> consists of some number of monad transformers applied to <code>m</code>, but this is not
mandatory.</p><p>New instances should use this class, <code><a href=".././Init/Prelude.html#MonadLift">MonadLift</a></code>. Clients that require one monad to be liftable into
another should instead request <code><a href=".././Init/Prelude.html#MonadLiftT">MonadLiftT</a></code>, which is the reflexive, transitive closure of
<code><a href=".././Init/Prelude.html#MonadLift">MonadLift</a></code>.</p><ul class="structure_fields" id="MonadLift.mk"><li id="MonadLift.monadLift" class="structure_field"><div class="structure_field_info">monadLift<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Translates an action from monad <code>m</code> into monad <code>n</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadLift" class="instances-list"></ul></details></div></div><div class="decl" id="MonadLiftT"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3786-L3802">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadLiftT"><span class="name">MonadLiftT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max (u + 1) v) w)</div></div><p>Computations in the monad <code>m</code> can be run in the monad <code>n</code>. These translations are inserted
automatically by the compiler.</p><p>Usually, <code>n</code> consists of some number of monad transformers applied to <code>m</code>, but this is not
mandatory.</p><p>This is the reflexive, transitive closure of <code><a href=".././Init/Prelude.html#MonadLift">MonadLift</a></code>. Clients that require one monad to be
liftable into another should request an instance of <code><a href=".././Init/Prelude.html#MonadLiftT">MonadLiftT</a></code>. New instances should instead be
defined for <code><a href=".././Init/Prelude.html#MonadLift">MonadLift</a></code> itself.</p><ul class="structure_fields" id="MonadLiftT.mk"><li id="MonadLiftT.monadLift" class="structure_field"><div class="structure_field_info">monadLift<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Translates an action from monad <code>m</code> into monad <code>n</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadLiftT" class="instances-list"></ul></details></div></div><div class="decl" id="liftM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3806-L3807">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#liftM"><span class="name">liftM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">self</span> : <span class="fn"><a href=".././Init/Prelude.html#MonadLiftT">MonadLiftT</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></div></div><p>Translates an action from monad <code>m</code> into monad <code>n</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href=".././Init/Prelude.html#liftM">liftM</a> <a href=".././Init/Prelude.html#Eq">=</a> @<a href=".././Init/Prelude.html#MonadLiftT.monadLift">monadLift</a></li></ul></details><details id="instances-for-list-liftM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instMonadLiftTOfMonadLift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3809-L3811">source</a></div><div class="attributes">@[always_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadLiftTOfMonadLift"><span class="name">instMonadLiftTOfMonadLift</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_3</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_4</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">n</span> <span class="fn">o</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadLiftT">MonadLiftT</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadLiftT">MonadLiftT</a> <span class="fn">m</span> <span class="fn">o</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instMonadLiftTOfMonadLift">instMonadLiftTOfMonadLift</a> <span class="fn">m</span> <span class="fn">n</span> <span class="fn">o</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadLiftT.mk">{</a> <span class="fn">monadLift</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.12} (<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#MonadLift.monadLift">MonadLift.monadLift</a> <span class="fn">(<a href=".././Init/Prelude.html#MonadLiftT.monadLift">monadLift</a> <span class="fn">x</span>)</span></span></span> <a href=".././Init/Prelude.html#MonadLiftT.mk">}</a></li></ul></details></div></div><div class="decl" id="instMonadLiftT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3813-L3814">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadLiftT"><span class="name">instMonadLiftT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadLiftT">MonadLiftT</a> <span class="fn">m</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instMonadLiftT">instMonadLiftT</a> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadLiftT.mk">{</a> <span class="fn">monadLift</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.10} (<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>) =&gt; <span class="fn">x</span></span> <a href=".././Init/Prelude.html#MonadLiftT.mk">}</a></li></ul></details></div></div><div class="decl" id="MonadEval"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3816-L3826">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadEval"><span class="name">MonadEval</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a> <span class="fn">(<a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max (u + 1) v) w)</div></div><p>Typeclass used for adapting monads. This is similar to <code><a href=".././Init/Prelude.html#MonadLift">MonadLift</a></code>, but instances are allowed to
make use of default state for the purpose of synthesizing such an instance, if necessary.
Every <code><a href=".././Init/Prelude.html#MonadLift">MonadLift</a></code> instance gives a <code><a href=".././Init/Prelude.html#MonadEval">MonadEval</a></code> instance.</p><p>The purpose of this class is for the <code>#eval</code> command,
which looks for a <code><a href=".././Init/Prelude.html#MonadEval">MonadEval</a> m CommandElabM</code> or <code><a href=".././Init/Prelude.html#MonadEval">MonadEval</a> m <a href=".././Init/System/IO.html#IO">IO</a></code> instance.</p><ul class="structure_fields" id="MonadEval.mk"><li id="MonadEval.monadEval" class="structure_field"><div class="structure_field_info">monadEval<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Evaluates a value from monad <code>m</code> into monad <code>n</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadEval" class="instances-list"></ul></details></div></div><div class="decl" id="instMonadEvalOfMonadLift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3828-L3829">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadEvalOfMonadLift"><span class="name">instMonadEvalOfMonadLift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadEval">MonadEval</a> <span class="fn">m</span> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instMonadEvalOfMonadLift">instMonadEvalOfMonadLift</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadEval.mk">{</a> <span class="fn">monadEval</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.19} =&gt; <a href=".././Init/Prelude.html#MonadLift.monadLift">MonadLift.monadLift</a></span> <a href=".././Init/Prelude.html#MonadEval.mk">}</a></li></ul></details></div></div><div class="decl" id="MonadEvalT"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3831-L3834">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadEvalT"><span class="name">MonadEvalT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max (u + 1) v) w)</div></div><p>The transitive closure of <code><a href=".././Init/Prelude.html#MonadEval">MonadEval</a></code>.</p><ul class="structure_fields" id="MonadEvalT.mk"><li id="MonadEvalT.monadEval" class="structure_field"><div class="structure_field_info">monadEval<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Evaluates a value from monad <code>m</code> into monad <code>n</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadEvalT" class="instances-list"></ul></details></div></div><div class="decl" id="instMonadEvalTOfMonadEval"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3836-L3837">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadEvalTOfMonadEval"><span class="name">instMonadEvalTOfMonadEval</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_3</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_4</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadEval">MonadEval</a> <span class="fn">n</span> <span class="fn">o</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadEvalT">MonadEvalT</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadEvalT">MonadEvalT</a> <span class="fn">m</span> <span class="fn">o</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instMonadEvalTOfMonadEval">instMonadEvalTOfMonadEval</a> <span class="fn">m</span> <span class="fn">n</span> <span class="fn">o</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <a href=".././Init/Prelude.html#MonadEvalT.mk">{</a> <span class="fn">monadEval</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.30} (<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#MonadEval.monadEval">MonadEval.monadEval</a> <span class="fn">(<a href=".././Init/Prelude.html#MonadEvalT.monadEval">MonadEvalT.monadEval</a> <span class="fn">x</span>)</span></span></span> <a href=".././Init/Prelude.html#MonadEvalT.mk">}</a></li></ul></details></div></div><div class="decl" id="instMonadEvalT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3839-L3840">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadEvalT"><span class="name">instMonadEvalT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadEvalT">MonadEvalT</a> <span class="fn">m</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instMonadEvalT">instMonadEvalT</a> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadEvalT.mk">{</a> <span class="fn">monadEval</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.10} (<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>) =&gt; <span class="fn">x</span></span> <a href=".././Init/Prelude.html#MonadEvalT.mk">}</a></li></ul></details></div></div><div class="decl" id="MonadFunctor"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3842-L3858">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadFunctor"><span class="name">MonadFunctor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a> <span class="fn">(<a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max (u + 1) v) w)</div></div><p>A way to interpret a fully-polymorphic function in <code>m</code> into <code>n</code>. Such a function can be thought of
as one that may change the effects in <code>m</code>, but can't do so based on specific values that are
provided.</p><p>Clients of <code><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a></code> should typically use <code><a href=".././Init/Prelude.html#MonadFunctorT">MonadFunctorT</a></code>, which is the reflexive, transitive
closure of <code><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a></code>. New instances should be defined for <code>MonadFunctor.</code></p><ul class="structure_fields" id="MonadFunctor.mk"><li id="MonadFunctor.monadMap" class="structure_field"><div class="structure_field_info">monadMap<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">({<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span>)</span> → <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></span></div><div class="structure_field_doc"><p>Lifts a fully-polymorphic transformation of <code>m</code> into <code>n</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadFunctor" class="instances-list"></ul></details></div></div><div class="decl" id="MonadFunctorT"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3860-L3873">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadFunctorT"><span class="name">MonadFunctorT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max (u + 1) v) w)</div></div><p>A way to interpret a fully-polymorphic function in <code>m</code> into <code>n</code>. Such a function can be thought of
as one that may change the effects in <code>m</code>, but can't do so based on specific values that are
provided.</p><p>This is the reflexive, transitive closure of <code><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a></code>. It automatically chains together
<code><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a></code> instances as needed. Clients of <code><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a></code> should typically use <code><a href=".././Init/Prelude.html#MonadFunctorT">MonadFunctorT</a></code>,
but new instances should be defined for <code><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a></code>.</p><ul class="structure_fields" id="MonadFunctorT.mk"><li id="MonadFunctorT.monadMap" class="structure_field"><div class="structure_field_info">monadMap<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">({<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span>)</span> → <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></span></div><div class="structure_field_doc"><p>Lifts a fully-polymorphic transformation of <code>m</code> into <code>n</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadFunctorT" class="instances-list"></ul></details></div></div><div class="decl" id="instMonadFunctorTOfMonadFunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3877-L3879">source</a></div><div class="attributes">@[always_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadFunctorTOfMonadFunctor"><span class="name">instMonadFunctorTOfMonadFunctor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_3</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_4</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a> <span class="fn">n</span> <span class="fn">o</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadFunctorT">MonadFunctorT</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadFunctorT">MonadFunctorT</a> <span class="fn">m</span> <span class="fn">o</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="monadFunctorRefl"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3881-L3882">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#monadFunctorRefl"><span class="name">monadFunctorRefl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadFunctorT">MonadFunctorT</a> <span class="fn">m</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#monadFunctorRefl">monadFunctorRefl</a> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadFunctorT.mk">{</a> <span class="fn">monadMap</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.12} (<span class="fn">f</span> : <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> ?u.12} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span>) =&gt; <span class="fn">f</span></span> <a href=".././Init/Prelude.html#MonadFunctorT.mk">}</a></li></ul></details></div></div><div class="decl" id="Except"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3884-L3896">source</a></div><div class="attributes">@[unbox]</div>
<div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Except"><span class="name">Except</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p><code><a href=".././Init/Prelude.html#Except">Except</a> ε α</code> is a type which represents either an error of type <code>ε</code> or a successful result with a
value of type <code>α</code>.</p><p><code><a href=".././Init/Prelude.html#Except">Except</a> ε : Type u → Type v</code> is a <code><a href=".././Init/Prelude.html#Monad">Monad</a></code> that represents computations that may throw exceptions:
the <code><a href=".././Init/Prelude.html#Pure.pure">pure</a></code> operation is <code><a href=".././Init/Prelude.html#Except.ok">Except.ok</a></code> and the <code><a href=".././Init/Prelude.html#Bind.bind">bind</a></code> operation returns the first encountered
<code><a href=".././Init/Prelude.html#Except.error">Except.error</a></code>.</p><ul class="constructors"><li class="constructor" id="Except.error">error<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span> : <span class="fn"><span class="fn">ε</span> → <span class="fn"><a href=".././Init/Prelude.html#Except">Except</a> <span class="fn">ε</span> <span class="fn">α</span></span></span><div class="inductive_ctor_doc"><p>A failure value of type <code>ε</code></p></div></li><li class="constructor" id="Except.ok">ok<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#Except">Except</a> <span class="fn">ε</span> <span class="fn">α</span></span></span><div class="inductive_ctor_doc"><p>A success value of type <code>α</code></p></div></li></ul><details id="instances-for-list-Except" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedExcept"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3900-L3901">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedExcept"><span class="name">instInhabitedExcept</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">ε</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Prelude.html#Except">Except</a> <span class="fn">ε</span> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instInhabitedExcept">instInhabitedExcept</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#Except.error">Except.error</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="MonadExceptOf"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3903-L3920">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadExceptOf"><span class="name">MonadExceptOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <span class="fn"><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> v → <a href=".././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u (v + 1)) w)</div></div><p>Exception monads provide the ability to throw errors and handle errors.</p><p>In this class, <code>ε</code> is a <code><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a></code>, which means that it can influence the choice of instance.
<code><a href=".././Init/Prelude.html#MonadExcept">MonadExcept</a> ε</code> provides the same operations, but requires that <code>ε</code> be inferable from <code>m</code>.</p><p><code><a href=".././Init/Prelude.html#tryCatchThe">tryCatchThe</a></code>, which takes an explicit exception type, is used to desugar <code>try ... catch ...</code> steps
inside <code>do</code>-blocks when the handlers have type annotations.</p><ul class="structure_fields" id="MonadExceptOf.mk"><li id="MonadExceptOf.throw" class="structure_field"><div class="structure_field_info">throw<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span> : <span class="fn"><span class="fn">ε</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Throws an exception of type <code>ε</code> to the nearest enclosing <code>catch</code>.</p></div></li><li id="MonadExceptOf.tryCatch" class="structure_field"><div class="structure_field_info">tryCatch<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">body</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">handler</span> : <span class="fn"><span class="fn">ε</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span>)</span></span>
 : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div><div class="structure_field_doc"><p>Catches errors thrown in <code>body</code>, passing them to <code>handler</code>. Errors in <code>handler</code> are not caught.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadExceptOf" class="instances-list"></ul></details></div></div><div class="decl" id="throwThe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3922-L3929">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#throwThe"><span class="name">throwThe</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> v → <a href=".././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">ε</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>Throws an exception, with the exception type specified explicitly. This is useful when a monad
supports throwing more than one type of exception.</p><p>Use <code><a href=".././Init/Prelude.html#MonadExceptOf.throw">throw</a></code> for a version that expects the exception type to be inferred from <code>m</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#throwThe">throwThe</a> <span class="fn">ε</span> <span class="fn">e</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf.throw">MonadExceptOf.throw</a> <span class="fn">e</span></span></li></ul></details><details id="instances-for-list-throwThe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="tryCatchThe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3931-L3938">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#tryCatchThe"><span class="name">tryCatchThe</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> v → <a href=".././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">handle</span> : <span class="fn"><span class="fn">ε</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>Catches errors, recovering using <code>handle</code>. The exception type is specified explicitly. This is useful when a monad
supports throwing or handling more than one type of exception.</p><p>Use <code><a href=".././Init/Prelude.html#MonadExceptOf.tryCatch">tryCatch</a></code>, for a version that expects the exception type to be inferred from <code>m</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#tryCatchThe">tryCatchThe</a> <span class="fn">ε</span> <span class="fn">x</span> <span class="fn">handle</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf.tryCatch">MonadExceptOf.tryCatch</a> <span class="fn">x</span> <span class="fn">handle</span></span></li></ul></details><details id="instances-for-list-tryCatchThe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="MonadExcept"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3940-L3957">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadExcept"><span class="name">MonadExcept</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> v → <a href=".././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max u (v + 1)) w)</div></div><p>Exception monads provide the ability to throw errors and handle errors.</p><p>In this class, <code>ε</code> is an <code><a href=".././Init/Prelude.html#outParam">outParam</a></code>, which means that it is inferred from <code>m</code>. <code><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> ε</code>
provides the same operations, but allows <code>ε</code> to influence instance synthesis.</p><p><code><a href=".././Init/Prelude.html#MonadExcept.tryCatch">MonadExcept.tryCatch</a></code> is used to desugar <code>try ... catch ...</code> steps inside <code>do</code>-blocks when the
handlers do not have exception type annotations.</p><ul class="structure_fields" id="MonadExcept.mk"><li id="MonadExcept.throw" class="structure_field"><div class="structure_field_info">throw<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span> : <span class="fn"><span class="fn">ε</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Throws an exception of type <code>ε</code> to the nearest enclosing handler.</p></div></li><li id="MonadExcept.tryCatch" class="structure_field"><div class="structure_field_info">tryCatch<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">body</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">handler</span> : <span class="fn"><span class="fn">ε</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span>)</span></span>
 : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div><div class="structure_field_doc"><p>Catches errors thrown in <code>body</code>, passing them to <code>handler</code>. Errors in <code>handler</code> are not caught.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadExcept" class="instances-list"></ul></details></div></div><div class="decl" id="MonadExcept.ofExcept"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3959-L3965">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadExcept.ofExcept"><span class="name">MonadExcept</span>.<span class="name">ofExcept</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε</span> : <a href=".././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadExcept">MonadExcept</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Except">Except</a> <span class="fn">ε</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div></div><p>Re-interprets an <code><a href=".././Init/Prelude.html#Except">Except</a> ε</code> action in an exception monad <code>m</code>, succeeding if it succeeds and throwing
an exception if it throws an exception.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#MonadExcept.ofExcept">ofExcept</a> <span class="fn">(<a href=".././Init/Prelude.html#Except.ok">Except.ok</a> <span class="fn">a</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">a</span></span></li><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#MonadExcept.ofExcept">ofExcept</a> <span class="fn">(<a href=".././Init/Prelude.html#Except.error">Except.error</a> <span class="fn">e</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadExcept.throw">throw</a> <span class="fn">e</span></span></li></ul></details><details id="instances-for-list-MonadExcept.ofExcept" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instMonadExceptOfMonadExceptOf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3969-L3971">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadExceptOfMonadExceptOf"><span class="name">instMonadExceptOfMonadExceptOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> v → <a href=".././foundational_types.html">Type</a> w</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadExcept">MonadExcept</a> <span class="fn">ε</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instMonadExceptOfMonadExceptOf">instMonadExceptOfMonadExceptOf</a> <span class="fn">ε</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <a href=".././Init/Prelude.html#MonadExcept.mk">{</a> <span class="fn">throw</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.18} =&gt; <span class="fn"><a href=".././Init/Prelude.html#throwThe">throwThe</a> <span class="fn">ε</span></span></span>, <span class="fn">tryCatch</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.18} =&gt; <span class="fn"><a href=".././Init/Prelude.html#tryCatchThe">tryCatchThe</a> <span class="fn">ε</span></span></span> <a href=".././Init/Prelude.html#MonadExcept.mk">}</a></li></ul></details></div></div><div class="decl" id="MonadExcept.orElse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3976-L3983">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadExcept.orElse"><span class="name">MonadExcept</span>.<span class="name">orElse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> v → <a href=".././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadExcept">MonadExcept</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t₁</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t₂</span> : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>Unconditional error recovery that ignores which exception was thrown. Usually used via the <code>&lt;|&gt;</code>
operator.</p><p>If both computations throw exceptions, then the result is the second exception.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#MonadExcept.orElse">MonadExcept.orElse</a> <span class="fn">t₁</span> <span class="fn">t₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadExcept.tryCatch">tryCatch</a> <span class="fn">t₁</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">ε</span>) =&gt; <span class="fn"><span class="fn">t₂</span> <a href=".././Init/Prelude.html#Unit.unit">(</a><a href=".././Init/Prelude.html#Unit.unit">)</a></span></span></span></li></ul></details><details id="instances-for-list-MonadExcept.orElse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="MonadExcept.instOrElse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3985-L3986">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadExcept.instOrElse"><span class="name">MonadExcept</span>.<span class="name">instOrElse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> v → <a href=".././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadExcept">MonadExcept</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#OrElse">OrElse</a> <span class="fn">(<span class="fn">m</span> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#MonadExcept.instOrElse">MonadExcept.instOrElse</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#OrElse.mk">{</a> <span class="fn">orElse</span> := <a href=".././Init/Prelude.html#MonadExcept.orElse">MonadExcept.orElse</a> <a href=".././Init/Prelude.html#OrElse.mk">}</a></li></ul></details></div></div><div class="decl" id="ReaderT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L3990-L3998">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT"><span class="name">ReaderT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>Adds the ability to access a read-only value of type <code>ρ</code> to a monad. The value can be locally
overridden by <code><a href=".././Init/Prelude.html#MonadWithReaderOf.withReader">withReader</a></code>, but it cannot be mutated.</p><p>Actions in the resulting monad are functions that take the local value as a parameter, returning
ordinary actions in <code>m</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">ρ</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></li></ul></details><details id="instances-for-list-ReaderT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedReaderT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4000-L4001">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedReaderT"><span class="name">instInhabitedReaderT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">m</span> <span class="fn">α</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedReaderT">instInhabitedReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn">ρ</span>) =&gt; <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="ReaderT.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4003-L4008">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.run"><span class="name">ReaderT</span>.<span class="name">run</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">ρ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>Executes an action from a monad with a read-only value in the underlying monad <code>m</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#ReaderT.run">run</a></span> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <span class="fn">r</span></span></li></ul></details><details id="instances-for-list-ReaderT.run" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ReaderT.instMonadLift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4015-L4016">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.instMonadLift"><span class="name">ReaderT</span>.<span class="name">instMonadLift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">m</span> <span class="fn">(<a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#ReaderT.instMonadLift">ReaderT.instMonadLift</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadLift.mk">{</a> <span class="fn">monadLift</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.16} (<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>) (<span class="fn">x_1</span> : <span class="fn">ρ</span>) =&gt; <span class="fn">x</span></span> <a href=".././Init/Prelude.html#MonadLift.mk">}</a></li></ul></details></div></div><div class="decl" id="ReaderT.instMonadExceptOf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4018-L4021">source</a></div><div class="attributes">@[always_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.instMonadExceptOf"><span class="name">ReaderT</span>.<span class="name">instMonadExceptOf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <a href=".././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> <span class="fn">ε</span> <span class="fn">(<a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="ReaderT.read"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4028-L4034">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.read"><span class="name">ReaderT</span>.<span class="name">read</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">ρ</span></span></div></div><p>Retrieves the reader monad's local value. Typically accessed via <code><a href=".././Init/Prelude.html#ReaderT.read">read</a></code>, or via <code><a href=".././Init/Prelude.html#readThe">readThe</a></code> when more
than one local value is available.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#ReaderT.read">ReaderT.read</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Pure.pure">pure</a></li></ul></details><details id="instances-for-list-ReaderT.read" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ReaderT.pure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4036-L4042">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.pure"><span class="name">ReaderT</span>.<span class="name">pure</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span></div></div><p>Returns the provided value <code>a</code>, ignoring the reader monad's local value. Typically used via
<code><a href=".././Init/Prelude.html#Pure.pure">Pure.pure</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#ReaderT.pure">ReaderT.pure</a> <span class="fn">a</span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">a</span></span></li></ul></details><details id="instances-for-list-ReaderT.pure" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ReaderT.bind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4044-L4050">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.bind"><span class="name">ReaderT</span>.<span class="name">bind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">β</span></span></div></div><p>Sequences two reader monad computations. Both are provided with the local value, and the second is
passed the value of the first. Typically used via the <code>&gt;&gt;=</code> operator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#ReaderT.bind">bind</a></span> <span class="fn">f</span> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">a</span> ← <span class="fn"><span class="fn">x</span> <span class="fn">r</span></span>
  <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">r</span></span></span></li></ul></details><details id="instances-for-list-ReaderT.bind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ReaderT.instFunctorOfMonad"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4052-L4055">source</a></div><div class="attributes">@[always_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.instFunctorOfMonad"><span class="name">ReaderT</span>.<span class="name">instFunctorOfMonad</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Functor">Functor</a> <span class="fn">(<a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="ReaderT.instApplicativeOfMonad"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4057-L4062">source</a></div><div class="attributes">@[always_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.instApplicativeOfMonad"><span class="name">ReaderT</span>.<span class="name">instApplicativeOfMonad</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Applicative">Applicative</a> <span class="fn">(<a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="ReaderT.instMonad"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4064-L4065">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.instMonad"><span class="name">ReaderT</span>.<span class="name">instMonad</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">(<a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#ReaderT.instMonad">ReaderT.instMonad</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Monad.mk">{</a> <span class="fn">toApplicative</span> := <a href=".././Init/Prelude.html#ReaderT.instApplicativeOfMonad">ReaderT.instApplicativeOfMonad</a>, <span class="fn">bind</span> := <span class="fn">fun {<span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> ?u.19} =&gt; <a href=".././Init/Prelude.html#ReaderT.bind">ReaderT.bind</a></span> <a href=".././Init/Prelude.html#Monad.mk">}</a></li></ul></details></div></div><div class="decl" id="ReaderT.instMonadFunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4067-L4068">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.instMonadFunctor"><span class="name">ReaderT</span>.<span class="name">instMonadFunctor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u_1 → <a href=".././foundational_types.html">Type</a> u_2</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a> <span class="fn">m</span> <span class="fn">(<a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#ReaderT.instMonadFunctor">ReaderT.instMonadFunctor</a> <span class="fn">ρ</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <a href=".././Init/Prelude.html#MonadFunctor.mk">{</a> <span class="fn">monadMap</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.19} (<span class="fn">f</span> : <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> ?u.19} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span>) (<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span>) (<span class="fn">ctx</span> : <span class="fn">ρ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">x</span> <span class="fn">ctx</span>)</span></span></span> <a href=".././Init/Prelude.html#MonadFunctor.mk">}</a></li></ul></details></div></div><div class="decl" id="ReaderT.adapt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4070-L4076">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.adapt"><span class="name">ReaderT</span>.<span class="name">adapt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ' </span><span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">ρ'</span> → <span class="fn">ρ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ'</span> <span class="fn">m</span> <span class="fn">α</span></span></span></div></div><p>Modifies a reader monad's local value with <code>f</code>. The resulting computation applies <code>f</code> to the
incoming local value and passes the result to the inner computation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#ReaderT.adapt">ReaderT.adapt</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <span class="fn">(<span class="fn">f</span> <span class="fn">r</span>)</span></span></li></ul></details><details id="instances-for-list-ReaderT.adapt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="MonadReaderOf"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4081-L4096">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadReaderOf"><span class="name">MonadReaderOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <span class="fn"><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> v</div></div><p>Reader monads provide the ability to implicitly thread a value through a computation. The value can
be read, but not written. A <code><a href=".././Init/Prelude.html#MonadWithReader">MonadWithReader</a> ρ</code> instance additionally allows the value to be locally
overridden for a sub-computation.</p><p>In this class, <code>ρ</code> is a <code><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a></code>, which means that it can influence the choice of instance.
<code><a href=".././Init/Prelude.html#MonadReader">MonadReader</a> ρ</code> provides the same operations, but requires that <code>ρ</code> be inferable from <code>m</code>.</p><ul class="structure_fields" id="MonadReaderOf.mk"><li id="MonadReaderOf.read" class="structure_field"><div class="structure_field_info">read : <span class="fn"><span class="fn">m</span> <span class="fn">ρ</span></span></div><div class="structure_field_doc"><p>Retrieves the local value.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadReaderOf" class="instances-list"></ul></details></div></div><div class="decl" id="MonadReader"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4098-L4112">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadReader"><span class="name">MonadReader</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> v</div></div><p>Reader monads provide the ability to implicitly thread a value through a computation. The value can
be read, but not written. A <code><a href=".././Init/Prelude.html#MonadWithReader">MonadWithReader</a> ρ</code> instance additionally allows the value to be locally
overridden for a sub-computation.</p><p>In this class, <code>ρ</code> is an <code><a href=".././Init/Prelude.html#outParam">outParam</a></code>, which means that it is inferred from <code>m</code>. <code><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a> ρ</code>
provides the same operations, but allows <code>ρ</code> to influence instance synthesis.</p><ul class="structure_fields" id="MonadReader.mk"><li id="MonadReader.read" class="structure_field"><div class="structure_field_info">read : <span class="fn"><span class="fn">m</span> <span class="fn">ρ</span></span></div><div class="structure_field_doc"><p>Retrieves the local value.</p><p>Use <code><a href=".././Init/Prelude.html#readThe">readThe</a></code> to explicitly specify a type when more than one value is available.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadReader" class="instances-list"></ul></details></div></div><div class="decl" id="readThe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4116-L4124">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#readThe"><span class="name">readThe</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">ρ</span></span></div></div><p>Retrieves the local value whose type is <code>ρ</code>.  This is useful when a monad supports reading more than
one type of value.</p><p>Use <code><a href=".././Init/Prelude.html#ReaderT.read">read</a></code> for a version that expects the type <code>ρ</code> to be inferred from <code>m</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#readThe">readThe</a> <span class="fn">ρ</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadReaderOf.read">MonadReaderOf.read</a></li></ul></details><details id="instances-for-list-readThe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instMonadReaderOfMonadReaderOf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4126-L4127">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadReaderOfMonadReaderOf"><span class="name">instMonadReaderOfMonadReaderOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadReader">MonadReader</a> <span class="fn">ρ</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instMonadReaderOfMonadReaderOf">instMonadReaderOfMonadReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadReader.mk">{</a> <span class="fn">read</span> := <span class="fn"><a href=".././Init/Prelude.html#readThe">readThe</a> <span class="fn">ρ</span></span> <a href=".././Init/Prelude.html#MonadReader.mk">}</a></li></ul></details></div></div><div class="decl" id="instMonadReaderOfOfMonadLift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4129-L4130">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadReaderOfOfMonadLift"><span class="name">instMonadReaderOfOfMonadLift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a> <span class="fn">ρ</span> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instMonadReaderOfOfMonadLift">instMonadReaderOfOfMonadLift</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadReaderOf.mk">{</a> <span class="fn">read</span> := <span class="fn"><a href=".././Init/Prelude.html#liftM">liftM</a> <a href=".././Init/Prelude.html#MonadReader.read">read</a></span> <a href=".././Init/Prelude.html#MonadReaderOf.mk">}</a></li></ul></details></div></div><div class="decl" id="instMonadReaderOfReaderTOfMonad"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4132-L4133">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadReaderOfReaderTOfMonad"><span class="name">instMonadReaderOfReaderTOfMonad</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a> <span class="fn">ρ</span> <span class="fn">(<a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instMonadReaderOfReaderTOfMonad">instMonadReaderOfReaderTOfMonad</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadReaderOf.mk">{</a> <span class="fn">read</span> := <a href=".././Init/Prelude.html#ReaderT.read">ReaderT.read</a> <a href=".././Init/Prelude.html#MonadReaderOf.mk">}</a></li></ul></details></div></div><div class="decl" id="MonadWithReaderOf"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4135-L4148">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadWithReaderOf"><span class="name">MonadWithReaderOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <span class="fn"><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p>A reader monad that additionally allows the value to be locally overridden.</p><p>In this class, <code>ρ</code> is a <code><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a></code>, which means that it can influence the choice of instance.
<code><a href=".././Init/Prelude.html#MonadWithReader">MonadWithReader</a> ρ</code> provides the same operations, but requires that <code>ρ</code> be inferable from <code>m</code>.</p><ul class="structure_fields" id="MonadWithReaderOf.mk"><li id="MonadWithReaderOf.withReader" class="structure_field"><div class="structure_field_info">withReader<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">ρ</span> → <span class="fn">ρ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
 : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div><div class="structure_field_doc"><p>Locally modifies the reader monad's value while running an action.</p><p>During the inner action <code>x</code>, reading the value returns <code>f</code> applied to the original value. After
control returns from <code>x</code>, the reader monad's value is restored.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadWithReaderOf" class="instances-list"></ul></details></div></div><div class="decl" id="withTheReader"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4150-L4162">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#withTheReader"><span class="name">withTheReader</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">ρ</span> → <span class="fn">ρ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>Locally modifies the reader monad's value while running an action, with the reader monad's local
value type specified explicitly. This is useful when a monad supports reading more than one type of
value.</p><p>During the inner action <code>x</code>, reading the value returns <code>f</code> applied to the original value. After
control returns from <code>x</code>, the reader monad's value is restored.</p><p>Use <code><a href=".././Init/Prelude.html#MonadWithReaderOf.withReader">withReader</a></code> for a version that expects the local value's type to be inferred from <code>m</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#withTheReader">withTheReader</a> <span class="fn">ρ</span> <span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadWithReaderOf.withReader">MonadWithReaderOf.withReader</a> <span class="fn">f</span> <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-withTheReader" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="MonadWithReader"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4164-L4177">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadWithReader"><span class="name">MonadWithReader</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p>A reader monad that additionally allows the value to be locally overridden.</p><p>In this class, <code>ρ</code> is an <code><a href=".././Init/Prelude.html#outParam">outParam</a></code>, which means that it is inferred from <code>m</code>. <code><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a> ρ</code>
provides the same operations, but allows <code>ρ</code> to influence instance synthesis.</p><ul class="structure_fields" id="MonadWithReader.mk"><li id="MonadWithReader.withReader" class="structure_field"><div class="structure_field_info">withReader<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">ρ</span> → <span class="fn">ρ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
 : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div><div class="structure_field_doc"><p>Locally modifies the reader monad's value while running an action.</p><p>During the inner action <code>x</code>, reading the value returns <code>f</code> applied to the original value. After
control returns from <code>x</code>, the reader monad's value is restored.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadWithReader" class="instances-list"></ul></details></div></div><div class="decl" id="instMonadWithReaderOfMonadWithReaderOf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4181-L4182">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadWithReaderOfMonadWithReaderOf"><span class="name">instMonadWithReaderOfMonadWithReaderOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadWithReader">MonadWithReader</a> <span class="fn">ρ</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instMonadWithReaderOfMonadWithReaderOf">instMonadWithReaderOfMonadWithReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadWithReader.mk">{</a> <span class="fn">withReader</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.17} =&gt; <span class="fn"><a href=".././Init/Prelude.html#withTheReader">withTheReader</a> <span class="fn">ρ</span></span></span> <a href=".././Init/Prelude.html#MonadWithReader.mk">}</a></li></ul></details></div></div><div class="decl" id="instMonadWithReaderOfOfMonadFunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4184-L4185">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadWithReaderOfOfMonadFunctor"><span class="name">instMonadWithReaderOfOfMonadFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a> <span class="fn">ρ</span> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instMonadWithReaderOfOfMonadFunctor">instMonadWithReaderOfOfMonadFunctor</a> <a href=".././Init/Prelude.html#Eq">=</a>   <a href=".././Init/Prelude.html#MonadWithReaderOf.mk">{</a> <span class="fn">withReader</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.28} (<span class="fn">f</span> : <span class="fn"><span class="fn">ρ</span> → <span class="fn">ρ</span></span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#MonadFunctorT.monadMap">monadMap</a> <span class="fn">fun {<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> ?u.28} =&gt; <span class="fn"><a href=".././Init/Prelude.html#withTheReader">withTheReader</a> <span class="fn">ρ</span> <span class="fn">f</span></span></span></span></span> <a href=".././Init/Prelude.html#MonadWithReaderOf.mk">}</a></li></ul></details></div></div><div class="decl" id="instMonadWithReaderOfReaderT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4187-L4188">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadWithReaderOfReaderT"><span class="name">instMonadWithReaderOfReaderT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a> <span class="fn">ρ</span> <span class="fn">(<a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instMonadWithReaderOfReaderT">instMonadWithReaderOfReaderT</a> <a href=".././Init/Prelude.html#Eq">=</a>   <a href=".././Init/Prelude.html#MonadWithReaderOf.mk">{</a> <span class="fn">withReader</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.18} (<span class="fn">f</span> : <span class="fn"><span class="fn">ρ</span> → <span class="fn">ρ</span></span>) (<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span>) (<span class="fn">ctx</span> : <span class="fn">ρ</span>) =&gt; <span class="fn"><span class="fn">x</span> <span class="fn">(<span class="fn">f</span> <span class="fn">ctx</span>)</span></span></span> <a href=".././Init/Prelude.html#MonadWithReaderOf.mk">}</a></li></ul></details></div></div><div class="decl" id="MonadStateOf"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4190-L4218">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadStateOf"><span class="name">MonadStateOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">σ</span> : <span class="fn"><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p>State monads provide a value of a given type (the <em>state</em>) that can be retrieved or replaced.
Instances may implement these operations by passing state values around, by using a mutable
reference cell (e.g. <code><a href=".././Init/System/ST.html#ST.Ref">ST.Ref</a> σ</code>), or in other ways.</p><p>In this class, <code>σ</code> is a <code><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a></code>, which means that it can influence the choice of instance.
<code><a href=".././Init/Prelude.html#MonadState">MonadState</a> σ</code> provides the same operations, but requires that <code>σ</code> be inferable from <code>m</code>.</p><p>The mutable state of a state monad is visible between multiple <code>do</code>-blocks or functions, unlike
<a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=do-notation-let-mut">local mutable state</a> in <code>do</code>-notation.</p><ul class="structure_fields" id="MonadStateOf.mk"><li id="MonadStateOf.get" class="structure_field"><div class="structure_field_info">get : <span class="fn"><span class="fn">m</span> <span class="fn">σ</span></span></div><div class="structure_field_doc"><p>Retrieves the current value of the monad's mutable state.</p></div></li><li id="MonadStateOf.set" class="structure_field"><div class="structure_field_info">set : <span class="fn"><span class="fn">σ</span> → <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></span></div><div class="structure_field_doc"><p>Replaces the current value of the mutable state with a new one.</p></div></li><li id="MonadStateOf.modifyGet" class="structure_field"><div class="structure_field_info">modifyGet<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">(<span class="fn">σ</span> → <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">σ</span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Applies a function to the current state that both computes a new state and a value. The new state
replaces the current state, and the value is returned.</p><p>It is equivalent to <code>do let (a, s) := f (← get); <a href=".././Init/Prelude.html#List.set">set</a> s; <a href=".././Init/Prelude.html#Pure.pure">pure</a> a</code>. However, using <code><a href=".././Init/Prelude.html#MonadStateOf.modifyGet">modifyGet</a></code> may
lead to higher performance because it doesn't add a new reference to the state value. Additional
references can inhibit in-place updates of data.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadStateOf" class="instances-list"></ul></details></div></div><div class="decl" id="getThe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4222-L4227">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#getThe"><span class="name">getThe</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">σ</span></span></div></div><p>Gets the current state that has the explicitly-provided type <code>σ</code>. When the current monad has
multiple state types available, this function selects one of them.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#getThe">getThe</a> <span class="fn">σ</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadStateOf.get">MonadStateOf.get</a></li></ul></details><details id="instances-for-list-getThe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="modifyThe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4229-L4240">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#modifyThe"><span class="name">modifyThe</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><p>Mutates the current state that has the explicitly-provided type <code>σ</code>, replacing its value with the
result of applying <code>f</code> to it. When the current monad has multiple state types available, this
function selects one of them.</p><p>It is equivalent to <code>do <a href=".././Init/Prelude.html#List.set">set</a> (f (← get))</code>. However, using <code><a href=".././Init/Prelude.html#modify">modify</a></code> may lead to higher performance
because it doesn't add a new reference to the state value. Additional references can inhibit
in-place updates of data.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#modifyThe">modifyThe</a> <span class="fn">σ</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadStateOf.modifyGet">MonadStateOf.modifyGet</a> <span class="fn">fun (<span class="fn">s</span> : <span class="fn">σ</span>) =&gt; <a href=".././Init/Prelude.html#Prod.mk">(</a><a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a><a href=".././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">s</span></span><a href=".././Init/Prelude.html#Prod.mk">)</a></span></span></li></ul></details><details id="instances-for-list-modifyThe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="modifyGetThe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4242-L4253">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#modifyGetThe"><span class="name">modifyGetThe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>Applies a function to the current state that has the explicitly-provided type <code>σ</code>. The function both
computes a new state and a value. The new state replaces the current state, and the value is
returned.</p><p>It is equivalent to <code>do let (a, s) := f (← <a href=".././Init/Prelude.html#getThe">getThe</a> σ); <a href=".././Init/Prelude.html#List.set">set</a> s; <a href=".././Init/Prelude.html#Pure.pure">pure</a> a</code>. However, using <code><a href=".././Init/Prelude.html#modifyGetThe">modifyGetThe</a></code>
may lead to higher performance because it doesn't add a new reference to the state value. Additional
references can inhibit in-place updates of data.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#modifyGetThe">modifyGetThe</a> <span class="fn">σ</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadStateOf.modifyGet">MonadStateOf.modifyGet</a> <span class="fn">f</span></span></li></ul></details><details id="instances-for-list-modifyGetThe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="MonadState"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4255-L4283">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadState"><span class="name">MonadState</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">σ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (u + 1) v)</div></div><p>State monads provide a value of a given type (the <em>state</em>) that can be retrieved or replaced.
Instances may implement these operations by passing state values around, by using a mutable
reference cell (e.g. <code><a href=".././Init/System/ST.html#ST.Ref">ST.Ref</a> σ</code>), or in other ways.</p><p>In this class, <code>σ</code> is an <code><a href=".././Init/Prelude.html#outParam">outParam</a></code>, which means that it is inferred from <code>m</code>. <code><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> σ</code>
provides the same operations, but allows <code>σ</code> to influence instance synthesis.</p><p>The mutable state of a state monad is visible between multiple <code>do</code>-blocks or functions, unlike
<a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=do-notation-let-mut">local mutable state</a> in <code>do</code>-notation.</p><ul class="structure_fields" id="MonadState.mk"><li id="MonadState.get" class="structure_field"><div class="structure_field_info">get : <span class="fn"><span class="fn">m</span> <span class="fn">σ</span></span></div><div class="structure_field_doc"><p>Retrieves the current value of the monad's mutable state.</p></div></li><li id="MonadState.set" class="structure_field"><div class="structure_field_info">set : <span class="fn"><span class="fn">σ</span> → <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></span></div><div class="structure_field_doc"><p>Replaces the current value of the mutable state with a new one.</p></div></li><li id="MonadState.modifyGet" class="structure_field"><div class="structure_field_info">modifyGet<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">(<span class="fn">σ</span> → <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">σ</span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Applies a function to the current state that both computes a new state and a value. The new state
replaces the current state, and the value is returned.</p><p>It is equivalent to <code>do let (a, s) := f (← get); <a href=".././Init/Prelude.html#List.set">set</a> s; <a href=".././Init/Prelude.html#Pure.pure">pure</a> a</code>. However, using <code><a href=".././Init/Prelude.html#MonadStateOf.modifyGet">modifyGet</a></code> may
lead to higher performance because it doesn't add a new reference to the state value. Additional
references can inhibit in-place updates of data.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadState" class="instances-list"></ul></details></div></div><div class="decl" id="instMonadStateOfMonadStateOf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4287-L4290">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadStateOfMonadStateOf"><span class="name">instMonadStateOfMonadStateOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadState">MonadState</a> <span class="fn">σ</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instMonadStateOfMonadStateOf">instMonadStateOfMonadStateOf</a> <span class="fn">σ</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <a href=".././Init/Prelude.html#MonadState.mk">{</a> <span class="fn">get</span> := <span class="fn"><a href=".././Init/Prelude.html#getThe">getThe</a> <span class="fn">σ</span></span>, <span class="fn">set</span> := <a href=".././Init/Prelude.html#MonadStateOf.set">set</a>, <span class="fn">modifyGet</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.19} (<span class="fn">f</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">σ</span></span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#MonadStateOf.modifyGet">MonadStateOf.modifyGet</a> <span class="fn">f</span></span></span> <a href=".././Init/Prelude.html#MonadState.mk">}</a></li></ul></details></div></div><div class="decl" id="modify"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4292-L4303">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#modify"><span class="name">modify</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadState">MonadState</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><p>Mutates the current state, replacing its value with the result of applying <code>f</code> to it.</p><p>Use <code><a href=".././Init/Prelude.html#modifyThe">modifyThe</a></code> to explicitly select a state type to modify.</p><p>It is equivalent to <code>do <a href=".././Init/Prelude.html#List.set">set</a> (f (← get))</code>. However, using <code><a href=".././Init/Prelude.html#modify">modify</a></code> may lead to higher performance
because it doesn't add a new reference to the state value. Additional references can inhibit
in-place updates of data.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#modify">modify</a> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadState.modifyGet">modifyGet</a> <span class="fn">fun (<span class="fn">s</span> : <span class="fn">σ</span>) =&gt; <a href=".././Init/Prelude.html#Prod.mk">(</a><a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a><a href=".././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">s</span></span><a href=".././Init/Prelude.html#Prod.mk">)</a></span></span></li></ul></details><details id="instances-for-list-modify" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="getModify"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4305-L4312">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#getModify"><span class="name">getModify</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadState">MonadState</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">σ</span></span></div></div><p>Replaces the state with the result of applying <code>f</code> to it. Returns the old value of the state.</p><p>It is equivalent to <code><a href=".././Init/Prelude.html#List.get">get</a> &lt;* <a href=".././Init/Prelude.html#modify">modify</a> f</code> but may be more efficient.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#getModify">getModify</a> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadState.modifyGet">modifyGet</a> <span class="fn">fun (<span class="fn">s</span> : <span class="fn">σ</span>) =&gt; <a href=".././Init/Prelude.html#Prod.mk">(</a><span class="fn">s</span><a href=".././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">s</span></span><a href=".././Init/Prelude.html#Prod.mk">)</a></span></span></li></ul></details><details id="instances-for-list-getModify" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instMonadStateOfOfMonadLift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4316-L4320">source</a></div><div class="attributes">@[always_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadStateOfOfMonadLift"><span class="name">instMonadStateOfOfMonadLift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> u → <a href=".././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instMonadStateOfOfMonadLift">instMonadStateOfOfMonadLift</a> <a href=".././Init/Prelude.html#Eq">=</a>   <a href=".././Init/Prelude.html#MonadStateOf.mk">{</a> <span class="fn">get</span> := <span class="fn"><a href=".././Init/Prelude.html#liftM">liftM</a> <a href=".././Init/Prelude.html#MonadStateOf.get">MonadStateOf.get</a></span>, <span class="fn">set</span> := <span class="fn">fun (<span class="fn">s</span> : <span class="fn">σ</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<a href=".././Init/Prelude.html#MonadStateOf.set">set</a> <span class="fn">s</span>)</span></span></span>,
    <span class="fn">modifyGet</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.30} (<span class="fn">f</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">σ</span></span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#MonadLiftT.monadLift">monadLift</a> <span class="fn">(<a href=".././Init/Prelude.html#MonadState.modifyGet">modifyGet</a> <span class="fn">f</span>)</span></span></span> <a href=".././Init/Prelude.html#MonadStateOf.mk">}</a></li></ul></details></div></div><div class="decl" id="EStateM.Result"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4324-L4335">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.Result"><span class="name">EStateM</span>.<span class="name">Result</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>The value returned from a combined state and exception monad in which exceptions do not
automatically roll back the state.</p><p><code><a href=".././Init/Prelude.html#EStateM.Result">Result</a> ε σ α</code> is equivalent to <code><a href=".././Init/Prelude.html#Except">Except</a> ε α × σ</code>, but using a single combined inductive type yields
a more efficient data representation.</p><ul class="constructors"><li class="constructor" id="EStateM.Result.ok">ok<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result">Result</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></span></span><div class="inductive_ctor_doc"><p>A success value of type <code>α</code> and a new state <code>σ</code>.</p></div></li><li class="constructor" id="EStateM.Result.error">error<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><span class="fn">ε</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result">Result</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></span></span><div class="inductive_ctor_doc"><p>An exception of type <code>ε</code> and a new state <code>σ</code>.</p></div></li></ul><details id="instances-for-list-EStateM.Result" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.instInhabitedResult"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4339-L4340">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.instInhabitedResult"><span class="name">EStateM</span>.<span class="name">instInhabitedResult</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">ε</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">σ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Prelude.html#EStateM.Result">Result</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#EStateM.instInhabitedResult">EStateM.instInhabitedResult</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="EStateM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4345-L4352">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM"><span class="name">EStateM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>A combined state and exception monad in which exceptions do not automatically roll back the state.</p><p>Instances of <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">EStateM.Backtrackable</a></code> provide a way to roll back some part of the state if needed.</p><p><code><a href=".././Init/Prelude.html#EStateM">EStateM</a> ε σ</code> is equivalent to <code><a href=".././Init/Control/Except.html#ExceptT">ExceptT</a> ε (StateM σ)</code>, but it is more efficient.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">σ</span> → <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result">EStateM.Result</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></li></ul></details><details id="instances-for-list-EStateM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.instInhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4358-L4359">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.instInhabited"><span class="name">EStateM</span>.<span class="name">instInhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">ε</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#EStateM.instInhabited">EStateM.instInhabited</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn">fun (<span class="fn">s</span> : <span class="fn">σ</span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a> <span class="fn">s</span></span></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="EStateM.pure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4361-L4366">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.pure"><span class="name">EStateM</span>.<span class="name">pure</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>Returns a value without modifying the state or throwing an exception.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#EStateM.pure">EStateM.pure</a> <span class="fn">a</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span></li></ul></details><details id="instances-for-list-EStateM.pure" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.set"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4368-L4370">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.set"><span class="name">EStateM</span>.<span class="name">set</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn">σ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><p>Replaces the current value of the mutable state with a new one.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#EStateM.set">EStateM.set</a> <span class="fn">s</span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a> <span class="fn">s</span></span></li></ul></details><details id="instances-for-list-EStateM.set" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.get"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4372-L4374">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.get"><span class="name">EStateM</span>.<span class="name">get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">σ</span></span></div></div><p>Retrieves the current value of the monad's mutable state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#EStateM.get">EStateM.get</a> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">s</span> <span class="fn">s</span></span></li></ul></details><details id="instances-for-list-EStateM.get" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.modifyGet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4376-L4379">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.modifyGet"><span class="name">EStateM</span>.<span class="name">modifyGet</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>Applies a function to the current state that both computes a new state and a value. The new state
replaces the current state, and the value is returned.</p><p>It is equivalent to <code>do let (a, s) := f (← get); <a href=".././Init/Prelude.html#List.set">set</a> s; <a href=".././Init/Prelude.html#Pure.pure">pure</a> a</code>. However, using <code><a href=".././Init/Prelude.html#MonadStateOf.modifyGet">modifyGet</a></code> may
lead to higher performance because it doesn't add a new reference to the state value. Additional
references can inhibit in-place updates of data.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#EStateM.modifyGet">EStateM.modifyGet</a> <span class="fn">f</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">s</span></span> with
  | <a href=".././Init/Prelude.html#Prod.mk">(</a><span class="fn">a</span><a href=".././Init/Prelude.html#Prod.mk">,</a> <span class="fn">s</span><a href=".././Init/Prelude.html#Prod.mk">)</a> =&gt; <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span></span></li></ul></details><details id="instances-for-list-EStateM.modifyGet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.throw"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4381-L4383">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.throw"><span class="name">EStateM</span>.<span class="name">throw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">ε</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>Throws an exception of type <code>ε</code> to the nearest enclosing handler.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#EStateM.throw">EStateM.throw</a> <span class="fn">e</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span></li></ul></details><details id="instances-for-list-EStateM.throw" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.Backtrackable"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4385-L4398">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.Backtrackable"><span class="name">EStateM</span>.<span class="name">Backtrackable</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">δ</span> : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Exception handlers in <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> save some part of the state, determined by <code>δ</code>, and restore it if an
exception is caught. By default, <code>δ</code> is <code><a href=".././Init/Prelude.html#Unit">Unit</a></code>, and no information is saved.</p><ul class="structure_fields" id="EStateM.Backtrackable.mk"><li id="EStateM.Backtrackable.save" class="structure_field"><div class="structure_field_info">save : <span class="fn"><span class="fn">σ</span> → <span class="fn">δ</span></span></div><div class="structure_field_doc"><p>Extracts the information in the state that should be rolled back if an exception is handled.</p></div></li><li id="EStateM.Backtrackable.restore" class="structure_field"><div class="structure_field_info">restore : <span class="fn"><span class="fn">σ</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn">σ</span></span></span></div><div class="structure_field_doc"><p>Updates the current state with the saved information that should be rolled back. This updated
state becomes the current state when an exception is handled.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-EStateM.Backtrackable" class="instances-list"></ul></details></div></div><div class="decl" id="EStateM.tryCatch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4400-L4413">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.tryCatch"><span class="name">EStateM</span>.<span class="name">tryCatch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">δ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> <span class="fn">δ</span> <span class="fn">σ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">handle</span> : <span class="fn"><span class="fn">ε</span> → <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>Handles exceptions thrown in the combined error and state monad.</p><p>The <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> δ σ</code> instance is used to save a snapshot of part of the state prior to running
<code>x</code>. If an exception is caught, the state is updated with the saved snapshot, rolling back part of
the state. If no instance of <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a></code> is provided, a fallback instance in which <code>δ</code> is <code><a href=".././Init/Prelude.html#Unit">Unit</a></code>
is used, and no information is rolled back.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#EStateM.tryCatch">tryCatch</a></span> <span class="fn">handle</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">x</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s_1</span></span> =&gt; <span class="fn"><span class="fn">handle</span> <span class="fn">e</span> <span class="fn">(<a href=".././Init/Prelude.html#EStateM.Backtrackable.restore">EStateM.Backtrackable.restore</a> <span class="fn">s_1</span> <span class="fn">(<a href=".././Init/Prelude.html#EStateM.Backtrackable.save">EStateM.Backtrackable.save</a> <span class="fn">s</span>)</span>)</span></span>
  | <span class="fn">ok</span> =&gt; <span class="fn">ok</span></span></li></ul></details><details id="instances-for-list-EStateM.tryCatch" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.orElse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4415-L4428">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.orElse"><span class="name">EStateM</span>.<span class="name">orElse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α </span><span class="fn">δ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> <span class="fn">δ</span> <span class="fn">σ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x₁</span> : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x₂</span> : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>Failure handling that does not depend on specific exception values.</p><p>The <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> δ σ</code> instance is used to save a snapshot of part of the state prior to running
<code>x₁</code>. If an exception is caught, the state is updated with the saved snapshot, rolling back part of
the state. If no instance of <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a></code> is provided, a fallback instance in which <code>δ</code> is <code><a href=".././Init/Prelude.html#Unit">Unit</a></code>
is used, and no information is rolled back.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x₁</span>.<a href=".././Init/Prelude.html#EStateM.orElse">orElse</a></span> <span class="fn">x₂</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">x₁</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">a</span> <span class="fn">s_1</span></span> =&gt; <span class="fn"><span class="fn">x₂</span> <a href=".././Init/Prelude.html#Unit.unit">(</a><a href=".././Init/Prelude.html#Unit.unit">)</a> <span class="fn">(<a href=".././Init/Prelude.html#EStateM.Backtrackable.restore">EStateM.Backtrackable.restore</a> <span class="fn">s_1</span> <span class="fn">(<a href=".././Init/Prelude.html#EStateM.Backtrackable.save">EStateM.Backtrackable.save</a> <span class="fn">s</span>)</span>)</span></span>
  | <span class="fn">ok</span> =&gt; <span class="fn">ok</span></span></li></ul></details><details id="instances-for-list-EStateM.orElse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.adaptExcept"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4430-L4437">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.adaptExcept"><span class="name">EStateM</span>.<span class="name">adaptExcept</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α </span><span class="fn">ε'</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">ε</span> → <span class="fn">ε'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε'</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>Transforms exceptions with a function, doing nothing on successful results.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#EStateM.adaptExcept">EStateM.adaptExcept</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">x</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">(<span class="fn">f</span> <span class="fn">e</span>)</span> <span class="fn">s</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span></span></li></ul></details><details id="instances-for-list-EStateM.adaptExcept" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.bind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4439-L4446">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.bind"><span class="name">EStateM</span>.<span class="name">bind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">β</span></span></div></div><p>Sequences two <code><a href=".././Init/Prelude.html#EStateM">EStateM</a> ε σ</code> actions, passing the returned value from the first into the second.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#EStateM.bind">bind</a></span> <span class="fn">f</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">x</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span> =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">s</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span></span></li></ul></details><details id="instances-for-list-EStateM.bind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4448-L4455">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.map"><span class="name">EStateM</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">β</span></span></div></div><p>Transforms the value returned from an <code><a href=".././Init/Prelude.html#EStateM">EStateM</a> ε σ</code> action using a function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#EStateM.map">EStateM.map</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">x</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">s</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span></span></li></ul></details><details id="instances-for-list-EStateM.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.seqRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4457-L4465">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.seqRight"><span class="name">EStateM</span>.<span class="name">seqRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α </span><span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">y</span> : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">β</span></span></div></div><p>Sequences two <code><a href=".././Init/Prelude.html#EStateM">EStateM</a> ε σ</code> actions, running <code>x</code> before <code>y</code>. The first action's return value is
ignored.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#EStateM.seqRight">seqRight</a></span> <span class="fn">y</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">x</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span> =&gt; <span class="fn"><span class="fn">y</span> <a href=".././Init/Prelude.html#Unit.unit">(</a><a href=".././Init/Prelude.html#Unit.unit">)</a> <span class="fn">s</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span></span></li></ul></details><details id="instances-for-list-EStateM.seqRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.instMonad"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4467-L4472">source</a></div><div class="attributes">@[always_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.instMonad"><span class="name">EStateM</span>.<span class="name">instMonad</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">(<a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="EStateM.instOrElseOfBacktrackable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4474-L4475">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.instOrElseOfBacktrackable"><span class="name">EStateM</span>.<span class="name">instOrElseOfBacktrackable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α </span><span class="fn">δ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> <span class="fn">δ</span> <span class="fn">σ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#OrElse">OrElse</a> <span class="fn">(<a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#EStateM.instOrElseOfBacktrackable">EStateM.instOrElseOfBacktrackable</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#OrElse.mk">{</a> <span class="fn">orElse</span> := <a href=".././Init/Prelude.html#EStateM.orElse">EStateM.orElse</a> <a href=".././Init/Prelude.html#OrElse.mk">}</a></li></ul></details></div></div><div class="decl" id="EStateM.instMonadStateOf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4477-L4480">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.instMonadStateOf"><span class="name">EStateM</span>.<span class="name">instMonadStateOf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">(<a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#EStateM.instMonadStateOf">EStateM.instMonadStateOf</a> <a href=".././Init/Prelude.html#Eq">=</a>   <a href=".././Init/Prelude.html#MonadStateOf.mk">{</a> <span class="fn">get</span> := <a href=".././Init/Prelude.html#EStateM.get">EStateM.get</a>, <span class="fn">set</span> := <a href=".././Init/Prelude.html#EStateM.set">EStateM.set</a>, <span class="fn">modifyGet</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.12} =&gt; <a href=".././Init/Prelude.html#EStateM.modifyGet">EStateM.modifyGet</a></span> <a href=".././Init/Prelude.html#MonadStateOf.mk">}</a></li></ul></details></div></div><div class="decl" id="EStateM.instMonadExceptOfOfBacktrackable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4482-L4484">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.instMonadExceptOfOfBacktrackable"><span class="name">EStateM</span>.<span class="name">instMonadExceptOfOfBacktrackable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">δ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> <span class="fn">δ</span> <span class="fn">σ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> <span class="fn">ε</span> <span class="fn">(<a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#EStateM.instMonadExceptOfOfBacktrackable">EStateM.instMonadExceptOfOfBacktrackable</a> <a href=".././Init/Prelude.html#Eq">=</a>   <a href=".././Init/Prelude.html#MonadExceptOf.mk">{</a> <span class="fn">throw</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.23} =&gt; <a href=".././Init/Prelude.html#EStateM.throw">EStateM.throw</a></span>, <span class="fn">tryCatch</span> := <span class="fn">fun {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> ?u.23} =&gt; <a href=".././Init/Prelude.html#EStateM.tryCatch">EStateM.tryCatch</a></span> <a href=".././Init/Prelude.html#MonadExceptOf.mk">}</a></li></ul></details></div></div><div class="decl" id="EStateM.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4486-L4491">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.run"><span class="name">EStateM</span>.<span class="name">run</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn">σ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM.Result">Result</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>Executes an <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> action with the initial state <code>s</code>. The returned value includes the final state
and indicates whether an exception was thrown or a value was returned.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#EStateM.run">run</a></span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <span class="fn">s</span></span></li></ul></details><details id="instances-for-list-EStateM.run" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.run'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4493-L4501">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.run'"><span class="name">EStateM</span>.<span class="name">run'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε </span><span class="fn">σ </span><span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn">σ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></div></div><p>Executes an <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> with the initial state <code>s</code> for the returned value <code>α</code>, discarding the final
state. Returns <code><a href=".././Init/Prelude.html#Option.none">none</a></code> if an unhandled exception was thrown.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#EStateM.run'">run'</a></span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn"><span class="fn">x</span>.<a href=".././Init/Prelude.html#EStateM.run">run</a></span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">v</span> <span class="fn">a</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">a</span> <span class="fn">a_1</span></span> =&gt; <a href=".././Init/Prelude.html#Option.none">none</a></span></li></ul></details><details id="instances-for-list-EStateM.run'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.dummySave"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4503-L4504">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.dummySave"><span class="name">EStateM</span>.<span class="name">dummySave</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">σ</span> → <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><p>The <code><a href=".././Init/Prelude.html#EStateM.Backtrackable.save">save</a></code> implementation for <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a> σ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#EStateM.dummySave">EStateM.dummySave</a> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a></li></ul></details><details id="instances-for-list-EStateM.dummySave" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.dummyRestore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4506-L4507">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.dummyRestore"><span class="name">EStateM</span>.<span class="name">dummyRestore</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Prelude.html#PUnit">PUnit</a> → <span class="fn">σ</span></span></span></div></div><p>The <code><a href=".././Init/Prelude.html#EStateM.Backtrackable.restore">restore</a></code> implementation for <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a> σ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#EStateM.dummyRestore">EStateM.dummyRestore</a> <span class="fn">s</span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">s</span></li></ul></details><details id="instances-for-list-EStateM.dummyRestore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="EStateM.nonBacktrackable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4509-L4518">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.nonBacktrackable"><span class="name">EStateM</span>.<span class="name">nonBacktrackable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a> <span class="fn">σ</span></span></div></div><p>A fallback <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a></code> instance that saves no information from a state. This allows every type
to be used as a state in <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code>, with no rollback.</p><p>Because this is the first declared instance of <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> _ σ</code>, it will be picked only if there
are no other <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> _ σ</code> instances registered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#EStateM.nonBacktrackable">EStateM.nonBacktrackable</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#EStateM.Backtrackable.mk">{</a> <span class="fn">save</span> := <a href=".././Init/Prelude.html#EStateM.dummySave">EStateM.dummySave</a>, <span class="fn">restore</span> := <a href=".././Init/Prelude.html#EStateM.dummyRestore">EStateM.dummyRestore</a> <a href=".././Init/Prelude.html#EStateM.Backtrackable.mk">}</a></li></ul></details></div></div><div class="decl" id="Hashable"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4522-L4525">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Hashable"><span class="name">Hashable</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max 1 u)</div></div><p>Types that can be hashed into a <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code>.</p><ul class="structure_fields" id="Hashable.mk"><li id="Hashable.hash" class="structure_field"><div class="structure_field_info">hash : <span class="fn"><span class="fn">α</span> → <a href=".././Init/Prelude.html#UInt64">UInt64</a></span></div><div class="structure_field_doc"><p>Hashes a value into a <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Hashable" class="instances-list"></ul></details></div></div><div class="decl" id="mixHash"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4529-L4531">source</a></div><div class="attributes">@[extern lean_uint64_mix_hash]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#mixHash"><span class="name">mixHash</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">u₁ </span><span class="fn">u₂</span> : <a href=".././Init/Prelude.html#UInt64">UInt64</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt64">UInt64</a></div></div><p>An opaque hash mixing operation, used to implement hashing for products.</p></div></div><div class="decl" id="instHashableSubtype"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4533-L4534">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHashableSubtype"><span class="name">instHashableSubtype</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">(<a href=".././Init/Prelude.html#Subtype">Subtype</a> <span class="fn">p</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHashableSubtype">instHashableSubtype</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <span class="fn">fun (<span class="fn">a</span> : <span class="fn"><a href=".././Init/Prelude.html#Subtype">Subtype</a> <span class="fn">p</span></span>) =&gt; <span class="fn"><a href=".././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn"><span class="fn">a</span>.<a href=".././Init/Prelude.html#Subtype.val">val</a></span></span></span> <a href=".././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="String.hash"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4536-L4540">source</a></div><div class="attributes">@[extern lean_string_hash]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.hash"><span class="name">String</span>.<span class="name">hash</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt64">UInt64</a></div></div><p>Computes a hash for strings.</p></div></div><div class="decl" id="instHashableString"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4542-L4543">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHashableString"><span class="name">instHashableString</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Hashable">Hashable</a> <a href=".././Init/Prelude.html#String">String</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#instHashableString">instHashableString</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <a href=".././Init/Prelude.html#String.hash">String.hash</a> <a href=".././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Name.hash"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4552-L4603">source</a></div><div class="attributes">@[implemented_by Lean.Name.hash._override]</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.hash"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">hash</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Name</a> → <a href=".././Init/Prelude.html#UInt64">UInt64</a></span></div></div><p>A hash function for names, which is stored inside the name itself as a
computed field.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a>.<a href=".././Init/Prelude.html#Lean.Name.hash">hash</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#UInt64.ofNatLT">UInt64.ofNatLT</a> <span class="fn">1723</span> <a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.Name.hash._proof_1">Lean.Name.hash._proof_1✝</a></span></li><li class="equation"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.hash">hash</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#mixHash">mixHash</a> <span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Lean.Name.hash">hash</a></span> <span class="fn"><span class="fn">s</span>.<a href=".././Init/Prelude.html#String.hash">hash</a></span></span></li><li class="equation"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Lean.Name.num">num</a></span> <span class="fn">v</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.hash">hash</a></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#mixHash">mixHash</a> <span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Lean.Name.hash">hash</a></span> <span class="fn">(if h : <span class="fn">v</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <a href=".././Init/Prelude.html#UInt64.size">UInt64.size</a> then <span class="fn"><a href=".././Init/Prelude.html#UInt64.ofNatLT">UInt64.ofNatLT</a> <span class="fn">v</span> <span class="fn">h</span></span> else <span class="fn"><a href=".././Init/Prelude.html#UInt64.ofNatLT">UInt64.ofNatLT</a> <span class="fn">17</span> <a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.Name.hash._proof_2">Lean.Name.hash._proof_2✝</a></span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Name.hash" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4552-L4603">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name"><span class="name">Lean</span>.<span class="name">Name</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Hierarchical names consist of a sequence of components, each of
which is either a string or numeric, that are written separated by dots (<code>.</code>).</p><p>Hierarchical names are used to name declarations and for creating
unique identifiers for free variables and metavariables.</p><p>You can create hierarchical names using a backtick:</p><pre><code>`Lean.Meta.whnf
</code></pre><p>It is short for <code>.<a href=".././Init/Prelude.html#Substring.str">str</a> (.<a href=".././Init/Prelude.html#Substring.str">str</a> (.<a href=".././Init/Prelude.html#Substring.str">str</a> .<a href=".././Init/Prelude.html#Lean.Name.anonymous">anonymous</a> &quot;Lean&quot;) &quot;Meta&quot;) &quot;whnf&quot;</code>.</p><p>You can use double backticks to request Lean to statically check whether the name
corresponds to a Lean declaration in scope.</p><pre><code>``Lean.Meta.whnf
</code></pre><p>If the name is not in scope, Lean will report an error.</p><p>There are two ways to convert a <code><a href=".././Init/Prelude.html#String">String</a></code> to a <code><a href=".././Init/Prelude.html#Lean.Name">Name</a></code>:</p><ol>
<li><p><code><a href=".././Init/Prelude.html#Lean.Name.mkSimple">Name.mkSimple</a></code> creates a name with a single string component.</p>
</li>
<li><p><code><a href=".././Init/Meta/Defs.html#String.toName">String.toName</a></code> first splits the string into its dot-separated
components, and then creates a hierarchical name.</p>
</li>
</ol><ul class="constructors"><li class="constructor" id="Lean.Name.anonymous">anonymous : <a href=".././Init/Prelude.html#Lean.Name">Name</a><div class="inductive_ctor_doc"><p>The &quot;anonymous&quot; name.</p></div></li><li class="constructor" id="Lean.Name.str">str<span class="decl_args">
<span class="fn">(<span class="fn">pre</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">str</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.Name">Name</a><div class="inductive_ctor_doc"><p>A string name. The name <code>Lean.Meta.<a href=".././Init/Prelude.html#ReaderT.run">run</a></code> is represented at</p><pre><code class="language-lean">.<a href=".././Init/Prelude.html#Substring.str">str</a> (.<a href=".././Init/Prelude.html#Substring.str">str</a> (.<a href=".././Init/Prelude.html#Substring.str">str</a> .<a href=".././Init/Prelude.html#Lean.Name.anonymous">anonymous</a> &quot;Lean&quot;) &quot;Meta&quot;) &quot;run&quot;
</code></pre></div></li><li class="constructor" id="Lean.Name.num">num<span class="decl_args">
<span class="fn">(<span class="fn">pre</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.Name">Name</a><div class="inductive_ctor_doc"><p>A numerical name. This kind of name is used, for example, to create hierarchical names for
free variables and metavariables. The identifier <code>_uniq.231</code> is represented as</p><pre><code class="language-lean">.<a href=".././Init/Prelude.html#Lean.Name.num">num</a> (.<a href=".././Init/Prelude.html#Substring.str">str</a> .<a href=".././Init/Prelude.html#Lean.Name.anonymous">anonymous</a> &quot;_uniq&quot;) 231
</code></pre></div></li></ul><details id="instances-for-list-Lean.Name" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.instInhabitedName"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4605-L4606">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instInhabitedName"><span class="name">Lean</span>.<span class="name">instInhabitedName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.Name">Name</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.instInhabitedName">Lean.instInhabitedName</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.instHashableName"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4608-L4609">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instHashableName"><span class="name">Lean</span>.<span class="name">instHashableName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Hashable">Hashable</a> <a href=".././Init/Prelude.html#Lean.Name">Name</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.instHashableName">Lean.instHashableName</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <a href=".././Init/Prelude.html#Lean.Name.hash">Lean.Name.hash</a> <a href=".././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Name.mkStr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4613-L4618">source</a></div><div class="attributes">@[reducible, inline, export lean_name_mk_string]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p><code>.<a href=".././Init/Prelude.html#Substring.str">str</a> p s</code> is now the preferred form.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Lean.Name.mkStr">mkStr</a></span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s</span></span></li></ul></details><details id="instances-for-list-Lean.Name.mkStr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.mkNum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4620-L4625">source</a></div><div class="attributes">@[reducible, inline, export lean_name_mk_numeral]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkNum"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkNum</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p><code>.<a href=".././Init/Prelude.html#Lean.Name.num">num</a> p v</code> is now the preferred form.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Lean.Name.mkNum">mkNum</a></span> <span class="fn">v</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Lean.Name.num">num</a></span> <span class="fn">v</span></span></li></ul></details><details id="instances-for-list-Lean.Name.mkNum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.mkSimple"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4627-L4633">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkSimple"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkSimple</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Converts a <code><a href=".././Init/Prelude.html#String">String</a></code> to a <code><a href=".././Init/Prelude.html#Lean.Name">Name</a></code> without performing any parsing. <code><a href=".././Init/Prelude.html#Lean.Name.mkSimple">mkSimple</a> s</code> is short for <code>.<a href=".././Init/Prelude.html#Substring.str">str</a> .<a href=".././Init/Prelude.html#Lean.Name.anonymous">anonymous</a> s</code>.</p><p>This means that <code><a href=".././Init/Prelude.html#Lean.Name.mkSimple">mkSimple</a> &quot;a.b&quot;</code> is the name <code>«a.b»</code>, not <code>a.b</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkSimple">Lean.Name.mkSimple</a> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s</span></span></li></ul></details><details id="instances-for-list-Lean.Name.mkSimple" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.mkStr1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4635-L4637">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr1"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr1</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s₁</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Make name <code>s₁</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">s₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₁</span></span></li></ul></details><details id="instances-for-list-Lean.Name.mkStr1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.mkStr2"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4639-L4641">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr2"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr2</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s₁ </span><span class="fn">s₂</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Make name <code>s₁.s₂</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr2">Lean.Name.mkStr2</a> <span class="fn">s₁</span> <span class="fn">s₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₁</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₂</span></span></li></ul></details><details id="instances-for-list-Lean.Name.mkStr2" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.mkStr3"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4643-L4645">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr3"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr3</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s₁ </span><span class="fn">s₂ </span><span class="fn">s₃</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Make name <code>s₁.s₂.s₃</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr3">Lean.Name.mkStr3</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">s₃</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₁</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₂</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₃</span></span></li></ul></details><details id="instances-for-list-Lean.Name.mkStr3" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.mkStr4"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4647-L4649">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr4"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr4</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s₁ </span><span class="fn">s₂ </span><span class="fn">s₃ </span><span class="fn">s₄</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Make name <code>s₁.s₂.s₃.s₄</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr4">Lean.Name.mkStr4</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">s₃</span> <span class="fn">s₄</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₁</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₂</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₃</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₄</span></span></li></ul></details><details id="instances-for-list-Lean.Name.mkStr4" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.mkStr5"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4651-L4653">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr5"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr5</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s₁ </span><span class="fn">s₂ </span><span class="fn">s₃ </span><span class="fn">s₄ </span><span class="fn">s₅</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Make name <code>s₁.s₂.s₃.s₄.s₅</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr5">Lean.Name.mkStr5</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">s₃</span> <span class="fn">s₄</span> <span class="fn">s₅</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₁</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₂</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₃</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₄</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₅</span></span></li></ul></details><details id="instances-for-list-Lean.Name.mkStr5" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.mkStr6"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4655-L4657">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr6"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr6</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s₁ </span><span class="fn">s₂ </span><span class="fn">s₃ </span><span class="fn">s₄ </span><span class="fn">s₅ </span><span class="fn">s₆</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Make name <code>s₁.s₂.s₃.s₄.s₅.s₆</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr6">Lean.Name.mkStr6</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">s₃</span> <span class="fn">s₄</span> <span class="fn">s₅</span> <span class="fn">s₆</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₁</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₂</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₃</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₄</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₅</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₆</span></span></li></ul></details><details id="instances-for-list-Lean.Name.mkStr6" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.mkStr7"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4659-L4661">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr7"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr7</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s₁ </span><span class="fn">s₂ </span><span class="fn">s₃ </span><span class="fn">s₄ </span><span class="fn">s₅ </span><span class="fn">s₆ </span><span class="fn">s₇</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Make name <code>s₁.s₂.s₃.s₄.s₅.s₆.s₇</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr7">Lean.Name.mkStr7</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">s₃</span> <span class="fn">s₄</span> <span class="fn">s₅</span> <span class="fn">s₆</span> <span class="fn">s₇</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₁</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₂</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₃</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₄</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₅</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₆</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₇</span></span></li></ul></details><details id="instances-for-list-Lean.Name.mkStr7" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.mkStr8"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4663-L4665">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr8"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">mkStr8</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s₁ </span><span class="fn">s₂ </span><span class="fn">s₃ </span><span class="fn">s₄ </span><span class="fn">s₅ </span><span class="fn">s₆ </span><span class="fn">s₇ </span><span class="fn">s₈</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Make name <code>s₁.s₂.s₃.s₄.s₅.s₆.s₇.s₈</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr8">Lean.Name.mkStr8</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">s₃</span> <span class="fn">s₄</span> <span class="fn">s₅</span> <span class="fn">s₆</span> <span class="fn">s₇</span> <span class="fn">s₈</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₁</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₂</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₃</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₄</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₅</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₆</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₇</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₈</span></span></li></ul></details><details id="instances-for-list-Lean.Name.mkStr8" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.beq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4667-L4673">source</a></div><div class="attributes">@[extern lean_name_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.beq"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">beq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Name</a> → <a href=".././Init/Prelude.html#Lean.Name">Name</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>(Boolean) equality comparator for names.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a>.<a href=".././Init/Prelude.html#Lean.Name.beq">beq</a></span> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p₁</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₁</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.beq">beq</a></span> <span class="fn">(<span class="fn"><span class="fn">p₂</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s₂</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">s₁</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">s₂</span> <a href=".././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn"><span class="fn">p₁</span>.<a href=".././Init/Prelude.html#Lean.Name.beq">beq</a></span> <span class="fn">p₂</span></span>)</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p₁</span>.<a href=".././Init/Prelude.html#Lean.Name.num">num</a></span> <span class="fn">n₁</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.beq">beq</a></span> <span class="fn">(<span class="fn"><span class="fn">p₂</span>.<a href=".././Init/Prelude.html#Lean.Name.num">num</a></span> <span class="fn">n₂</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">n₁</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">n₂</span> <a href=".././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn"><span class="fn">p₁</span>.<a href=".././Init/Prelude.html#Lean.Name.beq">beq</a></span> <span class="fn">p₂</span></span>)</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝¹</span>.<a href=".././Init/Prelude.html#Lean.Name.beq">beq</a></span> <span class="fn">x✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Name.beq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.instBEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4675-L4676">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.instBEq"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">instBEq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <a href=".././Init/Prelude.html#Lean.Name">Name</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.Name.instBEq">Lean.Name.instBEq</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <a href=".././Init/Prelude.html#Lean.Name.beq">Lean.Name.beq</a> <a href=".././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Name.appendCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4678-L4685">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.appendCore"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">appendCore</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Name</a> → <a href=".././Init/Prelude.html#Lean.Name">Name</a> → <a href=".././Init/Prelude.html#Lean.Name">Name</a></span></div></div><p>This function does not have special support for macro scopes.
See <code><a href=".././Init/Prelude.html#Lean.Name.append">Name.append</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Lean.Name.appendCore">appendCore</a></span> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Lean.Name.appendCore">appendCore</a></span> <span class="fn">(<span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Lean.Name.appendCore">appendCore</a></span> <span class="fn">p</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Lean.Name.appendCore">appendCore</a></span> <span class="fn">(<span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Lean.Name.num">num</a></span> <span class="fn">d</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Lean.Name.appendCore">appendCore</a></span> <span class="fn">p</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.num">num</a></span> <span class="fn">d</span></span></li></ul></details><details id="instances-for-list-Lean.Name.appendCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.defaultMaxRecDepth"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4689-L4690">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.defaultMaxRecDepth"><span class="name">Lean</span>.<span class="name">defaultMaxRecDepth</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The default maximum recursion depth. This is adjustable using the <code><a href=".././Init/Prelude.html#Lean.Macro.Context.maxRecDepth">maxRecDepth</a></code> option.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.defaultMaxRecDepth">Lean.defaultMaxRecDepth</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">512</span></li></ul></details><details id="instances-for-list-Lean.defaultMaxRecDepth" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.maxRecDepthErrorMessage"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4692-L4696">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.maxRecDepthErrorMessage"><span class="name">Lean</span>.<span class="name">maxRecDepthErrorMessage</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#String">String</a></div></div><p>The message to display on stack overflow.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.maxRecDepthErrorMessage">Lean.maxRecDepthErrorMessage</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">&quot;maximum recursion depth has been reached\nuse `set_option maxRecDepth &lt;num&gt;` to increase limit\nuse `set_option diagnostics true` to get diagnostic information&quot;</span></li></ul></details><details id="instances-for-list-Lean.maxRecDepthErrorMessage" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Syntax">Syntax <a class="hover-link" href="#Syntax">#</a></h1></div><div class="decl" id="Lean.SourceInfo"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4700-L4747">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SourceInfo"><span class="name">Lean</span>.<span class="name">SourceInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Source information that relates syntax to the context that it came from.</p><p>The primary purpose of <code><a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></code> is to relate the output of the parser and the macro expander to
the original source file. When produced by the parser, <code><a href=".././Init/Prelude.html#Lean.Syntax.node">Syntax.node</a></code> does not carry source info; the
parser associates it only with atoms and identifiers. If a <code><a href=".././Init/Prelude.html#Lean.Syntax.node">Syntax.node</a></code> is introduced by a
quotation, then it has synthetic source info that both associates it with an original reference
position and indicates that the original atoms in it may not originate from the Lean file under
elaboration.</p><p>Source info is also used to relate Lean's output to the internal data that it represents; this is
the basis for many interactive features. When used this way, it can occur on <code><a href=".././Init/Prelude.html#Lean.Syntax.node">Syntax.node</a></code> as well.</p><ul class="constructors"><li class="constructor" id="Lean.SourceInfo.original">original<span class="decl_args">
<span class="fn">(<span class="fn">leading</span> : <a href=".././Init/Prelude.html#Substring">Substring</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">pos</span> : <a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">trailing</span> : <a href=".././Init/Prelude.html#Substring">Substring</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">endPos</span> : <a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a><div class="inductive_ctor_doc"><p>A token produced by the parser from original input that includes both leading and trailing
whitespace as well as position information.</p><p>The <code>leading</code> whitespace is inferred after parsing by <code>Syntax.updateLeading</code>. This is because the
“preceding token” is not well-defined during parsing, especially in the presence of backtracking.</p></div></li><li class="constructor" id="Lean.SourceInfo.synthetic">synthetic<span class="decl_args">
<span class="fn">(<span class="fn">pos </span><span class="fn">endPos</span> : <a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">canonical</span> : <a href=".././Init/Prelude.html#Bool">Bool</a> := <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a><div class="inductive_ctor_doc"><p>Synthetic syntax is syntax that was produced by a metaprogram or by Lean itself (e.g. by a
quotation). Synthetic syntax is annotated with a source span from the original syntax, which
relates it to the source file.</p><p>The delaborator uses this constructor to store an encoded indicator of which core language
expression gave rise to the syntax.</p><p>The <code>canonical</code> flag on synthetic syntax is enabled for syntax that is not literally part of the
original input syntax but should be treated “as if” the user really wrote it for the purpose of
hovers and error messages. This is usually used on identifiers in order to connect the binding
site to the user's original syntax even if the name of the identifier changes during expansion, as
well as on tokens that should receive targeted messages.</p><p>Generally speaking, a macro expansion should only use a given piece of input syntax in a single
canonical token. An exception to this rule is when the same identifier is used to declare two
binders, as in the macro expansion for dependent if:</p><pre><code>`(if $h : $cond then $t else $e) ~&gt;
`(dite $cond (fun $h =&gt; $t) (fun $h =&gt; $t))
</code></pre><p>In these cases, if the user hovers over <code>h</code> they will see information about both binding sites.</p></div></li><li class="constructor" id="Lean.SourceInfo.none">none : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a><div class="inductive_ctor_doc"><p>A synthesized token without position information.</p></div></li></ul><details id="instances-for-list-Lean.SourceInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.instInhabitedSourceInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4749-L4749">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instInhabitedSourceInfo"><span class="name">Lean</span>.<span class="name">instInhabitedSourceInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.instInhabitedSourceInfo">Lean.instInhabitedSourceInfo</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.SourceInfo.getPos?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4753-L4763">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SourceInfo.getPos?"><span class="name">Lean</span>.<span class="name">SourceInfo</span>.<span class="name">getPos?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">canonicalOnly</span> : <a href=".././Init/Prelude.html#Bool">Bool</a> := <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></span></div></div><p>Gets the position information from a <code><a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></code>, if available.
If <code>canonicalOnly</code> is true, then <code>.<a href=".././Init/Prelude.html#Lean.SourceInfo.synthetic">synthetic</a></code> syntax with <code>canonical := <a href=".././Init/Prelude.html#Bool.false">false</a></code>
will also return <code><a href=".././Init/Prelude.html#Option.none">none</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.SourceInfo.original">Lean.SourceInfo.original</a> <span class="fn">leading</span> <span class="fn">pos</span> <span class="fn">trailing</span> <span class="fn">endPos</span>)</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getPos?">getPos?</a></span> <span class="fn">canonicalOnly</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">pos</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.SourceInfo.synthetic">Lean.SourceInfo.synthetic</a> <span class="fn">pos</span> <span class="fn">endPos</span> <a href=".././Init/Prelude.html#Bool.true">true</a>)</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getPos?">getPos?</a></span> <span class="fn">canonicalOnly</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">pos</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.SourceInfo.synthetic">Lean.SourceInfo.synthetic</a> <span class="fn">pos</span> <span class="fn">endPos</span> <span class="fn">canonical</span>)</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getPos?">getPos?</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">pos</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">info</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getPos?">getPos?</a></span> <span class="fn">canonicalOnly</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Option.none">none</a></li></ul></details><details id="instances-for-list-Lean.SourceInfo.getPos?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.SourceInfo.getTailPos?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4765-L4775">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SourceInfo.getTailPos?"><span class="name">Lean</span>.<span class="name">SourceInfo</span>.<span class="name">getTailPos?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">canonicalOnly</span> : <a href=".././Init/Prelude.html#Bool">Bool</a> := <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></span></div></div><p>Gets the end position information from a <code><a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></code>, if available.
If <code>canonicalOnly</code> is true, then <code>.<a href=".././Init/Prelude.html#Lean.SourceInfo.synthetic">synthetic</a></code> syntax with <code>canonical := <a href=".././Init/Prelude.html#Bool.false">false</a></code>
will also return <code><a href=".././Init/Prelude.html#Option.none">none</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.SourceInfo.original">Lean.SourceInfo.original</a> <span class="fn">leading</span> <span class="fn">pos</span> <span class="fn">trailing</span> <span class="fn">endPos</span>)</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getTailPos?">getTailPos?</a></span> <span class="fn">canonicalOnly</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">endPos</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.SourceInfo.synthetic">Lean.SourceInfo.synthetic</a> <span class="fn">pos</span> <span class="fn">endPos</span> <a href=".././Init/Prelude.html#Bool.true">true</a>)</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getTailPos?">getTailPos?</a></span> <span class="fn">canonicalOnly</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">endPos</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.SourceInfo.synthetic">Lean.SourceInfo.synthetic</a> <span class="fn">pos</span> <span class="fn">endPos</span> <span class="fn">canonical</span>)</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getTailPos?">getTailPos?</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">endPos</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">info</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getTailPos?">getTailPos?</a></span> <span class="fn">canonicalOnly</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Option.none">none</a></li></ul></details><details id="instances-for-list-Lean.SourceInfo.getTailPos?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.SourceInfo.getTrailing?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4777-L4783">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SourceInfo.getTrailing?"><span class="name">Lean</span>.<span class="name">SourceInfo</span>.<span class="name">getTrailing?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#Substring">Substring</a></span></div></div><p>Gets the substring representing the trailing whitespace of a <code><a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></code>, if available.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.SourceInfo.original">Lean.SourceInfo.original</a> <span class="fn">leading</span> <span class="fn">pos</span> <span class="fn">trailing</span> <span class="fn">endPos</span>)</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getTrailing?">getTrailing?</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">trailing</span></span></li><li class="equation"><span class="fn"><span class="fn">info</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getTrailing?">getTrailing?</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Option.none">none</a></li></ul></details><details id="instances-for-list-Lean.SourceInfo.getTrailing?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.SourceInfo.getTrailingTailPos?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4785-L4793">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SourceInfo.getTrailingTailPos?"><span class="name">Lean</span>.<span class="name">SourceInfo</span>.<span class="name">getTrailingTailPos?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">canonicalOnly</span> : <a href=".././Init/Prelude.html#Bool">Bool</a> := <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></span></div></div><p>Gets the end position information of the trailing whitespace of a <code><a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></code>, if available.
If <code>canonicalOnly</code> is true, then <code>.<a href=".././Init/Prelude.html#Lean.SourceInfo.synthetic">synthetic</a></code> syntax with <code>canonical := <a href=".././Init/Prelude.html#Bool.false">false</a></code>
will also return <code><a href=".././Init/Prelude.html#Option.none">none</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">info</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getTrailingTailPos?">getTrailingTailPos?</a></span> <span class="fn">canonicalOnly</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">info</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getTrailing?">getTrailing?</a></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">trailing</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">trailing</span>.<a href=".././Init/Prelude.html#Substring.stopPos">stopPos</a></span></span>
  | <a href=".././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><span class="fn"><span class="fn">info</span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getTailPos?">getTailPos?</a></span> <span class="fn">canonicalOnly</span></span></span></li></ul></details><details id="instances-for-list-Lean.SourceInfo.getTrailingTailPos?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.SyntaxNodeKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4797-L4805">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SyntaxNodeKind"><span class="name">Lean</span>.<span class="name">SyntaxNodeKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Specifies the interpretation of a <code><a href=".././Init/Prelude.html#Lean.Syntax.node">Syntax.node</a></code> value. An abbreviation for <code><a href=".././Init/Prelude.html#Lean.Name">Name</a></code>.</p><p>Node kinds may be any name, and do not need to refer to declarations in the environment.
Conventionally, however, a node's kind corresponds to the <code>Parser</code> or <code>ParserDesc</code> declaration that
produces it. There are also a number of built-in node kinds that are used by the parsing
infrastructure, such as <code><a href=".././Init/Prelude.html#Lean.nullKind">nullKind</a></code> and <code><a href=".././Init/Prelude.html#Lean.choiceKind">choiceKind</a></code>; these do not correspond to parser declarations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></li></ul></details><details id="instances-for-list-Lean.SyntaxNodeKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Syntax-AST">Syntax AST <a class="hover-link" href="#Syntax-AST">#</a></h1></div><div class="decl" id="Lean.Syntax.Preresolved"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4809-L4820">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.Preresolved"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">Preresolved</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>A possible binding of an identifier in the context in which it was quoted.</p><p>Identifiers in quotations may refer to either global declarations or to namespaces that are in scope
at the site of the quotation. These are saved in the <code><a href=".././Init/Prelude.html#Lean.Syntax.ident">Syntax.ident</a></code> constructor and are part of the
implementation of hygienic macros.</p><ul class="constructors"><li class="constructor" id="Lean.Syntax.Preresolved.namespace">namespace<span class="decl_args">
<span class="fn">(<span class="fn">ns</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.Syntax.Preresolved">Preresolved</a><div class="inductive_ctor_doc"><p>A potential namespace reference</p></div></li><li class="constructor" id="Lean.Syntax.Preresolved.decl">decl<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fields</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#String">String</a></span>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.Syntax.Preresolved">Preresolved</a><div class="inductive_ctor_doc"><p>A potential global constant or section variable reference, with additional field accesses</p></div></li></ul><details id="instances-for-list-Lean.Syntax.Preresolved" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4822-L4875">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax"><span class="name">Lean</span>.<span class="name">Syntax</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Lean syntax trees.</p><p>Syntax trees are used pervasively throughout Lean: they are produced by the parser, transformed by
the macro expander, and elaborated. They are also produced by the delaborator and presented to
users.</p><ul class="constructors"><li class="constructor" id="Lean.Syntax.missing">missing : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a><div class="inductive_ctor_doc"><p>A portion of the syntax tree that is missing because of a parse error.</p><p>The indexing operator on <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> also returns <code><a href=".././Init/Prelude.html#Lean.Syntax.missing">Syntax.missing</a></code> when the index is out of bounds.</p></div></li><li class="constructor" id="Lean.Syntax.node">node<span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a><div class="inductive_ctor_doc"><p>A node in the syntax tree that may have further syntax as child nodes. The node's <code>kind</code>
determines its interpretation.</p><p>For nodes produced by the parser, the <code>info</code> field is typically <code><a href=".././Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a></code>, and source
information is stored in the corresponding fields of identifiers and atoms. This field is used in
two ways:</p><ol>
<li>The delaborator uses it to associate nodes with metadata that are used to implement
interactive features.</li>
<li>Nodes created by quotations use the field to mark the syntax as synthetic (storing the result
of <code><a href=".././Init/Prelude.html#Lean.SourceInfo.fromRef">Lean.SourceInfo.fromRef</a></code>) even when its leading or trailing tokens are not.</li>
</ol></div></li><li class="constructor" id="Lean.Syntax.atom">atom<span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a><div class="inductive_ctor_doc"><p>A non-identifier atomic component of syntax.</p><p>All of the following are atoms:</p><ul>
<li>keywords, such as <code>def</code>, <code>fun</code>, and <code>inductive</code></li>
<li>literals, such as numeric or string literals</li>
<li>punctuation and delimiters, such as <code>(</code>, <code>)</code>, and <code>=&gt;</code>.</li>
</ul><p>Identifiers are represented by the <code><a href=".././Init/Prelude.html#Lean.Syntax.ident">Lean.Syntax.ident</a></code> constructor. Atoms also correspond to
quoted strings inside <code>syntax</code> declarations.</p></div></li><li class="constructor" id="Lean.Syntax.ident">ident<span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">rawVal</span> : <a href=".././Init/Prelude.html#Substring">Substring</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">preresolved</span> : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Lean.Syntax.Preresolved">Preresolved</a></span>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a><div class="inductive_ctor_doc"><p>An identifier.</p><p>In addition to source information, identifiers have the following fields:</p><ul>
<li><code>rawVal</code> is the literal substring from the input file</li>
<li><code><a href=".././Init/Prelude.html#Subtype.val">val</a></code> is the parsed Lean name, potentially including macro scopes.</li>
<li><code>preresolved</code> is the list of possible declarations this could refer to, populated by
<a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=quasiquotation">quotations</a>.</li>
</ul></div></li></ul><details id="instances-for-list-Lean.Syntax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.node1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4877-L4879">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.node1"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node1</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a₁</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Create syntax node with 1 child</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node1">Lean.Syntax.node1</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">a₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <a href=".././Init/Prelude.html#Array.mkArray1">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray1">]</a></span></li></ul></details><details id="instances-for-list-Lean.Syntax.node1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.node2"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4881-L4883">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.node2"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node2</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Create syntax node with 2 children</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node2">Lean.Syntax.node2</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">a₁</span> <span class="fn">a₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <a href=".././Init/Prelude.html#Array.mkArray2">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray2">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray2">]</a></span></li></ul></details><details id="instances-for-list-Lean.Syntax.node2" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.node3"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4885-L4887">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.node3"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node3</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">a₃</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Create syntax node with 3 children</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node3">Lean.Syntax.node3</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <a href=".././Init/Prelude.html#Array.mkArray3">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray3">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray3">,</a> <span class="fn">a₃</span><a href=".././Init/Prelude.html#Array.mkArray3">]</a></span></li></ul></details><details id="instances-for-list-Lean.Syntax.node3" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.node4"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4889-L4891">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.node4"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node4</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">a₃ </span><span class="fn">a₄</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Create syntax node with 4 children</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node4">Lean.Syntax.node4</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span> <span class="fn">a₄</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <a href=".././Init/Prelude.html#Array.mkArray4">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray4">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray4">,</a> <span class="fn">a₃</span><a href=".././Init/Prelude.html#Array.mkArray4">,</a> <span class="fn">a₄</span><a href=".././Init/Prelude.html#Array.mkArray4">]</a></span></li></ul></details><details id="instances-for-list-Lean.Syntax.node4" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.node5"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4893-L4895">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.node5"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node5</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">a₃ </span><span class="fn">a₄ </span><span class="fn">a₅</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Create syntax node with 5 children</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node5">Lean.Syntax.node5</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span> <span class="fn">a₄</span> <span class="fn">a₅</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <a href=".././Init/Prelude.html#Array.mkArray5">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray5">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray5">,</a> <span class="fn">a₃</span><a href=".././Init/Prelude.html#Array.mkArray5">,</a> <span class="fn">a₄</span><a href=".././Init/Prelude.html#Array.mkArray5">,</a> <span class="fn">a₅</span><a href=".././Init/Prelude.html#Array.mkArray5">]</a></span></li></ul></details><details id="instances-for-list-Lean.Syntax.node5" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.node6"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4897-L4899">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.node6"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node6</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">a₃ </span><span class="fn">a₄ </span><span class="fn">a₅ </span><span class="fn">a₆</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Create syntax node with 6 children</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node6">Lean.Syntax.node6</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span> <span class="fn">a₄</span> <span class="fn">a₅</span> <span class="fn">a₆</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <a href=".././Init/Prelude.html#Array.mkArray6">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray6">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray6">,</a> <span class="fn">a₃</span><a href=".././Init/Prelude.html#Array.mkArray6">,</a> <span class="fn">a₄</span><a href=".././Init/Prelude.html#Array.mkArray6">,</a> <span class="fn">a₅</span><a href=".././Init/Prelude.html#Array.mkArray6">,</a> <span class="fn">a₆</span><a href=".././Init/Prelude.html#Array.mkArray6">]</a></span></li></ul></details><details id="instances-for-list-Lean.Syntax.node6" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.node7"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4901-L4903">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.node7"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node7</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">a₃ </span><span class="fn">a₄ </span><span class="fn">a₅ </span><span class="fn">a₆ </span><span class="fn">a₇</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Create syntax node with 7 children</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node7">Lean.Syntax.node7</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span> <span class="fn">a₄</span> <span class="fn">a₅</span> <span class="fn">a₆</span> <span class="fn">a₇</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <a href=".././Init/Prelude.html#Array.mkArray7">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray7">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray7">,</a> <span class="fn">a₃</span><a href=".././Init/Prelude.html#Array.mkArray7">,</a> <span class="fn">a₄</span><a href=".././Init/Prelude.html#Array.mkArray7">,</a> <span class="fn">a₅</span><a href=".././Init/Prelude.html#Array.mkArray7">,</a> <span class="fn">a₆</span><a href=".././Init/Prelude.html#Array.mkArray7">,</a> <span class="fn">a₇</span><a href=".././Init/Prelude.html#Array.mkArray7">]</a></span></li></ul></details><details id="instances-for-list-Lean.Syntax.node7" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.node8"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4905-L4907">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.node8"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">node8</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">info</span> : <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">a₃ </span><span class="fn">a₄ </span><span class="fn">a₅ </span><span class="fn">a₆ </span><span class="fn">a₇ </span><span class="fn">a₈</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Create syntax node with 8 children</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node8">Lean.Syntax.node8</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span> <span class="fn">a₄</span> <span class="fn">a₅</span> <span class="fn">a₆</span> <span class="fn">a₇</span> <span class="fn">a₈</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <a href=".././Init/Prelude.html#Array.mkArray8">#[</a><span class="fn">a₁</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₂</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₃</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₄</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₅</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₆</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₇</span><a href=".././Init/Prelude.html#Array.mkArray8">,</a> <span class="fn">a₈</span><a href=".././Init/Prelude.html#Array.mkArray8">]</a></span></li></ul></details><details id="instances-for-list-Lean.Syntax.node8" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.SyntaxNodeKinds"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4909-L4915">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SyntaxNodeKinds"><span class="name">Lean</span>.<span class="name">SyntaxNodeKinds</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p><code><a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a></code> is a set of <code><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></code>, implemented as a list.</p><p>Singleton <code><a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a></code> are extremely common. They are written as name literals, rather than as
lists; list syntax is required only for empty or non-singleton sets of kinds.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">Lean.SyntaxNodeKinds</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></span></li></ul></details><details id="instances-for-list-Lean.SyntaxNodeKinds" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.TSyntax"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4917-L4925">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TSyntax"><span class="name">Lean</span>.<span class="name">TSyntax</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ks</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Typed syntax, which tracks the potential kinds of the <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> it contains.</p><p>While syntax quotations produce or expect <code><a href=".././Init/Prelude.html#Lean.TSyntax">TSyntax</a></code> values of the correct kinds, this is not
otherwise enforced; it can easily be circumvented by direct use of the constructor.</p><ul class="structure_fields" id="Lean.TSyntax.mk"><li id="Lean.TSyntax.raw" class="structure_field"><div class="structure_field_info">raw : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div><div class="structure_field_doc"><p>The underlying <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> value.</p></div></li></ul><details id="instances-for-list-Lean.TSyntax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.instInhabitedSyntax"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4927-L4928">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instInhabitedSyntax"><span class="name">Lean</span>.<span class="name">instInhabitedSyntax</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.instInhabitedSyntax">Lean.instInhabitedSyntax</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Lean.Syntax.missing">Lean.Syntax.missing</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.instInhabitedTSyntax"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4930-L4931">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instInhabitedTSyntax"><span class="name">Lean</span>.<span class="name">instInhabitedTSyntax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ks</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">ks</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.instInhabitedTSyntax">Lean.instInhabitedTSyntax</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Lean.TSyntax.mk">{</a> <span class="fn">raw</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a> <a href=".././Init/Prelude.html#Lean.TSyntax.mk">}</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Builtin-kinds">Builtin kinds <a class="hover-link" href="#Builtin-kinds">#</a></h1></div><div class="decl" id="Lean.choiceKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4935-L4942">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.choiceKind"><span class="name">Lean</span>.<span class="name">choiceKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p>The <code>`choice</code> kind is used to represent ambiguous parse results.</p><p>The parser prioritizes longer matches over shorter ones, but there is not always a unique longest
match. All the parse results are saved, and the determination of which to use is deferred
until typing information is available.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.choiceKind">Lean.choiceKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`choice</span></li></ul></details><details id="instances-for-list-Lean.choiceKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.nullKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4944-L4950">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.nullKind"><span class="name">Lean</span>.<span class="name">nullKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p><code>`null</code> is the “fallback” kind, used when no other kind applies. Null nodes result from
repetition operators, and empty null nodes represent the failure of an optional parse.</p><p>The null kind is used for raw list parsers like <code>many</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.nullKind">Lean.nullKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`null</span></li></ul></details><details id="instances-for-list-Lean.nullKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.groupKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4952-L4956">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.groupKind"><span class="name">Lean</span>.<span class="name">groupKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p>The <code>`group</code> kind is used for nodes that result from <code>Lean.Parser.group</code>. This avoids confusion
with the null kind when used inside <code><a href=".././Init/Control/Basic.html#optional">optional</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.groupKind">Lean.groupKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`group</span></li></ul></details><details id="instances-for-list-Lean.groupKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.identKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4958-L4964">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.identKind"><span class="name">Lean</span>.<span class="name">identKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p>The pseudo-kind assigned to identifiers: <code>`ident</code>.</p><p>The name <code>`ident</code> is not actually used as a kind for <code><a href=".././Init/Prelude.html#Lean.Syntax.node">Syntax.node</a></code> values. It is used by
convention as the kind of <code><a href=".././Init/Prelude.html#Lean.Syntax.ident">Syntax.ident</a></code> values.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.identKind">Lean.identKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`ident</span></li></ul></details><details id="instances-for-list-Lean.identKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.strLitKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4966-L4967">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.strLitKind"><span class="name">Lean</span>.<span class="name">strLitKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p><code>`str</code> is the node kind of string literals like <code>&quot;foo&quot;</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.strLitKind">Lean.strLitKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`str</span></li></ul></details><details id="instances-for-list-Lean.strLitKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.charLitKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4969-L4970">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.charLitKind"><span class="name">Lean</span>.<span class="name">charLitKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p><code>`char</code> is the node kind of character literals like <code>'A'</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.charLitKind">Lean.charLitKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`char</span></li></ul></details><details id="instances-for-list-Lean.charLitKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.numLitKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4972-L4973">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.numLitKind"><span class="name">Lean</span>.<span class="name">numLitKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p><code>`num</code> is the node kind of number literals like <code>42</code> and <code>0xa1</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.numLitKind">Lean.numLitKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`num</span></li></ul></details><details id="instances-for-list-Lean.numLitKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.hexnumKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4975-L4981">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.hexnumKind"><span class="name">Lean</span>.<span class="name">hexnumKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p><code>`hexnum</code> is the node kind of hexadecimal numbers like <code>ea10</code>
without the <code>0x</code> prefix. Recall that <code>hexnum</code> is not a token and must be prefixed.
For hexadecimal number literals, you should use <code><a href=".././Init/Prelude.html#Lean.Name.num">num</a></code> instead.
Example: <code>syntax anchor := &quot;#&quot; noWs hexnum</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.hexnumKind">Lean.hexnumKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`hexnum</span></li></ul></details><details id="instances-for-list-Lean.hexnumKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.scientificLitKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4983-L4984">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.scientificLitKind"><span class="name">Lean</span>.<span class="name">scientificLitKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p><code>`scientific</code> is the node kind of floating point literals like <code>1.23e-3</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.scientificLitKind">Lean.scientificLitKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`scientific</span></li></ul></details><details id="instances-for-list-Lean.scientificLitKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.nameLitKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4986-L4987">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.nameLitKind"><span class="name">Lean</span>.<span class="name">nameLitKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p><code>`name</code> is the node kind of name literals like <code>`foo</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.nameLitKind">Lean.nameLitKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`name</span></li></ul></details><details id="instances-for-list-Lean.nameLitKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.fieldIdxKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4989-L4990">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.fieldIdxKind"><span class="name">Lean</span>.<span class="name">fieldIdxKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p><code>`fieldIdx</code> is the node kind of projection indices like the <code>2</code> in <code>x.2</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.fieldIdxKind">Lean.fieldIdxKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`fieldIdx</span></li></ul></details><details id="instances-for-list-Lean.fieldIdxKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.hygieneInfoKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L4992-L5000">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.hygieneInfoKind"><span class="name">Lean</span>.<span class="name">hygieneInfoKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p><code>`hygieneInfo</code> is the node kind of the <code>Lean.Parser.hygieneInfo</code> parser, which produces an
“invisible token” that captures the hygiene information at the current point without parsing
anything.</p><p>They can be used to generate identifiers (with <code><a href=".././Init/Meta/Defs.html#Lean.HygieneInfo.mkIdent">Lean.HygieneInfo.mkIdent</a></code>) as if they were
introduced in a macro's input, rather than by its implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.hygieneInfoKind">Lean.hygieneInfoKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`hygieneInfo</span></li></ul></details><details id="instances-for-list-Lean.hygieneInfoKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.interpolatedStrLitKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5002-L5006">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.interpolatedStrLitKind"><span class="name">Lean</span>.<span class="name">interpolatedStrLitKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p><code>`interpolatedStrLitKind</code> is the node kind of interpolated string literal
fragments like <code>&quot;value = {</code> and <code>}&quot;</code> in <code>s!&quot;value = {x}&quot;</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.interpolatedStrLitKind">Lean.interpolatedStrLitKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`interpolatedStrLitKind</span></li></ul></details><details id="instances-for-list-Lean.interpolatedStrLitKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.interpolatedStrKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5007-L5011">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.interpolatedStrKind"><span class="name">Lean</span>.<span class="name">interpolatedStrKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p><code>`interpolatedStrKind</code> is the node kind of an interpolated string literal like <code>&quot;value = {x}&quot;</code>
in <code>s!&quot;value = {x}&quot;</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.interpolatedStrKind">Lean.interpolatedStrKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`interpolatedStrKind</span></li></ul></details><details id="instances-for-list-Lean.interpolatedStrKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.mkNode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5013-L5015">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.mkNode"><span class="name">Lean</span>.<span class="name">mkNode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">k</span></div></div><p>Creates an info-less node of the given kind and children.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.mkNode">Lean.mkNode</a> <span class="fn">k</span> <span class="fn">args</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Lean.TSyntax.mk">{</a> <span class="fn">raw</span> := <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href=".././Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">k</span> <span class="fn">args</span></span> <a href=".././Init/Prelude.html#Lean.TSyntax.mk">}</a></li></ul></details><details id="instances-for-list-Lean.mkNode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.mkNullNode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5017-L5020">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.mkNullNode"><span class="name">Lean</span>.<span class="name">mkNullNode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span> := <a href=".././Init/Prelude.html#Array.empty">#[</a><a href=".././Init/Prelude.html#Array.empty">]</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Creates an info-less <code><a href=".././Init/Prelude.html#Lean.nullKind">nullKind</a></code> node with the given children, if any.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.mkNullNode">Lean.mkNullNode</a> <span class="fn">args</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.mkNode">Lean.mkNode</a> <a href=".././Init/Prelude.html#Lean.nullKind">Lean.nullKind</a> <span class="fn">args</span>)</span>.<a href=".././Init/Prelude.html#Lean.TSyntax.raw">raw</a></span></li></ul></details><details id="instances-for-list-Lean.mkNullNode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.getKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5024-L5039">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getKind"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getKind</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></div></div><p>Gets the kind of a <code><a href=".././Init/Prelude.html#Lean.Syntax.node">Syntax.node</a></code> value, or the pseudo-kind of any other <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> value.</p><p>“Pseudo-kinds” are kinds that are assigned by convention to non-<code><a href=".././Init/Prelude.html#Lean.Syntax.node">Syntax.node</a></code> values:
<code><a href=".././Init/Prelude.html#Lean.identKind">identKind</a></code> for <code><a href=".././Init/Prelude.html#Lean.Syntax.ident">Syntax.ident</a></code>, <code>`missing</code> for <code><a href=".././Init/Prelude.html#Lean.Syntax.missing">Syntax.missing</a></code>, and the atom's string literal
for atoms.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">k</span> <span class="fn">args</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getKind">getKind</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></li><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.missing">Lean.Syntax.missing</a>.<a href=".././Init/Prelude.html#Lean.Syntax.getKind">getKind</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">`missing</span></li><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> <span class="fn">info</span> <span class="fn">v</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getKind">getKind</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkSimple">Lean.Name.mkSimple</a> <span class="fn">v</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.ident">Lean.Syntax.ident</a> <span class="fn">info</span> <span class="fn">rawVal</span> <span class="fn">val</span> <span class="fn">preresolved</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getKind">getKind</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Lean.identKind">Lean.identKind</a></li></ul></details><details id="instances-for-list-Lean.Syntax.getKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.setKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5041-L5049">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.setKind"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">setKind</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Changes the kind at the root of a <code><a href=".././Init/Prelude.html#Lean.Syntax.node">Syntax.node</a></code> to <code>k</code>.</p><p>Returns all other <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> values unchanged.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">args</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.setKind">setKind</a></span> <span class="fn">k</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">k</span> <span class="fn">args</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.setKind">setKind</a></span> <span class="fn">k</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">stx</span></li></ul></details><details id="instances-for-list-Lean.Syntax.setKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.isOfKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5051-L5059">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.isOfKind"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">isOfKind</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Checks whether syntax has the given kind or pseudo-kind.</p><p>“Pseudo-kinds” are kinds that are assigned by convention to non-<code><a href=".././Init/Prelude.html#Lean.Syntax.node">Syntax.node</a></code> values:
<code><a href=".././Init/Prelude.html#Lean.identKind">identKind</a></code> for <code><a href=".././Init/Prelude.html#Lean.Syntax.ident">Syntax.ident</a></code>, <code>`missing</code> for <code><a href=".././Init/Prelude.html#Lean.Syntax.missing">Syntax.missing</a></code>, and the atom's string literal
for atoms.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.isOfKind">isOfKind</a></span> <span class="fn">k</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getKind">getKind</a></span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</li></ul></details><details id="instances-for-list-Lean.Syntax.isOfKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.getArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5061-L5068">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getArg"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getArg</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Gets the <code>i</code>'th argument of the syntax node. This can also be written <code>stx[i]</code>.
Returns <code><a href=".././Init/Prelude.html#Lean.Syntax.missing">missing</a></code> if <code>i</code> is out of range.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">args</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getArg">getArg</a></span> <span class="fn">i</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">args</span>.<a href=".././Init/Prelude.html#Array.getD">getD</a></span> <span class="fn">i</span> <a href=".././Init/Prelude.html#Lean.Syntax.missing">Lean.Syntax.missing</a></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getArg">getArg</a></span> <span class="fn">i</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Lean.Syntax.missing">Lean.Syntax.missing</a></li></ul></details><details id="instances-for-list-Lean.Syntax.getArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.getArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5070-L5074">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getArgs"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getArgs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span></div></div><p>Gets the list of arguments of the syntax node, or <code>#[]</code> if it's not a <code><a href=".././Init/Prelude.html#Lean.Syntax.node">node</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">args</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getArgs">getArgs</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">args</span></li><li class="equation"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getArgs">getArgs</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Array.empty">#[</a><a href=".././Init/Prelude.html#Array.empty">]</a></li></ul></details><details id="instances-for-list-Lean.Syntax.getArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.getNumArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5076-L5080">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getNumArgs"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getNumArgs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Gets the number of arguments of the syntax node, or <code>0</code> if it's not a <code><a href=".././Init/Prelude.html#Lean.Syntax.node">node</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">args</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getNumArgs">getNumArgs</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">args</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span></li><li class="equation"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getNumArgs">getNumArgs</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></li></ul></details><details id="instances-for-list-Lean.Syntax.getNumArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.getOptional?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5082-L5091">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getOptional?"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getOptional?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span></div></div><p>Assuming <code>stx</code> was parsed by <code><a href=".././Init/Control/Basic.html#optional">optional</a></code>, returns the enclosed syntax
if it parsed something and <code><a href=".././Init/Prelude.html#Option.none">none</a></code> otherwise.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">args</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getOptional?">getOptional?</a></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">kind</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <a href=".././Init/Prelude.html#Lean.nullKind">Lean.nullKind</a> <a href=".././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">args</span>.<a href=".././Init/Prelude.html#Array.size">size</a></span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">1</span> with
  | <a href=".././Init/Prelude.html#Bool.true">true</a> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">args</span>.<a href=".././Init/Prelude.html#Array.get!Internal">get!Internal</a></span> <span class="fn">0</span>)</span></span>
  | <a href=".././Init/Prelude.html#Bool.false">false</a> =&gt; <a href=".././Init/Prelude.html#Option.none">none</a></span></li><li class="equation"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getOptional?">getOptional?</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Option.none">none</a></li></ul></details><details id="instances-for-list-Lean.Syntax.getOptional?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.isMissing"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5093-L5096">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.isMissing"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">isMissing</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Is this syntax <code>.<a href=".././Init/Prelude.html#Lean.Syntax.missing">missing</a></code>?</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.missing">Lean.Syntax.missing</a>.<a href=".././Init/Prelude.html#Lean.Syntax.isMissing">isMissing</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Lean.Syntax.isMissing">isMissing</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Syntax.isMissing" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.isNodeOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5098-L5100">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.isNodeOf"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">isNodeOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Is this syntax a <code><a href=".././Init/Prelude.html#Lean.Syntax.node">node</a></code> with kind <code>k</code>?</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.isNodeOf">isNodeOf</a></span> <span class="fn">k</span> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.isOfKind">isOfKind</a></span> <span class="fn">k</span></span> <a href=".././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getNumArgs">getNumArgs</a></span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">n</span>)</li></ul></details><details id="instances-for-list-Lean.Syntax.isNodeOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.isIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5102-L5105">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.isIdent"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">isIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p><code>stx.<a href=".././Init/Prelude.html#Lean.Syntax.isIdent">isIdent</a></code> is <code><a href=".././Init/Prelude.html#Bool.true">true</a></code> iff <code>stx</code> is an identifier.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.ident">Lean.Syntax.ident</a> <span class="fn">info</span> <span class="fn">rawVal</span> <span class="fn">val</span> <span class="fn">preresolved</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.isIdent">isIdent</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Lean.Syntax.isIdent">isIdent</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Syntax.isIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.getId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5107-L5110">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getId"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getId</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <a href=".././Init/Prelude.html#Lean.Name">Name</a></span></div></div><p>If this is an <code><a href=".././Init/Prelude.html#Lean.Syntax.ident">ident</a></code>, return the parsed value, else <code>.<a href=".././Init/Prelude.html#Lean.Name.anonymous">anonymous</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.ident">Lean.Syntax.ident</a> <span class="fn">info</span> <span class="fn">rawVal</span> <span class="fn">val</span> <span class="fn">preresolved</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getId">getId</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">val</span></li><li class="equation"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getId">getId</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a></li></ul></details><details id="instances-for-list-Lean.Syntax.getId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.getInfo?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5112-L5117">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getInfo?"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getInfo?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></span></span></div></div><p>Retrieve the immediate info from the Syntax node.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> <span class="fn">info</span> <span class="fn">val</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getInfo?">getInfo?</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">info</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.ident">Lean.Syntax.ident</a> <span class="fn">info</span> <span class="fn">rawVal</span> <span class="fn">val</span> <span class="fn">preresolved</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getInfo?">getInfo?</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">info</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">args</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getInfo?">getInfo?</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">info</span></span></li><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.missing">Lean.Syntax.missing</a>.<a href=".././Init/Prelude.html#Lean.Syntax.getInfo?">getInfo?</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Option.none">none</a></li></ul></details><details id="instances-for-list-Lean.Syntax.getInfo?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.getHeadInfo?"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5119-L5132">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getHeadInfo?"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getHeadInfo?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></span></span></div></div><p>Retrieve the left-most node or leaf's info in the Syntax tree.</p></div></div><div class="decl" id="Lean.Syntax.getHeadInfo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5134-L5138">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getHeadInfo"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getHeadInfo</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></div></div><p>Retrieve the left-most leaf's info in the Syntax tree, or <code><a href=".././Init/Prelude.html#Option.none">none</a></code> if there is no token.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getHeadInfo">getHeadInfo</a></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getHeadInfo?">getHeadInfo?</a></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">info</span></span> =&gt; <span class="fn">info</span>
  | <a href=".././Init/Prelude.html#Option.none">none</a> =&gt; <a href=".././Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a></span></li></ul></details><details id="instances-for-list-Lean.Syntax.getHeadInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.getPos?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5140-L5146">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getPos?"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getPos?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">canonicalOnly</span> : <a href=".././Init/Prelude.html#Bool">Bool</a> := <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></span></div></div><p>Get the starting position of the syntax, if possible.
If <code>canonicalOnly</code> is true, non-canonical <code><a href=".././Init/Prelude.html#Lean.SourceInfo.synthetic">synthetic</a></code> nodes are treated as not carrying
position information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getPos?">getPos?</a></span> <span class="fn">canonicalOnly</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getHeadInfo">getHeadInfo</a></span>.<a href=".././Init/Prelude.html#Lean.SourceInfo.getPos?">getPos?</a></span> <span class="fn">canonicalOnly</span></span></li></ul></details><details id="instances-for-list-Lean.Syntax.getPos?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.getTailPos?"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5148-L5172">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getTailPos?"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">getTailPos?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">canonicalOnly</span> : <a href=".././Init/Prelude.html#Bool">Bool</a> := <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#String.Pos.Raw">String.Pos.Raw</a></span></div></div><p>Get the ending position of the syntax, if possible.
If <code>canonicalOnly</code> is true, non-canonical <code><a href=".././Init/Prelude.html#Lean.SourceInfo.synthetic">synthetic</a></code> nodes are treated as not carrying
position information.</p></div></div><div class="decl" id="Lean.Syntax.SepArray"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5174-L5186">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.SepArray"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">SepArray</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">sep</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>An array of syntax elements interspersed with the given separators.</p><p>Separator arrays result from repetition operators such as <code>,*</code>.
<a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=coercions">Coercions</a> to and from <code><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> insert or remove separators
as required.</p><p>The typed equivalent is <code><a href=".././Init/Prelude.html#Lean.Syntax.TSepArray">Lean.Syntax.TSepArray</a></code>.</p><ul class="structure_fields" id="Lean.Syntax.SepArray.mk"><li id="Lean.Syntax.SepArray.elemsAndSeps" class="structure_field"><div class="structure_field_info">elemsAndSeps : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span></div><div class="structure_field_doc"><p>The array of elements and separators, ordered like
<code>#[el1, sep1, el2, sep2, el3]</code>.</p></div></li></ul><details id="instances-for-list-Lean.Syntax.SepArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.TSepArray"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5188-L5199">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.TSepArray"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">TSepArray</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ks</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">sep</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>An array of syntax elements that alternate with the given separator. Each syntax element has a kind
drawn from <code>ks</code>.</p><p>Separator arrays result from repetition operators such as <code>,*</code>.
<a href="https://lean-lang.org/doc/reference/4.25.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=coercions">Coercions</a> to and from <code><a href=".././Init/Prelude.html#Array">Array</a> (TSyntax ks)</code> insert or remove
separators as required. The untyped equivalent is <code><a href=".././Init/Prelude.html#Lean.Syntax.SepArray">Lean.Syntax.SepArray</a></code>.</p><ul class="structure_fields" id="Lean.Syntax.TSepArray.mk"><li id="Lean.Syntax.TSepArray.elemsAndSeps" class="structure_field"><div class="structure_field_info">elemsAndSeps : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span></div><div class="structure_field_doc"><p>The array of elements and separators, ordered like
<code>#[el1, sep1, el2, sep2, el3]</code>.</p></div></li></ul><details id="instances-for-list-Lean.Syntax.TSepArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.TSyntaxArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5203-L5206">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TSyntaxArray"><span class="name">Lean</span>.<span class="name">TSyntaxArray</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ks</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>An array of syntaxes of kind <code>ks</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntaxArray">Lean.TSyntaxArray</a> <span class="fn">ks</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">(<a href=".././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">ks</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.TSyntaxArray" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.TSyntaxArray.rawImpl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5208-L5209">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TSyntaxArray.rawImpl"><span class="name">Lean</span>.<span class="name">TSyntaxArray</span>.<span class="name">rawImpl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ks</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntaxArray">TSyntaxArray</a> <span class="fn">ks</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span></span></div></div><p>Implementation of <code><a href=".././Init/Prelude.html#Lean.TSyntaxArray.raw">TSyntaxArray.raw</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.TSyntaxArray.rawImpl">Lean.TSyntaxArray.rawImpl</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a></li></ul></details><details id="instances-for-list-Lean.TSyntaxArray.rawImpl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.TSyntaxArray.raw"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5211-L5213">source</a></div><div class="attributes">@[implemented_by Lean.TSyntaxArray.rawImpl]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TSyntaxArray.raw"><span class="name">Lean</span>.<span class="name">TSyntaxArray</span>.<span class="name">raw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ks</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">as</span> : <span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntaxArray">TSyntaxArray</a> <span class="fn">ks</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span></div></div><p>Converts a <code><a href=".././Init/Prelude.html#Lean.TSyntaxArray">TSyntaxArray</a></code> to an <code><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code>, without reallocation.</p></div></div><div class="decl" id="Lean.TSyntaxArray.mkImpl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5215-L5216">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TSyntaxArray.mkImpl"><span class="name">Lean</span>.<span class="name">TSyntaxArray</span>.<span class="name">mkImpl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ks</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span> → <span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntaxArray">TSyntaxArray</a> <span class="fn">ks</span></span></span></div></div><p>Implementation of <code><a href=".././Init/Prelude.html#Lean.TSyntaxArray.mk">TSyntaxArray.mk</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.TSyntaxArray.mkImpl">Lean.TSyntaxArray.mkImpl</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a></li></ul></details><details id="instances-for-list-Lean.TSyntaxArray.mkImpl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.TSyntaxArray.mk"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5218-L5220">source</a></div><div class="attributes">@[implemented_by Lean.TSyntaxArray.mkImpl]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TSyntaxArray.mk"><span class="name">Lean</span>.<span class="name">TSyntaxArray</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ks</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">as</span> : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntaxArray">TSyntaxArray</a> <span class="fn">ks</span></span></div></div><p>Converts an <code><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> to a <code><a href=".././Init/Prelude.html#Lean.TSyntaxArray">TSyntaxArray</a></code>, without reallocation.</p></div></div><div class="decl" id="Lean.SourceInfo.fromRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5222-L5233">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SourceInfo.fromRef"><span class="name">Lean</span>.<span class="name">SourceInfo</span>.<span class="name">fromRef</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ref</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">canonical</span> : <a href=".././Init/Prelude.html#Bool">Bool</a> := <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></div></div><p>Constructs a synthetic <code><a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></code> using a <code><a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> for the span.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.SourceInfo.fromRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.mkAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5235-L5237">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.mkAtom"><span class="name">Lean</span>.<span class="name">mkAtom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Constructs a synthetic <code><a href=".././Init/Prelude.html#Lean.Syntax.atom">atom</a></code> with no source info.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.mkAtom">Lean.mkAtom</a> <span class="fn">val</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> <a href=".././Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">val</span></span></li></ul></details><details id="instances-for-list-Lean.mkAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.mkAtomFrom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5239-L5241">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.mkAtomFrom"><span class="name">Lean</span>.<span class="name">mkAtomFrom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">src</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">canonical</span> : <a href=".././Init/Prelude.html#Bool">Bool</a> := <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Constructs a synthetic <code><a href=".././Init/Prelude.html#Lean.Syntax.atom">atom</a></code> with source info coming from <code>src</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.mkAtomFrom">Lean.mkAtomFrom</a> <span class="fn">src</span> <span class="fn">val</span> <span class="fn">canonical</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> <span class="fn">(<a href=".././Init/Prelude.html#Lean.SourceInfo.fromRef">Lean.SourceInfo.fromRef</a> <span class="fn">src</span> <span class="fn">canonical</span>)</span> <span class="fn">val</span></span></li></ul></details><details id="instances-for-list-Lean.mkAtomFrom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Parser-descriptions">Parser descriptions <a class="hover-link" href="#Parser-descriptions">#</a></h1></div><div class="decl" id="Lean.ParserDescr"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5245-L5324">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.ParserDescr"><span class="name">Lean</span>.<span class="name">ParserDescr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>A <code><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></code> is a grammar for parsers. This is used by the <code>syntax</code> command
to produce parsers without having to <code>import Lean</code>.</p><ul class="constructors"><li class="constructor" id="Lean.ParserDescr.const">const<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><p>A (named) nullary parser, like <code>ppSpace</code></p></div></li><li class="constructor" id="Lean.ParserDescr.unary">unary<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><p>A (named) unary parser, like <code>group(p)</code></p></div></li><li class="constructor" id="Lean.ParserDescr.binary">binary<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p₁ </span><span class="fn">p₂</span> : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><p>A (named) binary parser, like <code>orelse</code> or <code>andthen</code>
(written as <code>p1 &lt;|&gt; p2</code> and <code>p1 p2</code> respectively in <code>syntax</code>)</p></div></li><li class="constructor" id="Lean.ParserDescr.node">node<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prec</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><p>Parses using <code>p</code>, then pops the stack to create a new node with kind <code>kind</code>.
The precedence <code>prec</code> is used to determine whether the parser should apply given
the current precedence level.</p></div></li><li class="constructor" id="Lean.ParserDescr.trailingNode">trailingNode<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prec </span><span class="fn">lhsPrec</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><p>Like <code><a href=".././Init/Prelude.html#Lean.Syntax.node">node</a></code> but for trailing parsers (which start with a nonterminal).
Assumes the lhs is already on the stack, and parses using <code>p</code>, then pops the
stack including the lhs to create a new node with kind <code>kind</code>.
The precedence <code>prec</code> and <code>lhsPrec</code> are used to determine whether the parser
should apply.</p></div></li><li class="constructor" id="Lean.ParserDescr.symbol">symbol<span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><p>Parses the literal symbol.</p><p>The symbol is automatically included in the set of reserved tokens (&quot;keywords&quot;).
Keywords cannot be used as identifiers, unless the identifier is otherwise escaped.
For example, <code>&quot;fun&quot;</code> reserves <code>fun</code> as a keyword; to refer an identifier named <code>fun</code> one can write <code>«fun»</code>.
Adding a <code>&amp;</code> prefix prevents it from being reserved, for example <code>&amp;&quot;true&quot;</code>.</p><p>Whitespace before or after the atom is used as a pretty printing hint.
For example, <code>&quot; + &quot;</code> parses <code>+</code> and pretty prints it with whitespace on both sides.
The whitespace has no effect on parsing behavior.</p></div></li><li class="constructor" id="Lean.ParserDescr.nonReservedSymbol">nonReservedSymbol<span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">includeIdent</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><p>Parses a literal symbol. The <code>&amp;</code> prefix prevents it from being included in the set of reserved tokens (&quot;keywords&quot;).
This means that the symbol can still be recognized as an identifier by other parsers.</p><p>Some syntax categories, such as <code>tactic</code>, automatically apply <code>&amp;</code> to the first symbol.</p><p>Whitespace before or after the atom is used as a pretty printing hint.
For example, <code>&quot; + &quot;</code> parses <code>+</code> and pretty prints it with whitespace on both sides.
The whitespace has no effect on parsing behavior.</p><p>(Not exposed by parser description syntax:
If the <code>includeIdent</code> argument is true, lets <code><a href=".././Init/Prelude.html#Lean.Syntax.ident">ident</a></code> be reinterpreted as <code><a href=".././Init/Prelude.html#Lean.Syntax.atom">atom</a></code> if it matches.)</p></div></li><li class="constructor" id="Lean.ParserDescr.cat">cat<span class="decl_args">
<span class="fn">(<span class="fn">catName</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">rbp</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><p>Parses using the category parser <code>catName</code> with right binding power
(i.e. precedence) <code>rbp</code>.</p></div></li><li class="constructor" id="Lean.ParserDescr.parser">parser<span class="decl_args">
<span class="fn">(<span class="fn">declName</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><p>Parses using another parser <code>declName</code>, which can be either
a <code>Parser</code> or <code><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></code>.</p></div></li><li class="constructor" id="Lean.ParserDescr.nodeWithAntiquot">nodeWithAntiquot<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><p>Like <code><a href=".././Init/Prelude.html#Lean.Syntax.node">node</a></code>, but also declares that the body can be matched using an antiquotation
with name <code><a href=".././Init/Prelude.html#Lean.MacroScopesView.name">name</a></code>. For example, <code>def $id:declId := 1</code> uses an antiquotation with
name <code>declId</code> in the place where a <code>declId</code> is expected.</p></div></li><li class="constructor" id="Lean.ParserDescr.sepBy">sepBy<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">sep</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">psep</span> : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">allowTrailingSep</span> : <a href=".././Init/Prelude.html#Bool">Bool</a> := <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><p>A <code>sepBy(p, sep)</code> parses 0 or more occurrences of <code>p</code> separated by <code>sep</code>.
<code>psep</code> is usually the same as <code><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">symbol</a> sep</code>, but it can be overridden.
<code>sep</code> is only used in the antiquot syntax: <code>$x;*</code> would match if <code>sep</code> is <code>&quot;;&quot;</code>.
<code>allowTrailingSep</code> is true if e.g. <code>a, b,</code> is also allowed to match.</p></div></li><li class="constructor" id="Lean.ParserDescr.sepBy1">sepBy1<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">sep</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">psep</span> : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">allowTrailingSep</span> : <a href=".././Init/Prelude.html#Bool">Bool</a> := <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><p><code><a href=".././Init/Prelude.html#Lean.ParserDescr.sepBy1">sepBy1</a></code> is just like <code><a href=".././Init/Prelude.html#Lean.ParserDescr.sepBy">sepBy</a></code>, except it takes 1 or more instead of
0 or more occurrences of <code>p</code>.</p></div></li><li class="constructor" id="Lean.ParserDescr.unicodeSymbol">unicodeSymbol<span class="decl_args">
<span class="fn">(<span class="fn">val </span><span class="fn">asciiVal</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">preserveForPP</span> : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
 : <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a><div class="inductive_ctor_doc"><ul>
<li><code>unicode(&quot;→&quot;, &quot;-&gt;&quot;)</code> parses a symbol matching either <code>→</code> or <code>-&gt;</code>. Each symbol is reserved.
The second symbol is an ASCII version of the first.
The  <code>pp.unicode</code> option controls which is used when pretty printing.</li>
<li><code>unicode(&quot;→&quot;, &quot;-&gt;&quot;, preserveForPP)</code> is the same except for pretty printing behavior.
When the <code>pp.unicode</code> option is enabled, then the pretty printer uses whichever symbol
matches the underlying atom in the syntax.
The intent is that <code>preserveForPP</code> means that the ASCII variant is preferred.
For example, <code>fun</code> notation uses <code>preserveForPP</code> for its arrow; the delaborator chooses
<code>↦</code> or <code>=&gt;</code> depending on the value of <code>pp.unicode.fun</code>, letting users opt-in to formatting with <code>↦</code>.
Note that <code>notation</code> creates a pretty printer preferring the ASCII version.</li>
</ul></div></li></ul><details id="instances-for-list-Lean.ParserDescr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.instInhabitedParserDescr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5326-L5327">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instInhabitedParserDescr"><span class="name">Lean</span>.<span class="name">instInhabitedParserDescr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.instInhabitedParserDescr">Lean.instInhabitedParserDescr</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;&quot;</span></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.TrailingParserDescr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5329-L5335">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TrailingParserDescr"><span class="name">Lean</span>.<span class="name">TrailingParserDescr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Although <code><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">TrailingParserDescr</a></code> is an abbreviation for <code><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></code>, Lean will
look at the declared type in order to determine whether to add the parser to
the leading or trailing parser table. The determination is done automatically
by the <code>syntax</code> command.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></li></ul></details><details id="instances-for-list-Lean.TrailingParserDescr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>Runtime support for making quotation terms auto-hygienic, by mangling identifiers
introduced by them with a &quot;macro scope&quot; supplied by the context. Details to appear in a
paper soon.</p></div><div class="decl" id="Lean.MacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5343-L5349">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MacroScope"><span class="name">Lean</span>.<span class="name">MacroScope</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>A macro scope identifier is just a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> that gets bumped every time we
enter a new macro scope. Within a macro scope, all occurrences of identifier <code>x</code>
parse to the same thing, but <code>x</code> parsed from different macro scopes will
produce different identifiers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.MacroScope">Lean.MacroScope</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Nat">Nat</a></li></ul></details><details id="instances-for-list-Lean.MacroScope" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.reservedMacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5350-L5351">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.reservedMacroScope"><span class="name">Lean</span>.<span class="name">reservedMacroScope</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Macro scope used internally. It is not available for our frontend.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.reservedMacroScope">Lean.reservedMacroScope</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></li></ul></details><details id="instances-for-list-Lean.reservedMacroScope" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.firstFrontendMacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5352-L5353">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.firstFrontendMacroScope"><span class="name">Lean</span>.<span class="name">firstFrontendMacroScope</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>First macro scope available for our frontend</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.firstFrontendMacroScope">Lean.firstFrontendMacroScope</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Lean.reservedMacroScope">Lean.reservedMacroScope</a> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></li></ul></details><details id="instances-for-list-Lean.firstFrontendMacroScope" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MonadRef"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5355-L5365">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MonadRef"><span class="name">Lean</span>.<span class="name">MonadRef</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> → <a href=".././foundational_types.html">Type</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> 1</div></div><p>A <code><a href=".././Init/Prelude.html#Lean.MonadRef">MonadRef</a></code> is a monad that has a <code><a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> in the read-only state.
This is used to keep track of the location where we are working; if an exception
is thrown, the <code><a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a></code> gives the location where the error will be reported,
assuming no more specific location is provided.</p><ul class="structure_fields" id="Lean.MonadRef.mk"><li id="Lean.MonadRef.getRef" class="structure_field"><div class="structure_field_info">getRef : <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span></div><div class="structure_field_doc"><p>Get the current value of the <code><a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a></code></p></div></li><li id="Lean.MonadRef.withRef" class="structure_field"><div class="structure_field_info">withRef<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a>}</span></span>
</span> : <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></div><div class="structure_field_doc"><p>Run <code>x : m α</code> with a modified value for the <code><a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a></code></p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Lean.MonadRef" class="instances-list"></ul></details></div></div><div class="decl" id="Lean.instMonadRefOfMonadLiftOfMonadFunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5369-L5371">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instMonadRefOfMonadLiftOfMonadFunctor"><span class="name">Lean</span>.<span class="name">instMonadRefOfMonadLiftOfMonadFunctor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m </span><span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> → <a href=".././foundational_types.html">Type</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef">MonadRef</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef">MonadRef</a> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.replaceRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5373-L5380">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.replaceRef"><span class="name">Lean</span>.<span class="name">replaceRef</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ref </span><span class="fn">oldRef</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div></div><p>Replaces <code>oldRef</code> with <code><a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a></code>, unless <code><a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a></code> has no position info.
This biases us to having a valid span to report an error on.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.replaceRef">Lean.replaceRef</a> <span class="fn">ref</span> <span class="fn">oldRef</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">ref</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getPos?">getPos?</a></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">val</span></span> =&gt; <span class="fn">ref</span>
  | <span class="fn">x</span> =&gt; <span class="fn">oldRef</span></span></li></ul></details><details id="instances-for-list-Lean.replaceRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.withRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5382-L5391">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.withRef"><span class="name">Lean</span>.<span class="name">withRef</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> → <a href=".././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef">MonadRef</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ref</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>Run <code>x : m α</code> with a modified value for the <code><a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a></code>. This is not exactly
the same as <code><a href=".././Init/Prelude.html#Lean.MonadRef.withRef">MonadRef.withRef</a></code>, because it uses <code><a href=".././Init/Prelude.html#Lean.replaceRef">replaceRef</a></code> to avoid putting
syntax with bad spans in the state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.withRef">Lean.withRef</a> <span class="fn">ref</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">oldRef</span> ← <a href=".././Init/Prelude.html#Lean.MonadRef.getRef">Lean.getRef</a>
  have ref : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> := <span class="fn"><a href=".././Init/Prelude.html#Lean.replaceRef">Lean.replaceRef</a> <span class="fn">ref</span> <span class="fn">oldRef</span></span>
  <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef.withRef">Lean.MonadRef.withRef</a> <span class="fn">ref</span> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-Lean.withRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.withRef?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5393-L5401">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.withRef?"><span class="name">Lean</span>.<span class="name">withRef?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> → <a href=".././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef">MonadRef</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ref?</span> : <span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>If <code>ref? = <a href=".././Init/Prelude.html#Option.some">some</a> <a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a></code>, run <code>x : m α</code> with a modified value for the <code><a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a></code> by calling <code><a href=".././Init/Prelude.html#Lean.MonadRef.withRef">withRef</a></code>.
Otherwise, run <code>x</code> directly.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.withRef?">Lean.withRef?</a> <span class="fn">(<a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">ref</span>)</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.withRef">Lean.withRef</a> <span class="fn">ref</span> <span class="fn">x</span></span></li><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.withRef?">Lean.withRef?</a> <span class="fn">ref?</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></li></ul></details><details id="instances-for-list-Lean.withRef?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MonadQuotation"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5403-L5429">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MonadQuotation"><span class="name">Lean</span>.<span class="name">MonadQuotation</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> → <a href=".././foundational_types.html">Type</a></span>)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef">Lean.MonadRef</a> <span class="fn">m</span></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> 1</div></div><p>A monad that supports syntax quotations. Syntax quotations (in term
position) are monadic values that when executed retrieve the current &quot;macro
scope&quot; from the monad and apply it to every identifier they introduce
(independent of whether this identifier turns out to be a reference to an
existing declaration, or an actually fresh binding during further
elaboration). We also apply the position of the result of <code><a href=".././Init/Prelude.html#Lean.MonadRef.getRef">getRef</a></code> to each
introduced symbol, which results in better error positions than not applying
any position.</p><ul class="structure_fields" id="Lean.MonadQuotation.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#Lean.MonadRef.getRef">getRef</a> : <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href=".././Init/Prelude.html#Lean.MonadRef.withRef">withRef</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a>}</span></span>
</span> : <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></div></li><li id="Lean.MonadQuotation.getCurrMacroScope" class="structure_field"><div class="structure_field_info">getCurrMacroScope : <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Lean.MacroScope">MacroScope</a></span></div><div class="structure_field_doc"><p>Get the fresh scope of the current macro invocation</p></div></li><li id="Lean.MonadQuotation.getContext" class="structure_field"><div class="structure_field_info">getContext : <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Lean.Name">Name</a></span></div><div class="structure_field_doc"><p>Get the context name used in Note <code><a href=".././Init/Prelude.html#Lean.Macro">Macro</a> Scope Representation</code>.</p></div></li><li id="Lean.MonadQuotation.withFreshMacroScope" class="structure_field"><div class="structure_field_info">withFreshMacroScope<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div><div class="structure_field_doc"><p>Execute action in a new macro invocation context. This transformer should be
used at all places that morally qualify as the beginning of a &quot;macro call&quot;,
e.g. <code>elabCommand</code> and <code>elabTerm</code> in the case of the elaborator. However, it
can also be used internally inside a &quot;macro&quot; if identifiers introduced by
e.g. different recursive calls should be independent and not collide. While
returning an intermediate syntax tree that will recursively be expanded by
the elaborator can be used for the same effect, doing direct recursion inside
the macro guarded by this transformer is often easier because one is not
restricted to passing a single syntax tree. Modelling this helper as a
transformer and not just a monadic action ensures that the current macro
scope before the recursive call is restored after it, as expected.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Lean.MonadQuotation" class="instances-list"></ul></details></div></div><div class="decl" id="Lean.MonadQuotation.getMainModule"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5434-L5435">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MonadQuotation.getMainModule"><span class="name">Lean</span>.<span class="name">MonadQuotation</span>.<span class="name">getMainModule</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> → <a href=".././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">self</span> : <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation">MonadQuotation</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Lean.Name">Name</a></span></div></div><p>Get the context name used in Note <code><a href=".././Init/Prelude.html#Lean.Macro">Macro</a> Scope Representation</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href=".././Init/Prelude.html#Lean.MonadQuotation.getMainModule">Lean.MonadQuotation.getMainModule</a> <a href=".././Init/Prelude.html#Eq">=</a> @<a href=".././Init/Prelude.html#Lean.MonadQuotation.getContext">Lean.MonadQuotation.getContext</a></li></ul></details><details id="instances-for-list-Lean.MonadQuotation.getMainModule" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MonadRef.mkInfoFromRefPos"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5437-L5440">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MonadRef.mkInfoFromRefPos"><span class="name">Lean</span>.<span class="name">MonadRef</span>.<span class="name">mkInfoFromRefPos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> → <a href=".././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef">MonadRef</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></span></div></div><p>Construct a synthetic <code><a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></code> from the <code><a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a></code> in the monad state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.MonadRef.mkInfoFromRefPos">Lean.MonadRef.mkInfoFromRefPos</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href=".././Init/Prelude.html#Lean.MonadRef.getRef">Lean.getRef</a>
  <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href=".././Init/Prelude.html#Lean.SourceInfo.fromRef">Lean.SourceInfo.fromRef</a> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.MonadRef.mkInfoFromRefPos" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.instMonadQuotationOfMonadFunctorOfMonadLift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5442-L5445">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instMonadQuotationOfMonadFunctorOfMonadLift"><span class="name">Lean</span>.<span class="name">instMonadQuotationOfMonadFunctorOfMonadLift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> → <a href=".././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation">MonadQuotation</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation">MonadQuotation</a> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Note-Macro-Scope-Representation">Note [Macro Scope Representation] <a class="hover-link" href="#Note-Macro-Scope-Representation">#</a></h1><p>We represent a name with macro scopes as</p><pre><code>&lt;actual name&gt;._@.(&lt;ctx&gt;.&lt;scopes&gt;)*.&lt;ctx&gt;._hyg.&lt;scopes&gt;
</code></pre><p>Example: suppose the context name is <code><a href=".././Init/Data/List/Basic.html">Init.Data.List.Basic</a></code>, and name is <code>foo.bla</code>, and macroscopes [2, 5]</p><pre><code>foo.bla._@.Init.Data.List.Basic._hyg.2.5
</code></pre><p>The delimiter <code>_hyg</code> is used just to improve the <code><a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">hasMacroScopes</a></code> performance.</p><p>The primary purpose of the context name is to differentiate macro scopes from different files as the
numeric scopes are reset in each file. The current scope is always the right-most one. Scopes from
multiple files may be collected when we execute a macro generated in an imported file in the current
file.</p><pre><code>foo.bla._@.Init.Data.List.Basic.2.1.Init.Lean.Expr._hyg.4
</code></pre><p>The delimiter <code>_hyg</code> is used just to improve the <code><a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">hasMacroScopes</a></code> performance.
In practice, we further specify the context name down to be unique per declaration so that the
numeric scopes are not influenced by the elaboration of preceding declarations. This helps both with
ensuring declaration names are more stable so that <code>prefer_native</code> can find the correct native
symbol as well as making exported information in general more stable, avoiding rebuilds under the
module system. Thus the actual encoding of the context name in the current implementation is</p><pre><code>&lt;main module&gt;.&lt;uniq&gt;._hygCtx
</code></pre><p>where <code>&lt;uniq&gt;</code> is an identifier unique within the current module, set by
<code>Command.withInitQuotContext</code>; see there for details. Thus we can assume the full context name to be
unique throughout all modules and reset the numeric scopes whenever establishing a fresh context
name.</p></div><div class="decl" id="Lean.Name.hasMacroScopes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5483-L5487">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.hasMacroScopes"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">hasMacroScopes</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Name</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Does this name have hygienic macro scopes?</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">pre</span>.<a href=".././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">hasMacroScopes</a></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">s</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">&quot;_hyg&quot;</span>)</li><li class="equation"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Lean.Name.num">num</a></span> <span class="fn">i</span>)</span>.<a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">hasMacroScopes</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">p</span>.<a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">hasMacroScopes</a></span></li><li class="equation"><span class="fn"><span class="fn">x✝</span>.<a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">hasMacroScopes</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Name.hasMacroScopes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.eraseMacroScopes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5496-L5501">source</a></div><div class="attributes">@[export lean_erase_macro_scopes]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.eraseMacroScopes"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">eraseMacroScopes</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Remove the macro scopes from the name.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Lean.Name.eraseMacroScopes">eraseMacroScopes</a></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">hasMacroScopes</a></span> with
  | <a href=".././Init/Prelude.html#Bool.true">true</a> =&gt; <span class="fn"><a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.eraseMacroScopesAux">Lean.eraseMacroScopesAux✝</a> <span class="fn">n</span></span>
  | <a href=".././Init/Prelude.html#Bool.false">false</a> =&gt; <span class="fn">n</span></span></li></ul></details><details id="instances-for-list-Lean.Name.eraseMacroScopes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.simpMacroScopes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5507-L5512">source</a></div><div class="attributes">@[export lean_simp_macro_scopes]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.simpMacroScopes"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">simpMacroScopes</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Helper function we use to create binder names that do not need to be unique.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Lean.Name.simpMacroScopes">simpMacroScopes</a></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">n</span>.<a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">hasMacroScopes</a></span> with
  | <a href=".././Init/Prelude.html#Bool.true">true</a> =&gt; <span class="fn"><a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.simpMacroScopesAux">Lean.simpMacroScopesAux✝</a> <span class="fn">n</span></span>
  | <a href=".././Init/Prelude.html#Bool.false">false</a> =&gt; <span class="fn">n</span></span></li></ul></details><details id="instances-for-list-Lean.Name.simpMacroScopes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MacroScopesView"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5514-L5531">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MacroScopesView"><span class="name">Lean</span>.<span class="name">MacroScopesView</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>A <code><a href=".././Init/Prelude.html#Lean.MacroScopesView">MacroScopesView</a></code> represents a parsed hygienic name. <code><a href=".././Init/Prelude.html#Lean.extractMacroScopes">extractMacroScopes</a></code>
will decode it from a <code><a href=".././Init/Prelude.html#Lean.Name">Name</a></code>, and <code>.<a href=".././Init/Prelude.html#Lean.MacroScopesView.review">review</a></code> will re-encode it. The grammar of a
hygienic name is:</p><pre><code>&lt;name&gt;._@.(&lt;module_name&gt;.&lt;scopes&gt;)*.&lt;mainModule&gt;._hyg.&lt;scopes&gt;
</code></pre><ul class="structure_fields" id="Lean.MacroScopesView.mk"><li id="Lean.MacroScopesView.name" class="structure_field"><div class="structure_field_info">name : <a href=".././Init/Prelude.html#Lean.Name">Name</a></div><div class="structure_field_doc"><p>The original (unhygienic) name.</p></div></li><li id="Lean.MacroScopesView.imported" class="structure_field"><div class="structure_field_info">imported : <a href=".././Init/Prelude.html#Lean.Name">Name</a></div><div class="structure_field_doc"><p>All the name components <code>(&lt;module_name&gt;.&lt;scopes&gt;)*</code> from the imports
concatenated together.</p></div></li><li id="Lean.MacroScopesView.ctx" class="structure_field"><div class="structure_field_info">ctx : <a href=".././Init/Prelude.html#Lean.Name">Name</a></div><div class="structure_field_doc"><p>The context name, a globally unique prefix.</p></div></li><li id="Lean.MacroScopesView.scopes" class="structure_field"><div class="structure_field_info">scopes : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Lean.MacroScope">MacroScope</a></span></div><div class="structure_field_doc"><p>The list of macro scopes.</p></div></li></ul><details id="instances-for-list-Lean.MacroScopesView" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.instInhabitedMacroScopesView"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5533-L5534">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instInhabitedMacroScopesView"><span class="name">Lean</span>.<span class="name">instInhabitedMacroScopesView</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.MacroScopesView">MacroScopesView</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.instInhabitedMacroScopesView">Lean.instInhabitedMacroScopesView</a> <a href=".././Init/Prelude.html#Eq">=</a>   <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Lean.MacroScopesView.mk">{</a> <span class="fn">name</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">imported</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">ctx</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">scopes</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a> <a href=".././Init/Prelude.html#Lean.MacroScopesView.mk">}</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.MacroScopesView.review"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5536-L5542">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MacroScopesView.review"><span class="name">Lean</span>.<span class="name">MacroScopesView</span>.<span class="name">review</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">view</span> : <a href=".././Init/Prelude.html#Lean.MacroScopesView">MacroScopesView</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Encode a hygienic name from the parsed pieces.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.MacroScopesView.review" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.extractMacroScopes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5571-L5578">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.extractMacroScopes"><span class="name">Lean</span>.<span class="name">extractMacroScopes</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.MacroScopesView">MacroScopesView</a></div></div><p>Revert all <code><a href=".././Init/Prelude.html#Lean.addMacroScope">addMacroScope</a></code> calls. <code>v = <a href=".././Init/Prelude.html#Lean.extractMacroScopes">extractMacroScopes</a> n → n = v.<a href=".././Init/Prelude.html#Lean.MacroScopesView.review">review</a></code>.
This operation is useful for analyzing/transforming the original identifiers, then adding back
the scopes (via <code><a href=".././Init/Prelude.html#Lean.MacroScopesView.review">MacroScopesView.review</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.extractMacroScopes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.addMacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5580-L5594">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.addMacroScope"><span class="name">Lean</span>.<span class="name">addMacroScope</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ctx </span><span class="fn">n</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">scp</span> : <a href=".././Init/Prelude.html#Lean.MacroScope">MacroScope</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Add a new macro scope onto the name <code>n</code>, in the given <code><a href=".././Init/Prelude.html#Lean.MacroScopesView.ctx">ctx</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.addMacroScope" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Name.append"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5596-L5615">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.append"><span class="name">Lean</span>.<span class="name">Name</span>.<span class="name">append</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Name</a></div></div><p>Appends two names <code>a</code> and <code>b</code>, propagating macro scopes from <code>a</code> or <code>b</code>, if any, to the result.
Panics if both <code>a</code> and <code>b</code> have macro scopes.</p><p>This function is used for the <code><a href=".././Init/Prelude.html#Append">Append</a> <a href=".././Init/Prelude.html#Lean.Name">Name</a></code> instance.</p><p>See also <code><a href=".././Init/Prelude.html#Lean.Name.appendCore">Lean.Name.appendCore</a></code>, which appends names without any consideration for macro scopes.
Also consider <code><a href=".././Init/Prelude.html#Lean.Name.eraseMacroScopes">Lean.Name.eraseMacroScopes</a></code> to erase macro scopes before appending, if appropriate.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Name.append" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.instAppendName"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5617-L5618">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instAppendName"><span class="name">Lean</span>.<span class="name">instAppendName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Append">Append</a> <a href=".././Init/Prelude.html#Lean.Name">Name</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.instAppendName">Lean.instAppendName</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Append.mk">{</a> <span class="fn">append</span> := <a href=".././Init/Prelude.html#Lean.Name.append">Lean.Name.append</a> <a href=".././Init/Prelude.html#Append.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.MonadQuotation.addMacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5620-L5627">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MonadQuotation.addMacroScope"><span class="name">Lean</span>.<span class="name">MonadQuotation</span>.<span class="name">addMacroScope</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href=".././foundational_types.html">Type</a> → <a href=".././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation">MonadQuotation</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Lean.Name">Name</a></span></div></div><p>Add a new macro scope onto the name <code>n</code>, using the monad state to supply the
main module and current macro scope.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation.addMacroScope">Lean.MonadQuotation.addMacroScope</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">ctx</span> ← <a href=".././Init/Prelude.html#Lean.MonadQuotation.getContext">Lean.MonadQuotation.getContext</a>
  let <span class="fn">scp</span> ← <a href=".././Init/Prelude.html#Lean.MonadQuotation.getCurrMacroScope">Lean.getCurrMacroScope</a>
  <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href=".././Init/Prelude.html#Lean.addMacroScope">Lean.addMacroScope</a> <span class="fn">ctx</span> <span class="fn">n</span> <span class="fn">scp</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.MonadQuotation.addMacroScope" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.matchesNull"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5631-L5633">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.matchesNull"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">matchesNull</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Is this syntax a null <code><a href=".././Init/Prelude.html#Lean.Syntax.node">node</a></code>?</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.matchesNull">matchesNull</a></span> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.isNodeOf">isNodeOf</a></span> <a href=".././Init/Prelude.html#Lean.nullKind">Lean.nullKind</a> <span class="fn">n</span></span></li></ul></details><details id="instances-for-list-Lean.Syntax.matchesNull" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.matchesIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5635-L5644">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.matchesIdent"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">matchesIdent</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">id</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Function used for determining whether a syntax pattern <code>`(id)</code> is matched.
There are various conceivable notions of when two syntactic identifiers should be regarded as identical,
but semantic definitions like whether they refer to the same global name cannot be implemented without
context information (i.e. <code>MonadResolveName</code>). Thus in patterns we default to the structural solution
of comparing the identifiers' <code><a href=".././Init/Prelude.html#Lean.Name">Name</a></code> values, though we at least do so modulo macro scopes so that
identifiers that &quot;look&quot; the same match. This is particularly useful when dealing with identifiers that
do not actually refer to Lean bindings, e.g. in the <code>stx</code> pattern <code>`(many($p))</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.matchesIdent">matchesIdent</a></span> <span class="fn">id</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.isIdent">isIdent</a></span> <a href=".././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.getId">getId</a></span>.<a href=".././Init/Prelude.html#Lean.Name.eraseMacroScopes">eraseMacroScopes</a></span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">id</span>.<a href=".././Init/Prelude.html#Lean.Name.eraseMacroScopes">eraseMacroScopes</a></span>)</li></ul></details><details id="instances-for-list-Lean.Syntax.matchesIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Syntax.matchesLit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5646-L5652">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.matchesLit"><span class="name">Lean</span>.<span class="name">Syntax</span>.<span class="name">matchesLit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Is this syntax a node kind <code>k</code> wrapping an <code><a href=".././Init/Prelude.html#Lean.Syntax.atom">atom</a> _ <a href=".././Init/Prelude.html#Subtype.val">val</a></code>?</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">args</span>)</span>.<a href=".././Init/Prelude.html#Lean.Syntax.matchesLit">matchesLit</a></span> <span class="fn">k</span> <span class="fn">val</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   (<span class="fn">k</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">kind</span> <a href=".././Init/Prelude.html#Bool.and">&amp;&amp;</a>     <span class="fn">match <span class="fn"><span class="fn"><span class="fn">args</span>.<a href=".././Init/Prelude.html#Array.getD">getD</a></span> <span class="fn">0</span> <a href=".././Init/Prelude.html#Lean.Syntax.missing">Lean.Syntax.missing</a></span> with
    | <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> <span class="fn">info</span> <span class="fn">val'</span></span> =&gt; <span class="fn">val</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">val'</span>
    | <span class="fn">x</span> =&gt; <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.Syntax.matchesLit">matchesLit</a></span> <span class="fn">k</span> <span class="fn">val</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Syntax.matchesLit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.MethodsRefPointed"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5658-L5660">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.MethodsRefPointed"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">MethodsRefPointed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#NonemptyType">NonemptyType</a></div></div><p>References</p></div></div><div class="decl" id="Lean.Macro.MethodsRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5663-L5663">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.MethodsRef"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">MethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.Macro.MethodsRef">Lean.Macro.MethodsRef</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.MethodsRefPointed">Lean.Macro.MethodsRefPointed</a>.<a href=".././Init/Prelude.html#NonemptyType.type">type</a></span></li></ul></details><details id="instances-for-list-Lean.Macro.MethodsRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.instNonemptyMethodsRef"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5665-L5665">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instNonemptyMethodsRef"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instNonemptyMethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <a href=".././Init/Prelude.html#Lean.Macro.MethodsRef">MethodsRef</a></span></div></div></div></div><div class="decl" id="Lean.Macro.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5667-L5681">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.Context"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>The read-only context for the <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code> monad.</p><ul class="structure_fields" id="Lean.Macro.Context.mk"><li id="Lean.Macro.Context.methods" class="structure_field"><div class="structure_field_info">methods : <a href=".././Init/Prelude.html#Lean.Macro.MethodsRef">MethodsRef</a></div><div class="structure_field_doc"><p>An opaque reference to the <code><a href=".././Init/Prelude.html#Lean.Macro.Methods">Methods</a></code> object. This is done to break a
dependency cycle: the <code><a href=".././Init/Prelude.html#Lean.Macro.Methods">Methods</a></code> involve <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code> which has not been defined yet.</p></div></li><li id="Lean.Macro.Context.quotContext" class="structure_field"><div class="structure_field_info">quotContext : <a href=".././Init/Prelude.html#Lean.Name">Name</a></div><div class="structure_field_doc"><p>The quotation context name for <code><a href=".././Init/Prelude.html#Lean.MonadQuotation.getContext">MonadQuotation.getContext</a></code>.</p></div></li><li id="Lean.Macro.Context.currMacroScope" class="structure_field"><div class="structure_field_info">currMacroScope : <a href=".././Init/Prelude.html#Lean.MacroScope">MacroScope</a></div><div class="structure_field_doc"><p>The current macro scope.</p></div></li><li id="Lean.Macro.Context.currRecDepth" class="structure_field"><div class="structure_field_info">currRecDepth : <a href=".././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>The current recursion depth.</p></div></li><li id="Lean.Macro.Context.maxRecDepth" class="structure_field"><div class="structure_field_info">maxRecDepth : <a href=".././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>The maximum recursion depth.</p></div></li><li id="Lean.Macro.Context.ref" class="structure_field"><div class="structure_field_info">ref : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></div><div class="structure_field_doc"><p>The syntax which supplies the position of error messages.</p></div></li></ul><details id="instances-for-list-Lean.Macro.Context" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.Exception"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5683-L5690">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.Exception"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">Exception</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>An exception in the <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code> monad.</p><ul class="constructors"><li class="constructor" id="Lean.Macro.Exception.error">error : <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <span class="fn"><a href=".././Init/Prelude.html#String">String</a> → <a href=".././Init/Prelude.html#Lean.Macro.Exception">Exception</a></span></span><div class="inductive_ctor_doc"><p>A general error, given a message and a span (expressed as a <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code>).</p></div></li><li class="constructor" id="Lean.Macro.Exception.unsupportedSyntax">unsupportedSyntax : <a href=".././Init/Prelude.html#Lean.Macro.Exception">Exception</a><div class="inductive_ctor_doc"><p>An unsupported syntax exception. We keep this separate because it is
used for control flow: if one macro does not support a syntax then we try
the next one.</p></div></li></ul><details id="instances-for-list-Lean.Macro.Exception" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5692-L5701">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.State"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>The mutable state for the <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code> monad.</p><ul class="structure_fields" id="_private.Init.Prelude.0.Lean.Macro.State.mk"><li id="Lean.Macro.State.macroScope" class="structure_field"><div class="structure_field_info">macroScope : <a href=".././Init/Prelude.html#Lean.MacroScope">MacroScope</a></div><div class="structure_field_doc"><p>The global macro scope counter, used for producing fresh scope names.</p></div></li><li id="Lean.Macro.State.traceMsgs" class="structure_field"><div class="structure_field_info">traceMsgs : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> (<a href=".././Init/Prelude.html#Lean.Name">Name</a> <a href=".././Init/Prelude.html#Prod">×</a> <a href=".././Init/Prelude.html#String">String</a>)</span></div><div class="structure_field_doc"><p>The list of trace messages that have been produced, each with a trace
class and a message.</p></div></li><li id="_private.Init.Prelude.0.Lean.Macro.State.expandedMacroDecls" class="structure_field"><div class="structure_field_info">expandedMacroDecls : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></li></ul><details id="instances-for-list-Lean.Macro.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5701-L5701">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instInhabitedState"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.Macro.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.Macro.instInhabitedState">Lean.Macro.instInhabitedState</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Lean.Macro.instInhabitedState.default">Lean.Macro.instInhabitedState.default</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Macro.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5701-L5701">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Macro.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.Macro.instInhabitedState.default">Lean.Macro.instInhabitedState.default</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.Macro.State.mk">{</a> <span class="fn">macroScope</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">traceMsgs</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">expandedMacroDecls</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a> <a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.Macro.State.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Macro.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MacroM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5705-L5715">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MacroM"><span class="name">Lean</span>.<span class="name">MacroM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>The <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code> monad is the main monad for macro expansion. It has the
information needed to handle hygienic name generation, and is the monad that
<code>macro</code> definitions live in.</p><p>Notably, this is a (relatively) pure monad: there is no <code><a href=".././Init/System/IO.html#IO">IO</a></code> and no access to
the <code>Environment</code>. That means that things like declaration lookup are
impossible here, as well as <code><a href=".././Init/System/IO.html#IO.Ref">IO.Ref</a></code> or other side-effecting operations.
For more capabilities, macros can instead be written as <code>elab</code> using <code>adaptExpander</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <a href=".././Init/Prelude.html#Lean.Macro.Context">Lean.Macro.Context</a> <span class="fn">(<a href=".././Init/Prelude.html#EStateM">EStateM</a> <a href=".././Init/Prelude.html#Lean.Macro.Exception">Lean.Macro.Exception</a> <a href=".././Init/Prelude.html#Lean.Macro.State">Lean.Macro.State</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.MacroM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5717-L5722">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro"><span class="name">Lean</span>.<span class="name">Macro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>A <code>macro</code> has type <code><a href=".././Init/Prelude.html#Lean.Macro">Macro</a></code>, which is a <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code>: it
receives an input syntax and is supposed to &quot;expand&quot; it into another piece of
syntax.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.Macro">Lean.Macro</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span>)</span></li></ul></details><details id="instances-for-list-Lean.Macro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.instMonadRefMacroM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5726-L5728">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instMonadRefMacroM"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instMonadRefMacroM</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef">MonadRef</a> <a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Macro.throwUnsupported"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5730-L5732">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.throwUnsupported"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">throwUnsupported</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">α</span></span></div></div><p>Throw an <code><a href=".././Init/Prelude.html#Lean.Macro.Exception.unsupportedSyntax">unsupportedSyntax</a></code> exception.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.Macro.throwUnsupported">Lean.Macro.throwUnsupported</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadExcept.throw">throw</a> <a href=".././Init/Prelude.html#Lean.Macro.Exception.unsupportedSyntax">Lean.Macro.Exception.unsupportedSyntax</a></span></li></ul></details><details id="instances-for-list-Lean.Macro.throwUnsupported" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.throwError"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5734-L5740">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.throwError"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">throwError</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">msg</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">α</span></span></div></div><p>Throw an error with the given message,
using the <code><a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a></code> for the location information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.throwError">Lean.Macro.throwError</a> <span class="fn">msg</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">ref</span> ← <a href=".././Init/Prelude.html#Lean.MonadRef.getRef">Lean.getRef</a>
  <span class="fn"><a href=".././Init/Prelude.html#MonadExcept.throw">throw</a> <span class="fn">(<a href=".././Init/Prelude.html#Lean.Macro.Exception.error">Lean.Macro.Exception.error</a> <span class="fn">ref</span> <span class="fn">msg</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Macro.throwError" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.throwErrorAt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5742-L5744">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.throwErrorAt"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">throwErrorAt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ref</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">msg</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">α</span></span></div></div><p>Throw an error with the given message and location information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.throwErrorAt">Lean.Macro.throwErrorAt</a> <span class="fn">ref</span> <span class="fn">msg</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.withRef">Lean.withRef</a> <span class="fn">ref</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.Macro.throwError">Lean.Macro.throwError</a> <span class="fn">msg</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Macro.throwErrorAt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.withFreshMacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5746-L5752">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.withFreshMacroScope"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">withFreshMacroScope</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">α</span></span></div></div><p>Increments the macro scope counter so that inside the body of <code>x</code> the macro
scope is fresh.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Macro.withFreshMacroScope" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.withIncRecDepth"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5754-L5759">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.withIncRecDepth"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">withIncRecDepth</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ref</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">α</span></span></div></div><p>Run <code>x</code> with an incremented recursion depth counter.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Macro.withIncRecDepth" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.instMonadQuotationMacroM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5761-L5764">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instMonadQuotationMacroM"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instMonadQuotationMacroM</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation">MonadQuotation</a> <a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Macro.addMacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5766-L5768">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.addMacroScope"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">addMacroScope</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href=".././Init/Prelude.html#Lean.Name">Name</a></span></div></div><p>Add a new macro scope to the name <code>n</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.addMacroScope">Lean.Macro.addMacroScope</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation.addMacroScope">Lean.MonadQuotation.addMacroScope</a> <span class="fn">n</span></span></li></ul></details><details id="instances-for-list-Lean.Macro.addMacroScope" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.Methods"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5770-L5785">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.Methods"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">Methods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>The opaque methods that are available to <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code>.</p><ul class="structure_fields" id="Lean.Macro.Methods.mk"><li id="Lean.Macro.Methods.expandMacro?" class="structure_field"><div class="structure_field_info">expandMacro? : <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">(<a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span></span></div><div class="structure_field_doc"><p>Expands macros in the given syntax. A return value of <code><a href=".././Init/Prelude.html#Option.none">none</a></code> means there
was nothing to expand.</p></div></li><li id="Lean.Macro.Methods.getCurrNamespace" class="structure_field"><div class="structure_field_info">getCurrNamespace : <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href=".././Init/Prelude.html#Lean.Name">Name</a></span></div><div class="structure_field_doc"><p>Get the current namespace in the file.</p></div></li><li id="Lean.Macro.Methods.hasDecl" class="structure_field"><div class="structure_field_info">hasDecl : <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Name</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href=".././Init/Prelude.html#Bool">Bool</a></span></span></div><div class="structure_field_doc"><p>Check if a given name refers to a declaration.</p></div></li><li id="Lean.Macro.Methods.resolveNamespace" class="structure_field"><div class="structure_field_info">resolveNamespace : <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Name</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">(<a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span></span></div><div class="structure_field_doc"><p>Resolves the given name to an overload list of namespaces.</p></div></li><li id="Lean.Macro.Methods.resolveGlobalName" class="structure_field"><div class="structure_field_info">resolveGlobalName : <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Name</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">(<a href=".././Init/Prelude.html#List">List</a> (<a href=".././Init/Prelude.html#Lean.Name">Name</a> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#String">String</a></span>))</span></span></span></div><div class="structure_field_doc"><p>Resolves the given name to an overload list of global definitions.
The <code><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#String">String</a></code> in each alternative is the deduced list of projections
(which are ambiguous with name components).</p></div></li></ul><details id="instances-for-list-Lean.Macro.Methods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.instInhabitedMethods.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5785-L5785">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instInhabitedMethods.default"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instInhabitedMethods</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Macro.Methods">Methods</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.Macro.instInhabitedMethods.default">Lean.Macro.instInhabitedMethods.default</a> <a href=".././Init/Prelude.html#Eq">=</a>   <a href=".././Init/Prelude.html#Lean.Macro.Methods.mk">{</a> <span class="fn">expandMacro?</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">getCurrNamespace</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">hasDecl</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">resolveNamespace</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a>,
    <span class="fn">resolveGlobalName</span> := <a href=".././Init/Prelude.html#Inhabited.default">default</a> <a href=".././Init/Prelude.html#Lean.Macro.Methods.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Macro.instInhabitedMethods.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.instInhabitedMethods"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5785-L5785">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instInhabitedMethods"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instInhabitedMethods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.Macro.Methods">Methods</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.Macro.instInhabitedMethods">Lean.Macro.instInhabitedMethods</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././Init/Prelude.html#Lean.Macro.instInhabitedMethods.default">Lean.Macro.instInhabitedMethods.default</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Macro.mkMethodsImp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5787-L5789">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.mkMethodsImp"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">mkMethodsImp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">methods</span> : <a href=".././Init/Prelude.html#Lean.Macro.Methods">Methods</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Macro.MethodsRef">MethodsRef</a></div></div><p>Implementation of <code><a href=".././Init/Prelude.html#Lean.Macro.mkMethods">mkMethods</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.mkMethodsImp">Lean.Macro.mkMethodsImp</a> <span class="fn">methods</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a> <span class="fn">methods</span></span></li></ul></details><details id="instances-for-list-Lean.Macro.mkMethodsImp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.mkMethods"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5791-L5793">source</a></div><div class="attributes">@[implemented_by Lean.Macro.mkMethodsImp]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.mkMethods"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">mkMethods</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">methods</span> : <a href=".././Init/Prelude.html#Lean.Macro.Methods">Methods</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Macro.MethodsRef">MethodsRef</a></div></div><p>Make an opaque reference to a <code><a href=".././Init/Prelude.html#Lean.Macro.Methods">Methods</a></code>.</p></div></div><div class="decl" id="Lean.Macro.instInhabitedMethodsRef"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5795-L5796">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instInhabitedMethodsRef"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">instInhabitedMethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.Macro.MethodsRef">MethodsRef</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.Macro.instInhabitedMethodsRef">Lean.Macro.instInhabitedMethodsRef</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.mkMethods">Lean.Macro.mkMethods</a> <a href=".././Init/Prelude.html#Inhabited.default">default</a></span> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Macro.getMethodsImp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5798-L5800">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.getMethodsImp"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">getMethodsImp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href=".././Init/Prelude.html#Lean.Macro.Methods">Methods</a></span></div></div><p>Implementation of <code><a href=".././Init/Prelude.html#Lean.Macro.getMethods">getMethods</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.Macro.getMethodsImp">Lean.Macro.getMethodsImp</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">ctx</span> ← <a href=".././Init/Prelude.html#MonadReader.read">read</a>
  <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a> <span class="fn"><span class="fn">ctx</span>.<a href=".././Init/Prelude.html#Lean.Macro.Context.methods">methods</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Macro.getMethodsImp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.getMethods"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5802-L5803">source</a></div><div class="attributes">@[implemented_by Lean.Macro.getMethodsImp]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.getMethods"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">getMethods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href=".././Init/Prelude.html#Lean.Macro.Methods">Methods</a></span></div></div><p>Extract the methods list from the <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code> state.</p></div></div><div class="decl" id="Lean.Macro.expandMacro?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5805-L5810">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.expandMacro?"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">expandMacro?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">(<a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span></div></div><p><code><a href=".././Init/Prelude.html#Lean.Macro.Methods.expandMacro?">expandMacro?</a> stx</code> returns <code><a href=".././Init/Prelude.html#Option.some">some</a> stxNew</code> if <code>stx</code> is a macro,
and <code>stxNew</code> is its expansion.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.expandMacro?">Lean.expandMacro?</a> <span class="fn">stx</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href=".././Init/Prelude.html#Lean.Macro.getMethods">Lean.Macro.getMethods</a>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href=".././Init/Prelude.html#Lean.Macro.Methods.expandMacro?">expandMacro?</a></span> <span class="fn">stx</span></span></span></li></ul></details><details id="instances-for-list-Lean.Macro.expandMacro?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.hasDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5812-L5814">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.hasDecl"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">hasDecl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">declName</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code><a href=".././Init/Prelude.html#Bool.true">true</a></code> if the environment contains a declaration with name <code>declName</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.hasDecl">Lean.Macro.hasDecl</a> <span class="fn">declName</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href=".././Init/Prelude.html#Lean.Macro.getMethods">Lean.Macro.getMethods</a>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href=".././Init/Prelude.html#Lean.Macro.Methods.hasDecl">hasDecl</a></span> <span class="fn">declName</span></span></span></li></ul></details><details id="instances-for-list-Lean.Macro.hasDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.getCurrNamespace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5816-L5818">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.getCurrNamespace"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">getCurrNamespace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href=".././Init/Prelude.html#Lean.Name">Name</a></span></div></div><p>Gets the current namespace given the position in the file.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.Macro.getCurrNamespace">Lean.Macro.getCurrNamespace</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href=".././Init/Prelude.html#Lean.Macro.getMethods">Lean.Macro.getMethods</a>
  <span class="fn"><span class="fn">__do_lift</span>.<a href=".././Init/Prelude.html#Lean.Macro.Methods.getCurrNamespace">getCurrNamespace</a></span></span></li></ul></details><details id="instances-for-list-Lean.Macro.getCurrNamespace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.resolveNamespace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5820-L5822">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.resolveNamespace"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">resolveNamespace</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">(<a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span></div></div><p>Resolves the given name to an overload list of namespaces.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.resolveNamespace">Lean.Macro.resolveNamespace</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href=".././Init/Prelude.html#Lean.Macro.getMethods">Lean.Macro.getMethods</a>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href=".././Init/Prelude.html#Lean.Macro.Methods.resolveNamespace">resolveNamespace</a></span> <span class="fn">n</span></span></span></li></ul></details><details id="instances-for-list-Lean.Macro.resolveNamespace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.resolveGlobalName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5824-L5836">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.resolveGlobalName"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">resolveGlobalName</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <span class="fn">(<a href=".././Init/Prelude.html#List">List</a> (<a href=".././Init/Prelude.html#Lean.Name">Name</a> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#String">String</a></span>))</span></span></div></div><p>Resolves the given name to an overload list of global definitions.
The <code><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#String">String</a></code> in each alternative is the deduced list of projections
(which are ambiguous with name components).</p><p>Remark: it will not trigger actions associated with reserved names. Recall that Lean
has reserved names. For example, a definition <code>foo</code> has a reserved name <code>foo.def</code> for theorem
containing stating that <code>foo</code> is equal to its definition. The action associated with <code>foo.def</code>
automatically proves the theorem. At the macro level, the name is resolved, but the action is not
executed. The actions are executed by the elaborator when converting <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> into <code>Expr</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.resolveGlobalName">Lean.Macro.resolveGlobalName</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href=".././Init/Prelude.html#Lean.Macro.getMethods">Lean.Macro.getMethods</a>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href=".././Init/Prelude.html#Lean.Macro.Methods.resolveGlobalName">resolveGlobalName</a></span> <span class="fn">n</span></span></span></li></ul></details><details id="instances-for-list-Lean.Macro.resolveGlobalName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Macro.trace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5838-L5840">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.trace"><span class="name">Lean</span>.<span class="name">Macro</span>.<span class="name">trace</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">clsName</span> : <a href=".././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">msg</span> : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href=".././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Add a new trace message, with the given trace class and message.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Macro.trace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.PrettyPrinter.UnexpandM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5848-L5852">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.PrettyPrinter.UnexpandM"><span class="name">Lean</span>.<span class="name">PrettyPrinter</span>.<span class="name">UnexpandM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>The unexpander monad, essentially <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <a href=".././Init/Prelude.html#Option">Option</a> α</code>. The <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> is the <code><a href=".././Init/Prelude.html#Lean.Macro.Context.ref">ref</a></code>,
and it has the possibility of failure without an error message.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.PrettyPrinter.UnexpandM">Lean.PrettyPrinter.UnexpandM</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> <span class="fn">(<a href=".././Init/Prelude.html#EStateM">EStateM</a> <a href=".././Init/Prelude.html#Unit">Unit</a> <a href=".././Init/Prelude.html#Unit">Unit</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.PrettyPrinter.UnexpandM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.PrettyPrinter.Unexpander"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5854-L5860">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.PrettyPrinter.Unexpander"><span class="name">Lean</span>.<span class="name">PrettyPrinter</span>.<span class="name">Unexpander</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Function that tries to reverse macro expansions as a post-processing step of delaboration.
While less general than an arbitrary delaborator, it can be declared without importing <code>Lean</code>.
Used by the <code>[app_unexpander]</code> attribute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Prelude.html#Lean.PrettyPrinter.Unexpander">Lean.PrettyPrinter.Unexpander</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.PrettyPrinter.UnexpandM">Lean.PrettyPrinter.UnexpandM</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span>)</span></li></ul></details><details id="instances-for-list-Lean.PrettyPrinter.Unexpander" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.PrettyPrinter.instMonadQuotationUnexpandM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Prelude.lean#L5862-L5868">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.PrettyPrinter.instMonadQuotationUnexpandM"><span class="name">Lean</span>.<span class="name">PrettyPrinter</span>.<span class="name">instMonadQuotationUnexpandM</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation">MonadQuotation</a> <a href=".././Init/Prelude.html#Lean.PrettyPrinter.UnexpandM">UnexpandM</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div></main>
<nav class="nav"><iframe src=".././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>