<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Init.Grind.Attr</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Init.Grind.Attr";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Init</span>.<span class="name">Grind</span>.<span class="name">Attr</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init/Tactics.html">Init.Tactics</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Grind.Attr" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Grind.genPattern"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">genPattern</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Grind.genHEqPattern"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">genHEqPattern</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.resetGrindAttrs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">resetGrindAttrs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindGen"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindGen</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindEq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindEqRhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEqRhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindEqBoth"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEqBoth</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindEqBwd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEqBwd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindBwd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindBwd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindFwd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindFwd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindRL"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindRL</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindLR"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindLR</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindDef"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindDef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindUsr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindUsr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindCases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindCases</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindCasesEager"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindCasesEager</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindIntro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindIntro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindExt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindExt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindInj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindInj</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindFunCC"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindFunCC</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindNorm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindNorm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindUnfold"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindUnfold</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindSym"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindSym</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grindMod"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindMod</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grind!"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind!</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grind?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grind!?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind!?</span></a></div></nav><main>
<div class="decl" id="Lean.Grind.genPattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L14-L58">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Grind.genPattern"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">genPattern</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">_h</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">_val</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Gadget for representing generalization steps <code>h : x = val</code> in patterns
This gadget is used to represent patterns in theorems that have been generalized to reduce the
number of casts introduced during E-matching based instantiation.</p><p>For example, consider the theorem</p><pre><code><a href="../.././Init/Data/Option/Lemmas.html#Option.pbind_some">Option.pbind_some</a> {α1 : Type u_1} {a : α1} {α2 : Type u_2}
    {f : (a_1 : α1) → some a = some a_1 → <a href="../.././Init/Prelude.html#Option">Option</a> α2}
    : (some a).pbind f = f a <a href="../.././Init/Prelude.html#rfl">rfl</a>
</code></pre><p>Now, suppose we have a goal containing the term <code>c.pbind g</code> and the equivalence class
<code>{c, some b}</code>. The E-matching module generates the instance</p><pre><code>(some b).pbind (cast ⋯ g)
</code></pre><p>The <code><a href="../.././Init/Prelude.html#cast">cast</a></code> is necessary because <code>g</code>'s type contains <code>c</code> instead of <code>some b. This </code>cast` problematic because we don't have a systematic way of pushing casts over functions
to its arguments. Moreover, heterogeneous equality is not effective because the following theorem
is not provable in DTT:</p><pre><code>theorem hcongr (h₁ : f ≍ g) (h₂ : a ≍ b)  : f a ≍ g b := ...
</code></pre><p>The standard solution is to generalize the theorem above and write it as</p><pre><code>theorem <a href="../.././Init/Data/Option/Lemmas.html#Option.pbind_some'">Option.pbind_some'</a>
        {α1 : Type u_1} {a : α1} {α2 : Type u_2}
        {x : <a href="../.././Init/Prelude.html#Option">Option</a> α1}
        {f : (a_1 : α1) → x = some a_1 → <a href="../.././Init/Prelude.html#Option">Option</a> α2}
        (h : x = some a)
        : x.pbind f = f a h := by
  subst h
  apply <a href="../.././Init/Data/Option/Lemmas.html#Option.pbind_some">Option.pbind_some</a>
</code></pre><p>Internally, we use this gadget to mark the E-matching pattern as</p><pre><code>(genPattern h x (some a)).pbind f
</code></pre><p>This pattern is matched in the same way we match <code>(some a).pbind f</code>, but it saves the proof
for the actual term to the <code>some</code>-application in <code>f</code>, and the actual term in <code>x</code>.</p><p>In the example above, <code>c.pbind g</code> also matches the pattern <code>(genPattern h x (some a)).pbind f</code>,
and stores <code>c</code> in <code>x</code>, <code>b</code> in <code>a</code>, and the proof that <code>c = some b</code> in <code>h</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Init/Grind/Attr.html#Lean.Grind.genPattern">Lean.Grind.genPattern</a> <span class="fn">_h</span> <span class="fn">x</span> <span class="fn">_val</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></li></ul></details><details id="instances-for-list-Lean.Grind.genPattern" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Grind.genHEqPattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L60-L61">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Grind.genHEqPattern"><span class="name">Lean</span>.<span class="name">Grind</span>.<span class="name">genHEqPattern</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">_h</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">_val</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Similar to <code><a href="../.././Init/Grind/Attr.html#Lean.Grind.genPattern">genPattern</a></code> but for the heterogeneous case</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Init/Grind/Attr.html#Lean.Grind.genHEqPattern">Lean.Grind.genHEqPattern</a> <span class="fn">_h</span> <span class="fn">x</span> <span class="fn">_val</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></li></ul></details><details id="instances-for-list-Lean.Grind.genHEqPattern" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.resetGrindAttrs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L65-L68">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.resetGrindAttrs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">resetGrindAttrs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Reset all <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> attributes. This command is intended for testing purposes only and should not be used in applications.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Attr.html#Lean.Parser.resetGrindAttrs">Lean.Parser.resetGrindAttrs</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.resetGrindAttrs</span> <span class="fn">1024</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;reset_grind_attrs%&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.resetGrindAttrs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindGen"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L71-L71">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindGen"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindGen</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L72-L77">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindEq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>=</code> modifier instructs <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> to check that the conclusion of the theorem is an equality,
and then uses the left-hand side of the equality as a pattern. This may fail if not all of the arguments appear
in the left-hand side.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindEqRhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L78-L83">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindEqRhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEqRhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>=_</code> modifier instructs <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> to check that the conclusion of the theorem is an equality,
and then uses the right-hand side of the equality as a pattern. This may fail if not all of the arguments appear
in the right-hand side.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindEqRhs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindEqBoth"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L84-L88">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindEqBoth"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEqBoth</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>_=_</code> modifier acts like a macro which expands to <code>=</code> and <code>=_</code>.  It adds two patterns,
allowing the equality theorem to trigger in either direction.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindEqBoth" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindEqBwd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L89-L96">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindEqBwd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindEqBwd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>←=</code> modifier is unlike the other <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> modifiers, and it used specifically for
backwards reasoning on equality. When a theorem's conclusion is an equality proposition and it
is annotated with <code>@[grind ←=]</code>, grind <code>will</code> instantiate it whenever the corresponding disequality
is assumed—this is a consequence of the fact that grind performs all proofs by contradiction.
Ordinarily, the grind attribute does not consider the <code>=</code> symbol when generating patterns.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindEqBwd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindBwd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L97-L105">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindBwd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindBwd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>←</code> modifier instructs <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> to select a multi-pattern from the conclusion of theorem.
In other words, <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> will use the theorem for backwards reasoning.
This may fail if not all of the arguments to the theorem appear in the conclusion.
Each time it encounters a subexpression which covers an argument which was not
previously covered, it adds that subexpression as a pattern, until all arguments have been covered.
If <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind!">grind!</a></code> is used, then only minimal indexable subexpressions are considered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindBwd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindFwd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L106-L114">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindFwd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindFwd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>→</code> modifier instructs <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> to select a multi-pattern from the hypotheses of the theorem.
In other words, <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> will use the theorem for forwards reasoning.
To generate a pattern, it traverses the hypotheses of the theorem from left to right.
Each time it encounters a subexpression which covers an argument which was not
previously covered, it adds that subexpression as a pattern, until all arguments have been covered.
If <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind!">grind!</a></code> is used, then only minimal indexable subexpressions are considered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindFwd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindRL"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L115-L122">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindRL"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindRL</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>⇐</code> modifier instructs <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> to select a multi-pattern by traversing the conclusion, and then
all the hypotheses from right to left.
Each time it encounters a subexpression which covers an argument which was not
previously covered, it adds that subexpression as a pattern, until all arguments have been covered.
If <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind!">grind!</a></code> is used, then only minimal indexable subexpressions are considered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindRL" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindLR"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L123-L130">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindLR"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindLR</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>⇒</code> modifier instructs <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> to select a multi-pattern by traversing all the hypotheses from
left to right, followed by the conclusion.
Each time it encounters a subexpression which covers an argument which was not
previously covered, it adds that subexpression as a pattern, until all arguments have been covered.
If <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind!">grind!</a></code> is used, then only minimal indexable subexpressions are considered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindLR" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindDef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L131-L138">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindDef"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindDef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>.</code> modifier instructs <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> to select a multi-pattern by traversing the conclusion of the
theorem, and then the hypotheses from left to right. We say this is the default modifier.
Each time it encounters a subexpression which covers an argument which was not
previously covered, it adds that subexpression as a pattern, until all arguments have been covered.
If <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind!">grind!</a></code> is used, then only minimal indexable subexpressions are considered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindDef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindUsr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L139-L149">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindUsr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindUsr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>usr</code> modifier indicates that this theorem was applied using a
<strong>user-defined instantiation pattern</strong>. Such patterns are declared with
the <code>grind_pattern</code> command, which lets you specify how <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> should
match and use particular theorems.</p><p>Example:</p><ul><li><code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a> [usr myThm]</code> means <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> is using <code>myThm</code>, but with
the custom pattern you defined with <code>grind_pattern</code>.</li></ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindUsr">Lean.Parser.Attr.grindUsr</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;grindUsr&quot;</span> <span class="fn">`Lean.Parser.Attr.grindUsr</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;usr&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindUsr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L150-L153">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindCases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindCases</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>cases</code> modifier marks inductively-defined predicates as suitable for case splitting.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindCases">Lean.Parser.Attr.grindCases</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;grindCases&quot;</span> <span class="fn">`Lean.Parser.Attr.grindCases</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;cases&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindCasesEager"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L154-L158">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindCasesEager"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindCasesEager</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>cases eager</code> modifier marks inductively-defined predicates as suitable for case splitting,
and instructs <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> to perform it eagerly while preprocessing hypotheses.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindCasesEager" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindIntro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L159-L175">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindIntro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindIntro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>intro</code> modifier instructs <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> to use the constructors (introduction rules)
of an inductive predicate as E-matching theorems.Example:</p><pre><code>inductive Even : <a href="../.././Init/Prelude.html#Nat">Nat</a> → Prop where
| zero : Even 0
| add2 : Even x → Even (x + 2)

attribute [grind intro] Even
example (h : Even x) : Even (x + 6) := by <a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a>
example : Even 0 := by <a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a>
</code></pre><p>Here <code>attribute [grind intro] Even</code> acts like a macro that expands to
<code>attribute [grind] Even.zero</code> and <code>attribute [grind] Even.add2</code>.
This is especially convenient for inductive predicates with many constructors.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindIntro">Lean.Parser.Attr.grindIntro</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;grindIntro&quot;</span> <span class="fn">`Lean.Parser.Attr.grindIntro</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;intro&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindIntro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindExt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L176-L183">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindExt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindExt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>ext</code> modifier marks extensionality theorems for use by <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code>.
For example, the standard library marks <code><a href="../.././Init/Core.html#funext">funext</a></code> with this attribute.</p><p>Whenever <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> encounters a disequality <code>a ≠ b</code>, it attempts to apply any
available extensionality theorems whose matches the type of <code>a</code> and <code>b</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindExt">Lean.Parser.Attr.grindExt</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;grindExt&quot;</span> <span class="fn">`Lean.Parser.Attr.grindExt</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;ext&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindExt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindInj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L184-L189">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindInj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindInj</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>inj</code> modifier marks injectivity theorems for use by <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code>.
The conclusion of the theorem must be of the form <code><a href="../.././Init/Data/Function.html#Function.Injective">Function.Injective</a> f</code>
where the term <code>f</code> contains at least one constant symbol.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindInj">Lean.Parser.Attr.grindInj</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;grindInj&quot;</span> <span class="fn">`Lean.Parser.Attr.grindInj</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;inj&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindInj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindFunCC"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L190-L199">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindFunCC"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindFunCC</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>funCC</code> modifier marks global functions that support <strong>function-valued congruence closure</strong>.
Given an application <code>f a₁ a₂ … aₙ</code>, when <code>funCC := true</code>,
<code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> generates and tracks equalities for all partial applications:</p><ul><li><code>f a₁</code></li><li><code>f a₁ a₂</code></li><li><code>…</code></li><li><code>f a₁ a₂ … aₙ</code></li></ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindFunCC">Lean.Parser.Attr.grindFunCC</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;grindFunCC&quot;</span> <span class="fn">`Lean.Parser.Attr.grindFunCC</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;funCC&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindFunCC" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindNorm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L200-L239">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindNorm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindNorm</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>norm</code> modifier instructs <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> to use a theorem as a normalization rule. That is,
the theorem is applied during the preprocessing step.
This feature is meant for advanced users who understand how the preprocessor and <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code>'s search
procedure interact with each other.
New users can still benefit from this feature by restricting its use to theorems that completely
eliminate a symbol from the goal. Example:</p><pre><code>theorem max_def : max n m = if n ≤ m then m else n
</code></pre><p>For a negative example, consider:</p><pre><code>opaque f : <a href="../.././Init/Data/Int/Basic.html#Int">Int</a> → <a href="../.././Init/Data/Int/Basic.html#Int">Int</a> → <a href="../.././Init/Data/Int/Basic.html#Int">Int</a> → <a href="../.././Init/Data/Int/Basic.html#Int">Int</a>
theorem fax1 : f x 0 1 = 1 := sorry
theorem fax2 : f 1 x 1 = 1 := sorry
attribute [grind norm] fax1
attribute [grind =] fax2

example (h : c = 1) : f c 0 c = 1 := by
  <a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a> -- fails
</code></pre><p>In this example, <code>fax1</code> is a normalization rule, but it is not applicable to the input goal since
<code>f c 0 c</code> is not an instance of <code>f x 0 1</code>. However, <code>f c 0 c</code> matches the pattern <code>f 1 x 1</code> modulo
the equality <code>c = 1</code>. Thus, <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> instantiates <code>fax2</code> with <code>x := 0</code>, producing the equality
<code>f 1 0 1 = 1</code>, which the normalizer simplifies to <code><a href="../.././Init/Prelude.html#True">True</a></code>. As a result, nothing useful is learned.
In the future, we plan to include linters to automatically detect issues like these.
Example:</p><pre><code>opaque f : <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a>
opaque g : <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a>

@[grind norm] axiom fax : f x = x + 2
@[grind norm ←] axiom fg : f x = g x

example : f x ≥ 2 := by <a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a>
example : f x ≥ g x := by <a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a>
example : f x + g x ≥ 4 := by <a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindNorm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindUnfold"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L240-L248">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindUnfold"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindUnfold</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>unfold</code> modifier instructs <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> to unfold the given definition during the preprocessing step.
Example:</p><pre><code>@[grind unfold] def h (x : Nat) := 2 * x
example : 6 ∣ 3*h x := by <a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindUnfold">Lean.Parser.Attr.grindUnfold</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;grindUnfold&quot;</span> <span class="fn">`Lean.Parser.Attr.grindUnfold</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;unfold&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindUnfold" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindSym"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L249-L271">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindSym"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindSym</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>symbol &lt;prio&gt;</code> sets the priority of a constant for <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code>’s pattern-selection
procedure. <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> prefers patterns that contain higher-priority symbols.
Example:</p><pre><code>opaque p : <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a> → Prop
opaque q : <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a> → Prop
opaque r : <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a> → Prop

attribute [grind symbol low] p
attribute [grind symbol high] q

axiom bar {x y} : p x y → q x x → r x y → r y x
attribute [grind →] bar
</code></pre><p>Here <code>p</code> is low priority, <code>q</code> is high priority, and <code>r</code> is default. <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> first
tries to find a multi-pattern covering <code>x</code> and <code>y</code> using only high-priority
symbols while scanning hypotheses left to right. This fails because <code>q x x</code> does
not cover <code>y</code>. It then allows both high and default symbols and succeeds with
the multi-pattern <code>q x x, r x y</code>. The term <code>p x y</code> is ignored due to <code>p</code>’s low
priority. Symbols with priority <code>0</code> are never used in patterns.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindSym" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grindMod"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L272-L276">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grindMod"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grindMod</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grindMod" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L278-L290">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Marks a theorem or definition for use by the <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> tactic.</p><p>An optional modifier (e.g. <code>=</code>, <code>→</code>, <code>←</code>, <code>cases</code>, <code>intro</code>, <code>ext</code>, <code>inj</code>, etc.)
controls how <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code> uses the declaration:</p><ul><li>whether it is applied forwards, backwards, or both,</li><li>whether equalities are used on the left, right, or both sides,</li><li>whether case-splits, constructors, extensionality, or injectivity are applied,</li><li>or whether custom instantiation patterns are used.</li></ul><p>See the individual modifier docstrings for details.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grind!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L291-L309">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind!"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code>@[grind]</code>, but enforces the <strong>minimal indexable subexpression condition</strong>:
when several subterms cover the same free variables, <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind!">grind!</a></code> chooses the smallest one.</p><p>This influences E-matching pattern selection.</p><h3 id="Example" class="markdown-heading">Example <a class="hover-link" href="#Example">#</a></h3><pre><code class="language-lean">theorem fg_eq (h : x &gt; 0) : f (g x) = x

@[grind &lt;-] theorem fg_eq (h : x &gt; 0) : f (g x) = x
-- Pattern selected: `f (g x)`

-- With minimal subexpression:
@[grind! &lt;-] theorem fg_eq (h : x &gt; 0) : f (g x) = x
-- Pattern selected: `g x`
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grind!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grind?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L310-L314">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code>@[grind]</code>, but also prints the pattern(s) selected by <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code>
as info messages. Useful for debugging annotations and modifiers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grind?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grind!?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L315-L319">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind!?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind!?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code>@[grind!]</code>, but also prints the pattern(s) selected by <code><a href="../.././Init/Grind/Attr.html#Lean.Parser.Attr.grind">grind</a></code>
as info messages. Combines minimal subexpression selection with debugging output.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grind!?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>