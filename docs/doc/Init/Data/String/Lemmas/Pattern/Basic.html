<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../../.././style.css"></link><link rel="icon" href="../../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Init.Data.String.Lemmas.Pattern.Basic</title><script defer="true" src="../../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../../.././";</script><script>const MODULE_NAME="Init.Data.String.Lemmas.Pattern.Basic";</script><script type="module" src="../../../../.././jump-src.js"></script><script type="module" src="../../../../.././search.js"></script><script type="module" src="../../../../.././expand-nav.js"></script><script type="module" src="../../../../.././how-about.js"></script><script type="module" src="../../../../.././instances.js"></script><script type="module" src="../../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Init</span>.<span class="name">Data</span>.<span class="name">String</span>.<span class="name">Lemmas</span>.<span class="name">Pattern</span>.<span class="name">Basic</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../../.././Init/ByCases.html">Init.ByCases</a></li><li><a href="../../../../.././Init/Data/Option/Lemmas.html">Init.Data.Option.Lemmas</a></li><li><a href="../../../../.././Init/Data/Order/Lemmas.html">Init.Data.Order.Lemmas</a></li><li><a href="../../../../.././Init/Data/String/OrderInstances.html">Init.Data.String.OrderInstances</a></li><li><a href="../../../../.././Init/Data/String/Termination.html">Init.Data.String.Termination</a></li><li><a href="../../../../.././Init/Data/Iterators/Consumers/Collect.html">Init.Data.Iterators.Consumers.Collect</a></li><li><a href="../../../../.././Init/Data/String/Lemmas/IsEmpty.html">Init.Data.String.Lemmas.IsEmpty</a></li><li><a href="../../../../.././Init/Data/String/Lemmas/Order.html">Init.Data.String.Lemmas.Order</a></li><li><a href="../../../../.././Init/Data/String/Lemmas/Splits.html">Init.Data.String.Lemmas.Splits</a></li><li><a href="../../../../.././Init/Data/String/Pattern/Basic.html">Init.Data.String.Pattern.Basic</a></li><li><a href="../../../../.././Init/Data/String/Pattern/Basic.html">Init.Data.String.Pattern.Basic</a></li><li><a href="../../../../.././Init/Data/Iterators/Lemmas/Consumers/Collect.html">Init.Data.Iterators.Lemmas.Consumers.Collect</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Data.String.Lemmas.Pattern.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.ForwardPatternModel"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">ForwardPatternModel</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsMatch</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsMatch.ne_startPos"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsMatch</span>.<span class="name">ne_startPos</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.isMatch_iff"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">isMatch_iff</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.isMatch_iff_exists_splits"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">isMatch_iff_exists_splits</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsLongestMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatch</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsLongestMatch.ne_startPos"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatch</span>.<span class="name">ne_startPos</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsLongestMatch.eq"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatch</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsMatch.exists_isLongestMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsMatch</span>.<span class="name">exists_isLongestMatch</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsLongestMatch.le_of_isMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatch</span>.<span class="name">le_of_isMatch</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.NoPrefixForwardPatternModel"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">NoPrefixForwardPatternModel</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.NoPrefixForwardPatternModel.of_length_eq"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">NoPrefixForwardPatternModel</span>.<span class="name">of_length_eq</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.isLongestMatch_iff_isMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">isLongestMatch_iff_isMatch</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsLongestMatchAt"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatchAt</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.isLongestMatchAt_iff"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">isLongestMatchAt_iff</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsLongestMatchAt.lt"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatchAt</span>.<span class="name">lt</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsLongestMatchAt.eq"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatchAt</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsLongestMatch.isLongestMatchAt_ofSliceFrom"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatch</span>.<span class="name">isLongestMatchAt_ofSliceFrom</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.MatchesAt"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">MatchesAt</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.matchesAt_iff_exists_isLongestMatchAt"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">matchesAt_iff_exists_isLongestMatchAt</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.matchesAt_iff_exists_isLongestMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">matchesAt_iff_exists_isLongestMatch</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.matchesAt_iff_exists_isMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">matchesAt_iff_exists_isMatch</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.matchAt?"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">matchAt?</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.matchAt?_eq_some_iff"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">matchAt?_eq_some_iff</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.matchAt?_eq_none_iff"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">matchAt?_eq_none_iff</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.LawfulForwardPatternModel"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">LawfulForwardPatternModel</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.LawfulForwardPatternModel.dropPrefix?_eq_none_iff"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">LawfulForwardPatternModel</span>.<span class="name">dropPrefix?_eq_none_iff</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsValidSearchFrom"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsValidSearchFrom</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsValidSearchFrom.matched_of_eq"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsValidSearchFrom</span>.<span class="name">matched_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsValidSearchFrom.mismatched_of_eq"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsValidSearchFrom</span>.<span class="name">mismatched_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.IsValidSearchFrom.endPos_of_eq"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsValidSearchFrom</span>.<span class="name">endPos_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.LawfulToForwardSearcherModel"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">LawfulToForwardSearcherModel</span></a></div><div class="nav_link"><a class="break_within" href="#String.Slice.Pattern.Model.LawfulToForwardSearcherModel.defaultImplementation"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">LawfulToForwardSearcherModel</span>.<span class="name">defaultImplementation</span></a></div></nav><main>
<div class="decl" id="String.Slice.Pattern.Model.ForwardPatternModel"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L37-L64">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">ForwardPatternModel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <span class="fn">ρ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../../.././foundational_types.html">Type</a></div></div><p>This data-carrying typeclass is used to give semantics to a pattern type that implements
<code>ForwardPattern</code> and/or <code>ToForwardSearcher</code> by providing an abstract, not necessarily
decidable <code><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel.Matches">ForwardPatternModel.Matches</a></code> predicate that implementates of <code>ForwardPattern</code>
and <code>ToForwardSearcher</code> can be validated against.</p><p>Correctness results for generic functions relying on the pattern infrastructure, for example the
correctness result for <code><a href="../../../../.././Init/Data/String/Slice.html#String.Slice.split">String.Slice.split</a></code>, are then
stated in terms of <code><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel.Matches">ForwardPatternModel.Matches</a></code>, and can be specialized to specific patterns
from there.</p><p>The corresponding compatibility typeclasses are
<code><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.LawfulForwardPatternModel">String.Slice.Pattern.Model.LawfulForwardPatternModel</a></code>
and
<code><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.LawfulToForwardSearcherModel">String.Slice.Pattern.Model.LawfulToForwardSearcherModel</a></code>.</p><p>We include the condition that the empty string is not a match. This is necessary for the theory to
work out as there is just no reasonable notion of searching that works for the empty string that is
still specific enough to yield reasonably strong correctness results for operations based on
searching.</p><p>This means that pattern types that allow searching for the empty string will have to special-case
the empty string in their correctness statements.</p><ul class="structure_fields" id="String.Slice.Pattern.Model.ForwardPatternModel.mk"><li id="String.Slice.Pattern.Model.ForwardPatternModel.Matches" class="structure_field"><div class="structure_field_info">Matches : <span class="fn"><a href="../../../../.././Init/Prelude.html#String">String</a> → <a href="../../../../.././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p>The predicate that says which strings match the pattern.</p></div></li><li id="String.Slice.Pattern.Model.ForwardPatternModel.not_matches_empty" class="structure_field"><div class="structure_field_info">not_matches_empty : <a href="../../../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel.Matches">Matches</a> <span class="fn">pat</span> <span class="fn">&quot;&quot;</span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-String.Slice.Pattern.Model.ForwardPatternModel" class="instances-list"></ul></details></div></div><div class="decl" id="String.Slice.Pattern.Model.IsMatch"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L66-L72">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsMatch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <span class="fn">ρ</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">endPos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../../.././foundational_types.html">Prop</a></div></div><p>Predicate stating that the region between the start of the slice <code>s</code> and the position
<code><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom.endPos">endPos</a></code> matches the pattern <code>pat</code>. Note that there might be a longer match, see
<code>String.Slice.Pattern.<a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch">IsLongestMatch</a></code>.</p><ul class="structure_fields" id="String.Slice.Pattern.Model.IsMatch.mk"><li id="String.Slice.Pattern.Model.IsMatch.matches_copy" class="structure_field"><div class="structure_field_info">matches_copy : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel.Matches">ForwardPatternModel.Matches</a> <span class="fn">pat</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Basic.html#String.Slice.sliceTo">sliceTo</a></span> <span class="fn">endPos</span>)</span>.<a href="../../../../.././Init/Data/String/Basic.html#String.Slice.copy">copy</a></span></span></div></li></ul><details id="instances-for-list-String.Slice.Pattern.Model.IsMatch" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String.Slice.Pattern.Model.IsMatch.ne_startPos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L74-L78">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsMatch.ne_startPos"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsMatch</span>.<span class="name">ne_startPos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsMatch">IsMatch</a> <span class="fn">pat</span> <span class="fn">pos</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">pos</span> <a href="../../../../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.startPos">startPos</a></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.isMatch_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L80-L82">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.isMatch_iff"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">isMatch_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsMatch">IsMatch</a> <span class="fn">pat</span> <span class="fn">pos</span></span> <a href="../../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel.Matches">ForwardPatternModel.Matches</a> <span class="fn">pat</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Basic.html#String.Slice.sliceTo">sliceTo</a></span> <span class="fn">pos</span>)</span>.<a href="../../../../.././Init/Data/String/Basic.html#String.Slice.copy">copy</a></span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.isMatch_iff_exists_splits"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L84-L88">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.isMatch_iff_exists_splits"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">isMatch_iff_exists_splits</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsMatch">IsMatch</a> <span class="fn">pat</span> <span class="fn">pos</span></span> <a href="../../../../.././Init/Core.html#Iff">↔</a> <a href="../../../../.././Init/Core.html#Exists">∃</a> <a href="../../../../.././Init/Core.html#Exists">(</a><span class="fn">t₁</span> <a href="../../../../.././Init/Core.html#Exists">:</a> <a href="../../../../.././Init/Prelude.html#String">String</a><a href="../../../../.././Init/Core.html#Exists">)</a><a href="../../../../.././Init/Core.html#Exists">,</a> <a href="../../../../.././Init/Core.html#Exists">∃</a> <a href="../../../../.././Init/Core.html#Exists">(</a><span class="fn">t₂</span> <a href="../../../../.././Init/Core.html#Exists">:</a> <a href="../../../../.././Init/Prelude.html#String">String</a><a href="../../../../.././Init/Core.html#Exists">)</a><a href="../../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn"><span class="fn">pos</span>.<a href="../../../../.././Init/Data/String/Lemmas/Splits.html#String.Slice.Pos.Splits">Splits</a></span> <span class="fn">t₁</span> <span class="fn">t₂</span></span> <a href="../../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel.Matches">ForwardPatternModel.Matches</a> <span class="fn">pat</span> <span class="fn">t₁</span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.IsLongestMatch"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L90-L100">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <span class="fn">ρ</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../../.././foundational_types.html">Prop</a></div></div><p>Predicate stating that the region between the start of the slice <code>s</code> and the position
<code><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom.endPos">endPos</a></code> matches that pattern <code>pat</code>, and that there is no longer match starting at the
beginning of the slice. This is what a correct matcher should match.</p><p>In some cases, being a match and being a longest match will coincide, see
<code><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.NoPrefixForwardPatternModel">String.Slice.Pattern.Model.NoPrefixForwardPatternModel</a></code>.</p><ul class="structure_fields" id="String.Slice.Pattern.Model.IsLongestMatch.mk"><li id="String.Slice.Pattern.Model.IsLongestMatch.isMatch" class="structure_field"><div class="structure_field_info">isMatch : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsMatch">IsMatch</a> <span class="fn">pat</span> <span class="fn">pos</span></span></div></li><li id="String.Slice.Pattern.Model.IsLongestMatch.not_isMatch" class="structure_field"><div class="structure_field_info">not_isMatch<span class="decl_args">
<span class="fn">(<span class="fn">pos'</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>)</span></span>
 : <span class="fn"><span class="fn">pos</span> <a href="../../../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">pos'</span> → <a href="../../../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsMatch">IsMatch</a> <span class="fn">pat</span> <span class="fn">pos'</span></span></span></div></li></ul><details id="instances-for-list-String.Slice.Pattern.Model.IsLongestMatch" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String.Slice.Pattern.Model.IsLongestMatch.ne_startPos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L102-L104">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch.ne_startPos"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatch</span>.<span class="name">ne_startPos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch">IsLongestMatch</a> <span class="fn">pat</span> <span class="fn">pos</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">pos</span> <a href="../../../../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.startPos">startPos</a></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.IsLongestMatch.eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L106-L110">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch.eq"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatch</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos </span><span class="fn">pos'</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch">IsLongestMatch</a> <span class="fn">pat</span> <span class="fn">pos</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch">IsLongestMatch</a> <span class="fn">pat</span> <span class="fn">pos'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">pos</span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">pos'</span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.IsMatch.exists_isLongestMatch"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L113-L120">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsMatch.exists_isLongestMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsMatch</span>.<span class="name">exists_isLongestMatch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsMatch">IsMatch</a> <span class="fn">pat</span> <span class="fn">pos</span></span> → <a href="../../../../.././Init/Core.html#Exists">∃</a> <a href="../../../../.././Init/Core.html#Exists">(</a><span class="fn">pos'</span> <a href="../../../../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span><a href="../../../../.././Init/Core.html#Exists">)</a><a href="../../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch">IsLongestMatch</a> <span class="fn">pat</span> <span class="fn">pos'</span></span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.IsLongestMatch.le_of_isMatch"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L122-L124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch.le_of_isMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatch</span>.<span class="name">le_of_isMatch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos </span><span class="fn">pos'</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch">IsLongestMatch</a> <span class="fn">pat</span> <span class="fn">pos</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsMatch">IsMatch</a> <span class="fn">pat</span> <span class="fn">pos'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">pos'</span> <a href="../../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">pos</span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.NoPrefixForwardPatternModel"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L126-L132">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.NoPrefixForwardPatternModel"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">NoPrefixForwardPatternModel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <span class="fn">ρ</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../.././foundational_types.html">Prop</a></div></div><p>Predicate stating that a match for a given pattern is never a proper prefix of another match.</p><p>This implies that the notion of match and longest match coincide.</p><ul class="structure_fields" id="String.Slice.Pattern.Model.NoPrefixForwardPatternModel.mk"><li id="String.Slice.Pattern.Model.NoPrefixForwardPatternModel.eq_empty" class="structure_field"><div class="structure_field_info">eq_empty<span class="decl_args">
<span class="fn">(<span class="fn">s </span><span class="fn">t</span> : <a href="../../../../.././Init/Prelude.html#String">String</a>)</span></span>
 : <span class="fn"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel.Matches">ForwardPatternModel.Matches</a> <span class="fn">pat</span> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel.Matches">ForwardPatternModel.Matches</a> <span class="fn">pat</span> (<span class="fn">s</span> <a href="../../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">t</span>)</span> → <span class="fn">t</span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">&quot;&quot;</span></span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-String.Slice.Pattern.Model.NoPrefixForwardPatternModel" class="instances-list"></ul></details></div></div><div class="decl" id="String.Slice.Pattern.Model.NoPrefixForwardPatternModel.of_length_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L134-L137">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.NoPrefixForwardPatternModel.of_length_eq"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">NoPrefixForwardPatternModel</span>.<span class="name">of_length_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">s </span><span class="fn">t</span> : <a href="../../../../.././Init/Prelude.html#String">String</a>), <span class="fn"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel.Matches">ForwardPatternModel.Matches</a> <span class="fn">pat</span> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel.Matches">ForwardPatternModel.Matches</a> <span class="fn">pat</span> <span class="fn">t</span></span> → <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Basic.html#String.length">length</a></span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t</span>.<a href="../../../../.././Init/Data/String/Basic.html#String.length">length</a></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.NoPrefixForwardPatternModel">NoPrefixForwardPatternModel</a> <span class="fn">pat</span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.isLongestMatch_iff_isMatch"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L139-L145">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.isLongestMatch_iff_isMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">isLongestMatch_iff_isMatch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <span class="fn">ρ</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.NoPrefixForwardPatternModel">NoPrefixForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch">IsLongestMatch</a> <span class="fn">pat</span> <span class="fn">pos</span></span> <a href="../../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsMatch">IsMatch</a> <span class="fn">pat</span> <span class="fn">pos</span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.IsLongestMatchAt"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L147-L153">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatchAt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <span class="fn">ρ</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">startPos </span><span class="fn">endPos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../../.././foundational_types.html">Prop</a></div></div><p>Predicate stating that the slice formed by <code>startPos</code> and <code><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom.endPos">endPos</a></code> contains is a match
of <code>pat</code> in <code>s</code> and it is longest among matches starting at <code>startPos</code>.</p><ul class="structure_fields" id="String.Slice.Pattern.Model.IsLongestMatchAt.mk"><li id="String.Slice.Pattern.Model.IsLongestMatchAt.le" class="structure_field"><div class="structure_field_info">le : <span class="fn">startPos</span> <a href="../../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">endPos</span></div></li><li id="String.Slice.Pattern.Model.IsLongestMatchAt.isLongestMatch_sliceFrom" class="structure_field"><div class="structure_field_info">isLongestMatch_sliceFrom : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch">IsLongestMatch</a> <span class="fn">pat</span> <span class="fn">(<span class="fn"><span class="fn">startPos</span>.<a href="../../../../.././Init/Data/String/Basic.html#String.Slice.Pos.sliceFrom">sliceFrom</a></span> <span class="fn">endPos</span> <span class="fn">⋯</span>)</span></span></div></li></ul><details id="instances-for-list-String.Slice.Pattern.Model.IsLongestMatchAt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String.Slice.Pattern.Model.isLongestMatchAt_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L155-L158">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.isLongestMatchAt_iff"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">isLongestMatchAt_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos₁ </span><span class="fn">pos₂</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt">IsLongestMatchAt</a> <span class="fn">pat</span> <span class="fn">pos₁</span> <span class="fn">pos₂</span></span> <a href="../../../../.././Init/Core.html#Iff">↔</a> <a href="../../../../.././Init/Core.html#Exists">∃</a> <a href="../../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../../.././Init/Core.html#Exists">:</a> <span class="fn">pos₁</span> <a href="../../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">pos₂</span><a href="../../../../.././Init/Core.html#Exists">)</a><a href="../../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch">IsLongestMatch</a> <span class="fn">pat</span> <span class="fn">(<span class="fn"><span class="fn">pos₁</span>.<a href="../../../../.././Init/Data/String/Basic.html#String.Slice.Pos.sliceFrom">sliceFrom</a></span> <span class="fn">pos₂</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.IsLongestMatchAt.lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L160-L164">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt.lt"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatchAt</span>.<span class="name">lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">startPos </span><span class="fn">endPos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt">IsLongestMatchAt</a> <span class="fn">pat</span> <span class="fn">startPos</span> <span class="fn">endPos</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">startPos</span> <a href="../../../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">endPos</span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.IsLongestMatchAt.eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L166-L169">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt.eq"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatchAt</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">startPos </span><span class="fn">endPos </span><span class="fn">endPos'</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt">IsLongestMatchAt</a> <span class="fn">pat</span> <span class="fn">startPos</span> <span class="fn">endPos</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt">IsLongestMatchAt</a> <span class="fn">pat</span> <span class="fn">startPos</span> <span class="fn">endPos'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">endPos</span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">endPos'</span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.IsLongestMatch.isLongestMatchAt_ofSliceFrom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L171-L175">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch.isLongestMatchAt_ofSliceFrom"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsLongestMatch</span>.<span class="name">isLongestMatchAt_ofSliceFrom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p₀</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos</span> : <span class="fn"><span class="fn">(<span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Basic.html#String.Slice.sliceFrom">sliceFrom</a></span> <span class="fn">p₀</span>)</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch">IsLongestMatch</a> <span class="fn">pat</span> <span class="fn">pos</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt">IsLongestMatchAt</a> <span class="fn">pat</span> <span class="fn">p₀</span> <span class="fn">(<a href="../../../../.././Init/Data/String/Basic.html#String.Slice.Pos.ofSliceFrom">Pos.ofSliceFrom</a> <span class="fn">pos</span>)</span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.MatchesAt"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L177-L181">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.MatchesAt"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">MatchesAt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <span class="fn">ρ</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../../.././foundational_types.html">Prop</a></div></div><p>Predicate stating that there is a (longest) match starting at the given position.</p><ul class="structure_fields" id="String.Slice.Pattern.Model.MatchesAt.mk"><li id="String.Slice.Pattern.Model.MatchesAt.exists_isLongestMatchAt" class="structure_field"><div class="structure_field_info">exists_isLongestMatchAt : <a href="../../../../.././Init/Core.html#Exists">∃</a> <a href="../../../../.././Init/Core.html#Exists">(</a><span class="fn">endPos</span> <a href="../../../../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span><a href="../../../../.././Init/Core.html#Exists">)</a><a href="../../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt">IsLongestMatchAt</a> <span class="fn">pat</span> <span class="fn">pos</span> <span class="fn">endPos</span></span></div></li></ul><details id="instances-for-list-String.Slice.Pattern.Model.MatchesAt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String.Slice.Pattern.Model.matchesAt_iff_exists_isLongestMatchAt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L183-L185">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.matchesAt_iff_exists_isLongestMatchAt"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">matchesAt_iff_exists_isLongestMatchAt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.MatchesAt">MatchesAt</a> <span class="fn">pat</span> <span class="fn">pos</span></span> <a href="../../../../.././Init/Core.html#Iff">↔</a> <a href="../../../../.././Init/Core.html#Exists">∃</a> <a href="../../../../.././Init/Core.html#Exists">(</a><span class="fn">endPos</span> <a href="../../../../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span><a href="../../../../.././Init/Core.html#Exists">)</a><a href="../../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt">IsLongestMatchAt</a> <span class="fn">pat</span> <span class="fn">pos</span> <span class="fn">endPos</span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.matchesAt_iff_exists_isLongestMatch"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L187-L190">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.matchesAt_iff_exists_isLongestMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">matchesAt_iff_exists_isLongestMatch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.MatchesAt">MatchesAt</a> <span class="fn">pat</span> <span class="fn">pos</span></span> <a href="../../../../.././Init/Core.html#Iff">↔</a> <a href="../../../../.././Init/Core.html#Exists">∃</a> <a href="../../../../.././Init/Core.html#Exists">(</a><span class="fn">endPos</span> <a href="../../../../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span><a href="../../../../.././Init/Core.html#Exists">)</a><a href="../../../../.././Init/Core.html#Exists">,</a> <a href="../../../../.././Init/Core.html#Exists">∃</a> <a href="../../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../../.././Init/Core.html#Exists">:</a> <span class="fn">pos</span> <a href="../../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">endPos</span><a href="../../../../.././Init/Core.html#Exists">)</a><a href="../../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch">IsLongestMatch</a> <span class="fn">pat</span> <span class="fn">(<span class="fn"><span class="fn">pos</span>.<a href="../../../../.././Init/Data/String/Basic.html#String.Slice.Pos.sliceFrom">sliceFrom</a></span> <span class="fn">endPos</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.matchesAt_iff_exists_isMatch"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L192-L199">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.matchesAt_iff_exists_isMatch"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">matchesAt_iff_exists_isMatch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.MatchesAt">MatchesAt</a> <span class="fn">pat</span> <span class="fn">pos</span></span> <a href="../../../../.././Init/Core.html#Iff">↔</a> <a href="../../../../.././Init/Core.html#Exists">∃</a> <a href="../../../../.././Init/Core.html#Exists">(</a><span class="fn">endPos</span> <a href="../../../../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span><a href="../../../../.././Init/Core.html#Exists">)</a><a href="../../../../.././Init/Core.html#Exists">,</a> <a href="../../../../.././Init/Core.html#Exists">∃</a> <a href="../../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../../.././Init/Core.html#Exists">:</a> <span class="fn">pos</span> <a href="../../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">endPos</span><a href="../../../../.././Init/Core.html#Exists">)</a><a href="../../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsMatch">IsMatch</a> <span class="fn">pat</span> <span class="fn">(<span class="fn"><span class="fn">pos</span>.<a href="../../../../.././Init/Data/String/Basic.html#String.Slice.Pos.sliceFrom">sliceFrom</a></span> <span class="fn">endPos</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.matchAt?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L202-L208">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.matchAt?"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">matchAt?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <span class="fn">ρ</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">startPos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Prelude.html#Option">Option</a> <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span></span></div></div><p>Noncomputable model function returning the end point of the longest match starting at the given
position, or <code>none</code> if there is no match.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.matchAt?">String.Slice.Pattern.Model.matchAt?</a> <span class="fn">pat</span> <span class="fn">startPos</span></span> <a href="../../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <a href="../../../../.././Init/Core.html#Exists">∃</a> <a href="../../../../.././Init/Core.html#Exists">(</a><span class="fn">endPos</span> <a href="../../../../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span><a href="../../../../.././Init/Core.html#Exists">)</a><a href="../../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt">String.Slice.Pattern.Model.IsLongestMatchAt</a> <span class="fn">pat</span> <span class="fn">startPos</span> <span class="fn">endPos</span></span> then <span class="fn"><a href="../../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">h</span>.<a href="../../../../.././Init/Classical.html#Exists.choose">choose</a></span></span>
  else <a href="../../../../.././Init/Prelude.html#Option.none">none</a></span></li></ul></details><details id="instances-for-list-String.Slice.Pattern.Model.matchAt?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String.Slice.Pattern.Model.matchAt?_eq_some_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L210-L216">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.matchAt?_eq_some_iff"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">matchAt?_eq_some_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">startPos </span><span class="fn">endPos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.matchAt?">matchAt?</a> <span class="fn">pat</span> <span class="fn">startPos</span></span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">endPos</span></span> <a href="../../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt">IsLongestMatchAt</a> <span class="fn">pat</span> <span class="fn">startPos</span> <span class="fn">endPos</span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.matchAt?_eq_none_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L218-L224">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.matchAt?_eq_none_iff"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">matchAt?_eq_none_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">startPos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.matchAt?">matchAt?</a> <span class="fn">pat</span> <span class="fn">startPos</span></span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../../.././Init/Core.html#Iff">↔</a> <a href="../../../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.MatchesAt">MatchesAt</a> <span class="fn">pat</span> <span class="fn">startPos</span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.LawfulForwardPatternModel"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L226-L235">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.LawfulForwardPatternModel"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">LawfulForwardPatternModel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <span class="fn">ρ</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.ForwardPattern">ForwardPattern</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="decl_extends">extends</span> <span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.LawfulForwardPattern">String.Slice.Pattern.LawfulForwardPattern</a> <span class="fn">pat</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../.././foundational_types.html">Prop</a></div></div><p>Predicate stating compatibility between <code><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a></code> and <code>ForwardPattern</code>.</p><p>This extends <code>LawfulForwardPattern</code>, but it is much stronger because it forces the
<code>ForwardPattern</code> to match the longest prefix of the given slice that matches the property
supplied by the <code><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a></code> instance.</p><ul class="structure_fields" id="String.Slice.Pattern.Model.LawfulForwardPatternModel.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.LawfulForwardPattern.dropPrefixOfNonempty?_eq">dropPrefixOfNonempty?_eq</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.isEmpty">isEmpty</a></span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
 : <span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.ForwardPattern.dropPrefixOfNonempty?">ForwardPattern.dropPrefixOfNonempty?</a> <span class="fn">pat</span> <span class="fn">s</span> <span class="fn">h</span></span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.ForwardPattern.dropPrefix?">ForwardPattern.dropPrefix?</a> <span class="fn">pat</span> <span class="fn">s</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.LawfulForwardPattern.startsWith_eq">startsWith_eq</a><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>)</span></span>
 : <span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.ForwardPattern.startsWith">ForwardPattern.startsWith</a> <span class="fn">pat</span> <span class="fn">s</span></span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.ForwardPattern.dropPrefix?">ForwardPattern.dropPrefix?</a> <span class="fn">pat</span> <span class="fn">s</span>)</span>.<a href="../../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></li><li id="String.Slice.Pattern.Model.LawfulForwardPatternModel.dropPrefix?_eq_some_iff" class="structure_field"><div class="structure_field_info">dropPrefix?_eq_some_iff<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>)</span></span>
 : <span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.ForwardPattern.dropPrefix?">ForwardPattern.dropPrefix?</a> <span class="fn">pat</span> <span class="fn">s</span></span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">pos</span></span> <a href="../../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatch">IsLongestMatch</a> <span class="fn">pat</span> <span class="fn">pos</span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-String.Slice.Pattern.Model.LawfulForwardPatternModel" class="instances-list"></ul></details></div></div><div class="decl" id="String.Slice.Pattern.Model.LawfulForwardPatternModel.dropPrefix?_eq_none_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L238-L245">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.LawfulForwardPatternModel.dropPrefix?_eq_none_iff"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">LawfulForwardPatternModel</span>.<span class="name">dropPrefix?_eq_none_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.ForwardPattern">ForwardPattern</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.LawfulForwardPatternModel">LawfulForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p₀</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.ForwardPattern.dropPrefix?">ForwardPattern.dropPrefix?</a> <span class="fn">pat</span> <span class="fn">(<span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Basic.html#String.Slice.sliceFrom">sliceFrom</a></span> <span class="fn">p₀</span>)</span></span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../../.././Init/Core.html#Iff">↔</a> <a href="../../../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.MatchesAt">MatchesAt</a> <span class="fn">pat</span> <span class="fn">p₀</span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.IsValidSearchFrom"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L247-L264">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsValidSearchFrom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <span class="fn">ρ</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span> → <span class="fn"><span class="fn"><a href="../../../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.SearchStep">SearchStep</a> <span class="fn">s</span>)</span></span> → <a href="../../../../.././foundational_types.html">Prop</a></span></span></div></div><p>Inductive predicate stating that a list of search steps represents a valid search from a given
position in a slice.</p><p>&quot;Searching&quot; here means always taking the longest match at the first position where the pattern
matches.</p><p>Hence, this predicate determines the list of search steps up to grouping of rejections.</p><ul class="constructors"><li class="constructor" id="String.Slice.Pattern.Model.IsValidSearchFrom.endPos">endPos<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom">IsValidSearchFrom</a> <span class="fn">pat</span> <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.endPos">endPos</a></span> <a href="../../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../../.././Init/Prelude.html#List.nil">]</a></span></li><li class="constructor" id="String.Slice.Pattern.Model.IsValidSearchFrom.matched">matched<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.SearchStep">SearchStep</a> <span class="fn">s</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">startPos </span><span class="fn">endPos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt">IsLongestMatchAt</a> <span class="fn">pat</span> <span class="fn">startPos</span> <span class="fn">endPos</span></span> →
  <span class="fn"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom">IsValidSearchFrom</a> <span class="fn">pat</span> <span class="fn">endPos</span> <span class="fn">l</span></span> → <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom">IsValidSearchFrom</a> <span class="fn">pat</span> <span class="fn">startPos</span> (<span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.SearchStep.matched">SearchStep.matched</a> <span class="fn">startPos</span> <span class="fn">endPos</span></span> <a href="../../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span></span></span></li><li class="constructor" id="String.Slice.Pattern.Model.IsValidSearchFrom.mismatched">mismatched<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.SearchStep">SearchStep</a> <span class="fn">s</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">startPos </span><span class="fn">endPos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span> : <span class="fn"><span class="fn">startPos</span> <a href="../../../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">endPos</span> →
  <span class="fn"><span class="fn">(∀ (<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>), <span class="fn"><span class="fn">startPos</span> <a href="../../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">pos</span> → <span class="fn"><span class="fn">pos</span> <a href="../../../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">endPos</span> → <a href="../../../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.MatchesAt">MatchesAt</a> <span class="fn">pat</span> <span class="fn">pos</span></span></span></span>)</span> →
    <span class="fn"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom">IsValidSearchFrom</a> <span class="fn">pat</span> <span class="fn">endPos</span> <span class="fn">l</span></span> → <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom">IsValidSearchFrom</a> <span class="fn">pat</span> <span class="fn">startPos</span> (<span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.SearchStep.rejected">SearchStep.rejected</a> <span class="fn">startPos</span> <span class="fn">endPos</span></span> <a href="../../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span></span></span></span></li></ul><details id="instances-for-list-String.Slice.Pattern.Model.IsValidSearchFrom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="String.Slice.Pattern.Model.IsValidSearchFrom.matched_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L266-L271">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom.matched_of_eq"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsValidSearchFrom</span>.<span class="name">matched_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">startPos </span><span class="fn">startPos' </span><span class="fn">endPos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.SearchStep">SearchStep</a> <span class="fn">s</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom">IsValidSearchFrom</a> <span class="fn">pat</span> <span class="fn">endPos</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsLongestMatchAt">IsLongestMatchAt</a> <span class="fn">pat</span> <span class="fn">startPos'</span> <span class="fn">endPos</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₃</span> : <span class="fn">startPos</span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">startPos'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom">IsValidSearchFrom</a> <span class="fn">pat</span> <span class="fn">startPos'</span> (<span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.SearchStep.matched">SearchStep.matched</a> <span class="fn">startPos</span> <span class="fn">endPos</span></span> <a href="../../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.IsValidSearchFrom.mismatched_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L273-L279">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom.mismatched_of_eq"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsValidSearchFrom</span>.<span class="name">mismatched_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">startPos </span><span class="fn">startPos' </span><span class="fn">endPos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.SearchStep">SearchStep</a> <span class="fn">s</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom">IsValidSearchFrom</a> <span class="fn">pat</span> <span class="fn">endPos</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₀</span> : <span class="fn">startPos'</span> <a href="../../../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">endPos</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">∀ (<span class="fn">pos</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>), <span class="fn"><span class="fn">startPos'</span> <a href="../../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">pos</span> → <span class="fn"><span class="fn">pos</span> <a href="../../../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">endPos</span> → <a href="../../../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.MatchesAt">MatchesAt</a> <span class="fn">pat</span> <span class="fn">pos</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₃</span> : <span class="fn">startPos</span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">startPos'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom">IsValidSearchFrom</a> <span class="fn">pat</span> <span class="fn">startPos'</span> (<span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.SearchStep.rejected">SearchStep.rejected</a> <span class="fn">startPos</span> <span class="fn">endPos</span></span> <a href="../../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.IsValidSearchFrom.endPos_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L281-L286">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom.endPos_of_eq"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">IsValidSearchFrom</span>.<span class="name">endPos_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.Pos">Pos</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.SearchStep">SearchStep</a> <span class="fn">s</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn">p</span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.endPos">endPos</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn">l</span> <a href="../../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../../.././Init/Prelude.html#List.nil">]</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom">IsValidSearchFrom</a> <span class="fn">pat</span> <span class="fn">p</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="String.Slice.Pattern.Model.LawfulToForwardSearcherModel"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L288-L297">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.LawfulToForwardSearcherModel"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">LawfulToForwardSearcherModel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <span class="fn">ρ</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <span class="fn"><a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a> → <a href="../../../../.././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.ToForwardSearcher">ToForwardSearcher</a> <span class="fn">pat</span> <span class="fn">σ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>) → <span class="fn"><a href="../../../../.././Init/Data/Iterators/Basic.html#Std.Iterator">Std.Iterator</a> <span class="fn">(<span class="fn">σ</span> <span class="fn">s</span>)</span> <a href="../../../../.././Init/Control/Id.html#Id">Id</a> <span class="fn">(<a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.SearchStep">SearchStep</a> <span class="fn">s</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>), <span class="fn"><a href="../../../../.././Init/Data/Iterators/Basic.html#Std.Iterators.Finite">Std.Iterators.Finite</a> <span class="fn">(<span class="fn">σ</span> <span class="fn">s</span>)</span> <a href="../../../../.././Init/Control/Id.html#Id">Id</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../../.././foundational_types.html">Prop</a></div></div><p>Predicate stating compatibility between <code><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a></code> and <code>ToForwardSearcher</code>.</p><p>We require the searcher to always match the longest match at the first position where the pattern
matches; see <code><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom">IsValidSearchFrom</a></code>.</p><ul class="structure_fields" id="String.Slice.Pattern.Model.LawfulToForwardSearcherModel.mk"><li id="String.Slice.Pattern.Model.LawfulToForwardSearcherModel.isValidSearchFrom_toList" class="structure_field"><div class="structure_field_info">isValidSearchFrom_toList<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href="../../../../.././Init/Data/String/Defs.html#String.Slice">Slice</a>)</span></span>
 : <span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.IsValidSearchFrom">IsValidSearchFrom</a> <span class="fn">pat</span> <span class="fn"><span class="fn">s</span>.<a href="../../../../.././Init/Data/String/Defs.html#String.Slice.startPos">startPos</a></span> <span class="fn"><span class="fn">(<a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.ToForwardSearcher.toSearcher">ToForwardSearcher.toSearcher</a> <span class="fn">pat</span> <span class="fn">s</span>)</span>.<a href="../../../../.././Init/Data/Iterators/Consumers/Collect.html#Std.Iter.toList">toList</a></span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-String.Slice.Pattern.Model.LawfulToForwardSearcherModel" class="instances-list"></ul></details></div></div><div class="decl" id="String.Slice.Pattern.Model.LawfulToForwardSearcherModel.defaultImplementation"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/String/Lemmas/Pattern/Basic.lean#L300-L339">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.LawfulToForwardSearcherModel.defaultImplementation"><span class="name">String</span>.<span class="name">Slice</span>.<span class="name">Pattern</span>.<span class="name">Model</span>.<span class="name">LawfulToForwardSearcherModel</span>.<span class="name">defaultImplementation</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ρ</span> : <a href="../../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">pat</span> : <span class="fn">ρ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.ForwardPattern">ForwardPattern</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Pattern/Basic.html#String.Slice.Pattern.StrictForwardPattern">StrictForwardPattern</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.ForwardPatternModel">ForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.LawfulForwardPatternModel">LawfulForwardPatternModel</a> <span class="fn">pat</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../../.././Init/Data/String/Lemmas/Pattern/Basic.html#String.Slice.Pattern.Model.LawfulToForwardSearcherModel">LawfulToForwardSearcherModel</a> <span class="fn">pat</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>