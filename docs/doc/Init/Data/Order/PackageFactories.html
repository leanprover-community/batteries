<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Init.Data.Order.PackageFactories</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Init.Data.Order.PackageFactories";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Init</span>.<span class="name">Data</span>.<span class="name">Order</span>.<span class="name">PackageFactories</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init/Data/Order/LemmasExtra.html">Init.Data.Order.LemmasExtra</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Data.Order.PackageFactories" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Std.PreorderPackage"><span class="name">Std</span>.<span class="name">PreorderPackage</span></a></div><div class="nav_link"><a class="break_within" href="#Std.instDecidableLE"><span class="name">Std</span>.<span class="name">instDecidableLE</span></a></div><div class="nav_link"><a class="break_within" href="#Std.instDecidableLT"><span class="name">Std</span>.<span class="name">instDecidableLT</span></a></div><div class="nav_link"><a class="break_within" href="#Std.FactoryInstances.beqOfDecidableLE"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">beqOfDecidableLE</span></a></div><div class="nav_link"><a class="break_within" href="#Std.FactoryInstances.instLawfulOrderBEqOfDecidableLE"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instLawfulOrderBEqOfDecidableLE</span></a></div><div class="nav_link"><a class="break_within" href="#Std.FactoryInstances.decidableLTOfLE"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">decidableLTOfLE</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Packages.PreorderOfLEArgs"><span class="name">Std</span>.<span class="name">Packages</span>.<span class="name">PreorderOfLEArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Std.PreorderPackage.ofLE"><span class="name">Std</span>.<span class="name">PreorderPackage</span>.<span class="name">ofLE</span></a></div><div class="nav_link"><a class="break_within" href="#Std.PartialOrderPackage"><span class="name">Std</span>.<span class="name">PartialOrderPackage</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Packages.PartialOrderOfLEArgs"><span class="name">Std</span>.<span class="name">Packages</span>.<span class="name">PartialOrderOfLEArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Std.PartialOrderPackage.ofLE"><span class="name">Std</span>.<span class="name">PartialOrderPackage</span>.<span class="name">ofLE</span></a></div><div class="nav_link"><a class="break_within" href="#Std.FactoryInstances.instOrdOfDecidableLE"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instOrdOfDecidableLE</span></a></div><div class="nav_link"><a class="break_within" href="#Std.FactoryInstances.instLawfulOrderOrdOfDecidableLE"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instLawfulOrderOrdOfDecidableLE</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LinearPreorderPackage"><span class="name">Std</span>.<span class="name">LinearPreorderPackage</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Packages.LinearPreorderOfLEArgs"><span class="name">Std</span>.<span class="name">Packages</span>.<span class="name">LinearPreorderOfLEArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LinearPreorderPackage.ofLE"><span class="name">Std</span>.<span class="name">LinearPreorderPackage</span>.<span class="name">ofLE</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LinearOrderPackage"><span class="name">Std</span>.<span class="name">LinearOrderPackage</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Packages.LinearOrderOfLEArgs"><span class="name">Std</span>.<span class="name">Packages</span>.<span class="name">LinearOrderOfLEArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LinearOrderPackage.ofLE"><span class="name">Std</span>.<span class="name">LinearOrderPackage</span>.<span class="name">ofLE</span></a></div><div class="nav_link"><a class="break_within" href="#Std.OrientedCmp.of_gt_iff_lt"><span class="name">Std</span>.<span class="name">OrientedCmp</span>.<span class="name">of_gt_iff_lt</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Packages.LinearPreorderOfOrdArgs"><span class="name">Std</span>.<span class="name">Packages</span>.<span class="name">LinearPreorderOfOrdArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LinearPreorderPackage.ofOrd"><span class="name">Std</span>.<span class="name">LinearPreorderPackage</span>.<span class="name">ofOrd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.FactoryInstances.instMinOfOrd"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instMinOfOrd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.FactoryInstances.instMaxOfOrd"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instMaxOfOrd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.FactoryInstances.instLawfulOrderLeftLeaningMinOfOrd"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instLawfulOrderLeftLeaningMinOfOrd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.FactoryInstances.instLawfulOrderLeftLeaningMaxOfOrd"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instLawfulOrderLeftLeaningMaxOfOrd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Packages.LinearOrderOfOrdArgs"><span class="name">Std</span>.<span class="name">Packages</span>.<span class="name">LinearOrderOfOrdArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LinearOrderPackage.ofOrd"><span class="name">Std</span>.<span class="name">LinearOrderPackage</span>.<span class="name">ofOrd</span></a></div></nav><main>
<div class="mod_doc"><h2 class="markdown-heading" id="Instance-packages-and-factories-for-them">Instance packages and factories for them <a class="hover-link" href="#Instance-packages-and-factories-for-them">#</a></h2><p>Instance packages are classes with the sole purpose to bundle together multiple smaller classes.
They should not be used as hypotheses, but they make it more convenient to define multiple instances
at once.</p></div><div class="decl" id="Std.PreorderPackage"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L23-L30">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage"><span class="name">Std</span>.<span class="name">PreorderPackage</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderLT">Std.LawfulOrderLT</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderBEq">Std.LawfulOrderBEq</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Data/Order/Classes.html#Std.IsPreorder">Std.IsPreorder</a> <span class="fn">α</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>This class entails <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code> and <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> instances as well as proofs that these operations
represent the same preorder structure on <code>α</code>.</p><ul class="structure_fields" id="Std.PreorderPackage.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#LE.le">le</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#LT.lt">lt</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#BEq.beq">beq</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderLT.lt_iff">lt_iff</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderBEq.beq_iff_le_and_ge">beq_iff_le_and_ge</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.IsPreorder.le_refl">le_refl</a><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.IsPreorder.le_trans">le_trans</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span></span></div></li><li id="Std.PreorderPackage.decidableLE" class="structure_field"><div class="structure_field_info">decidableLE : <span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span></div></li><li id="Std.PreorderPackage.decidableLT" class="structure_field"><div class="structure_field_info">decidableLT : <span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.PreorderPackage" class="instances-list"></ul></details></div></div><div class="decl" id="Std.instDecidableLE"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L32-L32">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.instDecidableLE"><span class="name">Std</span>.<span class="name">instDecidableLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage">PreorderPackage</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.instDecidableLE">Std.instDecidableLE</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLE">Std.PreorderPackage.decidableLE</a></li></ul></details></div></div><div class="decl" id="Std.instDecidableLT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L33-L33">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.instDecidableLT"><span class="name">Std</span>.<span class="name">instDecidableLT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage">PreorderPackage</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.instDecidableLT">Std.instDecidableLT</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLT">Std.PreorderPackage.decidableLT</a></li></ul></details></div></div><div class="decl" id="Std.FactoryInstances.beqOfDecidableLE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L37-L39">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.beqOfDecidableLE"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">beqOfDecidableLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.beqOfDecidableLE">Std.FactoryInstances.beqOfDecidableLE</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span>)</span></span> <a href="../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details><details id="instances-for-list-Std.FactoryInstances.beqOfDecidableLE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.FactoryInstances.instLawfulOrderBEqOfDecidableLE"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L41-L43">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderBEqOfDecidableLE"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instLawfulOrderBEqOfDecidableLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderBEq">LawfulOrderBEq</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="Std.FactoryInstances.decidableLTOfLE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L45-L51">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.decidableLTOfLE"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">decidableLTOfLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x✝</span> : <span class="fn"><a href="../../.././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderLT">LawfulOrderLT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span></div></div><p>If <code><a href="../../.././Init/Prelude.html#LT">LT</a></code> can be characterized in terms of a decidable <code><a href="../../.././Init/Prelude.html#LE">LE</a></code>, then <code><a href="../../.././Init/Prelude.html#LT">LT</a></code> is decidable either.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.decidableLTOfLE">Std.FactoryInstances.decidableLTOfLE</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span> then <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Std.FactoryInstances.decidableLTOfLE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Packages.PreorderOfLEArgs"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L55-L124">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs"><span class="name">Std</span>.<span class="name">Packages</span>.<span class="name">PreorderOfLEArgs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>This structure contains all the data needed to create a <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage">PreorderPackage</a> α</code> instance. Its fields
are automatically provided if possible. For the detailed rules how the fields are inferred, see
<code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE">PreorderPackage.ofLE</a></code>.</p><ul class="structure_fields" id="Std.Packages.PreorderOfLEArgs.mk"><li id="Std.Packages.PreorderOfLEArgs.le" class="structure_field"><div class="structure_field_info">le : <span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span></div></li><li id="Std.Packages.PreorderOfLEArgs.decidableLE" class="structure_field"><div class="structure_field_info">decidableLE : <span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span></div></li><li id="Std.Packages.PreorderOfLEArgs.lt" class="structure_field"><div class="structure_field_info">lt : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span></span></div></li><li id="Std.Packages.PreorderOfLEArgs.beq" class="structure_field"><div class="structure_field_info">beq : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span></span></span></div></li><li id="Std.Packages.PreorderOfLEArgs.lt_iff" class="structure_field"><div class="structure_field_info">lt_iff : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt">lt</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></span></div></li><li id="Std.Packages.PreorderOfLEArgs.decidableLT" class="structure_field"><div class="structure_field_info">decidableLT : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt">lt</a></span>;
<span class="fn">have <span class="fn">this_1</span> := <span class="fn">⋯</span>;
<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span></span></span></span></span></div></li><li id="Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge" class="structure_field"><div class="structure_field_info">beq_iff_le_and_ge : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">let <span class="fn">this_2</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq">beq</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></span></span></div></li><li id="Std.Packages.PreorderOfLEArgs.le_refl" class="structure_field"><div class="structure_field_info">le_refl : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></div></li><li id="Std.Packages.PreorderOfLEArgs.le_trans" class="structure_field"><div class="structure_field_info">le_trans : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span></span></span></span></div></li></ul><details id="instances-for-list-Std.Packages.PreorderOfLEArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.PreorderPackage.ofLE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L126-L180">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE"><span class="name">Std</span>.<span class="name">PreorderPackage</span>.<span class="name">ofLE</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs">Packages.PreorderOfLEArgs</a> <span class="fn">α</span></span> := by exact { })</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage">PreorderPackage</a> <span class="fn">α</span></span></div></div><p>Use this factory to conveniently define a preorder on a type <code>α</code> and all the associated operations
and instances given an <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code> instance.</p><p>Creates a <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage">PreorderPackage</a> α</code> instance. Such an instance entails <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code> and
<code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> instances as well as an <code>IsPreorder α</code> instance and <code>LawfulOrder*</code> instances proving the
compatibility of the operations with the preorder.</p><p>In the presence of <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code>, <code><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> α</code>, <code>Refl (· ≤ ·)</code> and <code><a href="../../.././Init/Prelude.html#Trans">Trans</a> (· ≤ ·) (· ≤ ·) (· ≤ ·)</code>
instances, no arguments are required and the factory can be used as in this example:</p><pre><code class="language-lean">public instance : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage">PreorderPackage</a> X := .<a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE">ofLE</a> X
</code></pre><p>If not all of these instances are available via typeclass synthesis, it is necessary to explicitly
provide some arguments:</p><pre><code class="language-lean">public instance : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage">PreorderPackage</a> X := .<a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE">ofLE</a> X {
  <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_refl">le_refl</a> := sorry
  <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans">le_trans</a> := sorry }
</code></pre><p>It is also possible to do all of this by hand, without resorting to <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage">PreorderPackage</a></code>. This can
be useful if, say, one wants to avoid specifying an <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code> instance, which is not possible with
<code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage">PreorderPackage</a></code>.</p><p><strong>How the arguments are filled</strong></p><p>Lean tries to fill all of the fields of the <code>args : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs">Packages.PreorderOfLEArgs</a> α</code> parameter
automatically. If it fails, it is necessary to provide some of the fields manually.</p><ul>
<li>For the data-carrying typeclasses <code><a href="../../.././Init/Prelude.html#LE">LE</a></code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a></code> and <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code>, existing instances are always preferred.
If no existing instances can be synthesized, it is attempted to derive an instance from the <code><a href="../../.././Init/Prelude.html#LE">LE</a></code>
instance.</li>
<li>Some proof obligations can be filled automatically if the data-carrying typeclasses have been
derived from the <code><a href="../../.././Init/Prelude.html#LE">LE</a></code> instance. For example: If the <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq">beq</a></code> field is omitted and no <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> instance
can be synthesized, it is derived from the <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code> instance. In this case, <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge">beq_iff_le_and_ge</a></code> can
be omitted because Lean can infer that <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> and <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code> are compatible.</li>
<li>Other proof obligations, namely <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_refl">le_refl</a></code> and <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans">le_trans</a></code>, can be omitted if <code>Refl</code> and <code><a href="../../.././Init/Prelude.html#Trans">Trans</a></code>
instances can be synthesized.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.PreorderPackage.ofLE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.PartialOrderPackage"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L186-L191">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage"><span class="name">Std</span>.<span class="name">PartialOrderPackage</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage">Std.PreorderPackage</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Data/Order/Classes.html#Std.IsPartialOrder">Std.IsPartialOrder</a> <span class="fn">α</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>This class entails <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code> and <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> instances as well as proofs that these operations
represent the same partial order structure on <code>α</code>.</p><ul class="structure_fields" id="Std.PartialOrderPackage.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#LE.le">le</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#LT.lt">lt</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#BEq.beq">beq</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderLT.lt_iff">lt_iff</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderBEq.beq_iff_le_and_ge">beq_iff_le_and_ge</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.IsPreorder.le_refl">le_refl</a><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.IsPreorder.le_trans">le_trans</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLE">decidableLE</a> : <span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLT">decidableLT</a> : <span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.IsPartialOrder.le_antisymm">le_antisymm</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.PartialOrderPackage" class="instances-list"></ul></details></div></div><div class="decl" id="Std.Packages.PartialOrderOfLEArgs"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L193-L207">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs"><span class="name">Std</span>.<span class="name">Packages</span>.<span class="name">PartialOrderOfLEArgs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs">Std.Packages.PreorderOfLEArgs</a> <span class="fn">α</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>This structure contains all the data needed to create a <code>PartialOrderPakckage α</code> instance. Its
fields are automatically provided if possible. For the detailed rules how the fields are inferred,
see <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.ofLE">PartialOrderPackage.ofLE</a></code>.</p><ul class="structure_fields" id="Std.Packages.PartialOrderOfLEArgs.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a> : <span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a> : <span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt">lt</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq">beq</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt_iff">lt_iff</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt">lt</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLT">decidableLT</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt">lt</a></span>;
<span class="fn">have <span class="fn">this_1</span> := <span class="fn">⋯</span>;
<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge">beq_iff_le_and_ge</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">let <span class="fn">this_2</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq">beq</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_refl">le_refl</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans">le_trans</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span></span></span></span></div></li><li id="Std.Packages.PartialOrderOfLEArgs.le_antisymm" class="structure_field"><div class="structure_field_info">le_antisymm : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></span></div></li></ul><details id="instances-for-list-Std.Packages.PartialOrderOfLEArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.PartialOrderPackage.ofLE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L254-L258">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.ofLE"><span class="name">Std</span>.<span class="name">PartialOrderPackage</span>.<span class="name">ofLE</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs">Packages.PartialOrderOfLEArgs</a> <span class="fn">α</span></span> := by exact { })</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage">PartialOrderPackage</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.ofLE">Std.PartialOrderPackage.ofLE</a> <span class="fn">α</span> <span class="fn">args</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.mk">{</a> <span class="fn">toPreorderPackage</span> := <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE">Std.PreorderPackage.ofLE</a> <span class="fn">α</span> <span class="fn"><span class="fn">args</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.toPreorderOfLEArgs">toPreorderOfLEArgs</a></span></span>, <span class="fn">le_antisymm</span> := <span class="fn">⋯</span> <a href="../../.././Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.mk">}</a></li></ul></details><details id="instances-for-list-Std.PartialOrderPackage.ofLE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.FactoryInstances.instOrdOfDecidableLE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L264-L266">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instOrdOfDecidableLE"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instOrdOfDecidableLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instOrdOfDecidableLE">Std.FactoryInstances.instOrdOfDecidableLE</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Data/Ord/Basic.html#Ord.mk">{</a> <span class="fn">compare</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#ite">then</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#ite">then</a> <a href="../../.././Init/Data/Ord/Basic.html#Ordering.eq">Ordering.eq</a> <a href="../../.././Init/Prelude.html#ite">else</a> <a href="../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a> <a href="../../.././Init/Prelude.html#ite">else</a> <a href="../../.././Init/Data/Ord/Basic.html#Ordering.gt">Ordering.gt</a></span> <a href="../../.././Init/Data/Ord/Basic.html#Ord.mk">}</a></li></ul></details><details id="instances-for-list-Std.FactoryInstances.instOrdOfDecidableLE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.FactoryInstances.instLawfulOrderOrdOfDecidableLE"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L284-L288">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderOrdOfDecidableLE"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instLawfulOrderOrdOfDecidableLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Total</a> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd">LawfulOrderOrd</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="Std.LinearPreorderPackage"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L292-L297">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage"><span class="name">Std</span>.<span class="name">LinearPreorderPackage</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage">Std.PreorderPackage</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd">Std.LawfulOrderOrd</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Data/Order/Classes.html#Std.IsLinearPreorder">Std.IsLinearPreorder</a> <span class="fn">α</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>This class entails <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code>, <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> and <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code> instances as well as proofs that these
operations represent the same linear preorder structure on <code>α</code>.</p><ul class="structure_fields" id="Std.LinearPreorderPackage.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#LE.le">le</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#LT.lt">lt</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#BEq.beq">beq</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderLT.lt_iff">lt_iff</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderBEq.beq_iff_le_and_ge">beq_iff_le_and_ge</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.IsPreorder.le_refl">le_refl</a><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.IsPreorder.le_trans">le_trans</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLE">decidableLE</a> : <span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLT">decidableLT</a> : <span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././Init/Data/Ord/Basic.html#Ordering">Ordering</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd.isLE_compare">isLE_compare</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd.isGE_compare">isGE_compare</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Data/Ord/Basic.html#Ordering.isGE">isGE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.IsLinearPreorder.le_total">le_total</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.LinearPreorderPackage" class="instances-list"></ul></details></div></div><div class="decl" id="Std.Packages.LinearPreorderOfLEArgs"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L299-L338">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs"><span class="name">Std</span>.<span class="name">Packages</span>.<span class="name">LinearPreorderOfLEArgs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs">Std.Packages.PreorderOfLEArgs</a> <span class="fn">α</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>This structure contains all the data needed to create a <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a> α</code> instance. Its fields
are automatically provided if possible. For the detailed rules how the fields are inferred, see
<code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofLE">LinearPreorderPackage.ofLE</a></code>.</p><ul class="structure_fields" id="Std.Packages.LinearPreorderOfLEArgs.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a> : <span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a> : <span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt">lt</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq">beq</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt_iff">lt_iff</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt">lt</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLT">decidableLT</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt">lt</a></span>;
<span class="fn">have <span class="fn">this_1</span> := <span class="fn">⋯</span>;
<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge">beq_iff_le_and_ge</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">let <span class="fn">this_2</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq">beq</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_refl">le_refl</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans">le_trans</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span></span></span></span></div></li><li id="Std.Packages.LinearPreorderOfLEArgs.ord" class="structure_field"><div class="structure_field_info">ord : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span></span></span></div></li><li id="Std.Packages.LinearPreorderOfLEArgs.le_total" class="structure_field"><div class="structure_field_info">le_total<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li id="Std.Packages.LinearPreorderOfLEArgs.isLE_compare" class="structure_field"><div class="structure_field_info">isLE_compare : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">let <span class="fn">this_2</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord">ord</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span></span></span></span></div></li><li id="Std.Packages.LinearPreorderOfLEArgs.isGE_compare" class="structure_field"><div class="structure_field_info">isGE_compare : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">have <span class="fn">this_2</span> := <span class="fn">⋯</span>;
<span class="fn">let <span class="fn">this_3</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord">ord</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Data/Ord/Basic.html#Ordering.isGE">isGE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></span></span></span></div></li></ul><details id="instances-for-list-Std.Packages.LinearPreorderOfLEArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.LinearPreorderPackage.ofLE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L340-L390">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofLE"><span class="name">Std</span>.<span class="name">LinearPreorderPackage</span>.<span class="name">ofLE</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs">Packages.LinearPreorderOfLEArgs</a> <span class="fn">α</span></span> := by exact { })</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a> <span class="fn">α</span></span></div></div><p>Use this factory to conveniently define a linear preorder on a type <code>α</code> and all the associated
operations and instances given an <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code> instance.</p><p>Creates a <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a> α</code> instance. Such an instance entails <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code>, <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> and
<code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code> instances as well as an <code>IsLinearPreorder α</code> instance and <code>LawfulOrder*</code> instances proving
the compatibility of the operations with the linear preorder.</p><p>In the presence of <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code>, <code><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> α</code>, <code>Total (· ≤ ·)</code> and <code><a href="../../.././Init/Prelude.html#Trans">Trans</a> (· ≤ ·) (· ≤ ·) (· ≤ ·)</code>
instances, no arguments are required and the factory can be used as in this example:</p><pre><code class="language-lean">public instance : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a> X := .<a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE">ofLE</a> X
</code></pre><p>If not all of these instances are available via typeclass synthesis, it is necessary to explicitly
provide some arguments:</p><pre><code class="language-lean">public instance : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a> X := .<a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE">ofLE</a> X {
  <a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.le_total">le_total</a> := sorry
  <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans">le_trans</a> := sorry }
</code></pre><p>It is also possible to do all of this by hand, without resorting to <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a></code>. This
can be useful if, say, one wants to avoid specifying an <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code> instance, which is not possible with
<code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a></code>.</p><p><strong>How the arguments are filled</strong></p><p>Lean tries to fill all of the fields of the <code>args : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs">Packages.LinearPreorderOfLEArgs</a> α</code> parameter
automatically. If it fails, it is necessary to provide some of the fields manually.</p><ul>
<li>For the data-carrying typeclasses <code><a href="../../.././Init/Prelude.html#LE">LE</a></code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a></code>, <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code> and <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a></code>, existing instances are always
preferred. If no existing instances can be synthesized, it is attempted to derive an instance from
the <code><a href="../../.././Init/Prelude.html#LE">LE</a></code> instance.</li>
<li>Some proof obligations can be filled automatically if the data-carrying typeclasses have been
derived from the <code><a href="../../.././Init/Prelude.html#LE">LE</a></code> instance. For example: If the <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq">beq</a></code> field is omitted and no <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> instance
can be synthesized, it is derived from the <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code> instance. In this case, <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge">beq_iff_le_and_ge</a></code> can be
omitted because Lean can infer that <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> and <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code> are compatible.</li>
<li>Other proof obligations, namely <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.le_total">le_total</a></code> and <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans">le_trans</a></code>, can be omitted if <code>Total</code> and <code><a href="../../.././Init/Prelude.html#Trans">Trans</a></code>
instances can be synthesized.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofLE">Std.LinearPreorderPackage.ofLE</a> <span class="fn">α</span> <span class="fn">args</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.mk">{</a> <span class="fn">toPreorderPackage</span> := <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE">Std.PreorderPackage.ofLE</a> <span class="fn">α</span> <span class="fn"><span class="fn">args</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.toPreorderOfLEArgs">toPreorderOfLEArgs</a></span></span>, <span class="fn">toOrd</span> := <span class="fn"><span class="fn">args</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord">ord</a></span>, <span class="fn">toLawfulOrderOrd</span> := <span class="fn">⋯</span>,
    <span class="fn">le_total</span> := <span class="fn">⋯</span> <a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.mk">}</a></li></ul></details><details id="instances-for-list-Std.LinearPreorderPackage.ofLE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.LinearOrderPackage"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L392-L398">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage"><span class="name">Std</span>.<span class="name">LinearOrderPackage</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">Std.LinearPreorderPackage</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage">Std.PartialOrderPackage</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Prelude.html#Min">Min</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Prelude.html#Max">Max</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderMin">Std.LawfulOrderMin</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderMax">Std.LawfulOrderMax</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Data/Order/Classes.html#Std.IsLinearOrder">Std.IsLinearOrder</a> <span class="fn">α</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>This class entails <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code>, <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code>, <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code>, <code><a href="../../.././Init/Prelude.html#Min">Min</a> α</code> and <code><a href="../../.././Init/Prelude.html#Max">Max</a> α</code> instances as well as proofs
that these operations represent the same linear order structure on <code>α</code>.</p><ul class="structure_fields" id="Std.LinearOrderPackage.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#LE.le">le</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#LT.lt">lt</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#BEq.beq">beq</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderLT.lt_iff">lt_iff</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderBEq.beq_iff_le_and_ge">beq_iff_le_and_ge</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.IsPreorder.le_refl">le_refl</a><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.IsPreorder.le_trans">le_trans</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLE">decidableLE</a> : <span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLT">decidableLT</a> : <span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././Init/Data/Ord/Basic.html#Ordering">Ordering</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd.isLE_compare">isLE_compare</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd.isGE_compare">isGE_compare</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Data/Ord/Basic.html#Ordering.isGE">isGE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.IsLinearPreorder.le_total">le_total</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.IsPartialOrder.le_antisymm">le_antisymm</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#Min.min">min</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Prelude.html#Max.max">max</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.MinEqOr.min_eq_or">min_eq_or</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><a href="../../.././Init/Prelude.html#Min.min">min</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../../.././Init/Prelude.html#Min.min">min</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderInf.le_min_iff">le_min_iff</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Init/Prelude.html#Min.min">min</a> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.MaxEqOr.max_eq_or">max_eq_or</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><a href="../../.././Init/Prelude.html#Max.max">max</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../../.././Init/Prelude.html#Max.max">max</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderSup.max_le_iff">max_le_iff</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><a href="../../.././Init/Prelude.html#Max.max">max</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.LinearOrderPackage" class="instances-list"></ul></details></div></div><div class="decl" id="Std.Packages.LinearOrderOfLEArgs"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L400-L438">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs"><span class="name">Std</span>.<span class="name">Packages</span>.<span class="name">LinearOrderOfLEArgs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs">Std.Packages.LinearPreorderOfLEArgs</a> <span class="fn">α</span></span>, <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs">Std.Packages.PartialOrderOfLEArgs</a> <span class="fn">α</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>This structure contains all the data needed to create a <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a> α</code> instance. Its fields
are automatically provided if possible. For the detailed rules how the fields are inferred, see
<code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.ofLE">LinearOrderPackage.ofLE</a></code>.</p><ul class="structure_fields" id="Std.Packages.LinearOrderOfLEArgs.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a> : <span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a> : <span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt">lt</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq">beq</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt_iff">lt_iff</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt">lt</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLT">decidableLT</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt">lt</a></span>;
<span class="fn">have <span class="fn">this_1</span> := <span class="fn">⋯</span>;
<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge">beq_iff_le_and_ge</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">let <span class="fn">this_2</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq">beq</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_refl">le_refl</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans">le_trans</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord">ord</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.le_total">le_total</a><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.isLE_compare">isLE_compare</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">let <span class="fn">this_2</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord">ord</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.isGE_compare">isGE_compare</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">have <span class="fn">this_2</span> := <span class="fn">⋯</span>;
<span class="fn">let <span class="fn">this_3</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord">ord</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Data/Ord/Basic.html#Ordering.isGE">isGE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.le_antisymm">le_antisymm</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></span></div></li><li id="Std.Packages.LinearOrderOfLEArgs.min" class="structure_field"><div class="structure_field_info">min : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#Min">Min</a> <span class="fn">α</span></span></span></span></div></li><li id="Std.Packages.LinearOrderOfLEArgs.max" class="structure_field"><div class="structure_field_info">max : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#Max">Max</a> <span class="fn">α</span></span></span></span></div></li><li id="Std.Packages.LinearOrderOfLEArgs.min_eq" class="structure_field"><div class="structure_field_info">min_eq : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">let <span class="fn">this_2</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.min">min</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><a href="../../.././Init/Prelude.html#Min.min">Min.min</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span></span></span></span></span></div></li><li id="Std.Packages.LinearOrderOfLEArgs.max_eq" class="structure_field"><div class="structure_field_info">max_eq : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE">decidableLE</a></span>;
<span class="fn">let <span class="fn">this_2</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.max">max</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><a href="../../.././Init/Prelude.html#Max.max">Max.max</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span></span></span></span></span></div></li></ul><details id="instances-for-list-Std.Packages.LinearOrderOfLEArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.LinearOrderPackage.ofLE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L440-L501">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.ofLE"><span class="name">Std</span>.<span class="name">LinearOrderPackage</span>.<span class="name">ofLE</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs">Packages.LinearOrderOfLEArgs</a> <span class="fn">α</span></span> := by exact { })</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a> <span class="fn">α</span></span></div></div><p>Use this factory to conveniently define a linear order on a type <code>α</code> and all the associated
operations and instances given an <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code> instance.</p><p>Creates a <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a> α</code> instance. Such an instance entails <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code>, <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code>,
<code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code>, <code><a href="../../.././Init/Prelude.html#Min">Min</a> α</code> and <code><a href="../../.././Init/Prelude.html#Max">Max</a> α</code> instances as well as an <code>IsLinearOrder α</code> instance and <code>LawfulOrder*</code>
instances proving the compatibility of the operations with the linear order.</p><p>In the presence of <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code>, <code><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> α</code>, <code>Total (· ≤ ·)</code>, <code><a href="../../.././Init/Prelude.html#Trans">Trans</a> (· ≤ ·) (· ≤ ·) (· ≤ ·)</code> and
<code>Antisymm (· ≤ ·)</code> instances, no arguments are required and the factory can be used as in this
example:</p><pre><code class="language-lean">public instance : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a> X := .<a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE">ofLE</a> X
</code></pre><p>If not all of these instances are available via typeclass synthesis, it is necessary to explicitly
provide some arguments:</p><pre><code class="language-lean">public instance : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a> X := .<a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE">ofLE</a> X {
  <a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.le_total">le_total</a> := sorry
  <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans">le_trans</a> := sorry
  <a href="../../.././Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.le_antisymm">le_antisymm</a> := sorry }
</code></pre><p>It is also possible to do all of this by hand, without resorting to <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a></code>. This
can be useful if, say, one wants to avoid specifying an <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code> instance, which is not possible with
<code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a></code>.</p><p><strong>How the arguments are filled</strong></p><p>Lean tries to fill all of the fields of the <code>args : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs">Packages.LinearOrderOfLEArgs</a> α</code> parameter
automatically. If it fails, it is necessary to provide some of the fields manually.</p><ul>
<li>For the data-carrying typeclasses <code><a href="../../.././Init/Prelude.html#LE">LE</a></code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a></code>, <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code>, <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a></code>, <code><a href="../../.././Init/Prelude.html#Min">Min</a></code> and <code><a href="../../.././Init/Prelude.html#Max">Max</a></code>, existing instances
are always preferred. If no existing instances can be synthesized, it is attempted to derive an
instance from the <code><a href="../../.././Init/Prelude.html#LE">LE</a></code> instance.</li>
<li>Some proof obligations can be filled automatically if the data-carrying typeclasses have been
derived from the <code><a href="../../.././Init/Prelude.html#LE">LE</a></code> instance. For example: If the <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq">beq</a></code> field is omitted and no <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> instance
can be synthesized, it is derived from the <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code> instance. In this case, <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge">beq_iff_le_and_ge</a></code> can be
omitted because Lean can infer that <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> and <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code> are compatible.</li>
<li>Other proof obligations, namely <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.le_total">le_total</a></code>, <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans">le_trans</a></code> and <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.le_antisymm">le_antisymm</a></code>, can be omitted if
<code>Total</code>, <code><a href="../../.././Init/Prelude.html#Trans">Trans</a></code> and <code>Antisymm</code> instances can be synthesized.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.LinearOrderPackage.ofLE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.OrientedCmp.of_gt_iff_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L511-L522">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.OrientedCmp.of_gt_iff_lt"><span class="name">Std</span>.<span class="name">OrientedCmp</span>.<span class="name">of_gt_iff_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">cmp</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././Init/Data/Ord/Basic.html#Ordering">Ordering</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">cmp</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Ord/Basic.html#Ordering.gt">Ordering.gt</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">cmp</span> <span class="fn">b</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Order/Ord.html#Std.OrientedCmp">OrientedCmp</a> <span class="fn">cmp</span></span></div></div></div></div><div class="decl" id="Std.Packages.LinearPreorderOfOrdArgs"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L526-L600">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs"><span class="name">Std</span>.<span class="name">Packages</span>.<span class="name">LinearPreorderOfOrdArgs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>This structure contains all the data needed to create a <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a> α</code> instance.
Its fields are automatically provided if possible. For the detailed rules how the fields are
inferred, see <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofOrd">LinearPreorderPackage.ofOrd</a></code>.</p><ul class="structure_fields" id="Std.Packages.LinearPreorderOfOrdArgs.mk"><li id="Std.Packages.LinearPreorderOfOrdArgs.ord" class="structure_field"><div class="structure_field_info">ord : <span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span></div></li><li id="Std.Packages.LinearPreorderOfOrdArgs.transOrd" class="structure_field"><div class="structure_field_info">transOrd : <span class="fn"><a href="../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span></div></li><li id="Std.Packages.LinearPreorderOfOrdArgs.le" class="structure_field"><div class="structure_field_info">le : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span></span></div></li><li id="Std.Packages.LinearPreorderOfOrdArgs.lawfulOrderOrd" class="structure_field"><div class="structure_field_info">lawfulOrderOrd : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn">⋯</span>;
<span class="fn">let <span class="fn">this_2</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn"><a href="../../.././Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd">LawfulOrderOrd</a> <span class="fn">α</span></span></span></span></span></div></li><li id="Std.Packages.LinearPreorderOfOrdArgs.decidableLE" class="structure_field"><div class="structure_field_info">decidableLE : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn">have <span class="fn">this_1</span> := <span class="fn">⋯</span>;
<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span></span></span></span></div></li><li id="Std.Packages.LinearPreorderOfOrdArgs.lt" class="structure_field"><div class="structure_field_info">lt : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span></span></div></li><li id="Std.Packages.LinearPreorderOfOrdArgs.lt_iff" class="structure_field"><div class="structure_field_info">lt_iff : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn">have <span class="fn">this_2</span> := <span class="fn">⋯</span>;
<span class="fn">let <span class="fn">this_3</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt">lt</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a></span></span></span></span></span></div></li><li id="Std.Packages.LinearPreorderOfOrdArgs.decidableLT" class="structure_field"><div class="structure_field_info">decidableLT : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt">lt</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn">have <span class="fn">this_2</span> := <span class="fn">⋯</span>;
<span class="fn">have <span class="fn">this_3</span> := <span class="fn">⋯</span>;
<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span></span></span></span></span></span></div></li><li id="Std.Packages.LinearPreorderOfOrdArgs.beq" class="structure_field"><div class="structure_field_info">beq : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span></span></div></li><li id="Std.Packages.LinearPreorderOfOrdArgs.beq_iff" class="structure_field"><div class="structure_field_info">beq_iff : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn">have <span class="fn">this_2</span> := <span class="fn">⋯</span>;
<span class="fn">let <span class="fn">this_3</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq">beq</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Ord/Basic.html#Ordering.eq">Ordering.eq</a></span></span></span></span></span></div></li></ul><details id="instances-for-list-Std.Packages.LinearPreorderOfOrdArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.LinearPreorderPackage.ofOrd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L602-L668">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofOrd"><span class="name">Std</span>.<span class="name">LinearPreorderPackage</span>.<span class="name">ofOrd</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs">Packages.LinearPreorderOfOrdArgs</a> <span class="fn">α</span></span> := by exact { })</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a> <span class="fn">α</span></span></div></div><p>Use this factory to conveniently define a linear preorder on a type <code>α</code> and all the associated
operations and instances given an <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code> instance.</p><p>Creates a <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a> α</code> instance. Such an instance entails <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code>, <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> and
<code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code> instances as well as an <code>IsLinearPreorder α</code> instance and <code>LawfulOrder*</code> instances proving
the compatibility of the operations with the linear preorder.</p><p>In the presence of <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code> and <code>TransOrd α</code> instances, no arguments are required and the factory can
be used as in this example:</p><pre><code class="language-lean">public instance : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a> X := .<a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofOrd">ofOrd</a> X
</code></pre><p>If not all of these instances are available via typeclass synthesis, it is necessary to explicitly
provide some arguments:</p><pre><code class="language-lean">public instance : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a> X := .<a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofOrd">ofOrd</a> X {
  <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord">ord</a> := sorry
  <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.transOrd">transOrd</a> := sorry }
</code></pre><p>It is also possible to do all of this by hand, without resorting to <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a></code>. This
can be useful if, say, one wants to avoid specifying an <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code> instance, which is not possible with
<code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage">LinearPreorderPackage</a></code>.</p><p><strong>How the arguments are filled</strong></p><p>Lean tries to fill all of the fields of the <code>args : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs">Packages.LinearPreorderOfOrdArgs</a> α</code> parameter
automatically. If it fails, it is necessary to provide some of the fields manually.</p><ul>
<li>For the data-carrying typeclasses <code><a href="../../.././Init/Prelude.html#LE">LE</a></code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a></code>, <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code> and <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a></code>, existing instances are always
preferred. If no existing instances can be synthesized, it is attempted to derive an instance from
the <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a></code> instance.</li>
<li>Some proof obligations can be filled automatically if the data-carrying typeclasses have been
derived from the <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a></code> instance. For example: If the <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq">beq</a></code> field is omitted and no <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> instance
can be synthesized, it is derived from the <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code> instance. In this case, <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq_iff">beq_iff</a></code>
can be omitted because Lean can infer that <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> and <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code> are compatible.</li>
<li>Other proof obligations, for example <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.transOrd">transOrd</a></code>, can be omitted if a matching instance can be
synthesized.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.LinearPreorderPackage.ofOrd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.FactoryInstances.instMinOfOrd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L676-L678">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instMinOfOrd"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instMinOfOrd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Min">Min</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instMinOfOrd">Std.FactoryInstances.instMinOfOrd</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Min.mk">{</a> <span class="fn">min</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Min.mk">}</a></li></ul></details><details id="instances-for-list-Std.FactoryInstances.instMinOfOrd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.FactoryInstances.instMaxOfOrd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L680-L682">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instMaxOfOrd"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instMaxOfOrd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Max">Max</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instMaxOfOrd">Std.FactoryInstances.instMaxOfOrd</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Max.mk">{</a> <span class="fn">max</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">b</span> <span class="fn">a</span>)</span>.<a href="../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Max.mk">}</a></li></ul></details><details id="instances-for-list-Std.FactoryInstances.instMaxOfOrd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.FactoryInstances.instLawfulOrderLeftLeaningMinOfOrd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L684-L688">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderLeftLeaningMinOfOrd"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instLawfulOrderLeftLeaningMinOfOrd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd">LawfulOrderOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderLeftLeaningMin">LawfulOrderLeftLeaningMin</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="Std.FactoryInstances.instLawfulOrderLeftLeaningMaxOfOrd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L690-L694">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderLeftLeaningMaxOfOrd"><span class="name">Std</span>.<span class="name">FactoryInstances</span>.<span class="name">instLawfulOrderLeftLeaningMaxOfOrd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd">LawfulOrderOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Order/Classes.html#Std.LawfulOrderLeftLeaningMax">LawfulOrderLeftLeaningMax</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="Std.Packages.LinearOrderOfOrdArgs"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L698-L745">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs"><span class="name">Std</span>.<span class="name">Packages</span>.<span class="name">LinearOrderOfOrdArgs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs">Std.Packages.LinearPreorderOfOrdArgs</a> <span class="fn">α</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>This structure contains all the data needed to create a <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a> α</code> instance.
Its fields are automatically provided if possible. For the detailed rules how the fields are
inferred, see <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.ofOrd">LinearOrderPackage.ofOrd</a></code>.</p><ul class="structure_fields" id="Std.Packages.LinearOrderOfOrdArgs.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a> : <span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.transOrd">transOrd</a> : <span class="fn"><a href="../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lawfulOrderOrd">lawfulOrderOrd</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn">⋯</span>;
<span class="fn">let <span class="fn">this_2</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn"><a href="../../.././Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd">LawfulOrderOrd</a> <span class="fn">α</span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.decidableLE">decidableLE</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn">have <span class="fn">this_1</span> := <span class="fn">⋯</span>;
<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt">lt</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt_iff">lt_iff</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn">have <span class="fn">this_2</span> := <span class="fn">⋯</span>;
<span class="fn">let <span class="fn">this_3</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt">lt</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a></span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.decidableLT">decidableLT</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt">lt</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn">have <span class="fn">this_2</span> := <span class="fn">⋯</span>;
<span class="fn">have <span class="fn">this_3</span> := <span class="fn">⋯</span>;
<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span></span></span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq">beq</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq_iff">beq_iff</a> : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn">have <span class="fn">this_2</span> := <span class="fn">⋯</span>;
<span class="fn">let <span class="fn">this_3</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq">beq</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Ord/Basic.html#Ordering.eq">Ordering.eq</a></span></span></span></span></span></div></li><li id="Std.Packages.LinearOrderOfOrdArgs.eq_of_compare" class="structure_field"><div class="structure_field_info">eq_of_compare : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Ord/Basic.html#Ordering.eq">Ordering.eq</a> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></span></div></li><li id="Std.Packages.LinearOrderOfOrdArgs.min" class="structure_field"><div class="structure_field_info">min : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#Min">Min</a> <span class="fn">α</span></span></span></div></li><li id="Std.Packages.LinearOrderOfOrdArgs.max" class="structure_field"><div class="structure_field_info">max : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn"><a href="../../.././Init/Prelude.html#Max">Max</a> <span class="fn">α</span></span></span></div></li><li id="Std.Packages.LinearOrderOfOrdArgs.min_eq" class="structure_field"><div class="structure_field_info">min_eq : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_2</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.min">min</a></span>;
<span class="fn">have <span class="fn">this_3</span> := <span class="fn">⋯</span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><a href="../../.././Init/Prelude.html#Min.min">Min.min</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span></span></span></span></span></span></div></li><li id="Std.Packages.LinearOrderOfOrdArgs.max_eq" class="structure_field"><div class="structure_field_info">max_eq : <span class="fn">let <span class="fn">this</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord">ord</a></span>;
<span class="fn">let <span class="fn">this_1</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le">le</a></span>;
<span class="fn">let <span class="fn">this_2</span> := <span class="fn"><span class="fn">self</span>.<a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.max">max</a></span>;
<span class="fn">have <span class="fn">this_3</span> := <span class="fn">⋯</span>;
<span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><a href="../../.././Init/Prelude.html#Max.max">Max.max</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">a</span> <span class="fn">b</span>)</span>.<a href="../../.././Init/Data/Ord/Basic.html#Ordering.isGE">isGE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span></span></span></span></span></span></div></li></ul><details id="instances-for-list-Std.Packages.LinearOrderOfOrdArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.LinearOrderPackage.ofOrd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Data/Order/PackageFactories.lean#L747-L806">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.ofOrd"><span class="name">Std</span>.<span class="name">LinearOrderPackage</span>.<span class="name">ofOrd</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs">Packages.LinearOrderOfOrdArgs</a> <span class="fn">α</span></span> := by exact { })</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a> <span class="fn">α</span></span></div></div><p>Use this factory to conveniently define a linear order on a type <code>α</code> and all the associated
operations and instances given an <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code> instance.</p><p>Creates a <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a> α</code> instance. Such an instance entails <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code>, <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code>,
<code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code>, <code><a href="../../.././Init/Prelude.html#Min">Min</a> α</code> and <code><a href="../../.././Init/Prelude.html#Max">Max</a> α</code> instances as well as an <code>IsLinearOrder α</code> instance and <code>LawfulOrder*</code>
instances proving the compatibility of the operations with the linear order.</p><p>In the presence of <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code>, <code>TransOrd α</code> and <code>LawfulEqOrd α</code> instances, no arguments are required
and the factory can be used as in this
example:</p><pre><code class="language-lean">public instance : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a> X := .<a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE">ofLE</a> X
</code></pre><p>If not all of these instances are available via typeclass synthesis, it is necessary to explicitly
provide some arguments:</p><pre><code class="language-lean">public instance : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a> X := .<a href="../../.././Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE">ofLE</a> X {
  <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.transOrd">transOrd</a> := sorry
  <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.eq_of_compare">eq_of_compare</a> := sorry }
</code></pre><p>It is also possible to do all of this by hand, without resorting to <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a></code>. This
can be useful if, say, one wants to avoid specifying an <code><a href="../../.././Init/Prelude.html#LT">LT</a> α</code> instance, which is not possible with
<code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage">LinearOrderPackage</a></code>.</p><p><strong>How the arguments are filled</strong></p><p>Lean tries to fill all of the fields of the <code>args : <a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs">Packages.LinearOrderOfLEArgs</a> α</code> parameter
automatically. If it fails, it is necessary to provide some of the fields manually.</p><ul>
<li>For the data-carrying typeclasses <code><a href="../../.././Init/Prelude.html#LE">LE</a></code>, <code><a href="../../.././Init/Prelude.html#LT">LT</a></code>, <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code>, <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a></code>, <code><a href="../../.././Init/Prelude.html#Min">Min</a></code> and <code><a href="../../.././Init/Prelude.html#Max">Max</a></code>, existing instances
are always preferred. If no existing instances can be synthesized, it is attempted to derive an
instance from the <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a></code> instance.</li>
<li>Some proof obligations can be filled automatically if the data-carrying typeclasses have been
derived from the <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a></code> instance. For example: If the <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq">beq</a></code> field is omitted and no <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> instance
can be synthesized, it is derived from the <code><a href="../../.././Init/Prelude.html#LE">LE</a> α</code> instance. In this case, <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq_iff">beq_iff</a></code>
can be omitted because Lean can infer that <code><a href="../../.././Init/Prelude.html#BEq">BEq</a> α</code> and <code><a href="../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> α</code> are compatible.</li>
<li>Other proof obligations, such as <code><a href="../../.././Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.transOrd">transOrd</a></code>, can be omitted if matching instances can be
synthesized.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.LinearOrderPackage.ofOrd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>