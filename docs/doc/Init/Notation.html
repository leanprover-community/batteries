<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="icon" href=".././favicon.svg"></link><link rel="mask-icon" href=".././favicon.svg" color="#000000"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>Init.Notation</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="Init.Notation";</script><script type="module" src=".././jump-src.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././expand-nav.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Init</span>.<span class="name">Notation</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href=".././Init/Coe.html">Init.Coe</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Notation" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.command"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">command</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.term"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">term</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.tactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">tactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.doElem"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">doElem</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.structInstFieldDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">structInstFieldDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.level"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">level</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.attr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">attr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.stx"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">stx</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.prio"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">prio</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.prec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">prec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Syntax.addPrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Syntax</span>.<span class="name">addPrec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Syntax.subPrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Syntax</span>.<span class="name">subPrec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Syntax.addPrio"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Syntax</span>.<span class="name">addPrio</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Syntax.subPrio"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Syntax</span>.<span class="name">subPrio</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instCoeOutTSyntaxSyntax"><span class="name">Lean</span>.<span class="name">instCoeOutTSyntaxSyntax</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instCoeSyntaxNodeKindSyntaxNodeKinds"><span class="name">Lean</span>.<span class="name">instCoeSyntaxNodeKindSyntaxNodeKinds</span></a></div><div class="nav_link"><a class="break_within" href="#precMax"><span class="name">precMax</span></a></div><div class="nav_link"><a class="break_within" href="#precArg"><span class="name">precArg</span></a></div><div class="nav_link"><a class="break_within" href="#precLead"><span class="name">precLead</span></a></div><div class="nav_link"><a class="break_within" href="#«prec(_)»"><span class="name">«prec(_)»</span></a></div><div class="nav_link"><a class="break_within" href="#precMin"><span class="name">precMin</span></a></div><div class="nav_link"><a class="break_within" href="#precMin1"><span class="name">precMin1</span></a></div><div class="nav_link"><a class="break_within" href="#termMax_prec"><span class="name">termMax_prec</span></a></div><div class="nav_link"><a class="break_within" href="#prioDefault"><span class="name">prioDefault</span></a></div><div class="nav_link"><a class="break_within" href="#prioLow"><span class="name">prioLow</span></a></div><div class="nav_link"><a class="break_within" href="#prioMid"><span class="name">prioMid</span></a></div><div class="nav_link"><a class="break_within" href="#prioHigh"><span class="name">prioHigh</span></a></div><div class="nav_link"><a class="break_within" href="#«prio(_)»"><span class="name">«prio(_)»</span></a></div><div class="nav_link"><a class="break_within" href="#«stx_+»"><span class="name">«stx_+»</span></a></div><div class="nav_link"><a class="break_within" href="#«stx_*»"><span class="name">«stx_*»</span></a></div><div class="nav_link"><a class="break_within" href="#stx_?"><span class="name">stx_?</span></a></div><div class="nav_link"><a class="break_within" href="#«stx_&lt;|&gt;_»"><span class="name">«stx_&lt;|&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«stx_,*»"><span class="name">«stx_,*»</span></a></div><div class="nav_link"><a class="break_within" href="#«stx_,+»"><span class="name">«stx_,+»</span></a></div><div class="nav_link"><a class="break_within" href="#«stx_,*,?»"><span class="name">«stx_,*,?»</span></a></div><div class="nav_link"><a class="break_within" href="#«stx_,+,?»"><span class="name">«stx_,+,?»</span></a></div><div class="nav_link"><a class="break_within" href="#stx!_"><span class="name">stx!_</span></a></div><div class="nav_link"><a class="break_within" href="#rawNatLit"><span class="name">rawNatLit</span></a></div><div class="nav_link"><a class="break_within" href="#«term_∘_»"><span class="name">«term_∘_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_×_»"><span class="name">«term_×_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_×'_»"><span class="name">«term_×'_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_∣_»"><span class="name">«term_∣_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_|||_»"><span class="name">«term_|||_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_^^^_»"><span class="name">«term_^^^_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&amp;&amp;&amp;_»"><span class="name">«term_&amp;&amp;&amp;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_+_»"><span class="name">«term_+_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_-_»"><span class="name">«term_-_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_*_»"><span class="name">«term_*_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_/_»"><span class="name">«term_/_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_%_»"><span class="name">«term_%_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;&lt;&lt;_»"><span class="name">«term_&lt;&lt;&lt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&gt;&gt;&gt;_»"><span class="name">«term_&gt;&gt;&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_^_»"><span class="name">«term_^_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_++_»"><span class="name">«term_++_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term-_»"><span class="name">«term-_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term~~~_»"><span class="name">«term~~~_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⁻¹»"><span class="name">«term_⁻¹»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_•_»"><span class="name">«term_•_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;=_»"><span class="name">«term_&lt;=_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_≤_»"><span class="name">«term_≤_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;_»"><span class="name">«term_&lt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&gt;=_»"><span class="name">«term_&gt;=_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_≥_»"><span class="name">«term_≥_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&gt;_»"><span class="name">«term_&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_=_»"><span class="name">«term_=_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_==_»"><span class="name">«term_==_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_≍_»"><span class="name">«term_≍_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_/\_»"><span class="name">«term_/\_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_∧_»"><span class="name">«term_∧_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_\/_»"><span class="name">«term_\/_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_∨_»"><span class="name">«term_∨_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term¬_»"><span class="name">«term¬_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&amp;&amp;_»"><span class="name">«term_&amp;&amp;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_||_»"><span class="name">«term_||_»</span></a></div><div class="nav_link"><a class="break_within" href="#term!_"><span class="name">term!_</span></a></div><div class="nav_link"><a class="break_within" href="#«term_∈_»"><span class="name">«term_∈_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_∉_»"><span class="name">«term_∉_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_::_»"><span class="name">«term_::_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;$&gt;_»"><span class="name">«term_&lt;$&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&gt;&gt;=_»"><span class="name">«term_&gt;&gt;=_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;|&gt;_»"><span class="name">«term_&lt;|&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&gt;&gt;_»"><span class="name">«term_&gt;&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;*&gt;_»"><span class="name">«term_&lt;*&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;*_»"><span class="name">«term_&lt;*_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_*&gt;_»"><span class="name">«term_*&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.binderIdent"><span class="name">Lean</span>.<span class="name">binderIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.caseArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">caseArg</span></a></div><div class="nav_link"><a class="break_within" href="#termDepIfThenElse"><span class="name">termDepIfThenElse</span></a></div><div class="nav_link"><a class="break_within" href="#termIfThenElse"><span class="name">termIfThenElse</span></a></div><div class="nav_link"><a class="break_within" href="#termIfLet"><span class="name">termIfLet</span></a></div><div class="nav_link"><a class="break_within" href="#boolIfThenElse"><span class="name">boolIfThenElse</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;|_»"><span class="name">«term_&lt;|_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_|&gt;_»"><span class="name">«term_|&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_$__»"><span class="name">«term_$__»</span></a></div><div class="nav_link"><a class="break_within" href="#«term{_:_//_}»"><span class="name">«term{_:_//_}»</span></a></div><div class="nav_link"><a class="break_within" href="#termWithout_expected_type_"><span class="name">termWithout_expected_type_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.byElab"><span class="name">Lean</span>.<span class="name">byElab</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.rawStx"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">rawStx</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.rawStx.quot"><span class="name">Lean</span>.<span class="name">rawStx</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil"><span class="name">Lean</span>.<span class="name">instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.withAnnotateTerm"><span class="name">Lean</span>.<span class="name">withAnnotateTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.modCast"><span class="name">Lean</span>.<span class="name">modCast</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.deprecated"><span class="name">Lean</span>.<span class="name">deprecated</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Attr.coe"><span class="name">Lean</span>.<span class="name">Attr</span>.<span class="name">coe</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.command_code_action"><span class="name">Lean</span>.<span class="name">command_code_action</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.builtin_command_code_action"><span class="name">Lean</span>.<span class="name">builtin_command_code_action</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.includeStr"><span class="name">Lean</span>.<span class="name">includeStr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.runCmd"><span class="name">Lean</span>.<span class="name">runCmd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.runElab"><span class="name">Lean</span>.<span class="name">runElab</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.runMeta"><span class="name">Lean</span>.<span class="name">runMeta</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.reduceCmd"><span class="name">Lean</span>.<span class="name">reduceCmd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.guardMsgsFilterAction"><span class="name">Lean</span>.<span class="name">guardMsgsFilterAction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.guardMsgsFilterSeverity"><span class="name">Lean</span>.<span class="name">guardMsgsFilterSeverity</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.guardMsgsFilter"><span class="name">Lean</span>.<span class="name">guardMsgsFilter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.guardMsgsWhitespaceArg"><span class="name">Lean</span>.<span class="name">guardMsgsWhitespaceArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.guardMsgsWhitespace"><span class="name">Lean</span>.<span class="name">guardMsgsWhitespace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.guardMsgsOrderingArg"><span class="name">Lean</span>.<span class="name">guardMsgsOrderingArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.guardMsgsOrdering"><span class="name">Lean</span>.<span class="name">guardMsgsOrdering</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.guardMsgsPositionsArg"><span class="name">Lean</span>.<span class="name">guardMsgsPositionsArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.guardMsgsPositions"><span class="name">Lean</span>.<span class="name">guardMsgsPositions</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.guardMsgsSpecElt"><span class="name">Lean</span>.<span class="name">guardMsgsSpecElt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.guardMsgsSpec"><span class="name">Lean</span>.<span class="name">guardMsgsSpec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.guardMsgsCmd"><span class="name">Lean</span>.<span class="name">guardMsgsCmd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.infoTreesCmd"><span class="name">Lean</span>.<span class="name">infoTreesCmd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.setPremiseSelectorCmd"><span class="name">Lean</span>.<span class="name">setPremiseSelectorCmd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.checkTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">checkTactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.checkTacticFailure"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">checkTacticFailure</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.checkSimp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">checkSimp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.checkSimpFailure"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">checkSimpFailure</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.timeCmd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">timeCmd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.discrTreeKeyCmd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">discrTreeKeyCmd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.discrTreeSimpKeyCmd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">discrTreeSimpKeyCmd</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.commandSeal__"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">commandSeal__</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.commandUnseal__"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">commandUnseal__</span></a></div></nav><main>
<div class="decl" id="Lean.Parser.Category"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L15-L19">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Category"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Auxiliary type used to represent syntax categories. We mainly use auxiliary
definitions with this type to attach doc strings to syntax categories.</p><ul class="structure_fields" id="Lean.Parser.Category.mk"></ul><details id="instances-for-list-Lean.Parser.Category" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.command"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L23-L28">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Category.command"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">command</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p><code><a href=".././Init/Notation.html#Lean.Parser.Category.command">command</a></code> is the syntax category for things that appear at the top level
of a lean file. For example, <code>def foo := 1</code> is a <code><a href=".././Init/Notation.html#Lean.Parser.Category.command">command</a></code>, as is
<code>namespace Foo</code> and <code>end Foo</code>. Commands generally have an effect on the state of
adding something to the environment (like a new definition), as well as
commands like <code>variable</code> which modify future commands within a scope.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Category.command">Lean.Parser.Category.command</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.command" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.term"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L30-L35">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Category.term"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">term</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p><code><a href=".././Init/Notation.html#Lean.Parser.Category.term">term</a></code> is the builtin syntax category for terms. A term denotes an expression
in lean's type theory, for example <code>2 + 2</code> is a term. The difference between
<code>Term</code> and <code>Expr</code> is that the former is a kind of syntax, while the latter is
the result of elaboration. For example <code>by simp</code> is also a <code>Term</code>, but it elaborates
to different <code>Expr</code>s depending on the context.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Category.term">Lean.Parser.Category.term</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.term" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.tactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L37-L45">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Category.tactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">tactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p><code><a href=".././Init/Notation.html#Lean.Parser.Category.tactic">tactic</a></code> is the builtin syntax category for tactics. These appear after
<code>by</code> in proofs, and they are programs that take in the proof context
(the hypotheses in scope plus the type of the term to synthesize) and construct
a term of the expected type. For example, <code>simp</code> is a tactic, used in:</p><pre><code>example : 2 + 2 = 4 := by simp
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Category.tactic">Lean.Parser.Category.tactic</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.tactic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.doElem"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L47-L49">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Category.doElem"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">doElem</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p><code><a href=".././Init/Notation.html#Lean.Parser.Category.doElem">doElem</a></code> is a builtin syntax category for elements that can appear in the <code>do</code> notation.
For example, <code>let x ← e</code> is a <code><a href=".././Init/Notation.html#Lean.Parser.Category.doElem">doElem</a></code>, and a <code>do</code> block consists of a list of <code><a href=".././Init/Notation.html#Lean.Parser.Category.doElem">doElem</a></code>s.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Category.doElem">Lean.Parser.Category.doElem</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.doElem" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.structInstFieldDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L51-L53">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Category.structInstFieldDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">structInstFieldDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p><code><a href=".././Init/Notation.html#Lean.Parser.Category.structInstFieldDecl">structInstFieldDecl</a></code> is the syntax category for value declarations for fields in structure instance notation.
For example, the <code>:= 1</code> and <code>| 0 =&gt; 0 | n + 1 =&gt; n</code> in <code>{ x := 1, f | 0 =&gt; 0 | n + 1 =&gt; n }</code> are in the <code><a href=".././Init/Notation.html#Lean.Parser.Category.structInstFieldDecl">structInstFieldDecl</a></code> class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Category.structInstFieldDecl">Lean.Parser.Category.structInstFieldDecl</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.structInstFieldDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.level"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L55-L58">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Category.level"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">level</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p><code><a href=".././Init/Notation.html#Lean.Parser.Category.level">level</a></code> is a builtin syntax category for universe levels.
This is the <code>u</code> in <code>Sort u</code>: it can contain <code>max</code> and <code>imax</code>, addition with
constants, and variables.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Category.level">Lean.Parser.Category.level</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.level" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.attr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L60-L62">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Category.attr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">attr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p><code><a href=".././Init/Notation.html#Lean.Parser.Category.attr">attr</a></code> is a builtin syntax category for attributes.
Declarations can be annotated with attributes using the <code>@[...]</code> notation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Category.attr">Lean.Parser.Category.attr</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.attr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.stx"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L64-L66">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Category.stx"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">stx</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p><code><a href=".././Init/Notation.html#Lean.Parser.Category.stx">stx</a></code> is a builtin syntax category for syntax. This is the abbreviated
parser notation used inside <code>syntax</code> and <code>macro</code> declarations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Category.stx">Lean.Parser.Category.stx</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.stx" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.prio"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L68-L74">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Category.prio"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">prio</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p><code><a href=".././Init/Notation.html#Lean.Parser.Category.prio">prio</a></code> is a builtin syntax category for priorities.
Priorities are used in many different attributes.
Higher numbers denote higher priority, and for example typeclass search will
try high priority instances before low priority.
In addition to literals like <code>37</code>, you can also use <code>low</code>, <code>mid</code>, <code>high</code>, as well as
add and subtract priorities.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Category.prio">Lean.Parser.Category.prio</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.prio" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.prec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L76-L85">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Category.prec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">prec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p><code><a href=".././Init/Notation.html#Lean.Parser.Category.prec">prec</a></code> is a builtin syntax category for precedences. A precedence is a value
that expresses how tightly a piece of syntax binds: for example <code>1 + 2 * 3</code> is
parsed as <code>1 + (2 * 3)</code> because <code>*</code> has a higher precedence than <code>+</code>.
Higher numbers denote higher precedence.
In addition to literals like <code>37</code>, there are some special named precedence levels:</p><ul>
<li><code>arg</code> for the precedence of function arguments</li>
<li><code>max</code> for the highest precedence used in term parsers (not actually the maximum possible value)</li>
<li><code>lead</code> for the precedence of terms not supposed to be used as arguments
and you can also add and subtract precedences.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Category.prec">Lean.Parser.Category.prec</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.prec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>DSL for specifying parser precedences and priorities</p></div><div class="decl" id="Lean.Parser.Syntax.addPrec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L93-L94">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Syntax.addPrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Syntax</span>.<span class="name">addPrec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">TrailingParserDescr</a></div></div><p>Addition of precedences. This is normally used only for offsetting, e.g. <code>max + 1</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Syntax.addPrec">Lean.Parser.Syntax.addPrec</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`Lean.Parser.Syntax.addPrec</span> <span class="fn">65</span> <span class="fn">0</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; + &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`prec</span> <span class="fn">66</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Syntax.addPrec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Syntax.subPrec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L95-L96">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Syntax.subPrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Syntax</span>.<span class="name">subPrec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">TrailingParserDescr</a></div></div><p>Subtraction of precedences. This is normally used only for offsetting, e.g. <code>max - 1</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Syntax.subPrec">Lean.Parser.Syntax.subPrec</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`Lean.Parser.Syntax.subPrec</span> <span class="fn">65</span> <span class="fn">0</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; - &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`prec</span> <span class="fn">66</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Syntax.subPrec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Syntax.addPrio"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L98-L99">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Syntax.addPrio"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Syntax</span>.<span class="name">addPrio</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">TrailingParserDescr</a></div></div><p>Addition of priorities. This is normally used only for offsetting, e.g. <code>default + 1</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Syntax.addPrio">Lean.Parser.Syntax.addPrio</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`Lean.Parser.Syntax.addPrio</span> <span class="fn">65</span> <span class="fn">0</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; + &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`prio</span> <span class="fn">66</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Syntax.addPrio" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Syntax.subPrio"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L100-L101">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Syntax.subPrio"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Syntax</span>.<span class="name">subPrio</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">TrailingParserDescr</a></div></div><p>Subtraction of priorities. This is normally used only for offsetting, e.g. <code>default - 1</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Syntax.subPrio">Lean.Parser.Syntax.subPrio</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`Lean.Parser.Syntax.subPrio</span> <span class="fn">65</span> <span class="fn">0</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; - &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`prio</span> <span class="fn">66</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Syntax.subPrio" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.instCoeOutTSyntaxSyntax"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L105-L106">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.instCoeOutTSyntaxSyntax"><span class="name">Lean</span>.<span class="name">instCoeOutTSyntaxSyntax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ks</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Coe.html#CoeOut">CoeOut</a> <span class="fn">(<a href=".././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">ks</span>)</span> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.instCoeOutTSyntaxSyntax">Lean.instCoeOutTSyntaxSyntax</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Coe.html#CoeOut.mk">{</a> <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">stx</span> : <span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">ks</span></span>) =&gt; <span class="fn"><span class="fn">stx</span>.<a href=".././Init/Prelude.html#Lean.TSyntax.raw">raw</a></span></span> <a href=".././Init/Coe.html#CoeOut.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.instCoeSyntaxNodeKindSyntaxNodeKinds"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L108-L109">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.instCoeSyntaxNodeKindSyntaxNodeKinds"><span class="name">Lean</span>.<span class="name">instCoeSyntaxNodeKindSyntaxNodeKinds</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Coe.html#Coe">Coe</a> <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a> <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.instCoeSyntaxNodeKindSyntaxNodeKinds">Lean.instCoeSyntaxNodeKindSyntaxNodeKinds</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Coe.html#Coe.mk">{</a> <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">k</span> : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a>) =&gt; <a href=".././Init/Prelude.html#List.cons">[</a><span class="fn">k</span><a href=".././Init/Prelude.html#List.cons">]</a></span> <a href=".././Init/Coe.html#Coe.mk">}</a></li></ul></details></div></div><div class="decl" id="precMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L117-L117">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#precMax"><span class="name">precMax</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Maximum precedence used in term parsers, in particular for terms in
function position (<code>ident</code>, <code>paren</code>, ...)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#precMax">precMax</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`precMax</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;max&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-precMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="precArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L119-L119">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#precArg"><span class="name">precArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Precedence used for application arguments (<code>do</code>, <code>by</code>, ...).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#precArg">precArg</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`precArg</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;arg&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-precArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="precLead"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L121-L121">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#precLead"><span class="name">precLead</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Precedence used for terms not supposed to be used as arguments (<code>let</code>, <code>have</code>, ...).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#precLead">precLead</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`precLead</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;lead&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-precLead" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«prec(_)»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L123-L123">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«prec(_)»"><span class="name">«prec(_)»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Parentheses are used for grouping precedence expressions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-«prec(_)»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="precMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L125-L125">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#precMin"><span class="name">precMin</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Minimum precedence used in term parsers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#precMin">precMin</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`precMin</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;min&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-precMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="precMin1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L127-L127">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#precMin1"><span class="name">precMin1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>(min+1)</code> (we can only write <code>min+1</code> after <code>Meta.lean</code>)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#precMin1">precMin1</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`precMin1</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;min1&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-precMin1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="termMax_prec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L132-L132">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#termMax_prec"><span class="name">termMax_prec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>max:prec</code> as a term. It is equivalent to <code>eval_prec max</code> for <code>eval_prec</code> defined at <code>Meta.lean</code>.
We use <code>max_prec</code> to workaround bootstrapping issues.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#termMax_prec">termMax_prec</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`termMax_prec</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;max_prec&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-termMax_prec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="prioDefault"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L135-L135">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#prioDefault"><span class="name">prioDefault</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The default priority <code>default = 1000</code>, which is used when no priority is set.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#prioDefault">prioDefault</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`prioDefault</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;default&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-prioDefault" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="prioLow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L137-L137">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#prioLow"><span class="name">prioLow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The standardized &quot;low&quot; priority <code>low = 100</code>, for things that should be lower than default priority.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#prioLow">prioLow</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`prioLow</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;low&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-prioLow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="prioMid"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L141-L141">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#prioMid"><span class="name">prioMid</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The standardized &quot;medium&quot; priority <code>mid = 500</code>. This is lower than <code>default</code>, and higher than <code>low</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#prioMid">prioMid</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`prioMid</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mid&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-prioMid" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="prioHigh"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L143-L143">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#prioHigh"><span class="name">prioHigh</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The standardized &quot;high&quot; priority <code>high = 10000</code>, for things that should be higher than default priority.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#prioHigh">prioHigh</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`prioHigh</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;high&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-prioHigh" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«prio(_)»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L145-L145">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«prio(_)»"><span class="name">«prio(_)»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Parentheses are used for grouping priority expressions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-«prio(_)»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«stx_+»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L165-L171">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«stx_+»"><span class="name">«stx_+»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>p+</code> is shorthand for <code>many1(p)</code>. It uses parser <code>p</code> 1 or more times, and produces a
<code>nullNode</code> containing the array of parsed results. This parser has arity 1.</p><p>If <code>p</code> has arity more than 1, it is auto-grouped in the items generated by the parser.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«stx_+»">«stx_+»</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«stx_+»</span> <span class="fn">1023</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;+&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-«stx_+»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«stx_*»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L173-L179">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«stx_*»"><span class="name">«stx_*»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>p*</code> is shorthand for <code>many(p)</code>. It uses parser <code>p</code> 0 or more times, and produces a
<code>nullNode</code> containing the array of parsed results. This parser has arity 1.</p><p>If <code>p</code> has arity more than 1, it is auto-grouped in the items generated by the parser.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«stx_*»">«stx_*»</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«stx_*»</span> <span class="fn">1023</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;*&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-«stx_*»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="stx_?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L181-L192">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#stx_?"><span class="name">stx_?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>(p)?</code> is shorthand for <code>optional(p)</code>. It uses parser <code>p</code> 0 or 1 times, and produces a
<code>nullNode</code> containing the array of parsed results. This parser has arity 1.</p><p><code>p</code> is allowed to have arity n &gt; 1 (in which case the node will have either 0 or n children),
but if it has arity 0 then the result will be ambiguous.</p><p>Because <code>?</code> is an identifier character, <code>ident?</code> will not work as intended.
You have to write either <code>ident ?</code> or <code>(ident)?</code> for it to parse as the <code>?</code> combinator
applied to the <code>ident</code> parser.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#stx_?">stx_?</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`stx_?</span> <span class="fn">1023</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;?&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-stx_?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«stx_&lt;|&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L194-L209">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«stx_&lt;|&gt;_»"><span class="name">«stx_&lt;|&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>p1 &lt;|&gt; p2</code> is shorthand for <code>orelse(p1, p2)</code>, and parses either <code>p1</code> or <code>p2</code>.
It does not backtrack, meaning that if <code>p1</code> consumes at least one token then
<code>p2</code> will not be tried. Therefore, the parsers should all differ in their first
token. The <code>atomic(p)</code> parser combinator can be used to locally backtrack a parser.
(For full backtracking, consider using extensible syntax classes instead.)</p><p>On success, if the inner parser does not generate exactly one node, it will be
automatically wrapped in a <code>group</code> node, so the result will always be arity 1.</p><p>The <code>&lt;|&gt;</code> combinator does not generate a node of its own, and in particular
does not tag the inner parsers to distinguish them, which can present a problem
when reconstructing the parse. A well formed <code>&lt;|&gt;</code> parser should use disjoint
node kinds for <code>p1</code> and <code>p2</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«stx_&lt;|&gt;_»">«stx_&lt;|&gt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«stx_&lt;|&gt;_»</span> <span class="fn">2</span> <span class="fn">2</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;|&gt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`stx</span> <span class="fn">1</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«stx_&lt;|&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«stx_,*»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L224-L224">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«stx_,*»"><span class="name">«stx_,*»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>p,*</code> is shorthand for <code>sepBy(p, &quot;,&quot;)</code>. It parses 0 or more occurrences of
<code>p</code> separated by <code>,</code>, that is: <code>empty | p | p,p | p,p,p | ...</code>.</p><p>It produces a <code>nullNode</code> containing a <code>SepArray</code> with the interleaved parser
results. It has arity 1, and auto-groups its component parser if needed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«stx_,*»">«stx_,*»</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«stx_,*»</span> <span class="fn">1023</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;,*&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-«stx_,*»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«stx_,+»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L232-L232">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«stx_,+»"><span class="name">«stx_,+»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>p,+</code> is shorthand for <code>sepBy1(p, &quot;,&quot;)</code>. It parses 1 or more occurrences of
<code>p</code> separated by <code>,</code>, that is: <code>p | p,p | p,p,p | ...</code>.</p><p>It produces a <code>nullNode</code> containing a <code>SepArray</code> with the interleaved parser
results. It has arity 1, and auto-groups its component parser if needed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«stx_,+»">«stx_,+»</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«stx_,+»</span> <span class="fn">1023</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;,+&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-«stx_,+»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«stx_,*,?»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L242-L242">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«stx_,*,?»"><span class="name">«stx_,*,?»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>p,*,?</code> is shorthand for <code>sepBy(p, &quot;,&quot;, allowTrailingSep)</code>.
It parses 0 or more occurrences of <code>p</code> separated by <code>,</code>, possibly including
a trailing <code>,</code>, that is: <code>empty | p | p, | p,p | p,p, | p,p,p | ...</code>.</p><p>It produces a <code>nullNode</code> containing a <code>SepArray</code> with the interleaved parser
results. It has arity 1, and auto-groups its component parser if needed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«stx_,*,?»">«stx_,*,?»</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«stx_,*,?»</span> <span class="fn">1023</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;,*,?&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-«stx_,*,?»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«stx_,+,?»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L252-L252">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«stx_,+,?»"><span class="name">«stx_,+,?»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>p,+,?</code> is shorthand for <code>sepBy1(p, &quot;,&quot;, allowTrailingSep)</code>.
It parses 1 or more occurrences of <code>p</code> separated by <code>,</code>, possibly including
a trailing <code>,</code>, that is: <code>p | p, | p,p | p,p, | p,p,p | ...</code>.</p><p>It produces a <code>nullNode</code> containing a <code>SepArray</code> with the interleaved parser
results. It has arity 1, and auto-groups its component parser if needed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«stx_,+,?»">«stx_,+,?»</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«stx_,+,?»</span> <span class="fn">1023</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;,+,?&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-«stx_,+,?»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="stx!_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L258-L258">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#stx!_"><span class="name">stx!_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>!p</code> parses the negation of <code>p</code>. That is, it fails if <code>p</code> succeeds, and
otherwise parses nothing. It has arity 0.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#stx!_">stx!_</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`stx!_</span> <span class="fn">1023</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;!&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`stx</span> <span class="fn">1024</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-stx!_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="rawNatLit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L260-L270">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#rawNatLit"><span class="name">rawNatLit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>nat_lit n</code> macro constructs &quot;raw numeric literals&quot;. This corresponds to the
<code>Expr.lit (.natVal n)</code> constructor in the <code>Expr</code> data type.</p><p>Normally, when you write a numeral like <code>#check 37</code>, the parser turns this into
an application of <code><a href=".././Init/Prelude.html#OfNat.ofNat">OfNat.ofNat</a></code> to the raw literal <code>37</code> to cast it into the
target type, even if this type is <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> (so the cast is the identity function).
But sometimes it is necessary to talk about the raw numeral directly,
especially when proving properties about the <code>ofNat</code> function itself.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#rawNatLit">rawNatLit</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`rawNatLit</span> <span class="fn">1022</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;nat_lit &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`num</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-rawNatLit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_∘_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L272-L272">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_∘_»"><span class="name">«term_∘_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Function composition, usually written with the infix operator <code>∘</code>. A new function is created from
two existing functions, where one function's output is used as input to the other.</p><p>Examples:</p><ul>
<li><code><a href=".././Init/Prelude.html#Function.comp">Function.comp</a> <a href=".././Init/Data/List/Basic.html#List.reverse">List.reverse</a> (List.drop 2) [3, 2, 4, 1] = [1, 4]</code></li>
<li><code>(List.reverse ∘ <a href=".././Init/Data/List/Basic.html#List.drop">List.drop</a> 2) [3, 2, 4, 1] = [1, 4]</code></li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∘</code> in identifiers is <code>comp</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_∘_»">«term_∘_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_∘_»</span> <span class="fn">90</span> <span class="fn">91</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ∘ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">90</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_∘_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_×_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L273-L273">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_×_»"><span class="name">«term_×_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The product type, usually written <code>α × β</code>. Product types are also called pair or tuple types.
Elements of this type are pairs in which the first element is an <code>α</code> and the second element is a
<code>β</code>.</p><p>Products nest to the right, so <code>(x, y, z) : α × β × γ</code> is equivalent to <code>(x, (y, z)) : α × (β × γ)</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>×</code> in identifiers is <code><a href=".././Init/Prelude.html#Prod">Prod</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_×_»">«term_×_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_×_»</span> <span class="fn">35</span> <span class="fn">36</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; × &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">35</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_×_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_×'_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L274-L274">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_×'_»"><span class="name">«term_×'_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>A product type in which the types may be propositions, usually written <code>α ×' β</code>.</p><p>This type is primarily used internally and as an implementation detail of proof automation. It is
rarely useful in hand-written code.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>×'</code> in identifiers is <code><a href=".././Init/Prelude.html#PProd">PProd</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_×'_»">«term_×'_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_×'_»</span> <span class="fn">35</span> <span class="fn">36</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ×' &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">35</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_×'_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_∣_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L280-L280">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_∣_»"><span class="name">«term_∣_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Divisibility. <code>a ∣ b</code> (typed as <code>\|</code>) means that there is some <code>c</code> such that <code>b = a * c</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∣</code> in identifiers is <code>dvd</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_∣_»">«term_∣_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_∣_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ∣ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_∣_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_|||_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L281-L281">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_|||_»"><span class="name">«term_|||_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ||| b</code> computes the bitwise OR of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>|||</code> in identifiers is <code>or</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_|||_»">«term_|||_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_|||_»</span> <span class="fn">55</span> <span class="fn">55</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ||| &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">56</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_|||_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_^^^_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L282-L282">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_^^^_»"><span class="name">«term_^^^_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ^^^ b</code> computes the bitwise XOR of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>^^^</code> in identifiers is <code>xor</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_^^^_»">«term_^^^_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_^^^_»</span> <span class="fn">58</span> <span class="fn">58</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ^^^ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">59</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_^^^_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&amp;&amp;&amp;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L283-L283">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&amp;&amp;&amp;_»"><span class="name">«term_&amp;&amp;&amp;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a &amp;&amp;&amp; b</code> computes the bitwise AND of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&amp;&amp;&amp;</code> in identifiers is <code>and</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&amp;&amp;&amp;_»">«term_&amp;&amp;&amp;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&amp;&amp;&amp;_»</span> <span class="fn">60</span> <span class="fn">60</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &amp;&amp;&amp; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">61</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&amp;&amp;&amp;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_+_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L284-L284">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_+_»"><span class="name">«term_+_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a + b</code> computes the sum of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>+</code> in identifiers is <code>add</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_+_»">«term_+_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_+_»</span> <span class="fn">65</span> <span class="fn">65</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; + &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">66</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_+_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_-_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L285-L285">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_-_»"><span class="name">«term_-_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a - b</code> computes the difference of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><ul>
<li>For natural numbers, this operator saturates at 0: <code>a - b = 0</code> when <code>a ≤ b</code>.</li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>-</code> in identifiers is <code>sub</code> (when used as a binary operator).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_-_»">«term_-_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_-_»</span> <span class="fn">65</span> <span class="fn">65</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; - &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">66</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_-_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_*_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L286-L286">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_*_»"><span class="name">«term_*_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a * b</code> computes the product of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>*</code> in identifiers is <code>mul</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_*_»">«term_*_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_*_»</span> <span class="fn">70</span> <span class="fn">70</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; * &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">71</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_*_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_/_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L287-L287">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_/_»"><span class="name">«term_/_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a / b</code> computes the result of dividing <code>a</code> by <code>b</code>.
The meaning of this notation is type-dependent.</p><ul>
<li>For most types like <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>, <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code>, <code><a href=".././Init/Data/Rat/Basic.html#Rat">Rat</a></code>, <code>Real</code>, <code>a / 0</code> is defined to be <code>0</code>.</li>
<li>For <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>, <code>a / b</code> rounds downwards.</li>
<li>For <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code>, <code>a / b</code> rounds downwards if <code>b</code> is positive or upwards if <code>b</code> is negative.
It is implemented as <code><a href=".././Init/Data/Int/DivMod/Basic.html#Int.ediv">Int.ediv</a></code>, the unique function satisfying
<code>a % b + b * (a / b) = a</code> and <code>0 ≤ a % b &lt; natAbs b</code> for <code>b ≠ 0</code>.
Other rounding conventions are available using the functions
<code><a href=".././Init/Data/Int/DivMod/Basic.html#Int.fdiv">Int.fdiv</a></code> (floor rounding) and <code><a href=".././Init/Data/Int/DivMod/Basic.html#Int.tdiv">Int.tdiv</a></code> (truncation rounding).</li>
<li>For <code><a href=".././Init/Data/Float.html#Float">Float</a></code>, <code>a / 0</code> follows the IEEE 754 semantics for division,
usually resulting in <code>inf</code> or <code>nan</code>.</li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>/</code> in identifiers is <code>div</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_/_»">«term_/_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_/_»</span> <span class="fn">70</span> <span class="fn">70</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; / &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">71</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_/_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_%_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L288-L288">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_%_»"><span class="name">«term_%_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a % b</code> computes the remainder upon dividing <code>a</code> by <code>b</code>.
The meaning of this notation is type-dependent.</p><ul>
<li>For <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> and <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code> it satisfies <code>a % b + b * (a / b) = a</code>,
and <code>a % 0</code> is defined to be <code>a</code>.</li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>%</code> in identifiers is <code>mod</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_%_»">«term_%_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_%_»</span> <span class="fn">70</span> <span class="fn">70</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; % &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">71</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_%_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&lt;&lt;&lt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L289-L289">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&lt;&lt;&lt;_»"><span class="name">«term_&lt;&lt;&lt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a &lt;&lt;&lt; b</code> computes <code>a</code> shifted to the left by <code>b</code> places.
The meaning of this notation is type-dependent.</p><ul>
<li>On <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>, this is equivalent to <code>a * 2 ^ b</code>.</li>
<li>On <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code> and other fixed width unsigned types, this is the same but
truncated to the bit width.</li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;&lt;&lt;</code> in identifiers is <code>shiftLeft</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&lt;&lt;&lt;_»">«term_&lt;&lt;&lt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;&lt;&lt;_»</span> <span class="fn">75</span> <span class="fn">75</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;&lt;&lt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">76</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;&lt;&lt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&gt;&gt;&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L290-L290">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&gt;&gt;&gt;_»"><span class="name">«term_&gt;&gt;&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a &gt;&gt;&gt; b</code> computes <code>a</code> shifted to the right by <code>b</code> places.
The meaning of this notation is type-dependent.</p><ul>
<li>On <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> and fixed width unsigned types like <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code>,
this is equivalent to <code>a / 2 ^ b</code>.</li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&gt;&gt;&gt;</code> in identifiers is <code>shiftRight</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&gt;&gt;&gt;_»">«term_&gt;&gt;&gt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&gt;&gt;&gt;_»</span> <span class="fn">75</span> <span class="fn">75</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &gt;&gt;&gt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">76</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&gt;&gt;&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_^_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L291-L291">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_^_»"><span class="name">«term_^_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ^ b</code> computes <code>a</code> to the power of <code>b</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>^</code> in identifiers is <code>pow</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_^_»">«term_^_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_^_»</span> <span class="fn">80</span> <span class="fn">81</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ^ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">80</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_^_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_++_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L292-L292">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_++_»"><span class="name">«term_++_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ++ b</code> is the result of concatenation of <code>a</code> and <code>b</code>, usually read &quot;append&quot;.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>++</code> in identifiers is <code>append</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_++_»">«term_++_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_++_»</span> <span class="fn">65</span> <span class="fn">65</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ++ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">66</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_++_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term-_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L293-L293">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term-_»"><span class="name">«term-_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>-a</code> computes the negative or opposite of <code>a</code>.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>-</code> in identifiers is <code>neg</code> (when used as a unary operator).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term-_»">«term-_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`«term-_»</span> <span class="fn">75</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;-&quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">75</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term-_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term~~~_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L294-L294">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term~~~_»"><span class="name">«term~~~_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The implementation of <code>~~~a : α</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>~~~</code> in identifiers is <code>not</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term~~~_»">«term~~~_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`«term~~~_»</span> <span class="fn">100</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;~~~&quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">100</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term~~~_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_⁻¹»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L295-L295">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_⁻¹»"><span class="name">«term_⁻¹»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a⁻¹</code> computes the inverse of <code>a</code>.
The meaning of this notation is type-dependent.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_⁻¹»">«term_⁻¹»</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_⁻¹»</span> <span class="fn">1024</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;⁻¹&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-«term_⁻¹»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_•_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L296-L296">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_•_»"><span class="name">«term_•_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a • b</code> computes the product of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent, but it is intended to be used for left actions.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>•</code> in identifiers is <code>smul</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_•_»">«term_•_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_•_»</span> <span class="fn">73</span> <span class="fn">74</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; • &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">73</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_•_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>Remark: the infix commands above ensure a delaborator is generated for each relations.
We redefine the macros below to be able to use the auxiliary <code>binop%</code> elaboration helper for binary operators.
It addresses issue #382.</p></div><div class="mod_doc"><p>We have a macro to make <code>x • y</code> notation participate in the expression tree elaborator,
like other arithmetic expressions such as <code>+</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>=</code>, inequalities, etc.
The macro is using the <code>leftact%</code> elaborator introduced in
<a href="https://github.com/leanprover/lean4/issues/2854">this RFC</a>.</p><p>As a concrete example of the effect of this macro, consider</p><pre><code class="language-lean">variable [Ring R] [AddCommMonoid M] [Module R M] (r : R) (N : Submodule R M) (m : M) (n : N)
#check m + r • n
</code></pre><p>Without the macro, the expression would elaborate as <code>m + ↑(r • n : ↑N) : M</code>.
With the macro, the expression elaborates as <code>m + r • (↑n : M) : M</code>.
To get the first interpretation, one can write <code>m + (r • n :)</code>.</p><p>Here is a quick review of the expression tree elaborator:</p><ol>
<li>It builds up an expression tree of all the immediately accessible operations
that are marked with <code>binop%</code>, <code>unop%</code>, <code>leftact%</code>, <code>rightact%</code>, <code>binrel%</code>, etc.</li>
<li>It elaborates every leaf term of this tree
(without an expected type, so as if it were temporarily wrapped in <code>(... :)</code>).</li>
<li>Using the types of each elaborated leaf, it computes a supremum type they can all be
coerced to, if such a supremum exists.</li>
<li>It inserts coercions around leaf terms wherever needed.</li>
</ol><p>The hypothesis is that individual expression trees tend to be calculations with respect
to a single algebraic structure.</p><p>Note(kmill): If we were to remove <code><a href=".././Init/Prelude.html#HSMul">HSMul</a></code> and switch to using <code><a href=".././Init/Prelude.html#SMul">SMul</a></code> directly,
then the expression tree elaborator would not be able to insert coercions within the right operand;
they would likely appear as <code>↑(x • y)</code> rather than <code>x • ↑y</code>, unlike other arithmetic operations.</p></div><div class="decl" id="«term_&lt;=_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L370-L370">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&lt;=_»"><span class="name">«term_&lt;=_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The less-equal relation: <code>x ≤ y</code></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;=</code> in identifiers is <code>le</code> (prefer <code>≤</code> over <code>&lt;=</code>).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&lt;=_»">«term_&lt;=_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;=_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;= &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;=_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_≤_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L371-L371">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_≤_»"><span class="name">«term_≤_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The less-equal relation: <code>x ≤ y</code></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>≤</code> in identifiers is <code>le</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_≤_»">«term_≤_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_≤_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ≤ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_≤_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&lt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L372-L372">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&lt;_»"><span class="name">«term_&lt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The less-than relation: <code>x &lt; y</code></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;</code> in identifiers is <code>lt</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&lt;_»">«term_&lt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&gt;=_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L373-L373">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&gt;=_»"><span class="name">«term_&gt;=_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ≥ b</code> is an abbreviation for <code>b ≤ a</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&gt;=</code> in identifiers is <code>ge</code> (prefer <code>≥</code> over <code>&gt;=</code>).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&gt;=_»">«term_&gt;=_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&gt;=_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &gt;= &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&gt;=_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_≥_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L374-L374">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_≥_»"><span class="name">«term_≥_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ≥ b</code> is an abbreviation for <code>b ≤ a</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>≥</code> in identifiers is <code>ge</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_≥_»">«term_≥_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_≥_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ≥ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_≥_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L375-L375">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&gt;_»"><span class="name">«term_&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a &gt; b</code> is an abbreviation for <code>b &lt; a</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&gt;</code> in identifiers is <code>gt</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&gt;_»">«term_&gt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&gt;_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &gt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_=_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L376-L376">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_=_»"><span class="name">«term_=_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The equality relation. It has one introduction rule, <code><a href=".././Init/Prelude.html#Eq.refl">Eq.refl</a></code>.
We use <code>a = b</code> as notation for <code><a href=".././Init/Prelude.html#Eq">Eq</a> a b</code>.
A fundamental property of equality is that it is an equivalence relation.</p><pre><code>variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  <a href=".././Init/Prelude.html#Eq.trans">Eq.trans</a> (Eq.trans hab (Eq.symm hcb)) hcd
</code></pre><p>Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given <code>h1 : a = b</code> and <code>h2 : p a</code>, we can construct a proof for <code>p b</code> using substitution: <code><a href=".././Init/Prelude.html#Eq.subst">Eq.subst</a> h1 h2</code>.
Example:</p><pre><code>example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  <a href=".././Init/Prelude.html#Eq.subst">Eq.subst</a> h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
</code></pre><p>The triangle in the second presentation is a macro built on top of <code><a href=".././Init/Prelude.html#Eq.subst">Eq.subst</a></code> and <code><a href=".././Init/Prelude.html#Eq.symm">Eq.symm</a></code>, and you can enter it by typing <code>\t</code>.
For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>=</code> in identifiers is <code>eq</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_=_»">«term_=_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_=_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; = &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_=_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_==_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L377-L377">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_==_»"><span class="name">«term_==_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Boolean equality, notated as <code>a == b</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>==</code> in identifiers is <code>beq</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_==_»">«term_==_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_==_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; == &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_==_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_≍_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L378-L378">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_≍_»"><span class="name">«term_≍_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Heterogeneous equality. <code>a ≍ b</code> asserts that <code>a</code> and <code>b</code> have the same
type, and casting <code>a</code> across the equality yields <code>b</code>, and vice versa.</p><p>You should avoid using this type if you can. Heterogeneous equality does not
have all the same properties as <code><a href=".././Init/Prelude.html#Eq">Eq</a></code>, because the assumption that the types of
<code>a</code> and <code>b</code> are equal is often too weak to prove theorems of interest. One
public important non-theorem is the analogue of <code><a href=".././Init/Prelude.html#congr">congr</a></code>: If <code>f ≍ g</code> and <code>x ≍ y</code>
and <code>f x</code> and <code>g y</code> are well typed it does not follow that <code>f x ≍ g y</code>.
(This does follow if you have <code>f = g</code> instead.) However if <code>a</code> and <code>b</code> have
the same type then <code>a = b</code> and <code>a ≍ b</code> are equivalent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>≍</code> in identifiers is <code>heq</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_≍_»">«term_≍_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_≍_»</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ≍ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_≍_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>Remark: the infix commands above ensure a delaborator is generated for each relations.
We redefine the macros below to be able to use the auxiliary <code>binrel%</code> elaboration helper for binary relations.
It has better support for applying coercions. For example, suppose we have <code>binrel% <a href=".././Init/Prelude.html#Eq">Eq</a> n i</code> where <code>n : <a href=".././Init/Prelude.html#Nat">Nat</a></code> and
<code>i : <a href=".././Init/Data/Int/Basic.html#Int">Int</a></code>. The default elaborator fails because we don't have a coercion from <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code> to <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>, but
<code>binrel%</code> succeeds because it also tries a coercion from <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> to <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code> even when the nat occurs before the int.</p></div><div class="decl" id="«term_/\_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L407-L407">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_/\_»"><span class="name">«term_/\_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code><a href=".././Init/Prelude.html#And">And</a> a b</code>, or <code>a ∧ b</code>, is the conjunction of propositions. It can be
constructed and destructed like a pair: if <code>ha : a</code> and <code>hb : b</code> then
<code>⟨ha, hb⟩ : a ∧ b</code>, and if <code>h : a ∧ b</code> then <code>h.left : a</code> and <code>h.right : b</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>/\</code> in identifiers is <code>and</code> (prefer <code>∧</code> over <code>/\</code>).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_/\_»">«term_/\_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_/\_»</span> <span class="fn">35</span> <span class="fn">36</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; /\\ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">35</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_/\_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_∧_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L408-L408">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_∧_»"><span class="name">«term_∧_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code><a href=".././Init/Prelude.html#And">And</a> a b</code>, or <code>a ∧ b</code>, is the conjunction of propositions. It can be
constructed and destructed like a pair: if <code>ha : a</code> and <code>hb : b</code> then
<code>⟨ha, hb⟩ : a ∧ b</code>, and if <code>h : a ∧ b</code> then <code>h.left : a</code> and <code>h.right : b</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∧</code> in identifiers is <code>and</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_∧_»">«term_∧_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_∧_»</span> <span class="fn">35</span> <span class="fn">36</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ∧ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">35</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_∧_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_\/_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L409-L409">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_\/_»"><span class="name">«term_\/_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code><a href=".././Init/Prelude.html#Or">Or</a> a b</code>, or <code>a ∨ b</code>, is the disjunction of propositions. There are two
constructors for <code><a href=".././Init/Prelude.html#Or">Or</a></code>, called <code><a href=".././Init/Prelude.html#Or.inl">Or.inl</a> : a → a ∨ b</code> and <code><a href=".././Init/Prelude.html#Or.inr">Or.inr</a> : b → a ∨ b</code>,
and you can use <code>match</code> or <code>cases</code> to destruct an <code><a href=".././Init/Prelude.html#Or">Or</a></code> assumption into the
two cases.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>\/</code> in identifiers is <code>or</code> (prefer <code>∨</code> over <code>\/</code>).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_\/_»">«term_\/_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_\/_»</span> <span class="fn">30</span> <span class="fn">31</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; \\/ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">30</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_\/_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_∨_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L410-L410">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_∨_»"><span class="name">«term_∨_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code><a href=".././Init/Prelude.html#Or">Or</a> a b</code>, or <code>a ∨ b</code>, is the disjunction of propositions. There are two
constructors for <code><a href=".././Init/Prelude.html#Or">Or</a></code>, called <code><a href=".././Init/Prelude.html#Or.inl">Or.inl</a> : a → a ∨ b</code> and <code><a href=".././Init/Prelude.html#Or.inr">Or.inr</a> : b → a ∨ b</code>,
and you can use <code>match</code> or <code>cases</code> to destruct an <code><a href=".././Init/Prelude.html#Or">Or</a></code> assumption into the
two cases.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∨</code> in identifiers is <code>or</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_∨_»">«term_∨_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_∨_»</span> <span class="fn">30</span> <span class="fn">31</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ∨  &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">30</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_∨_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term¬_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L411-L411">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term¬_»"><span class="name">«term¬_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Prelude.html#Not">Not</a> p</code>, or <code>¬p</code>, is the negation of <code>p</code>. It is defined to be <code>p → <a href=".././Init/Prelude.html#False">False</a></code>,
so if your goal is <code>¬p</code> you can use <code>intro h</code> to turn the goal into
<code>h : p ⊢ <a href=".././Init/Prelude.html#False">False</a></code>, and if you have <code>hn : ¬p</code> and <code>h : p</code> then <code>hn h : <a href=".././Init/Prelude.html#False">False</a></code>
and <code>(hn h).elim</code> will prove anything.
For more information: <a href="https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic">Propositional Logic</a></p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>¬</code> in identifiers is <code>not</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term¬_»">«term¬_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`«term¬_»</span> <span class="fn">1024</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;¬&quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">40</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term¬_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&amp;&amp;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L421-L421">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&amp;&amp;_»"><span class="name">«term_&amp;&amp;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Boolean “and”, also known as conjunction. <code>and x y</code> can be written <code>x &amp;&amp; y</code>.</p><p>The corresponding propositional connective is <code><a href=".././Init/Prelude.html#And">And</a> : Prop → Prop → Prop</code>, written with the <code>∧</code>
operator.</p><p>The Boolean <code>and</code> is a <code>@[macro_inline]</code> function in order to give it short-circuiting evaluation:
if <code>x</code> is <code>false</code> then <code>y</code> is not evaluated at runtime.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&amp;&amp;</code> in identifiers is <code>and</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&amp;&amp;_»">«term_&amp;&amp;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&amp;&amp;_»</span> <span class="fn">35</span> <span class="fn">35</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &amp;&amp; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">36</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&amp;&amp;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_||_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L422-L422">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_||_»"><span class="name">«term_||_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Boolean “or”, also known as disjunction. <code>or x y</code> can be written <code>x || y</code>.</p><p>The corresponding propositional connective is <code><a href=".././Init/Prelude.html#Or">Or</a> : Prop → Prop → Prop</code>, written with the <code>∨</code>
operator.</p><p>The Boolean <code>or</code> is a <code>@[macro_inline]</code> function in order to give it short-circuiting evaluation:
if <code>x</code> is <code>true</code> then <code>y</code> is not evaluated at runtime.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>||</code> in identifiers is <code>or</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_||_»">«term_||_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_||_»</span> <span class="fn">30</span> <span class="fn">30</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; || &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">31</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_||_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="term!_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L423-L423">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#term!_"><span class="name">term!_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Boolean negation, also known as Boolean complement. <code>not x</code> can be written <code>!x</code>.</p><p>This is a function that maps the value <code>true</code> to <code>false</code> and the value <code>false</code> to <code>true</code>. The
propositional connective is <code><a href=".././Init/Prelude.html#Not">Not</a> : Prop → Prop</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>!</code> in identifiers is <code>not</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#term!_">term!_</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`term!_</span> <span class="fn">1024</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;!&quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">40</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-term!_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_∈_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L429-L429">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_∈_»"><span class="name">«term_∈_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The membership relation <code>a ∈ s : Prop</code> where <code>a : α</code>, <code>s : γ</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∈</code> in identifiers is <code>mem</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_∈_»">«term_∈_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_∈_»</span> <span class="fn">50</span> <span class="fn">50</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ∈ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">50</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_∈_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_∉_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L430-L431">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_∉_»"><span class="name">«term_∉_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ∉ b</code> is negated elementhood. It is notation for <code>¬ (a ∈ b)</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>∉</code> in identifiers is <code>notMem</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_∉_»">«term_∉_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_∉_»</span> <span class="fn">50</span> <span class="fn">50</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ∉ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">50</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_∉_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_::_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L436-L436">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_::_»"><span class="name">«term_::_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The list whose first element is <code>head</code>, where <code>tail</code> is the rest of the list.
Usually written <code>head :: tail</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>::</code> in identifiers is <code>cons</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_::_»">«term_::_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_::_»</span> <span class="fn">67</span> <span class="fn">68</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; :: &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">67</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_::_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&lt;$&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L437-L437">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&lt;$&gt;_»"><span class="name">«term_&lt;$&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Applies a function inside a functor. This is used to overload the <code>&lt;$&gt;</code> operator.</p><p>When mapping a constant function, use <code><a href=".././Init/Prelude.html#Functor.mapConst">Functor.mapConst</a></code> instead, because it may be more
efficient.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;$&gt;</code> in identifiers is <code>map</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&lt;$&gt;_»">«term_&lt;$&gt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;$&gt;_»</span> <span class="fn">100</span> <span class="fn">101</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;$&gt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">100</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;$&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&gt;&gt;=_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L438-L438">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&gt;&gt;=_»"><span class="name">«term_&gt;&gt;=_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Sequences two computations, allowing the second to depend on the value computed by the first.</p><p>If <code>x : m α</code> and <code>f : α → m β</code>, then <code>x &gt;&gt;= f : m β</code> represents the result of executing <code>x</code> to get
a value of type <code>α</code> and then passing it to <code>f</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&gt;&gt;=</code> in identifiers is <code>bind</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&gt;&gt;=_»">«term_&gt;&gt;=_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&gt;&gt;=_»</span> <span class="fn">55</span> <span class="fn">55</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &gt;&gt;= &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">56</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&gt;&gt;=_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&lt;|&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L439-L439">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&lt;|&gt;_»"><span class="name">«term_&lt;|&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a &lt;|&gt; b</code> executes <code>a</code> and returns the result, unless it fails in which
case it executes and returns <code>b</code>. Because <code>b</code> is not always executed, it
is passed as a thunk so it can be forced only when needed.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;|&gt;</code> in identifiers is <code>orElse</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&lt;|&gt;_»">«term_&lt;|&gt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;|&gt;_»</span> <span class="fn">20</span> <span class="fn">21</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;|&gt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">20</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;|&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&gt;&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L440-L440">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&gt;&gt;_»"><span class="name">«term_&gt;&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a &gt;&gt; b</code> executes <code>a</code>, ignores the result, and then executes <code>b</code>.
If <code>a</code> fails then <code>b</code> is not executed. Because <code>b</code> is not always executed, it
is passed as a thunk so it can be forced only when needed.
The meaning of this notation is type-dependent.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&gt;&gt;</code> in identifiers is <code>andThen</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&gt;&gt;_»">«term_&gt;&gt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&gt;&gt;_»</span> <span class="fn">60</span> <span class="fn">61</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &gt;&gt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">60</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&gt;&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&lt;*&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L441-L441">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&lt;*&gt;_»"><span class="name">«term_&lt;*&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The implementation of the <code>&lt;*&gt;</code> operator.</p><p>In a monad, <code>mf &lt;*&gt; mx</code> is the same as <code>do let f ← mf; x ← mx; pure (f x)</code>: it evaluates the
function first, then the argument, and applies one to the other.</p><p>To avoid surprising evaluation semantics, <code>mx</code> is taken &quot;lazily&quot;, using a <code><a href=".././Init/Prelude.html#Unit">Unit</a> → f α</code> function.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;*&gt;</code> in identifiers is <code>seq</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&lt;*&gt;_»">«term_&lt;*&gt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;*&gt;_»</span> <span class="fn">60</span> <span class="fn">60</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;*&gt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">61</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;*&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&lt;*_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L442-L442">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&lt;*_»"><span class="name">«term_&lt;*_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Sequences the effects of two terms, discarding the value of the second. This function is usually
invoked via the <code>&lt;*</code> operator.</p><p>Given <code>x : f α</code> and <code>y : f β</code>, <code>x &lt;* y</code> runs <code>x</code>, then runs <code>y</code>, and finally returns the result of
<code>x</code>.</p><p>The evaluation of the second argument is delayed by wrapping it in a function, enabling
“short-circuiting” behavior from <code>f</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>&lt;*</code> in identifiers is <code>seqLeft</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&lt;*_»">«term_&lt;*_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;*_»</span> <span class="fn">60</span> <span class="fn">60</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;* &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">61</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;*_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_*&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L443-L443">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_*&gt;_»"><span class="name">«term_*&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Sequences the effects of two terms, discarding the value of the first. This function is usually
invoked via the <code>*&gt;</code> operator.</p><p>Given <code>x : f α</code> and <code>y : f β</code>, <code>x *&gt; y</code> runs <code>x</code>, then runs <code>y</code>, and finally returns the result of
<code>y</code>.</p><p>The evaluation of the second argument is delayed by wrapping it in a function, enabling
“short-circuiting” behavior from <code>f</code>.</p><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>*&gt;</code> in identifiers is <code>seqRight</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_*&gt;_»">«term_*&gt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_*&gt;_»</span> <span class="fn">60</span> <span class="fn">60</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; *&gt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">61</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_*&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.binderIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L462-L466">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.binderIdent"><span class="name">Lean</span>.<span class="name">binderIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href=".././Init/Notation.html#Lean.binderIdent">binderIdent</a></code> matches an <code>ident</code> or a <code>_</code>. It is used for identifiers in binding
position, where <code>_</code> means that the value should be left unnamed and inaccessible.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;binderIdent&quot;</span> <span class="fn">`Lean.binderIdent</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`hole</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.binderIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.caseArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L470-L474">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Tactic.caseArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">caseArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>A case tag argument has the form <code>tag x₁ ... xₙ</code>; it refers to tag <code>tag</code> and renames
the last <code>n</code> hypotheses to <code>x₁ ... xₙ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.caseArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="termDepIfThenElse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L479-L481">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#termDepIfThenElse"><span class="name">termDepIfThenElse</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>&quot;Dependent&quot; if-then-else, normally written via the notation <code>if h : c then t(h) else e(h)</code>,
is sugar for <code><a href=".././Init/Prelude.html#dite">dite</a> c (fun h =&gt; t(h)) (fun h =&gt; e(h))</code>, and it is the same as
<code>if c then t else e</code> except that <code>t</code> is allowed to depend on a proof <code>h : c</code>,
and <code>e</code> can depend on <code>h : ¬c</code>. (Both branches use the same name for the hypothesis,
even though it has different types in the two cases.)</p><p>We use this to be able to communicate the if-then-else condition to the branches.
For example, <code>Array.get arr i h</code> expects a proof <code>h : i &lt; arr.size</code> in order to
avoid a bounds check, so you can write <code>if h : i &lt; arr.size then arr.get i h else ...</code>
to avoid the bounds check inside the if branch. (Of course in this case we have only
lifted the check into an explicit <code>if</code>, but we could also use this proof multiple times
or derive <code>i &lt; arr.size</code> from some other proposition that we are checking in the <code>if</code>.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-termDepIfThenElse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="termIfThenElse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L491-L493">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#termIfThenElse"><span class="name">termIfThenElse</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>if c then t else e</code> is notation for <code><a href=".././Init/Prelude.html#ite">ite</a> c t e</code>, &quot;if-then-else&quot;, which decides to
return <code>t</code> or <code>e</code> depending on whether <code>c</code> is true or false. The explicit argument
<code>c : Prop</code> does not have any actual computational content, but there is an additional
<code>[Decidable c]</code> argument synthesized by typeclass inference which actually
determines how to evaluate <code>c</code> to true or false. Write <code>if h : c then t else e</code>
instead for a &quot;dependent if-then-else&quot; <code><a href=".././Init/Prelude.html#dite">dite</a></code>, which allows <code>t</code>/<code>e</code> to use the fact
that <code>c</code> is true/false.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-termIfThenElse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="termIfLet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L500-L512">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#termIfLet"><span class="name">termIfLet</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>if let pat := d then t else e</code> is a shorthand syntax for:</p><pre><code>match d with
| pat =&gt; t
| _ =&gt; e
</code></pre><p>It matches <code>d</code> against the pattern <code>pat</code> and the bindings are available in <code>t</code>.
If the pattern does not match, it returns <code>e</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-termIfLet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="boolIfThenElse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L518-L520">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#boolIfThenElse"><span class="name">boolIfThenElse</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The conditional function.</p><p><code><a href=".././Init/Prelude.html#cond">cond</a> c x y</code> is the same as <code>if c then x else y</code>, but optimized for a Boolean condition rather than
a decidable proposition. It can also be written using the notation <code>bif c then x else y</code>.</p><p>Just like <code><a href=".././Init/Prelude.html#ite">ite</a></code>, <code><a href=".././Init/Prelude.html#cond">cond</a></code> is declared <code>@[macro_inline]</code>, which causes applications of <code><a href=".././Init/Prelude.html#cond">cond</a></code> to be
unfolded. As a result, <code>x</code> and <code>y</code> are not evaluated at runtime until one of them is selected, and
only the selected branch is evaluated.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-boolIfThenElse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_&lt;|_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L525-L530">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_&lt;|_»"><span class="name">«term_&lt;|_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Haskell-like pipe operator <code>&lt;|</code>. <code>f &lt;| x</code> means the same as the same as <code>f x</code>,
except that it parses <code>x</code> with lower precedence, which means that <code>f &lt;| g &lt;| x</code>
is interpreted as <code>f (g x)</code> rather than <code>(f g) x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_&lt;|_»">«term_&lt;|_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_&lt;|_»</span> <span class="fn">10</span> <span class="fn">0</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;| &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">10</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_&lt;|_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_|&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L549-L553">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_|&gt;_»"><span class="name">«term_|&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Haskell-like pipe operator <code>|&gt;</code>. <code>x |&gt; f</code> means the same as <code>f x</code>,
and it chains such that <code>x |&gt; f |&gt; g</code> is interpreted as <code>g (f x)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#«term_|&gt;_»">«term_|&gt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_|&gt;_»</span> <span class="fn">10</span> <span class="fn">0</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; |&gt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">11</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_|&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_$__»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L559-L565">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term_$__»"><span class="name">«term_$__»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Alternative syntax for <code>&lt;|</code>. <code>f $ x</code> means the same as the same as <code>f x</code>,
except that it parses <code>x</code> with lower precedence, which means that <code>f $ g $ x</code>
is interpreted as <code>f (g x)</code> rather than <code>(f g) x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-«term_$__»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term{_:_//_}»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L584-L584">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#«term{_:_//_}»"><span class="name">«term{_:_//_}»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>All the elements of a type that satisfy a predicate.</p><p><code><a href=".././Init/Prelude.html#Subtype">Subtype</a> p</code>, usually written <code>{ x : α // p x }</code> or <code>{ x // p x }</code>, contains all elements <code>x : α</code> for
which <code>p x</code> is true. Its constructor is a pair of the value and the proof that it satisfies the
predicate. In run-time code, <code>{ x : α // p x }</code> is represented identically to <code>α</code>.</p><p>There is a coercion from <code>{ x : α // p x }</code> to <code>α</code>, so elements of a subtype may be used where the
underlying type is expected.</p><p>Examples:</p><ul>
<li><code>{ n : <a href=".././Init/Prelude.html#Nat">Nat</a> // n % 2 = 0 }</code> is the type of even numbers.</li>
<li><code>{ xs : <a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#String">String</a> // xs.size = 5 }</code> is the type of arrays with five <code><a href=".././Init/Prelude.html#String">String</a></code>s.</li>
<li>Given <code>xs : <a href=".././Init/Prelude.html#List">List</a> α</code>, <code><a href=".././Init/Prelude.html#List">List</a> { x : α // x ∈ xs }</code> is the type of lists in which all elements are
contained in <code>xs</code>.</li>
</ul><p>Conventions for notations in identifiers:</p><ul>
<li>The recommended spelling of <code>{ x // p x }</code> in identifiers is <code>subtype</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-«term{_:_//_}»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="termWithout_expected_type_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L597-L597">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#termWithout_expected_type_"><span class="name">termWithout_expected_type_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>without_expected_type t</code> instructs Lean to elaborate <code>t</code> without an expected type.
Recall that terms such as <code>match ... with ...</code> and <code>⟨...⟩</code> will postpone elaboration until
expected type is known. So, <code>without_expected_type</code> is not effective in this case.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-termWithout_expected_type_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.byElab"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L601-L607">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.byElab"><span class="name">Lean</span>.<span class="name">byElab</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><ul>
<li>The <code>by_elab doSeq</code> expression runs the <code>doSeq</code> as a <code>TermElabM Expr</code> to
synthesize the expression.</li>
<li><code>by_elab fun expectedType? =&gt; do doSeq</code> receives the expected type (an <code><a href=".././Init/Prelude.html#Option">Option</a> Expr</code>)
as well.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.byElab">Lean.byElab</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.byElab</span> <span class="fn">1022</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;by_elab &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`doSeq</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.byElab" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.rawStx"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L609-L613">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.Category.rawStx"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">rawStx</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><p>Category for carrying raw syntax trees between macros; any content is printed as is by the pretty printer.
The only accepted parser for this category is an antiquotation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.Category.rawStx">Lean.Parser.Category.rawStx</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.rawStx" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.rawStx.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L609-L613">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.rawStx.quot"><span class="name">Lean</span>.<span class="name">rawStx</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.rawStx.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L615-L616">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil"><span class="name">Lean</span>.<span class="name">instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Coe.html#Coe">Coe</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> (<a href=".././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`rawStx</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil">Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Coe.html#Coe.mk">{</a> <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">stx</span> : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>) =&gt; <a href=".././Init/Prelude.html#Lean.TSyntax.mk">{</a> <span class="fn">raw</span> := <span class="fn">stx</span> <a href=".././Init/Prelude.html#Lean.TSyntax.mk">}</a></span> <a href=".././Init/Coe.html#Coe.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.withAnnotateTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L618-L619">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.withAnnotateTerm"><span class="name">Lean</span>.<span class="name">withAnnotateTerm</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>with_annotate_term <a href=".././Init/Notation.html#Lean.Parser.Category.stx">stx</a> e</code> annotates the lexical range of <code><a href=".././Init/Notation.html#Lean.Parser.Category.stx">stx</a> : Syntax</code> with term info for <code>e</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.withAnnotateTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.modCast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L621-L622">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.modCast"><span class="name">Lean</span>.<span class="name">modCast</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Normalize casts in an expression using the same method as the <code>norm_cast</code> tactic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.modCast">Lean.modCast</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.modCast</span> <span class="fn">1022</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;mod_cast &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.modCast" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.deprecated"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L624-L634">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.deprecated"><span class="name">Lean</span>.<span class="name">deprecated</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The attribute <code>@[deprecated]</code> on a declaration indicates that the declaration
is discouraged for use in new code, and/or should be migrated away from in
existing code. It may be removed in a future version of the library.</p><ul>
<li><code>@[deprecated myBetterDef]</code> means that <code>myBetterDef</code> is the suggested replacement.</li>
<li><code>@[deprecated myBetterDef &quot;use myBetterDef instead&quot;]</code> allows customizing the deprecation message.</li>
<li><code>@[deprecated (since := &quot;2024-04-21&quot;)]</code> records when the deprecation was first applied.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.deprecated" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Attr.coe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L636-L641">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Attr.coe"><span class="name">Lean</span>.<span class="name">Attr</span>.<span class="name">coe</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>@[coe]</code> attribute on a function (which should also appear in a
<code>instance : <a href=".././Init/Coe.html#Coe">Coe</a> A B := ⟨myFn⟩</code> declaration) allows the delaborator to show
applications of this function as <code>↑</code> when printing expressions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Attr.coe">Lean.Attr.coe</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Attr.coe</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;coe&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Attr.coe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.command_code_action"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L643-L655">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.command_code_action"><span class="name">Lean</span>.<span class="name">command_code_action</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>This attribute marks a code action that triggers on specific commands.</p><ul>
<li><p><code>@[command_code_action kind]</code>: This is a code action which applies to applications of the command
<code>kind</code> (a command syntax kind), which can replace the command or insert things before or after it.</p>
</li>
<li><p><code>@[command_code_action kind₁ kind₂]</code>: shorthand for
<code>@[command_code_action kind₁, <a href=".././Init/Notation.html#Lean.command_code_action">command_code_action</a> kind₂]</code>.</p>
</li>
<li><p><code>@[command_code_action]</code>: This is a command code action that applies to all commands.
Use sparingly.</p>
</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.command_code_action" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.builtin_command_code_action"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L657-L660">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.builtin_command_code_action"><span class="name">Lean</span>.<span class="name">builtin_command_code_action</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Builtin command code action. See <code><a href=".././Init/Notation.html#Lean.command_code_action">command_code_action</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.builtin_command_code_action" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.includeStr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L662-L667">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.includeStr"><span class="name">Lean</span>.<span class="name">includeStr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>When <code>parent_dir</code> contains the current Lean file, <code>include_str &quot;path&quot; / &quot;to&quot; / &quot;file&quot;</code> becomes
a string literal with the contents of the file at <code>&quot;parent_dir&quot; / &quot;path&quot; / &quot;to&quot; / &quot;file&quot;</code>. If this
file cannot be read, elaboration fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.includeStr">Lean.includeStr</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.includeStr</span> <span class="fn">1022</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;include_str &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.includeStr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.runCmd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L669-L673">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.runCmd"><span class="name">Lean</span>.<span class="name">runCmd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>run_cmd doSeq</code> command executes code in <code>CommandElabM <a href=".././Init/Prelude.html#Unit">Unit</a></code>.
This is the same as <code>#eval show CommandElabM <a href=".././Init/Prelude.html#Unit">Unit</a> from discard do doSeq</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.runCmd">Lean.runCmd</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.runCmd</span> <span class="fn">1022</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;run_cmd &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`doSeq</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.runCmd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.runElab"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L675-L679">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.runElab"><span class="name">Lean</span>.<span class="name">runElab</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>run_elab doSeq</code> command executes code in <code>TermElabM <a href=".././Init/Prelude.html#Unit">Unit</a></code>.
This is the same as <code>#eval show TermElabM <a href=".././Init/Prelude.html#Unit">Unit</a> from discard do doSeq</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.runElab">Lean.runElab</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.runElab</span> <span class="fn">1022</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;run_elab &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`doSeq</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.runElab" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.runMeta"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L681-L687">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.runMeta"><span class="name">Lean</span>.<span class="name">runMeta</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>run_meta doSeq</code> command executes code in <code>MetaM <a href=".././Init/Prelude.html#Unit">Unit</a></code>.
This is the same as <code>#eval show MetaM <a href=".././Init/Prelude.html#Unit">Unit</a> from do discard doSeq</code>.</p><p>(This is effectively a synonym for <code>run_elab</code> since <code>MetaM</code> lifts to <code>TermElabM</code>.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.runMeta">Lean.runMeta</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.runMeta</span> <span class="fn">1022</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;run_meta &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`doSeq</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.runMeta" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.reduceCmd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L689-L703">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.reduceCmd"><span class="name">Lean</span>.<span class="name">reduceCmd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>#reduce &lt;expression&gt;</code> reduces the expression <code>&lt;expression&gt;</code> to its normal form. This
involves applying reduction rules until no further reduction is possible.</p><p>By default, proofs and types within the expression are not reduced. Use modifiers
<code>(proofs := true)</code>  and <code>(types := true)</code> to reduce them.
Recall that propositions are types in Lean.</p><p><strong>Warning:</strong> This can be a computationally expensive operation,
especially for complex expressions.</p><p>Consider using <code>#eval &lt;expression&gt;</code> for simple evaluation/execution
of expressions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.reduceCmd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.guardMsgsFilterAction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L706-L706">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.guardMsgsFilterAction"><span class="name">Lean</span>.<span class="name">guardMsgsFilterAction</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.guardMsgsFilterAction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.guardMsgsFilterSeverity"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L709-L709">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.guardMsgsFilterSeverity"><span class="name">Lean</span>.<span class="name">guardMsgsFilterSeverity</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.guardMsgsFilterSeverity" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.guardMsgsFilter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L711-L725">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.guardMsgsFilter"><span class="name">Lean</span>.<span class="name">guardMsgsFilter</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>A message filter specification for <code>#guard_msgs</code>.</p><ul>
<li><code>info</code>, <code>warning</code>, <code>error</code>: capture (non-trace) messages with the given severity level.</li>
<li><code>trace</code>: captures trace messages</li>
<li><code>all</code>: capture all messages.</li>
</ul><p>The filters can be prefixed with</p><ul>
<li><code>check</code> (the default): capture and check the message</li>
<li><code>drop</code>: drop the message</li>
<li><code>pass</code>: let the message pass through</li>
</ul><p>If no filter is specified, <code>check all</code> is assumed.  Otherwise, these filters are processed in
left-to-right order, with an implicit <code>pass all</code> at the end.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.guardMsgsFilter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.guardMsgsWhitespaceArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L728-L728">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.guardMsgsWhitespaceArg"><span class="name">Lean</span>.<span class="name">guardMsgsWhitespaceArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.guardMsgsWhitespaceArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.guardMsgsWhitespace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L730-L738">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.guardMsgsWhitespace"><span class="name">Lean</span>.<span class="name">guardMsgsWhitespace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Whitespace handling for <code>#guard_msgs</code>:</p><ul>
<li><code>whitespace := exact</code> requires an exact whitespace match.</li>
<li><code>whitespace := normalized</code> converts all newline characters to a space before matching
(the default). This allows breaking long lines.</li>
<li><code>whitespace := lax</code> collapses whitespace to a single space before matching.
In all cases, leading and trailing whitespace is trimmed before matching.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.guardMsgsWhitespace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.guardMsgsOrderingArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L741-L741">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.guardMsgsOrderingArg"><span class="name">Lean</span>.<span class="name">guardMsgsOrderingArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.guardMsgsOrderingArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.guardMsgsOrdering"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L743-L749">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.guardMsgsOrdering"><span class="name">Lean</span>.<span class="name">guardMsgsOrdering</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Message ordering for <code>#guard_msgs</code>:</p><ul>
<li><code>ordering := exact</code> uses the exact ordering of the messages (the default).</li>
<li><code>ordering := sorted</code> sorts the messages in lexicographic order.
This helps with testing commands that are non-deterministic in their ordering.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.guardMsgsOrdering" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.guardMsgsPositionsArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L752-L752">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.guardMsgsPositionsArg"><span class="name">Lean</span>.<span class="name">guardMsgsPositionsArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.guardMsgsPositionsArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.guardMsgsPositions"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L754-L765">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.guardMsgsPositions"><span class="name">Lean</span>.<span class="name">guardMsgsPositions</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Position reporting for <code>#guard_msgs</code>:</p><ul>
<li><code>positions := true</code> will report the positions of messages with the line numbers computed
relative to the line of the <code>#guard_msgs</code> token, e.g.<pre><code>@ +3:7...+4:2
info: &lt;message&gt;
</code></pre>
Note that the reported column is absolute.</li>
<li><code>positions := false</code> (the default) will not render positions.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.guardMsgsPositions" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.guardMsgsSpecElt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L768-L769">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.guardMsgsSpecElt"><span class="name">Lean</span>.<span class="name">guardMsgsSpecElt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.guardMsgsSpecElt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.guardMsgsSpec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L772-L772">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.guardMsgsSpec"><span class="name">Lean</span>.<span class="name">guardMsgsSpec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.guardMsgsSpec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.guardMsgsCmd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L774-L856">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.guardMsgsCmd"><span class="name">Lean</span>.<span class="name">guardMsgsCmd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>/-- ... -/ #guard_msgs in cmd</code> captures the messages generated by the command <code>cmd</code>
and checks that they match the contents of the docstring.</p><p>Basic example:</p><pre><code class="language-lean">/--
error: Unknown identifier `x`
-/
#guard_msgs in
example : α := x
</code></pre><p>This checks that there is such an error and then consumes the message.</p><p>By default, the command captures all messages, but the filter condition can be adjusted.
For example, we can select only warnings:</p><pre><code class="language-lean">/--
warning: declaration uses 'sorry'
-/
#guard_msgs(warning) in
example : α := sorry
</code></pre><p>or only errors</p><pre><code class="language-lean">#guard_msgs(error) in
example : α := sorry
</code></pre><p>In the previous example, since warnings are not captured there is a warning on <code>sorry</code>.
We can drop the warning completely with</p><pre><code class="language-lean">#guard_msgs(error, drop warning) in
example : α := sorry
</code></pre><p>In general, <code>#guard_msgs</code> accepts a comma-separated list of configuration clauses in parentheses:</p><pre><code>#guard_msgs (configElt,*) in cmd
</code></pre><p>By default, the configuration list is
<code>(check all, whitespace := normalized, ordering := exact, positions := false)</code>.</p><p>Message filters select messages by severity:</p><ul>
<li><code>info</code>, <code>warning</code>, <code>error</code>: (non-trace) messages with the given severity level.</li>
<li><code>trace</code>: trace messages</li>
<li><code>all</code>: all messages.</li>
</ul><p>The filters can be prefixed with the action to take:</p><ul>
<li><code>check</code> (the default): capture and check the message</li>
<li><code>drop</code>: drop the message</li>
<li><code>pass</code>: let the message pass through</li>
</ul><p>If no filter is specified, <code>check all</code> is assumed.  Otherwise, these filters are processed in
left-to-right order, with an implicit <code>pass all</code> at the end.</p><p>Whitespace handling (after trimming leading and trailing whitespace):</p><ul>
<li><code>whitespace := exact</code> requires an exact whitespace match.</li>
<li><code>whitespace := normalized</code> converts all newline characters to a space before matching
(the default). This allows breaking long lines.</li>
<li><code>whitespace := lax</code> collapses whitespace to a single space before matching.</li>
</ul><p>Message ordering:</p><ul>
<li><code>ordering := exact</code> uses the exact ordering of the messages (the default).</li>
<li><code>ordering := sorted</code> sorts the messages in lexicographic order.
This helps with testing commands that are non-deterministic in their ordering.</li>
</ul><p>Position reporting:</p><ul>
<li><code>positions := true</code> reports the ranges of all messages relative to the line on which
<code>#guard_msgs</code> appears.</li>
<li><code>positions := false</code> does not report position info.</li>
</ul><p>For example, <code>#guard_msgs (error, drop all) in cmd</code> means to check warnings and drop
everything else.</p><p>The command elaborator has special support for <code>#guard_msgs</code> for linting.
The <code>#guard_msgs</code> itself wants to capture linter warnings,
so it elaborates the command it is attached to as if it were a top-level command.
However, the command elaborator runs linters for <em>all</em> top-level commands,
which would include <code>#guard_msgs</code> itself, and would cause duplicate and/or uncaptured linter warnings.
The top-level command elaborator only runs the linters if <code>#guard_msgs</code> is not present.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.guardMsgsCmd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.infoTreesCmd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L858-L863">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.infoTreesCmd"><span class="name">Lean</span>.<span class="name">infoTreesCmd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Format and print the info trees for a given command.
This is mostly useful for debugging info trees.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.infoTreesCmd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.setPremiseSelectorCmd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L865-L871">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.setPremiseSelectorCmd"><span class="name">Lean</span>.<span class="name">setPremiseSelectorCmd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Specify a premise selection engine.
Note that Lean does not ship a default premise selection engine,
so this is only useful in conjunction with a downstream package which provides one.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.setPremiseSelectorCmd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.checkTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L875-L880">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.checkTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">checkTactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>#check_tactic t ~&gt; r by commands</code> runs the tactic sequence <code>commands</code>
on a goal with <code>t</code> and sees if the resulting expression has reduced it
to <code>r</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.checkTactic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.checkTacticFailure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L882-L886">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.checkTacticFailure"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">checkTacticFailure</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>#check_tactic_failure t by tac</code> runs the tactic <code>tac</code>
on a goal with <code>t</code> and verifies it fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.checkTacticFailure" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.checkSimp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L888-L891">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.checkSimp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">checkSimp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>#check_simp t ~&gt; r</code> checks <code>simp</code> reduces <code>t</code> to <code>r</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.checkSimp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.checkSimpFailure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L893-L896">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.checkSimpFailure"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">checkSimpFailure</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>#check_simp t !~&gt;</code> checks <code>simp</code> fails on reducing <code>t</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.checkSimpFailure" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.timeCmd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L898-L907">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.timeCmd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">timeCmd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Time the elaboration of a command, and print the result (in milliseconds).</p><p>Example usage:</p><pre><code>set_option maxRecDepth 100000 in
#time example : (List.range 500).length = 500 := <a href=".././Init/Prelude.html#rfl">rfl</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././Init/Notation.html#Lean.Parser.timeCmd">Lean.Parser.timeCmd</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.timeCmd</span> <span class="fn">1022</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;#time &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`command</span> <span class="fn">0</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.timeCmd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.discrTreeKeyCmd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L909-L926">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.discrTreeKeyCmd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">discrTreeKeyCmd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>#discr_tree_key  t</code> prints the discrimination tree keys for a term <code>t</code> (or, if it is a single identifier, the type of that constant).
It uses the default configuration for generating keys.</p><p>For example,</p><pre><code>#discr_tree_key (∀ {a n : Nat}, bar a (OfNat.ofNat n))
-- bar _ (@OfNat.ofNat <a href=".././Init/Prelude.html#Nat">Nat</a> _ _)

#discr_tree_simp_key <a href=".././Init/Data/Nat/Basic.html#Nat.add_assoc">Nat.add_assoc</a>
-- @HAdd.hAdd <a href=".././Init/Prelude.html#Nat">Nat</a> <a href=".././Init/Prelude.html#Nat">Nat</a> <a href=".././Init/Prelude.html#Nat">Nat</a> _ (@HAdd.hAdd <a href=".././Init/Prelude.html#Nat">Nat</a> <a href=".././Init/Prelude.html#Nat">Nat</a> <a href=".././Init/Prelude.html#Nat">Nat</a> _ _ _) _
</code></pre><p><code>#discr_tree_simp_key</code> is similar to <code>#discr_tree_key</code>, but treats the underlying type
as one of a simp lemma, i.e. transforms it into an equality and produces the key of the
left-hand side.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.discrTreeKeyCmd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.discrTreeSimpKeyCmd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L928-L929">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.discrTreeSimpKeyCmd"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">discrTreeSimpKeyCmd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>#discr_tree_key  t</code> prints the discrimination tree keys for a term <code>t</code> (or, if it is a single identifier, the type of that constant).
It uses the default configuration for generating keys.</p><p>For example,</p><pre><code>#discr_tree_key (∀ {a n : Nat}, bar a (OfNat.ofNat n))
-- bar _ (@OfNat.ofNat <a href=".././Init/Prelude.html#Nat">Nat</a> _ _)

#discr_tree_simp_key <a href=".././Init/Data/Nat/Basic.html#Nat.add_assoc">Nat.add_assoc</a>
-- @HAdd.hAdd <a href=".././Init/Prelude.html#Nat">Nat</a> <a href=".././Init/Prelude.html#Nat">Nat</a> <a href=".././Init/Prelude.html#Nat">Nat</a> _ (@HAdd.hAdd <a href=".././Init/Prelude.html#Nat">Nat</a> <a href=".././Init/Prelude.html#Nat">Nat</a> <a href=".././Init/Prelude.html#Nat">Nat</a> _ _ _) _
</code></pre><p><code>#discr_tree_simp_key</code> is similar to <code>#discr_tree_key</code>, but treats the underlying type
as one of a simp lemma, i.e. transforms it into an equality and produces the key of the
left-hand side.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.discrTreeSimpKeyCmd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.commandSeal__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L931-L939">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.commandSeal__"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">commandSeal__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>seal foo</code> command ensures that the definition of <code>foo</code> is sealed, meaning it is marked as <code>[irreducible]</code>.
This command is particularly useful in contexts where you want to prevent the reduction of <code>foo</code> in proofs.</p><p>In terms of functionality, <code>seal foo</code> is equivalent to <code>attribute [local irreducible] foo</code>.
This attribute specifies that <code>foo</code> should be treated as irreducible only within the local scope,
which helps in maintaining the desired abstraction level without affecting global settings.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.commandSeal__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.commandUnseal__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Notation.lean#L941-L948">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Notation.html#Lean.Parser.commandUnseal__"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">commandUnseal__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>The <code>unseal foo</code> command ensures that the definition of <code>foo</code> is unsealed, meaning it is marked as <code>[semireducible]</code>, the
default reducibility setting. This command is useful when you need to allow some level of reduction of <code>foo</code> in proofs.</p><p>Functionally, <code>unseal foo</code> is equivalent to <code>attribute [local semireducible] foo</code>.
Applying this attribute makes <code>foo</code> semireducible only within the local scope.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.commandUnseal__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src=".././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>