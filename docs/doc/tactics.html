<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="./style.css"></link><link rel="icon" href="./favicon.svg"></link><link rel="mask-icon" href="./favicon.svg" color="#000000"></link><link rel="prefetch" href=".//declarations/declaration-data.bmp" as="image"></link><title>Tactics</title><script defer="true" src="./mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="./";</script><script type="module" src="./jump-src.js"></script><script type="module" src="./search.js"></script><script type="module" src="./expand-nav.js"></script><script type="module" src="./how-about.js"></script><script type="module" src="./instances.js"></script><script type="module" src="./importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Tactics</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='./search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p><a href="#Lean.Parser.Tactic.paren">(</a></p><p><a href="#Lean.cdot">.</a></p><p><a href="#Lean.Parser.Tactic.«tactic_&lt;;&gt;_»">&lt;;&gt;</a></p><p><a href="#Batteries.Tactic.seq_focus">&lt;;&gt;</a></p><p><a href="#Lean.Parser.Tactic.nestedTactic">Lean.Parser.Tactic.nestedTactic</a></p><p><a href="#Batteries.Tactic.tactic_">_</a></p><p><a href="#Batteries.Tactic.tacticAbsurd_">absurd</a></p><p><a href="#Lean.Parser.Tactic.tacticAc_nf_">ac_nf</a></p><p><a href="#Lean.Parser.Tactic.acNf0">ac_nf0</a></p><p><a href="#Lean.Parser.Tactic.acRfl">ac_rfl</a></p><p><a href="#Lean.Parser.Tactic.tacticAdmit">admit</a></p><p><a href="#Lean.Parser.Tactic.allGoals">all_goals</a></p><p><a href="#Lean.Parser.Tactic.tacticAnd_intros">and_intros</a></p><p><a href="#Lean.Parser.Tactic.anyGoals">any_goals</a></p><p><a href="#Lean.Parser.Tactic.apply">apply</a></p><p><a href="#Lean.Parser.Tactic.apply?">apply?</a></p><p><a href="#Lean.Parser.Tactic.applyAssumption">apply_assumption</a></p><p><a href="#Lean.Elab.Tactic.Ext.applyExtTheorem">apply_ext_theorem</a></p><p><a href="#Lean.Parser.Tactic.tacticApply_mod_cast_">apply_mod_cast</a></p><p><a href="#Lean.Parser.Tactic.applyRfl">apply_rfl</a></p><p><a href="#Lean.Parser.Tactic.applyRules">apply_rules</a></p><p><a href="#Array.tacticArray_get_dec">array_get_dec</a></p><p><a href="#Array.tacticArray_mem_dec">array_mem_dec</a></p><p><a href="#Lean.Parser.Tactic.as_aux_lemma">as_aux_lemma</a></p><p><a href="#Lean.Parser.Tactic.assumption">assumption</a></p><p><a href="#Lean.Parser.Tactic.tacticAssumption_mod_cast_">assumption_mod_cast</a></p><p><a href="#Lean.Parser.Tactic.attemptAll">attempt_all</a></p><p><a href="#Lean.Parser.Tactic.attemptAllPar">attempt_all_par</a></p><p><a href="#Lean.Parser.Tactic.bvCheck">bv_check</a></p><p><a href="#Lean.Parser.Tactic.bvDecideMacro">bv_decide</a></p><p><a href="#Lean.Parser.Tactic.bvTraceMacro">bv_decide?</a></p><p><a href="#Lean.Parser.Tactic.bvNormalizeMacro">bv_normalize</a></p><p><a href="#Lean.Parser.Tactic.tacticBv_omega">bv_omega</a></p><p><a href="#«tacticBy_cases_:_»">by_cases</a></p><p><a href="#Batteries.Tactic.byContra">by_contra</a></p><p><a href="#Lean.calcTactic">calc</a></p><p><a href="#Batteries.Tactic.casePatt">case</a></p><p><a href="#Lean.Parser.Tactic.case">case</a></p><p><a href="#Lean.Parser.Tactic.case'">case'</a></p><p><a href="#Batteries.Tactic.casePatt'">case'</a></p><p><a href="#Lean.Parser.Tactic.cases">cases</a></p><p><a href="#Lean.Parser.Tactic.cbv">cbv</a></p><p><a href="#Lean.Parser.Tactic.change">change</a></p><p><a href="#Lean.Parser.Tactic.classical">classical</a></p><p><a href="#tacticClean_wf">clean_wf</a></p><p><a href="#Lean.Parser.Tactic.clear">clear</a></p><p><a href="#Lean.Parser.Tactic.clearValue">clear_value</a></p><p><a href="#Lean.Parser.Tactic.congr">congr</a></p><p><a href="#Batteries.Tactic.congrConfigWith">congr</a></p><p><a href="#Batteries.Tactic.congrConfig">congr</a></p><p><a href="#Lean.Parser.Tactic.constructor">constructor</a></p><p><a href="#Lean.Parser.Tactic.contradiction">contradiction</a></p><p><a href="#Lean.Parser.Tactic.Conv.conv">conv</a></p><p><a href="#Lean.Parser.Tactic.Conv.convTactic">conv'</a></p><p><a href="#Lean.Parser.Tactic.cutsat">cutsat</a></p><p><a href="#Lean.Parser.Tactic.dbgTrace">dbg_trace</a></p><p><a href="#Lean.Parser.Tactic.decide">decide</a></p><p><a href="#Lean.Parser.Tactic.decide_cbv">decide_cbv</a></p><p><a href="#tacticDecreasing_tactic">decreasing_tactic</a></p><p><a href="#tacticDecreasing_trivial">decreasing_trivial</a></p><p><a href="#tacticDecreasing_trivial_pre_omega">decreasing_trivial_pre_omega</a></p><p><a href="#tacticDecreasing_with_">decreasing_with</a></p><p><a href="#Lean.Parser.Tactic.delta">delta</a></p><p><a href="#tacticDeriving_LawfulEq_tactic">deriving_LawfulEq_tactic</a></p><p><a href="#tacticDeriving_LawfulEq_tactic_step">deriving_LawfulEq_tactic_step</a></p><p><a href="#DerivingHelpers.tacticDeriving_ReflEq_tactic">deriving_ReflEq_tactic</a></p><p><a href="#Lean.Parser.Tactic.done">done</a></p><p><a href="#Lean.Parser.Tactic.dsimp">dsimp</a></p><p><a href="#Lean.Parser.Tactic.dsimpAutoUnfold">dsimp!</a></p><p><a href="#Lean.Parser.Tactic.dsimpTrace">dsimp?</a></p><p><a href="#Lean.Parser.Tactic.tacticDsimp?!_">dsimp?!</a></p><p><a href="#Batteries.Tactic.tacticEapply_">eapply</a></p><p><a href="#Lean.Parser.Tactic.eqRefl">eq_refl</a></p><p><a href="#Lean.Parser.Tactic.tacticErw___">erw</a></p><p><a href="#Lean.Parser.Tactic.exact">exact</a></p><p><a href="#Lean.Parser.Tactic.exact?">exact?</a></p><p><a href="#Lean.Parser.Tactic.tacticExact_mod_cast_">exact_mod_cast</a></p><p><a href="#Batteries.Tactic.exacts">exacts</a></p><p><a href="#Lean.Parser.Tactic.tacticExfalso">exfalso</a></p><p><a href="#Lean.Parser.Tactic.«tacticExists_,,»">exists</a></p><p><a href="#Lean.Parser.Tactic.exposeNames">expose_names</a></p><p><a href="#Lean.Elab.Tactic.Ext.ext">ext</a></p><p><a href="#Lean.Elab.Tactic.Ext.tacticExt1___">ext1</a></p><p><a href="#Lean.Parser.Tactic.extractLets">extract_lets</a></p><p><a href="#Lean.Parser.Tactic.fail">fail</a></p><p><a href="#Lean.Parser.Tactic.failIfSuccess">fail_if_success</a></p><p><a href="#Lean.Parser.Tactic.falseOrByContra">false_or_by_contra</a></p><p><a href="#Batteries.Tactic.tacticFapply_">fapply</a></p><p><a href="#Lean.Parser.Tactic.first">first</a></p><p><a href="#Lean.Parser.Tactic.firstPar">first_par</a></p><p><a href="#Lean.Parser.Tactic.focus">focus</a></p><p><a href="#Lean.Parser.Tactic.funCases">fun_cases</a></p><p><a href="#Lean.Parser.Tactic.funInduction">fun_induction</a></p><p><a href="#tacticFunext___">funext</a></p><p><a href="#Lean.Parser.Tactic.generalize">generalize</a></p><p><a href="#Batteries.Tactic.generalizeProofsElab">generalize_proofs</a></p><p><a href="#tacticGet_elem_tactic">get_elem_tactic</a></p><p><a href="#tacticGet_elem_tactic_extensible">get_elem_tactic_extensible</a></p><p><a href="#tacticGet_elem_tactic_trivial">get_elem_tactic_trivial</a></p><p><a href="#Lean.Parser.Tactic.grind">grind</a></p><p><a href="#Lean.Parser.Tactic.grindTrace">grind?</a></p><p><a href="#Lean.Parser.Tactic.grind_linarith">grind_linarith</a></p><p><a href="#Lean.Parser.Tactic.grind_order">grind_order</a></p><p><a href="#Lean.Parser.Tactic.grobner">grobner</a></p><p><a href="#Lean.Parser.Tactic.guardExpr">guard_expr</a></p><p><a href="#Lean.Parser.Tactic.guardHyp">guard_hyp</a></p><p><a href="#Lean.Parser.Tactic.guardTarget">guard_target</a></p><p><a href="#Lean.Parser.Tactic.tacticHave__">have</a></p><p><a href="#Lean.Parser.Tactic.tacticHave'">have'</a></p><p><a href="#Lean.Parser.Tactic.tacticHaveI__">haveI</a></p><p><a href="#Lean.Parser.Tactic.unknown">ident</a></p><p><a href="#Lean.Parser.Tactic.tacIfThenElse">if</a></p><p><a href="#Lean.Parser.Tactic.induction">induction</a></p><p><a href="#Lean.Parser.Tactic.tacticInfer_instance">infer_instance</a></p><p><a href="#Lean.Parser.Tactic.injection">injection</a></p><p><a href="#Lean.Parser.Tactic.injections">injections</a></p><p><a href="#Lean.Parser.Tactic.intro">intro</a></p><p><a href="#Batteries.Tactic.introDot">intro</a></p><p><a href="#Lean.Parser.Tactic.intros">intros</a></p><p><a href="#Lean.Parser.Tactic.tacticIterate____">iterate</a></p><p><a href="#Lean.Parser.Tactic.left">left</a></p><p><a href="#Lean.Parser.Tactic.tacticLet__">let</a></p><p><a href="#Lean.Parser.Tactic.letrec">let rec</a></p><p><a href="#Lean.Parser.Tactic.tacticLet'__">let'</a></p><p><a href="#Lean.Parser.Tactic.tacticLetI__">letI</a></p><p><a href="#Lean.Parser.Tactic.letToHave">let_to_have</a></p><p><a href="#Lean.Parser.Tactic.lia">lia</a></p><p><a href="#Lean.Parser.Tactic.liftLets">lift_lets</a></p><p><a href="#Batteries.Tactic.«tacticMap_tacs[_;]»">map_tacs</a></p><p><a href="#Lean.Parser.Tactic.massumptionMacro">massumption</a></p><p><a href="#Batteries.Tactic.«tacticMatch_,,With.»">match</a></p><p><a href="#Lean.Parser.Tactic.match">match</a></p><p><a href="#Lean.Parser.Tactic.mcasesMacro">mcases</a></p><p><a href="#Lean.Parser.Tactic.mclearMacro">mclear</a></p><p><a href="#Lean.Parser.Tactic.mconstructorMacro">mconstructor</a></p><p><a href="#Lean.Parser.Tactic.mdup">mdup</a></p><p><a href="#Lean.Parser.Tactic.mexactMacro">mexact</a></p><p><a href="#Lean.Parser.Tactic.mexfalsoMacro">mexfalso</a></p><p><a href="#Lean.Parser.Tactic.mexistsMacro">mexists</a></p><p><a href="#Lean.Parser.Tactic.mframeMacro">mframe</a></p><p><a href="#Lean.Parser.Tactic.mhaveMacro">mhave</a></p><p><a href="#Lean.Parser.Tactic.mintroMacro">mintro</a></p><p><a href="#Lean.Parser.Tactic.mleaveMacro">mleave</a></p><p><a href="#Lean.Parser.Tactic.mleftMacro">mleft</a></p><p><a href="#Lean.Parser.Tactic.mpureMacro">mpure</a></p><p><a href="#Lean.Parser.Tactic.mpureIntroMacro">mpure_intro</a></p><p><a href="#Lean.Parser.Tactic.mrefineMacro">mrefine</a></p><p><a href="#Lean.Parser.Tactic.mrenameIMacro">mrename_i</a></p><p><a href="#Lean.Parser.Tactic.mreplaceMacro">mreplace</a></p><p><a href="#Lean.Parser.Tactic.mrevertMacro">mrevert</a></p><p><a href="#Lean.Parser.Tactic.mrightMacro">mright</a></p><p><a href="#Lean.Parser.Tactic.mspecMacro">mspec</a></p><p><a href="#Lean.Parser.Tactic.mspecNoBind">mspec_no_bind</a></p><p><a href="#Lean.Parser.Tactic.mspecNoSimp">mspec_no_simp</a></p><p><a href="#Lean.Parser.Tactic.mspecializeMacro">mspecialize</a></p><p><a href="#Lean.Parser.Tactic.mspecializePureMacro">mspecialize_pure</a></p><p><a href="#Lean.Parser.Tactic.mstartMacro">mstart</a></p><p><a href="#Lean.Parser.Tactic.mstopMacro">mstop</a></p><p><a href="#Lean.Parser.Tactic.mvcgenMacro">mvcgen</a></p><p><a href="#Lean.Parser.Tactic.mvcgenHint">mvcgen?</a></p><p><a href="#Lean.Parser.Tactic.tacticMvcgen_trivial">mvcgen_trivial</a></p><p><a href="#Lean.Parser.Tactic.tacticMvcgen_trivial_extensible">mvcgen_trivial_extensible</a></p><p><a href="#Lean.Parser.Tactic.nativeDecide">native_decide</a></p><p><a href="#Lean.Parser.Tactic.«tacticNext_=&gt;_»">next</a></p><p><a href="#Lean.Parser.Tactic.tacticNofun">nofun</a></p><p><a href="#Lean.Parser.Tactic.«tacticNomatch_,,»">nomatch</a></p><p><a href="#Lean.Parser.Tactic.tacticNorm_cast__">norm_cast</a></p><p><a href="#Lean.Parser.Tactic.normCast0">norm_cast0</a></p><p><a href="#Lean.Parser.Tactic.obtain">obtain</a></p><p><a href="#Lean.Parser.Tactic.omega">omega</a></p><p><a href="#Batteries.Tactic.«tacticOn_goal-_=&gt;_»">on_goal</a></p><p><a href="#Lean.Parser.Tactic.open">open</a></p><p><a href="#Batteries.Tactic.«tacticPick_goal-_»">pick_goal</a></p><p><a href="#Lean.Parser.Tactic.pushCast">push_cast</a></p><p><a href="#Lean.Parser.Tactic.rcases">rcases</a></p><p><a href="#Batteries.Tactic.rcongr">rcongr</a></p><p><a href="#Lean.Parser.Tactic.refine">refine</a></p><p><a href="#Lean.Parser.Tactic.refine'">refine'</a></p><p><a href="#Lean.Parser.Tactic.tacticRefine_lift_">refine_lift</a></p><p><a href="#Lean.Parser.Tactic.tacticRefine_lift'_">refine_lift'</a></p><p><a href="#Lean.Parser.Tactic.rename">rename</a></p><p><a href="#Lean.Parser.Tactic.renameI">rename_i</a></p><p><a href="#Lean.Parser.Tactic.tacticRepeat_">repeat</a></p><p><a href="#Lean.Parser.Tactic.repeat'">repeat'</a></p><p><a href="#Lean.Parser.Tactic.repeat1'">repeat1'</a></p><p><a href="#Lean.Parser.Tactic.replace">replace</a></p><p><a href="#Lean.Parser.Tactic.revert">revert</a></p><p><a href="#Lean.Parser.Tactic.rewriteSeq">rewrite</a></p><p><a href="#Lean.Parser.Tactic.tacticRfl">rfl</a></p><p><a href="#Lean.Parser.Tactic.tacticRfl'">rfl'</a></p><p><a href="#Lean.Parser.Tactic.right">right</a></p><p><a href="#Lean.Parser.Tactic.rintro">rintro</a></p><p><a href="#Lean.Parser.Tactic.rotateLeft">rotate_left</a></p><p><a href="#Lean.Parser.Tactic.rotateRight">rotate_right</a></p><p><a href="#Lean.Parser.Tactic.runTac">run_tac</a></p><p><a href="#Lean.Parser.Tactic.rwSeq">rw</a></p><p><a href="#Lean.Parser.Tactic.rewrites?">rw?</a></p><p><a href="#Lean.Parser.Tactic.tacticRw_mod_cast___">rw_mod_cast</a></p><p><a href="#Lean.Parser.Tactic.tacticRwa__">rwa</a></p><p><a href="#Lean.Parser.Tactic.set_option">set_option</a></p><p><a href="#Lean.Parser.Tactic.show">show</a></p><p><a href="#Lean.Parser.Tactic.showTerm">show_term</a></p><p><a href="#Lean.Parser.Tactic.simp">simp</a></p><p><a href="#Lean.Parser.Tactic.simpAutoUnfold">simp!</a></p><p><a href="#Lean.Parser.Tactic.simpTrace">simp?</a></p><p><a href="#Lean.Parser.Tactic.tacticSimp?!_">simp?!</a></p><p><a href="#Lean.Parser.Tactic.simpAll">simp_all</a></p><p><a href="#Lean.Parser.Tactic.simpAllAutoUnfold">simp_all!</a></p><p><a href="#Lean.Parser.Tactic.simpAllTrace">simp_all?</a></p><p><a href="#Lean.Parser.Tactic.tacticSimp_all?!_">simp_all?!</a></p><p><a href="#Lean.Parser.Tactic.simpAllArith">simp_all_arith</a></p><p><a href="#Lean.Parser.Tactic.simpAllArithBang">simp_all_arith!</a></p><p><a href="#Lean.Parser.Tactic.simpArith">simp_arith</a></p><p><a href="#Lean.Parser.Tactic.simpArithBang">simp_arith!</a></p><p><a href="#tacticSimp_wf">simp_wf</a></p><p><a href="#Lean.Parser.Tactic.simpa">simpa</a></p><p><a href="#Lean.Parser.Tactic.tacticSimpa!_">simpa!</a></p><p><a href="#Lean.Parser.Tactic.tacticSimpa?_">simpa?</a></p><p><a href="#Lean.Parser.Tactic.tacticSimpa?!_">simpa?!</a></p><p><a href="#List.tacticSizeOf_list_dec">sizeOf_list_dec</a></p><p><a href="#Lean.Parser.Tactic.skip">skip</a></p><p><a href="#Lean.Parser.Tactic.sleep">sleep</a></p><p><a href="#Lean.solveTactic">solve</a></p><p><a href="#Lean.Parser.Tactic.solveByElim">solve_by_elim</a></p><p><a href="#Lean.Parser.Tactic.tacticSorry">sorry</a></p><p><a href="#Lean.Parser.Tactic.specialize">specialize</a></p><p><a href="#Lean.Parser.Tactic.split">split</a></p><p><a href="#Batteries.Tactic.tacticSplit_ands">split_ands</a></p><p><a href="#Batteries.Tactic.squeezeScope">squeeze_scope</a></p><p><a href="#Lean.Parser.Tactic.tacticStop_">stop</a></p><p><a href="#Lean.Parser.Tactic.subst">subst</a></p><p><a href="#Lean.Parser.Tactic.substEqs">subst_eqs</a></p><p><a href="#Lean.Parser.Tactic.substVars">subst_vars</a></p><p><a href="#Lean.Parser.Tactic.tacticSuffices_">suffices</a></p><p><a href="#Lean.Parser.Tactic.suggestions">suggestions</a></p><p><a href="#Batteries.Tactic.tacticSwap">swap</a></p><p><a href="#Lean.Parser.Tactic.symm">symm</a></p><p><a href="#Lean.Parser.Tactic.symmSaturate">symm_saturate</a></p><p><a href="#Lean.Parser.Tactic.traceMessage">trace</a></p><p><a href="#Lean.Parser.Tactic.traceState">trace_state</a></p><p><a href="#Batteries.Tactic.tacticTrans___">trans</a></p><p><a href="#Batteries.Tactic.tacticTransitivity___">transitivity</a></p><p><a href="#Batteries.Tactic.triv">triv</a></p><p><a href="#Lean.Parser.Tactic.tacticTrivial">trivial</a></p><p><a href="#Lean.Parser.Tactic.tacticTry_">try</a></p><p><a href="#Lean.Parser.Tactic.tryTrace">try?</a></p><p><a href="#Lean.Parser.Tactic.tryResult">try_suggestions</a></p><p><a href="#Lean.Parser.Tactic.unfold">unfold</a></p><p><a href="#Lean.Parser.Tactic.tacticUnhygienic_">unhygienic</a></p><p><a href="#Batteries.Tactic.unreachable">unreachable!</a></p><p><a href="#Lean.Server.Test.Cancel.tacticWait_for_unblock_async">wait_for_unblock_async</a></p><p><a href="#Lean.Parser.Tactic.withReducible">with_reducible</a></p><p><a href="#Lean.Parser.Tactic.withReducibleAndInstances">with_reducible_and_instances</a></p><p><a href="#Lean.Parser.Tactic.withUnfoldingAll">with_unfolding_all</a></p><p><a href="#Lean.Parser.Tactic.withUnfoldingNone">with_unfolding_none</a></p><p><a href="#«tactic∎»">∎</a></p></nav><main>
<p>The tactic language is a special-purpose programming language for constructing proofs, indicated using the keyword <code>by</code>.</p><div id="Lean.Parser.Tactic.paren"><h2>(</h2><p><p><code>(tacs)</code> executes a list of tactics in sequence, without requiring that
the goal be closed at the end like <code>· tacs</code>. Like <code>by</code> itself, the tactics
can be either separated by newlines or <code>;</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.paren">Init.Tactics</a></dd></dl></div><div id="Lean.cdot"><h2>.</h2><p><p><code>· tac</code> focuses on the main goal and tries to solve it using <code>tac</code>, or else fails.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/NotationExtra.html#Lean.cdot">Init.NotationExtra</a></dd></dl></div><div id="Lean.Parser.Tactic.«tactic_&lt;;&gt;_»"><h2>&lt;;&gt;</h2><p><p><code>tac &lt;;&gt; tac'</code> runs <code>tac</code> on the main goal and <code>tac'</code> on each produced goal,
concatenating all goals produced by <code>tac'</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.«tactic_&lt;;&gt;_»">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.seq_focus"><h2>&lt;;&gt;</h2><p><p><code>t &lt;;&gt; [t1; t2; ...; tn]</code> focuses on the first goal and applies <code>t</code>, which should result in <code>n</code>
subgoals. It then applies each <code>ti</code> to the corresponding goal and collects the resulting
subgoals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/SeqFocus.html#Batteries.Tactic.seq_focus">Batteries.Tactic.SeqFocus</a></dd></dl></div><div id="Lean.Parser.Tactic.nestedTactic"><h2>Lean.Parser.Tactic.nestedTactic</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Lean/Parser/Tactic.html#Lean.Parser.Tactic.nestedTactic">Lean.Parser.Tactic</a></dd></dl></div><div id="Batteries.Tactic.tactic_"><h2>_</h2><p><p><code>_</code> in tactic position acts like the <code>done</code> tactic: it fails and gives the list
of goals if there are any. It is useful as a placeholder after starting a tactic block
such as <code>by _</code> to make it syntactically correct and show the current goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tactic_">Batteries.Tactic.Init</a></dd></dl></div><div id="Batteries.Tactic.tacticAbsurd_"><h2>absurd</h2><p><p>Given a proof <code>h</code> of <code>p</code>, <code><a href="./Init/Prelude.html#absurd">absurd</a> h</code> changes the goal to <code>⊢ ¬ p</code>.
If <code>p</code> is a negation <code>¬q</code> then the goal is changed to <code>⊢ q</code> instead.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tacticAbsurd_">Batteries.Tactic.Init</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticAc_nf_"><h2>ac_nf</h2><p><p><code>ac_nf</code> normalizes equalities up to application of an associative and commutative operator.</p><ul><li><code>ac_nf</code> normalizes all hypotheses and the goal target of the goal.</li><li><code>ac_nf at l</code> normalizes at location(s) <code>l</code>, where <code>l</code> is either <code>*</code> or a
list of hypotheses in the local context. In the latter case, a turnstile <code>⊢</code> or <code>|-</code>
can also be used, to signify the target of the goal.</li></ul><pre><code>instance : <a href="./Init/Core.html#Std.Associative">Std.Associative</a> (α := Nat) (.+.) := ⟨Nat.add_assoc⟩
instance : <a href="./Init/Core.html#Std.Commutative">Std.Commutative</a> (α := Nat) (.+.) := ⟨Nat.add_comm⟩

example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by
 ac_nf
 -- goal: a + (b + (c + d)) = a + (b + (c + d))
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticAc_nf_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.acNf0"><h2>ac_nf0</h2><p><p>Implementation of <code>ac_nf</code> (the full <code>ac_nf</code> calls <code><a href="./Init/Core.html#trivial">trivial</a></code> afterwards).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.acNf0">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.acRfl"><h2>ac_rfl</h2><p><p><code>ac_rfl</code> proves equalities up to application of an associative and commutative operator.</p><pre><code>instance : <a href="./Init/Core.html#Std.Associative">Std.Associative</a> (α := Nat) (.+.) := ⟨Nat.add_assoc⟩
instance : <a href="./Init/Core.html#Std.Commutative">Std.Commutative</a> (α := Nat) (.+.) := ⟨Nat.add_comm⟩

example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.acRfl">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticAdmit"><h2>admit</h2><p><p><code>admit</code> is a synonym for <code>sorry</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.allGoals"><h2>all_goals</h2><p><p><code>all_goals tac</code> runs <code>tac</code> on each goal, concatenating the resulting goals.
If the tactic fails on any goal, the entire <code>all_goals</code> tactic fails.</p><p>See also <code>any_goals tac</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.allGoals">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticAnd_intros"><h2>and_intros</h2><p><p><code>and_intros</code> applies <code><a href="./Init/Prelude.html#And.intro">And.intro</a></code> until it does not make progress.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticAnd_intros">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.anyGoals"><h2>any_goals</h2><p><p><code>any_goals tac</code> applies the tactic <code>tac</code> to every goal,
concatenating the resulting goals for successful tactic applications.
If the tactic fails on all of the goals, the entire <code>any_goals</code> tactic fails.</p><p>This tactic is like <code>all_goals try tac</code> except that it fails if none of the applications of <code>tac</code> succeeds.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.anyGoals">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.apply"><h2>apply</h2><p><p><code>apply e</code> tries to match the current goal against the conclusion of <code>e</code>'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.</p><p>The <code>apply</code> tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.apply">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.apply?"><h2>apply?</h2><p><p>Searches environment for definitions or theorems that can refine the goal using <code>apply</code>
with conditions resolved when possible with <code>solve_by_elim</code>.</p><p>The optional <code>using</code> clause provides identifiers in the local context that must be
used when closing the goal.</p><p>Use <code>+grind</code> to enable <code>grind</code> as a fallback discharger for subgoals.
Use <code>+try?</code> to enable <code>try?</code> as a fallback discharger for subgoals.
Use <code>-star</code> to disable fallback to star-indexed lemmas.
Use <code>+all</code> to collect all successful lemmas instead of stopping at the first.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.apply?">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.applyAssumption"><h2>apply_assumption</h2><p><p><code>apply_assumption</code> looks for an assumption of the form <code>... → ∀ _, ... → head</code>
where <code>head</code> matches the current goal.</p><p>You can specify additional rules to apply using <code>apply_assumption [...]</code>.
By default <code>apply_assumption</code> will also try <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, <code><a href="./Init/Core.html#trivial">trivial</a></code>, <code><a href="./Init/Prelude.html#congrFun">congrFun</a></code>, and <code><a href="./Init/Prelude.html#congrArg">congrArg</a></code>.
If you don't want these, or don't want to use all hypotheses, use <code>apply_assumption only [...]</code>.
You can use <code>apply_assumption [-h]</code> to omit a local hypothesis.
You can use <code>apply_assumption using [a₁, ...]</code> to use all lemmas which have been labelled
with the attributes <code>aᵢ</code> (these attributes must be created using <code>register_label_attr</code>).</p><p><code>apply_assumption</code> will use consequences of local hypotheses obtained via <code>symm</code>.</p><p>If <code>apply_assumption</code> fails, it will call <code>exfalso</code> and try again.
Thus if there is an assumption of the form <code>P → ¬ Q</code>, the new tactic state
will have two goals, <code>P</code> and <code>Q</code>.</p><p>You can pass a further configuration via the syntax <code>apply_rules (config := {...}) lemmas</code>.
The options supported are the same as for <code>solve_by_elim</code> (and include all the options for <code>apply</code>).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.applyAssumption">Init.Tactics</a></dd></dl></div><div id="Lean.Elab.Tactic.Ext.applyExtTheorem"><h2>apply_ext_theorem</h2><p><p>Apply a single extensionality theorem to the current goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Ext.html#Lean.Elab.Tactic.Ext.applyExtTheorem">Init.Ext</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticApply_mod_cast_"><h2>apply_mod_cast</h2><p><p>Normalize casts in the goal and the given expression, then <code>apply</code> the expression to the goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/TacticsExtra.html#Lean.Parser.Tactic.tacticApply_mod_cast_">Init.TacticsExtra</a></dd></dl></div><div id="Lean.Parser.Tactic.applyRfl"><h2>apply_rfl</h2><p><p>The same as <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, but without trying <code>eq_refl</code> at the end.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.applyRfl">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.applyRules"><h2>apply_rules</h2><p><p><code>apply_rules [l₁, l₂, ...]</code> tries to solve the main goal by iteratively
applying the list of lemmas <code>[l₁, l₂, ...]</code> or by applying a local hypothesis.
If <code>apply</code> generates new goals, <code>apply_rules</code> iteratively tries to solve those goals.
You can use <code>apply_rules [-h]</code> to omit a local hypothesis.</p><p><code>apply_rules</code> will also use <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, <code><a href="./Init/Core.html#trivial">trivial</a></code>, <code><a href="./Init/Prelude.html#congrFun">congrFun</a></code> and <code><a href="./Init/Prelude.html#congrArg">congrArg</a></code>.
These can be disabled, as can local hypotheses, by using <code>apply_rules only [...]</code>.</p><p>You can use <code>apply_rules using [a₁, ...]</code> to use all lemmas which have been labelled
with the attributes <code>aᵢ</code> (these attributes must be created using <code>register_label_attr</code>).</p><p>You can pass a further configuration via the syntax <code>apply_rules (config := {...})</code>.
The options supported are the same as for <code>solve_by_elim</code> (and include all the options for <code>apply</code>).</p><p><code>apply_rules</code> will try calling <code>symm</code> on hypotheses and <code>exfalso</code> on the goal as needed.
This can be disabled with <code>apply_rules (config := {symm := false, exfalso := false})</code>.</p><p>You can bound the iteration depth using the syntax <code>apply_rules (config := {maxDepth := n})</code>.</p><p>Unlike <code>solve_by_elim</code>, <code>apply_rules</code> does not perform backtracking, and greedily applies
a lemma from the list until it gets stuck.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.applyRules">Init.Tactics</a></dd></dl></div><div id="Array.tacticArray_get_dec"><h2>array_get_dec</h2><p><p>This tactic, added to the <code>decreasing_trivial</code> toolbox, proves that
<code>sizeOf arr[i] &lt; sizeOf arr</code>, which is useful for well founded recursions
over a nested inductive like <code>inductive T | mk : <a href="./Init/Prelude.html#Array">Array</a> T → T</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Data/Array/Mem.html#Array.tacticArray_get_dec">Init.Data.Array.Mem</a></dd></dl></div><div id="Array.tacticArray_mem_dec"><h2>array_mem_dec</h2><p><p>This tactic, added to the <code>decreasing_trivial</code> toolbox, proves that <code>sizeOf a &lt; sizeOf arr</code>
provided that <code>a ∈ arr</code> which is useful for well founded recursions over a nested inductive like
<code>inductive T | mk : <a href="./Init/Prelude.html#Array">Array</a> T → T</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Data/Array/Mem.html#Array.tacticArray_mem_dec">Init.Data.Array.Mem</a></dd></dl></div><div id="Lean.Parser.Tactic.as_aux_lemma"><h2>as_aux_lemma</h2><p><p><code>as_aux_lemma =&gt; tac</code> does the same as <code>tac</code>, except that it wraps the resulting expression
into an auxiliary lemma. In some cases, this significantly reduces the size of expressions
because the proof term is not duplicated.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.as_aux_lemma">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.assumption"><h2>assumption</h2><p><p><code>assumption</code> tries to solve the main goal using a hypothesis of compatible type, or else fails.
Note also the <code>‹t›</code> term notation, which is a shorthand for <code>show t by assumption</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.assumption">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticAssumption_mod_cast_"><h2>assumption_mod_cast</h2><p><p><code>assumption_mod_cast</code> is a variant of <code>assumption</code> that solves the goal
using a hypothesis. Unlike <code>assumption</code>, it first pre-processes the goal and
each hypothesis to move casts as far outwards as possible, so it can be used
in more situations.</p><p>Concretely, it runs <code>norm_cast</code> on the goal. For each local hypothesis <code>h</code>, it also
normalizes <code>h</code> with <code>norm_cast</code> and tries to use that to close the goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticAssumption_mod_cast_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.attemptAll"><h2>attempt_all</h2><p><p>Helper internal tactic for implementing the tactic <code>try?</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Try.html#Lean.Parser.Tactic.attemptAll">Init.Try</a></dd></dl></div><div id="Lean.Parser.Tactic.attemptAllPar"><h2>attempt_all_par</h2><p><p>Helper internal tactic for implementing the tactic <code>try?</code> with parallel execution.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Try.html#Lean.Parser.Tactic.attemptAllPar">Init.Try</a></dd></dl></div><div id="Lean.Parser.Tactic.bvCheck"><h2>bv_check</h2><p><p>This tactic works just like <code>bv_decide</code> but skips calling a SAT solver by using a proof that is
already stored on disk. It is called with the name of an LRAT file in the same directory as the
current Lean file:</p><pre><code>bv_check &quot;proof.lrat&quot;
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/BVDecide/Syntax.html#Lean.Parser.Tactic.bvCheck">Std.Tactic.BVDecide.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.bvDecideMacro"><h2>bv_decide</h2><p><p>Close fixed-width <code><a href="./Init/Prelude.html#BitVec">BitVec</a></code> and <code><a href="./Init/Prelude.html#Bool">Bool</a></code> goals by obtaining a proof from an external SAT solver and
verifying it inside Lean. The solvable goals are currently limited to</p><ul><li>the Lean equivalent of <a href="https://smt-lib.org/logics-all.shtml#QF_BV"><code>QF_BV</code></a></li><li>automatically splitting up <code>structure</code>s that contain information about <code><a href="./Init/Prelude.html#BitVec">BitVec</a></code> or <code><a href="./Init/Prelude.html#Bool">Bool</a></code></li></ul><pre><code class="language-lean">example : ∀ (a b : <a href="./Init/Prelude.html#BitVec">BitVec</a> 64), (a &amp;&amp;&amp; b) + (a ^^^ b) = a ||| b := by
  intros
  bv_decide
</code></pre><p>If <code>bv_decide</code> encounters an unknown definition it will be treated like an unconstrained <code><a href="./Init/Prelude.html#BitVec">BitVec</a></code>
variable. Sometimes this enables solving goals despite not understanding the definition because
the precise properties of the definition do not matter in the specific proof.</p><p>If <code>bv_decide</code> fails to close a goal it provides a counter-example, containing assignments for all
terms that were considered as variables.</p><p>In order to avoid calling a SAT solver every time, the proof can be cached with <code>bv_decide?</code>.</p><p>If solving your problem relies inherently on using associativity or commutativity, consider enabling
the <code>bv.ac_nf</code> option.</p><p>Note: <code>bv_decide</code> trusts the correctness of the code generator and adds a axioms asserting its result.</p><p>Note: include <code>import Std.Tactic.BVDecide</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.bvDecideMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.bvTraceMacro"><h2>bv_decide?</h2><p><p>Suggest a proof script for a <code>bv_decide</code> tactic call. Useful for caching LRAT proofs.</p><p>Note: include <code>import Std.Tactic.BVDecide</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.bvTraceMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.bvNormalizeMacro"><h2>bv_normalize</h2><p><p>Run the normalization procedure of <code>bv_decide</code> only. Sometimes this is enough to solve basic
<code><a href="./Init/Prelude.html#BitVec">BitVec</a></code> goals already.</p><p>Note: include <code>import Std.Tactic.BVDecide</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.bvNormalizeMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticBv_omega"><h2>bv_omega</h2><p><p><code>bv_omega</code> is <code>omega</code> with an additional preprocessor that turns statements about <code><a href="./Init/Prelude.html#BitVec">BitVec</a></code> into statements about <code><a href="./Init/Prelude.html#Nat">Nat</a></code>.
Currently the preprocessor is implemented as <code>try simp only [bitvec_to_nat] at *</code>.
<code>bitvec_to_nat</code> is a <code>@[simp]</code> attribute that you can (cautiously) add to more theorems.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticBv_omega">Init.Tactics</a></dd></dl></div><div id="«tacticBy_cases_:_»"><h2>by_cases</h2><p><p><code>by_cases (h :)? p</code> splits the main goal into two cases, assuming <code>h : p</code> in the first branch, and <code>h : ¬ p</code> in the second branch.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/ByCases.html#«tacticBy_cases_:_»">Init.ByCases</a></dd></dl></div><div id="Batteries.Tactic.byContra"><h2>by_contra</h2><p><p><code>by_contra h</code> proves <code>⊢ p</code> by contradiction,
introducing a hypothesis <code>h : ¬p</code> and proving <code><a href="./Init/Prelude.html#False">False</a></code>.</p><ul><li>If <code>p</code> is a negation <code>¬q</code>, <code>h : q</code> will be introduced instead of <code>¬¬q</code>.</li><li>If <code>p</code> is decidable, it uses <code><a href="./Init/Core.html#Decidable.byContradiction">Decidable.byContradiction</a></code> instead of <code><a href="./Init/Classical.html#Classical.byContradiction">Classical.byContradiction</a></code>.</li><li>If <code>h</code> is omitted, the introduced variable will be called <code>this</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.byContra">Batteries.Tactic.Init</a></dd></dl></div><div id="Lean.calcTactic"><h2>calc</h2><p><p>Step-wise reasoning over transitive relations.</p><pre><code>calc
  a = b := pab
  b = c := pbc
  ...
  y = z := pyz
</code></pre><p>proves <code>a = z</code> from the given step-wise proofs. <code>=</code> can be replaced with any
relation implementing the typeclass <code><a href="./Init/Prelude.html#Trans">Trans</a></code>. Instead of repeating the right-
hand sides, subsequent left-hand sides can be replaced with <code>_</code>.</p><pre><code>calc
  a = b := pab
  _ = c := pbc
  ...
  _ = z := pyz
</code></pre><p>It is also possible to write the <em>first</em> relation as <code>&lt;lhs&gt;\n  _ = &lt;rhs&gt; := &lt;proof&gt;</code>. This is useful for aligning relation symbols, especially on longer
identifiers:</p><pre><code>calc abc
  _ = bce := pabce
  _ = cef := pbcef
  ...
  _ = xyz := pwxyz
</code></pre><p><code>calc</code> works as a term, as a tactic or as a <code>conv</code> tactic.</p><p>See <a href="https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs">Theorem Proving in Lean 4</a> for more information.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/NotationExtra.html#Lean.calcTactic">Init.NotationExtra</a></dd></dl></div><div id="Batteries.Tactic.casePatt"><h2>case</h2><p><ul><li><p><code>case _ : t =&gt; tac</code> finds the first goal that unifies with <code>t</code> and then solves it
using <code>tac</code> or else fails. Like <code>show</code>, it changes the type of the goal to <code>t</code>.
The <code>_</code> can optionally be a case tag, in which case it only looks at goals
whose tag would be considered by <code>case</code> (goals with an exact tag match,
followed by goals with the tag as a suffix, followed by goals with the tag as a prefix).</p></li><li><p><code>case _ n₁ ... nₘ : t =&gt; tac</code> additionally names the <code>m</code> most recent hypotheses with
inaccessible names to the given names. The names are renamed before matching against <code>t</code>.
The <code>_</code> can optionally be a case tag.</p></li><li><p><code>case _ : t := e</code> is short for <code>case _ : t =&gt; exact e</code>.</p></li><li><p><code>case _ : t₁ | _ : t₂ | ... =&gt; tac</code>
is equivalent to <code>(case _ : t₁ =&gt; tac); (case _ : t₂ =&gt; tac); ...</code>
but with all matching done on the original list of goals --
each goal is consumed as they are matched, so patterns may repeat or overlap.</p></li><li><p><code>case _ : t</code> will make the matched goal be the first goal.
<code>case _ : t₁ | _ : t₂ | ...</code> makes the matched goals be the first goals in the given order.</p></li><li><p><code>case _ : t := _</code> and <code>case _ : t := ?m</code> are the same as <code>case _ : t</code> but in the <code>?m</code> case the
goal tag is changed to <code>m</code>.
In particular, the goal becomes metavariable <code>?m</code>.</p></li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Case.html#Batteries.Tactic.casePatt">Batteries.Tactic.Case</a></dd></dl></div><div id="Lean.Parser.Tactic.case"><h2>case</h2><p><ul><li><code>case tag =&gt; tac</code> focuses on the goal with case name <code>tag</code> and solves it using <code>tac</code>,
or else fails.</li><li><code>case tag x₁ ... xₙ =&gt; tac</code> additionally renames the <code>n</code> most recent hypotheses
with inaccessible names to the given names.</li><li><code>case tag₁ | tag₂ =&gt; tac</code> is equivalent to <code>(case tag₁ =&gt; tac); (case tag₂ =&gt; tac)</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.case">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.case'"><h2>case'</h2><p><p><code>case'</code> is similar to the <code>case tag =&gt; tac</code> tactic, but does not ensure the goal
has been solved after applying <code>tac</code>, nor admits the goal if <code>tac</code> failed.
Recall that <code>case</code> closes the goal using <code>sorry</code> when <code>tac</code> fails, and
the tactic execution is not interrupted.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.case'">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.casePatt'"><h2>case'</h2><p><p><code>case' _ : t =&gt; tac</code> is similar to the <code>case _ : t =&gt; tac</code> tactic,
but it does not ensure the goal has been solved after applying <code>tac</code>,
nor does it admit the goal if <code>tac</code> failed.
Recall that <code>case</code> closes the goal using <code>sorry</code> when <code>tac</code> fails,
and the tactic execution is not interrupted.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Case.html#Batteries.Tactic.casePatt'">Batteries.Tactic.Case</a></dd></dl></div><div id="Lean.Parser.Tactic.cases"><h2>cases</h2><p><p>Assuming <code>x</code> is a variable in the local context with an inductive type,
<code>cases x</code> splits the main goal, producing one goal for each constructor of the
inductive type, in which the target is replaced by a general instance of that constructor.
If the type of an element in the local context depends on <code>x</code>,
that element is reverted and reintroduced afterward,
so that the case split affects that hypothesis as well.
<code>cases</code> detects unreachable cases and closes them automatically.</p><p>For example, given <code>n : <a href="./Init/Prelude.html#Nat">Nat</a></code> and a goal with a hypothesis <code>h : P n</code> and target <code>Q n</code>,
<code>cases n</code> produces one goal with hypothesis <code>h : P 0</code> and target <code>Q 0</code>,
and one goal with hypothesis <code>h : P (Nat.succ a)</code> and target <code>Q (Nat.succ a)</code>.
Here the name <code>a</code> is chosen automatically and is not accessible.
You can use <code>with</code> to provide the variables names for each constructor.</p><ul><li><code>cases e</code>, where <code>e</code> is an expression instead of a variable, generalizes <code>e</code> in the goal,
and then cases on the resulting variable.</li><li>Given <code>as : <a href="./Init/Prelude.html#List">List</a> α</code>, <code>cases as with | nil =&gt; tac₁ | cons a as' =&gt; tac₂</code>,
uses tactic <code>tac₁</code> for the <code>nil</code> case, and <code>tac₂</code> for the <code>cons</code> case,
and <code>a</code> and <code>as'</code> are used as names for the new variables introduced.</li><li><code>cases h : e</code>, where <code>e</code> is a variable or an expression,
performs cases on <code>e</code> as above, but also adds a hypothesis <code>h : e = ...</code> to each goal,
where <code>...</code> is the constructor instance for that particular case.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.cases">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.cbv"><h2>cbv</h2><p><p><code>cbv</code> performs simplification that closely mimics call-by-value evaluation.
It reduces terms by unfolding definitions using their defining equations and
applying matcher equations. The unfolding is propositional, so <code>cbv</code> also works
with functions defined via well-founded recursion or partial fixpoints.</p><p><code>cbv</code> has built-in support for goals of the form <code>lhs = rhs</code>. It proceeds in
two passes:</p><ol><li>Reduce <code>lhs</code>. If the result is definitionally equal to <code>rhs</code>, close the goal.</li><li>Otherwise, reduce <code>rhs</code>. If the result is now definitionally equal to the
reduced <code>lhs</code>, close the goal.</li><li>If neither check succeeds, generate a new goal <code>lhs' = rhs'</code>, where <code>lhs'</code>
and <code>rhs'</code> are the reduced forms of the original sides.</li></ol><p><code>cbv</code> is therefore not a finishing tactic in general: it may leave a new
(simpler) equality goal. For goals that are not equalities, <code>cbv</code> currently
leaves the goal unchanged.</p><p>The proofs produced by <code>cbv</code> only use the three standard axioms.
In particular, they do not require trust in the correctness of the code
generator.</p><p>This tactic is experimental and its behavior is likely to change in upcoming
releases of Lean.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.cbv">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.change"><h2>change</h2><p><ul><li><code>change tgt'</code> will change the goal from <code>tgt</code> to <code>tgt'</code>,
assuming these are definitionally equal.</li><li><code>change t' at h</code> will change hypothesis <code>h : t</code> to have type <code>t'</code>, assuming
assuming <code>t</code> and <code>t'</code> are definitionally equal.</li><li><code>change a with b</code> will change occurrences of <code>a</code> to <code>b</code> in the goal,
assuming <code>a</code> and <code>b</code> are definitionally equal.</li><li><code>change a with b at h</code> similarly changes <code>a</code> to <code>b</code> in the type of hypothesis <code>h</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.change">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.classical"><h2>classical</h2><p><p><code>classical tacs</code> runs <code>tacs</code> in a scope where <code><a href="./Init/Classical.html#Classical.propDecidable">Classical.propDecidable</a></code> is a low priority
local instance.</p><p>Note that <code>classical</code> is a scoping tactic: it adds the instance only within the
scope of the tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.classical">Init.Tactics</a></dd></dl></div><div id="tacticClean_wf"><h2>clean_wf</h2><p><p>This tactic is used internally by lean before presenting the proof obligations from a well-founded
definition to the user via <code>decreasing_by</code>. It is not necessary to use this tactic manually.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/WFTactics.html#tacticClean_wf">Init.WFTactics</a></dd></dl></div><div id="Lean.Parser.Tactic.clear"><h2>clear</h2><p><p><code>clear x...</code> removes the given hypotheses, or fails if there are remaining
references to a hypothesis.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.clear">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.clearValue"><h2>clear_value</h2><p><ul><li><p><code>clear_value x...</code> clears the values of the given local definitions.
A local definition <code>x : α := v</code> becomes a hypothesis <code>x : α</code>.</p></li><li><p><code>clear_value (h : x = _)</code> adds a hypothesis <code>h : x = v</code> before clearing the value of <code>x</code>.
This is short for <code>have h : x = v := rfl; clear_value x</code>.
Any value definitionally equal to <code>v</code> can be used in place of <code>_</code>.</p></li><li><p><code>clear_value *</code> clears values of all hypotheses that can be cleared.
Fails if none can be cleared.</p></li></ul><p>These syntaxes can be combined. For example, <code>clear_value x y *</code> ensures that <code>x</code> and <code>y</code> are cleared
while trying to clear all other local definitions,
and <code>clear_value (hx : x = _) y * with hx</code> does the same while first adding the <code>hx : x = v</code> hypothesis.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.clearValue">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.congr"><h2>congr</h2><p><p>Apply congruence (recursively) to goals of the form <code>⊢ f as = f bs</code> and <code>⊢ f as ≍ f bs</code>.
The optional parameter is the depth of the recursive applications.
This is useful when <code><a href="./Init/Prelude.html#congr">congr</a></code> is too aggressive in breaking down the goal.
For example, given <code>⊢ f (g (x + y)) = f (g (y + x))</code>,
<code><a href="./Init/Prelude.html#congr">congr</a></code> produces the goals <code>⊢ x = y</code> and <code>⊢ y = x</code>,
while <code><a href="./Init/Prelude.html#congr">congr</a> 2</code> produces the intended <code>⊢ x + y = y + x</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.congr">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.congrConfigWith"><h2>congr</h2><p><p>Apply congruence (recursively) to goals of the form <code>⊢ f as = f bs</code> and <code>⊢ f as ≍ f bs</code>.</p><ul><li><code><a href="./Init/Prelude.html#congr">congr</a> n</code> controls the depth of the recursive applications.
This is useful when <code><a href="./Init/Prelude.html#congr">congr</a></code> is too aggressive in breaking down the goal.
For example, given <code>⊢ f (g (x + y)) = f (g (y + x))</code>,
<code><a href="./Init/Prelude.html#congr">congr</a></code> produces the goals <code>⊢ x = y</code> and <code>⊢ y = x</code>,
while <code><a href="./Init/Prelude.html#congr">congr</a> 2</code> produces the intended <code>⊢ x + y = y + x</code>.</li><li>If, at any point, a subgoal matches a hypothesis then the subgoal will be closed.</li><li>You can use <code><a href="./Init/Prelude.html#congr">congr</a> with p (: n)?</code> to call <code>ext p (: n)?</code> to all subgoals generated by <code><a href="./Init/Prelude.html#congr">congr</a></code>.
For example, if the goal is <code>⊢ f '' s = g '' s</code> then <code><a href="./Init/Prelude.html#congr">congr</a> with x</code> generates the goal
<code>x : α ⊢ f x = g x</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Congr.html#Batteries.Tactic.congrConfigWith">Batteries.Tactic.Congr</a></dd></dl></div><div id="Batteries.Tactic.congrConfig"><h2>congr</h2><p><p>Apply congruence (recursively) to goals of the form <code>⊢ f as = f bs</code> and <code>⊢ f as ≍ f bs</code>.
The optional parameter is the depth of the recursive applications.
This is useful when <code><a href="./Init/Prelude.html#congr">congr</a></code> is too aggressive in breaking down the goal.
For example, given <code>⊢ f (g (x + y)) = f (g (y + x))</code>,
<code><a href="./Init/Prelude.html#congr">congr</a></code> produces the goals <code>⊢ x = y</code> and <code>⊢ y = x</code>,
while <code><a href="./Init/Prelude.html#congr">congr</a> 2</code> produces the intended <code>⊢ x + y = y + x</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Congr.html#Batteries.Tactic.congrConfig">Batteries.Tactic.Congr</a></dd></dl></div><div id="Lean.Parser.Tactic.constructor"><h2>constructor</h2><p><p>If the main goal's target type is an inductive type, <code>constructor</code> solves it with
the first matching constructor, or else fails.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.constructor">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.contradiction"><h2>contradiction</h2><p><p><code>contradiction</code> closes the main goal if its hypotheses are &quot;trivially contradictory&quot;.</p><ul><li>Inductive type/family with no applicable constructors<pre><code class="language-lean">example (h : False) : p := by contradiction
</code></pre></li><li>Injectivity of constructors<pre><code class="language-lean">example (h : none = some true) : p := by contradiction  --
</code></pre></li><li>Decidable false proposition<pre><code class="language-lean">example (h : 2 + 2 = 3) : p := by contradiction
</code></pre></li><li>Contradictory hypotheses<pre><code class="language-lean">example (h : p) (h' : ¬ p) : q := by contradiction
</code></pre></li><li>Other simple contradictions such as<pre><code class="language-lean">example (x : Nat) (h : x ≠ x) : p := by contradiction
</code></pre></li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.contradiction">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.Conv.conv"><h2>conv</h2><p><p><code>conv =&gt; ...</code> allows the user to perform targeted rewriting on a goal or hypothesis,
by focusing on particular subexpressions.</p><p>See <a href="https://lean-lang.org/theorem_proving_in_lean4/conv.html">https://lean-lang.org/theorem_proving_in_lean4/conv.html</a> for more details.</p><p>Basic forms:</p><ul><li><code>conv =&gt; cs</code> will rewrite the goal with conv tactics <code>cs</code>.</li><li><code>conv at h =&gt; cs</code> will rewrite hypothesis <code>h</code>.</li><li><code>conv in pat =&gt; cs</code> will rewrite the first subexpression matching <code>pat</code> (see <code>pattern</code>).</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Conv.html#Lean.Parser.Tactic.Conv.conv">Init.Conv</a></dd></dl></div><div id="Lean.Parser.Tactic.Conv.convTactic"><h2>conv'</h2><p><p>Executes the given conv block without converting regular goal into a <code>conv</code> goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Conv.html#Lean.Parser.Tactic.Conv.convTactic">Init.Conv</a></dd></dl></div><div id="Lean.Parser.Tactic.cutsat"><h2>cutsat</h2><p><p><code>cutsat</code> solves linear integer arithmetic goals.</p><p>It is a implemented as a thin wrapper around the <code>grind</code> tactic, enabling only the <code>lia</code> solver.
Please use <code>grind</code> instead if you need additional capabilities.</p><p><strong>Deprecated</strong>: Use <code>lia</code> instead.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Grind/Tactics.html#Lean.Parser.Tactic.cutsat">Init.Grind.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.dbgTrace"><h2>dbg_trace</h2><p><p><code>dbg_trace &quot;foo&quot;</code> prints <code>foo</code> when elaborated.
Useful for debugging tactic control flow:</p><pre><code>example : <a href="./Init/Prelude.html#False">False</a> ∨ <a href="./Init/Prelude.html#True">True</a> := by
  first
  | apply Or.inl; trivial; dbg_trace &quot;left&quot;
  | apply Or.inr; trivial; dbg_trace &quot;right&quot;
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.dbgTrace">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.decide"><h2>decide</h2><p><p><code>decide</code> attempts to prove the main goal (with target type <code>p</code>) by synthesizing an instance of <code><a href="./Init/Prelude.html#Decidable">Decidable</a> p</code>
and then reducing that instance to evaluate the truth value of <code>p</code>.
If it reduces to <code>isTrue h</code>, then <code>h</code> is a proof of <code>p</code> that closes the goal.</p><p>The target is not allowed to contain local variables or metavariables.
If there are local variables, you can first try using the <code>revert</code> tactic with these local variables to move them into the target,
or you can use the <code>+revert</code> option, described below.</p><p>Options:</p><ul><li><code>decide +revert</code> begins by reverting local variables that the target depends on,
after cleaning up the local context of irrelevant variables.
A variable is <em>relevant</em> if it appears in the target, if it appears in a relevant variable,
or if it is a proposition that refers to a relevant variable.</li><li><code>decide +kernel</code> uses kernel for reduction instead of the elaborator.
It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,
and (2) it reduces the <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instance only once instead of twice.</li><li><code>decide +native</code> uses the native code compiler (<code>#eval</code>) to evaluate the <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instance,
admitting the result via an axiom. This can be significantly more efficient than using reduction, but it is at the cost of increasing the size
This can be significantly more efficient than using reduction, but it is at the cost of increasing the size
of the trusted code base.
Namely, it depends on the correctness of the Lean compiler and all definitions with an <code>@[implemented_by]</code> attribute.
Like with <code>+kernel</code>, the <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instance is evaluated only once.</li></ul><p>Limitation: In the default mode or <code>+kernel</code> mode, since <code>decide</code> uses reduction to evaluate the term,
<code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.
Reduction can also get stuck on <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instances with <code><a href="./Init/Prelude.html#Eq.rec">Eq.rec</a></code> terms.
These can appear in instances defined using tactics (such as <code>rw</code> and <code>simp</code>).
To avoid this, create such instances using definitions such as <code><a href="./Init/PropLemmas.html#decidable_of_iff">decidable_of_iff</a></code> instead.</p><h2 id="Examples" class="markdown-heading">Examples <a class="hover-link" href="#Examples">#</a></h2><p>Proving inequalities:</p><pre><code class="language-lean">example : 2 + 2 ≠ 5 := by decide
</code></pre><p>Trying to prove a false proposition:</p><pre><code class="language-lean">example : 1 ≠ 1 := by decide
/-
tactic 'decide' proved that the proposition
  1 ≠ 1
is false
-/
</code></pre><p>Trying to prove a proposition whose <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instance fails to reduce</p><pre><code class="language-lean">opaque unknownProp : Prop

open scoped Classical in
example : unknownProp := by decide
/-
tactic 'decide' failed for proposition
  unknownProp
since its 'Decidable' instance reduced to
  <a href="./Init/Prelude.html#Classical.choice">Classical.choice</a> ⋯
rather than to the 'isTrue' constructor.
-/
</code></pre><h2 id="Properties-and-relations" class="markdown-heading">Properties and relations <a class="hover-link" href="#Properties-and-relations">#</a></h2><p>For equality goals for types with decidable equality, usually <code><a href="./Init/Prelude.html#rfl">rfl</a></code> can be used in place of <code>decide</code>.</p><pre><code class="language-lean">example : 1 + 1 = 2 := by decide
example : 1 + 1 = 2 := by <a href="./Init/Prelude.html#rfl">rfl</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.decide">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.decide_cbv"><h2>decide_cbv</h2><p><p><code>decide_cbv</code> is a finishing tactic that closes goals of the form <code>p</code>, where <code>p</code>
is a <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> proposition. It proceeds in two steps:</p><ol><li>Apply <code><a href="./Init/Prelude.html#of_decide_eq_true">of_decide_eq_true</a></code> to transform the goal into <code>decide p = true</code>.</li><li>Reduce <code>decide p</code> via call-by-value normalization. If the result is
definitionally equal to <code>true</code>, the goal is closed.</li></ol><p><code>decide_cbv</code> fails with an error if <code>decide p</code> does not reduce to <code>true</code>.
Unlike <code>cbv</code>, <code>decide_cbv</code> is a terminal tactic: it either closes the goal or
fails.</p><p>The proofs produced by <code>decide_cbv</code> only use the three standard axioms.
In particular, they do not require trust in the correctness of the code
generator.</p><p>This tactic is experimental and its behavior is likely to change in upcoming
releases of Lean.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.decide_cbv">Init.Tactics</a></dd></dl></div><div id="tacticDecreasing_tactic"><h2>decreasing_tactic</h2><p><p><code>decreasing_tactic</code> is called by default on well-founded recursions in order
to synthesize a proof that recursive calls decrease along the selected
well founded relation. It can be locally overridden by using <code>decreasing_by tac</code>
on the recursive definition, and it can also be globally extended by adding
more definitions for <code>decreasing_tactic</code> (or <code>decreasing_trivial</code>,
which this tactic calls).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/WFTactics.html#tacticDecreasing_tactic">Init.WFTactics</a></dd></dl></div><div id="tacticDecreasing_trivial"><h2>decreasing_trivial</h2><p><p>Extensible helper tactic for <code>decreasing_tactic</code>. This handles the &quot;base case&quot;
reasoning after applying lexicographic order lemmas.
It can be extended by adding more macro definitions, e.g.</p><pre><code>macro_rules | `(tactic| decreasing_trivial) =&gt; `(tactic| linarith)
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/WFTactics.html#tacticDecreasing_trivial">Init.WFTactics</a></dd></dl></div><div id="tacticDecreasing_trivial_pre_omega"><h2>decreasing_trivial_pre_omega</h2><p><p>Variant of <code>decreasing_trivial</code> that does not use <code>omega</code>, intended to be used in core modules
before <code>omega</code> is available.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/WFTactics.html#tacticDecreasing_trivial_pre_omega">Init.WFTactics</a></dd></dl></div><div id="tacticDecreasing_with_"><h2>decreasing_with</h2><p><p>Constructs a proof of decreasing along a well founded relation, by simplifying, then applying
lexicographic order lemmas and finally using <code>ts</code> to solve the base case. If it fails,
it prints a message to help the user diagnose an ill-founded recursive definition.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/WFTactics.html#tacticDecreasing_with_">Init.WFTactics</a></dd></dl></div><div id="Lean.Parser.Tactic.delta"><h2>delta</h2><p><p><code>delta id1 id2 ...</code> delta-expands the definitions <code>id1</code>, <code>id2</code>, ....
This is a low-level tactic, it will expose how recursive definitions have been
compiled by Lean.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.delta">Init.Tactics</a></dd></dl></div><div id="tacticDeriving_LawfulEq_tactic"><h2>deriving_LawfulEq_tactic</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/LawfulBEqTactics.html#tacticDeriving_LawfulEq_tactic">Init.LawfulBEqTactics</a></dd></dl></div><div id="tacticDeriving_LawfulEq_tactic_step"><h2>deriving_LawfulEq_tactic_step</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/LawfulBEqTactics.html#tacticDeriving_LawfulEq_tactic_step">Init.LawfulBEqTactics</a></dd></dl></div><div id="DerivingHelpers.tacticDeriving_ReflEq_tactic"><h2>deriving_ReflEq_tactic</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/LawfulBEqTactics.html#DerivingHelpers.tacticDeriving_ReflEq_tactic">Init.LawfulBEqTactics</a></dd></dl></div><div id="Lean.Parser.Tactic.done"><h2>done</h2><p><p><code>done</code> succeeds iff there are no remaining goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.done">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.dsimp"><h2>dsimp</h2><p><p>The <code>dsimp</code> tactic is the definitional simplifier. It is similar to <code>simp</code> but only
applies theorems that hold by reflexivity. Thus, the result is guaranteed to be
definitionally equal to the input.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.dsimp">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.dsimpAutoUnfold"><h2>dsimp!</h2><p><p><code>dsimp!</code> is shorthand for <code>dsimp</code> with <code>autoUnfold := true</code>.
This will unfold applications of functions defined by pattern matching, when one of the patterns applies.
This can be used to partially evaluate many definitions.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.dsimpAutoUnfold">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.dsimpTrace"><h2>dsimp?</h2><p><p><code>simp?</code> takes the same arguments as <code>simp</code>, but reports an equivalent call to <code>simp only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href="./Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: simp only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code>dsimp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.dsimpTrace">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticDsimp?!_"><h2>dsimp?!</h2><p><p><code>simp?</code> takes the same arguments as <code>simp</code>, but reports an equivalent call to <code>simp only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href="./Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: simp only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code>dsimp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticDsimp?!_">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.tacticEapply_"><h2>eapply</h2><p><p><code>eapply e</code> is like <code>apply e</code> but it does not add subgoals for variables that appear
in the types of other goals. Note that this can lead to a failure where there are
no goals remaining but there are still metavariables in the term:</p><pre><code>example (h : ∀ x : Nat, x = x → True) : <a href="./Init/Prelude.html#True">True</a> := by
  eapply h
  <a href="./Init/Prelude.html#rfl">rfl</a>
  -- no goals
-- (kernel) declaration has metavariables '_example'
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tacticEapply_">Batteries.Tactic.Init</a></dd></dl></div><div id="Lean.Parser.Tactic.eqRefl"><h2>eq_refl</h2><p><p><code>eq_refl</code> is equivalent to <code>exact <a href="./Init/Prelude.html#rfl">rfl</a></code>, but has a few optimizations.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.eqRefl">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticErw___"><h2>erw</h2><p><p><code>erw [rules]</code> is a shorthand for <code>rw (transparency := .default) [rules]</code>.
This does rewriting up to unfolding of regular definitions (by comparison to regular <code>rw</code>
which only unfolds <code>@[reducible]</code> definitions).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.tacticErw___">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.exact"><h2>exact</h2><p><p><code>exact e</code> closes the main goal if its target type matches that of <code>e</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.exact">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.exact?"><h2>exact?</h2><p><p>Searches environment for definitions or theorems that can solve the goal using <code>exact</code>
with conditions resolved by <code>solve_by_elim</code>.</p><p>The optional <code>using</code> clause provides identifiers in the local context that must be
used by <code>exact?</code> when closing the goal.  This is most useful if there are multiple
ways to resolve the goal, and one wants to guide which lemma is used.</p><p>Use <code>+grind</code> to enable <code>grind</code> as a fallback discharger for subgoals.
Use <code>+try?</code> to enable <code>try?</code> as a fallback discharger for subgoals.
Use <code>-star</code> to disable fallback to star-indexed lemmas (like <code><a href="./Init/Core.html#Empty.elim">Empty.elim</a></code>, <code><a href="./Init/Prelude.html#And.left">And.left</a></code>).
Use <code>+all</code> to collect all successful lemmas instead of stopping at the first.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.exact?">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticExact_mod_cast_"><h2>exact_mod_cast</h2><p><p>Normalize casts in the goal and the given expression, then close the goal with <code>exact</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/TacticsExtra.html#Lean.Parser.Tactic.tacticExact_mod_cast_">Init.TacticsExtra</a></dd></dl></div><div id="Batteries.Tactic.exacts"><h2>exacts</h2><p><p>Like <code>exact</code>, but takes a list of terms and checks that all goals are discharged after the tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.exacts">Batteries.Tactic.Init</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticExfalso"><h2>exfalso</h2><p><p><code>exfalso</code> converts a goal <code>⊢ tgt</code> into <code>⊢ <a href="./Init/Prelude.html#False">False</a></code> by applying <code><a href="./Init/Prelude.html#False.elim">False.elim</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticExfalso">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.«tacticExists_,,»"><h2>exists</h2><p><p><code>exists e₁, e₂, ...</code> is shorthand for <code>refine ⟨e₁, e₂, ...⟩; try <a href="./Init/Core.html#trivial">trivial</a></code>.
It is useful for existential goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.«tacticExists_,,»">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.exposeNames"><h2>expose_names</h2><p><p><code>expose_names</code> renames all inaccessible variables with accessible names, making them available
for reference in generated tactics. However, this renaming introduces machine-generated names
that are not fully under user control. <code>expose_names</code> is primarily intended as a preamble for
auto-generated end-game tactic scripts. It is also useful as an alternative to
<code>set_option tactic.hygienic false</code>. If explicit control over renaming is needed in the
middle of a tactic script, consider using structured tactic scripts with
<code>match .. with</code>, <code>induction .. with</code>, or <code>intro</code> with explicit user-defined names,
as well as tactics such as <code>next</code>, <code>case</code>, and <code>rename_i</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.exposeNames">Init.Tactics</a></dd></dl></div><div id="Lean.Elab.Tactic.Ext.ext"><h2>ext</h2><p><p>Applies extensionality lemmas that are registered with the <code>@[ext]</code> attribute.</p><ul><li><code>ext pat*</code> applies extensionality theorems as much as possible,
using the patterns <code>pat*</code> to introduce the variables in extensionality theorems using <code>rintro</code>.
For example, the patterns are used to name the variables introduced by lemmas such as <code><a href="./Init/Core.html#funext">funext</a></code>.</li><li>Without patterns,<code>ext</code> applies extensionality lemmas as much
as possible but introduces anonymous hypotheses whenever needed.</li><li><code>ext pat* : n</code> applies ext theorems only up to depth <code>n</code>.</li></ul><p>The <code>ext1 pat*</code> tactic is like <code>ext pat*</code> except that it only applies a single extensionality theorem.</p><p>Unused patterns will generate warning.
Patterns that don't match the variables will typically result in the introduction of anonymous hypotheses.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Ext.html#Lean.Elab.Tactic.Ext.ext">Init.Ext</a></dd></dl></div><div id="Lean.Elab.Tactic.Ext.tacticExt1___"><h2>ext1</h2><p><p><code>ext1 pat*</code> is like <code>ext pat*</code> except that it only applies a single extensionality theorem rather
than recursively applying as many extensionality theorems as possible.</p><p>The <code>pat*</code> patterns are processed using the <code>rintro</code> tactic.
If no patterns are supplied, then variables are introduced anonymously using the <code>intros</code> tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Ext.html#Lean.Elab.Tactic.Ext.tacticExt1___">Init.Ext</a></dd></dl></div><div id="Lean.Parser.Tactic.extractLets"><h2>extract_lets</h2><p><p>Extracts <code>let</code> and <code>have</code> expressions from within the target or a local hypothesis,
introducing new local definitions.</p><ul><li><code>extract_lets</code> extracts all the lets from the target.</li><li><code>extract_lets x y z</code> extracts all the lets from the target and uses <code>x</code>, <code>y</code>, and <code>z</code> for the first names.
Using <code>_</code> for a name leaves it unnamed.</li><li><code>extract_lets x y z at h</code> operates on the local hypothesis <code>h</code> instead of the target.</li></ul><p>For example, given a local hypotheses if the form <code>h : let x := v; b x</code>, then <code>extract_lets z at h</code>
introduces a new local definition <code>z := v</code> and changes <code>h</code> to be <code>h : b z</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.extractLets">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.fail"><h2>fail</h2><p><p><code>fail msg</code> is a tactic that always fails, and produces an error using the given message.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.fail">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.failIfSuccess"><h2>fail_if_success</h2><p><p><code>fail_if_success t</code> fails if the tactic <code>t</code> succeeds.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.failIfSuccess">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.falseOrByContra"><h2>false_or_by_contra</h2><p><p>Changes the goal to <code><a href="./Init/Prelude.html#False">False</a></code>, retaining as much information as possible:</p><ul><li>If the goal is <code><a href="./Init/Prelude.html#False">False</a></code>, do nothing.</li><li>If the goal is an implication or a function type, introduce the argument and restart.
(In particular, if the goal is <code>x ≠ y</code>, introduce <code>x = y</code>.)</li><li>Otherwise, for a propositional goal <code>P</code>, replace it with <code>¬ ¬ P</code>
(attempting to find a <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instance, but otherwise falling back to working classically)
and introduce <code>¬ P</code>.</li><li>For a non-propositional goal use <code><a href="./Init/Prelude.html#False.elim">False.elim</a></code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.falseOrByContra">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.tacticFapply_"><h2>fapply</h2><p><p><code>fapply e</code> is like <code>apply e</code> but it adds goals in the order they appear,
rather than putting the dependent goals first.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tacticFapply_">Batteries.Tactic.Init</a></dd></dl></div><div id="Lean.Parser.Tactic.first"><h2>first</h2><p><p><code>first | tac | ...</code> runs each <code>tac</code> until one succeeds, or else fails.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.first">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.firstPar"><h2>first_par</h2><p><p>Helper internal tactic for implementing the tactic <code>try?</code> with parallel execution, returning first success.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Try.html#Lean.Parser.Tactic.firstPar">Init.Try</a></dd></dl></div><div id="Lean.Parser.Tactic.focus"><h2>focus</h2><p><p><code>focus tac</code> focuses on the main goal, suppressing all other goals, and runs <code>tac</code> on it.
Usually <code>· tac</code>, which enforces that the goal is closed by <code>tac</code>, should be preferred.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.focus">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.funCases"><h2>fun_cases</h2><p><p>The <code>fun_cases</code> tactic is a convenience wrapper of the <code>cases</code> tactic when using a functional
cases principle.</p><p>The tactic invocation</p><pre><code>fun_cases f x ... y ...`
</code></pre><p>is equivalent to</p><pre><code>cases y, ... using f.fun_cases_unfolding x ...
</code></pre><p>where the arguments of <code>f</code> are used as arguments to <code>f.fun_cases_unfolding</code> or targets of the case
analysis, as appropriate.</p><p>The form</p><pre><code>fun_cases f
</code></pre><p>(with no arguments to <code>f</code>) searches the goal for a unique eligible application of <code>f</code>, and uses
these arguments. An application of <code>f</code> is eligible if it is saturated and the arguments that will
become targets are free variables.</p><p>The form <code>fun_cases f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂</code> works like with <code>cases</code>.</p><p>Under <code>set_option tactic.fun_induction.unfolding true</code> (the default), <code>fun_induction</code> uses the
<code>f.fun_cases_unfolding</code> theorem, which will try to automatically unfold the call to <code>f</code> in
the goal. With <code>set_option tactic.fun_induction.unfolding false</code>, it uses <code>f.fun_cases</code> instead.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.funCases">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.funInduction"><h2>fun_induction</h2><p><p>The <code>fun_induction</code> tactic is a convenience wrapper around the <code>induction</code> tactic to use the
functional induction principle.</p><p>The tactic invocation</p><pre><code>fun_induction f x₁ ... xₙ y₁ ... yₘ
</code></pre><p>where <code>f</code> is a function defined by non-mutual structural or well-founded recursion, is equivalent to</p><pre><code>induction y₁, ... yₘ using f.induct_unfolding x₁ ... xₙ
</code></pre><p>where the arguments of <code>f</code> are used as arguments to <code>f.induct_unfolding</code> or targets of the
induction, as appropriate.</p><p>The form</p><pre><code>fun_induction f
</code></pre><p>(with no arguments to <code>f</code>) searches the goal for a unique eligible application of <code>f</code>, and uses
these arguments. An application of <code>f</code> is eligible if it is saturated and the arguments that will
become targets are free variables.</p><p>The forms <code>fun_induction f x y generalizing z₁ ... zₙ</code> and
<code>fun_induction f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂</code> work like with <code>induction.</code></p><p>Under <code>set_option tactic.fun_induction.unfolding true</code> (the default), <code>fun_induction</code> uses the
<code>f.induct_unfolding</code> induction principle, which will try to automatically unfold the call to <code>f</code> in
the goal. With <code>set_option tactic.fun_induction.unfolding false</code>, it uses <code>f.induct</code> instead.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.funInduction">Init.Tactics</a></dd></dl></div><div id="tacticFunext___"><h2>funext</h2><p><p>Apply function extensionality and introduce new hypotheses.
The tactic <code><a href="./Init/Core.html#funext">funext</a></code> will keep applying the <code><a href="./Init/Core.html#funext">funext</a></code> lemma until the goal target is not reducible to</p><pre><code>  |-  ((fun x =&gt; ...) = (fun x =&gt; ...))
</code></pre><p>The variant <code><a href="./Init/Core.html#funext">funext</a> h₁ ... hₙ</code> applies <code><a href="./Init/Core.html#funext">funext</a></code> <code>n</code> times, and uses the given identifiers to name the new hypotheses.
Patterns can be used like in the <code>intro</code> tactic. Example, given a goal</p><pre><code>  |-  ((fun x : <a href="./Init/Prelude.html#Nat">Nat</a> × <a href="./Init/Prelude.html#Bool">Bool</a> =&gt; ...) = (fun x =&gt; ...))
</code></pre><p><code><a href="./Init/Core.html#funext">funext</a> (a, b)</code> applies <code><a href="./Init/Core.html#funext">funext</a></code> once and performs pattern matching on the newly introduced pair.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/NotationExtra.html#tacticFunext___">Init.NotationExtra</a></dd></dl></div><div id="Lean.Parser.Tactic.generalize"><h2>generalize</h2><p><ul><li><code>generalize ([h :] e = x),+</code> replaces all occurrences <code>e</code>s in the main goal
with a fresh hypothesis <code>x</code>s. If <code>h</code> is given, <code>h : e = x</code> is introduced as well.</li><li><code>generalize e = x at h₁ ... hₙ</code> also generalizes occurrences of <code>e</code>
inside <code>h₁</code>, ..., <code>hₙ</code>.</li><li><code>generalize e = x at *</code> will generalize occurrences of <code>e</code> everywhere.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.generalize">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.generalizeProofsElab"><h2>generalize_proofs</h2><p><p><code>generalize_proofs ids* [at locs]?</code> generalizes proofs in the current goal,
turning them into new local hypotheses.</p><ul><li><code>generalize_proofs</code> generalizes proofs in the target.</li><li><code>generalize_proofs at h₁ h₂</code> generalized proofs in hypotheses <code>h₁</code> and <code>h₂</code>.</li><li><code>generalize_proofs at *</code> generalizes proofs in the entire local context.</li><li><code>generalize_proofs pf₁ pf₂ pf₃</code> uses names <code>pf₁</code>, <code>pf₂</code>, and <code>pf₃</code> for the generalized proofs.
These can be <code>_</code> to not name proofs.</li></ul><p>If a proof is already present in the local context, it will use that rather than create a new
local hypothesis.</p><p>When doing <code>generalize_proofs at h</code>, if <code>h</code> is a let binding, its value is cleared,
and furthermore if <code>h</code> duplicates a preceding local hypothesis then it is eliminated.</p><p>The tactic is able to abstract proofs from under binders, creating universally quantified
proofs in the local context.
To disable this, use <code>generalize_proofs -abstract</code>.
The tactic is also set to recursively abstract proofs from the types of the generalized proofs.
This can be controlled with the <code>maxDepth</code> configuration option,
with <code>generalize_proofs (config := { maxDepth := 0 })</code> turning this feature off.</p><p>For example:</p><pre><code class="language-lean">def List.nthLe {α} (l : <a href="./Init/Prelude.html#List">List</a> α) (n : ℕ) (_h : n &lt; l.length) : α := sorry
example : List.nthLe [1, 2] 1 (by simp) = 2 := by
  -- ⊢ [1, 2].nthLe 1 ⋯ = 2
  generalize_proofs h
  -- h : 1 &lt; [1, 2].length
  -- ⊢ [1, 2].nthLe 1 h = 2
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/GeneralizeProofs.html#Batteries.Tactic.generalizeProofsElab">Batteries.Tactic.GeneralizeProofs</a></dd></dl></div><div id="tacticGet_elem_tactic"><h2>get_elem_tactic</h2><p><p><code>get_elem_tactic</code> is the tactic automatically called by the notation <code>arr[i]</code>
to prove any side conditions that arise when constructing the term
(e.g. the index is in bounds of the array). It just delegates to
<code>get_elem_tactic_extensible</code> and gives a diagnostic error message otherwise;
users are encouraged to extend <code>get_elem_tactic_extensible</code> instead of this tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#tacticGet_elem_tactic">Init.Tactics</a></dd></dl></div><div id="tacticGet_elem_tactic_extensible"><h2>get_elem_tactic_extensible</h2><p><p><code>get_elem_tactic_extensible</code> is an extensible tactic automatically called
by the notation <code>arr[i]</code> to prove any side conditions that arise when
constructing the term (e.g. the index is in bounds of the array).
The default behavior is to try <code>simp +arith</code> and <code>omega</code>
(for doing linear arithmetic in the index).</p><p>(Note that the core tactic <code>get_elem_tactic</code> has already tried
<code>done</code> and <code>assumption</code> before the extensible tactic is called.)</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#tacticGet_elem_tactic_extensible">Init.Tactics</a></dd></dl></div><div id="tacticGet_elem_tactic_trivial"><h2>get_elem_tactic_trivial</h2><p><p><code>get_elem_tactic_trivial</code> has been deprecated in favour of <code>get_elem_tactic_extensible</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#tacticGet_elem_tactic_trivial">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.grind"><h2>grind</h2><p><p><code>grind</code> is a tactic inspired by modern SMT solvers. <strong>Picture a virtual whiteboard</strong>:
every time grind discovers a new equality, inequality, or logical fact,
it writes it on the board, groups together terms known to be equal,
and lets each reasoning engine read from and contribute to the shared workspace.
These engines work together to handle equality reasoning, apply known theorems,
propagate new facts, perform case analysis, and run specialized solvers
for domains like linear arithmetic and commutative rings.</p><p>See <a href="https://lean-lang.org/doc/reference/4.29.0-rc1/find/?domain=Verso.Genre.Manual.section&amp;name=grind-tactic">the reference manual's chapter on <code>grind</code></a> for more information.</p><p><code>grind</code> is <em>not</em> designed for goals whose search space explodes combinatorially,
think large pigeonhole instances, graph‑coloring reductions, high‑order N‑queens boards,
or a 200‑variable Sudoku encoded as Boolean constraints.  Such encodings require
thousands (or millions) of case‑splits that overwhelm <code>grind</code>’s branching search.</p><p>For <strong>bit‑level or combinatorial problems</strong>, consider using <strong><code>bv_decide</code></strong>.
<code>bv_decide</code> calls a state‑of‑the‑art SAT solver (CaDiCaL) and then returns a
<em>compact, machine‑checkable certificate</em>.</p><h3 id="Equality-reasoning" class="markdown-heading">Equality reasoning <a class="hover-link" href="#Equality-reasoning">#</a></h3><p><code>grind</code> uses <strong>congruence closure</strong> to track equalities between terms.
When two terms are known to be equal, congruence closure automatically deduces
equalities between more complex expressions built from them.
For example, if <code>a = b</code>, then congruence closure will also conclude that <code>f a</code> = <code>f b</code>
for any function <code>f</code>. This forms the foundation for efficient equality reasoning in <code>grind</code>.
Here is an example:</p><pre><code>example (f : <a href="./Init/Prelude.html#Nat">Nat</a> → Nat) (h : a = b) : f (f b) = f (f a) := by
  grind
</code></pre><h3 id="Applying-theorems-using-E-matching" class="markdown-heading">Applying theorems using E-matching <a class="hover-link" href="#Applying-theorems-using-E-matching">#</a></h3><p>To apply existing theorems, <code>grind</code> uses a technique called <strong>E-matching</strong>,
which finds matches for known theorem patterns while taking equalities into account.
Combined with congruence closure, E-matching helps <code>grind</code> discover
non-obvious consequences of theorems and equalities automatically.</p><p>Consider the following functions and theorems:</p><pre><code>def f (a : Nat) : <a href="./Init/Prelude.html#Nat">Nat</a> :=
  a + 1

def g (a : Nat) : <a href="./Init/Prelude.html#Nat">Nat</a> :=
  a - 1

@[grind =]
theorem gf (x : Nat) : g (f x) = x := by
  simp [f, g]
</code></pre><p>The theorem <code>gf</code> asserts that <code>g (f x) = x</code> for all natural numbers <code>x</code>.
The attribute <code>[grind =]</code> instructs <code>grind</code> to use the left-hand side of the equation,
<code>g (f x)</code>, as a pattern for E-matching.
Suppose we now have a goal involving:</p><pre><code>example {a b} (h : f b = a) : g a = b := by
  grind
</code></pre><p>Although <code>g a</code> is not an instance of the pattern <code>g (f x)</code>,
it becomes one modulo the equation <code>f b = a</code>. By substituting <code>a</code>
with <code>f b</code> in <code>g a</code>, we obtain the term <code>g (f b)</code>,
which matches the pattern <code>g (f x)</code> with the assignment <code>x := b</code>.
Thus, the theorem <code>gf</code> is instantiated with <code>x := b</code>,
and the new equality <code>g (f b) = b</code> is asserted.
<code>grind</code> then uses congruence closure to derive the implied equality
<code>g a = g (f b)</code> and completes the proof.</p><p>The pattern used to instantiate theorems affects the effectiveness of <code>grind</code>.
For example, the pattern <code>g (f x)</code> is too restrictive in the following case:
the theorem <code>gf</code> will not be instantiated because the goal does not even
contain the function symbol <code>g</code>.</p><pre><code>example (h₁ : f b = a) (h₂ : f c = a) : b = c := by
  grind
</code></pre><p>You can use the command <code>grind_pattern</code> to manually select a pattern for a given theorem.
In the following example, we instruct <code>grind</code> to use <code>f x</code> as the pattern,
allowing it to solve the goal automatically:</p><pre><code>grind_pattern gf =&gt; f x

example {a b c} (h₁ : f b = a) (h₂ : f c = a) : b = c := by
  grind
</code></pre><p>You can enable the option <code>trace.grind.ematch.instance</code> to make <code>grind</code> print a
trace message for each theorem instance it generates.</p><p>You can also specify a <strong>multi-pattern</strong> to control when <code>grind</code> should apply a theorem.
A multi-pattern requires that all specified patterns are matched in the current context
before the theorem is applied. This is useful for theorems such as transitivity rules,
where multiple premises must be simultaneously present for the rule to apply.
The following example demonstrates this feature using a transitivity axiom for a binary relation <code>R</code>:</p><pre><code>opaque R : <a href="./Init/Data/Int/Basic.html#Int">Int</a> → <a href="./Init/Data/Int/Basic.html#Int">Int</a> → Prop
axiom Rtrans {x y z : Int} : R x y → R y z → R x z

grind_pattern Rtrans =&gt; R x y, R y z

example {a b c d} : R a b → R b c → R c d → R a d := by
  grind
</code></pre><p>By specifying the multi-pattern <code>R x y, R y z</code>, we instruct <code>grind</code> to
instantiate <code>Rtrans</code> only when both <code>R x y</code> and <code>R y z</code> are available in the context.
In the example, <code>grind</code> applies <code>Rtrans</code> to derive <code>R a c</code> from <code>R a b</code> and <code>R b c</code>,
and can then repeat the same reasoning to deduce <code>R a d</code> from <code>R a c</code> and <code>R c d</code>.</p><p>Instead of using <code>grind_pattern</code> to explicitly specify a pattern,
you can use the <code>@[grind]</code> attribute or one of its variants, which will use a heuristic to
generate a (multi-)pattern. The complete list is available in the reference manual. The main ones are:</p><ul><li><code>@[grind →]</code> will select a multi-pattern from the hypotheses of the theorem (i.e. it will use the theorem for forwards reasoning).
In more detail, it will traverse the hypotheses of the theorem from left-to-right, and each time it encounters a minimal indexable
(i.e. has a constant as its head) subexpression which &quot;covers&quot; (i.e. fixes the value of) an argument which was not
previously covered, it will add that subexpression as a pattern, until all arguments have been covered.</li><li><code>@[grind ←]</code> will select a multi-pattern from the conclusion of theorem (i.e. it will use the theorem for backwards reasoning).
This may fail if not all the arguments to the theorem appear in the conclusion.</li><li><code>@[grind]</code> will traverse the conclusion and then the hypotheses left-to-right, adding patterns as they increase the coverage,
stopping when all arguments are covered.</li><li><code>@[grind =]</code> checks that the conclusion of the theorem is an equality, and then uses the left-hand-side of the equality as a pattern.
This may fail if not all of the arguments appear in the left-hand-side.</li></ul><p>Here is the previous example again but using the attribute <code>[grind →]</code></p><pre><code>opaque R : <a href="./Init/Data/Int/Basic.html#Int">Int</a> → <a href="./Init/Data/Int/Basic.html#Int">Int</a> → Prop
@[grind →] axiom Rtrans {x y z : Int} : R x y → R y z → R x z

example {a b c d} : R a b → R b c → R c d → R a d := by
  grind
</code></pre><p>To control theorem instantiation and avoid generating an unbounded number of instances,
<code>grind</code> uses a generation counter. Terms in the original goal are assigned generation zero.
When <code>grind</code> applies a theorem using terms of generation <code>≤ n n</code>, any new terms it creates
are assigned generation <code>n + 1 + 1 1</code>. This limits how far the tactic explores when applying
theorems and helps prevent an excessive number of instantiations.</p><h4 id="Key-options" class="markdown-heading">Key options: <a class="hover-link" href="#Key-options">#</a></h4><ul><li><code>grind (ematch := &lt;num&gt;)</code> controls the number of E-matching rounds.</li><li><code>grind [&lt;name&gt;, ...]</code> instructs <code>grind</code> to use the declaration <code>name</code> during E-matching.</li><li><code>grind only [&lt;name&gt;, ...]</code> is like <code>grind [&lt;name&gt;, ...]</code> but does not use theorems tagged with <code>@[grind]</code>.</li><li><code>grind (gen := &lt;num&gt;)</code> sets the maximum generation.</li></ul><h3 id="Linear-integer-arithmetic-lia" class="markdown-heading">Linear integer arithmetic (<code>lia</code>) <a class="hover-link" href="#Linear-integer-arithmetic-lia">#</a></h3><p><code>grind</code> can solve goals that reduce to <strong>linear integer arithmetic (LIA)</strong> using an
integrated decision procedure called <strong><code>lia</code></strong>.  It understands</p><ul><li>equalities   <code>p = 0</code></li><li>inequalities  <code>p ≤ 0</code></li><li>disequalities <code>p ≠ 0</code></li><li>divisibility  <code>d ∣ p</code></li></ul><p>The solver incrementally assigns integer values to variables; when a partial
assignment violates a constraint it adds a new, implied constraint and retries.
This <em>model-based</em> search is <strong>complete for LIA</strong>.</p><h4 id="Key-options" class="markdown-heading">Key options: <a class="hover-link" href="#Key-options">#</a></h4><ul><li><code>grind -lia</code> disable the solver (useful for debugging)</li><li><code>grind +qlia</code> accept rational models (shrinks the search space but is incomplete for ℤ)</li></ul><h4 id="Examples" class="markdown-heading">Examples: <a class="hover-link" href="#Examples">#</a></h4><pre><code>-- Even + even is never odd.
example {x y : Int} : 2 * x + 4 * y ≠ 5 := by
  grind

-- Mixing equalities and inequalities.
example {x y : Int} :
    2 * x + 3 * y = 0 → 1 ≤ x → y &lt; 1 := by
  grind

-- Reasoning with divisibility.
example (a b : Int) :
    2 ∣ a + 1 → 2 ∣ b + a → ¬ 2 ∣ b + 2 * a := by
  grind

example (x y : Int) :
    27 ≤ 11*x + 13*y →
    11*x + 13*y ≤ 45 →
    -10 ≤ 7*x - 9*y →
    7*x - 9*y ≤ 4 → <a href="./Init/Prelude.html#False">False</a> := by
  grind

-- Types that implement the `ToInt` type-class.
example (a b c : UInt64)
    : a ≤ 2 → b ≤ 3 → c - a - b = 0 → c ≤ 5 := by
  grind
</code></pre><h3 id="Algebraic-solver-ring" class="markdown-heading">Algebraic solver (<code>ring</code>) <a class="hover-link" href="#Algebraic-solver-ring">#</a></h3><p><code>grind</code> ships with an algebraic solver nick-named <strong><code>ring</code></strong> for goals that can
be phrased as polynomial equations (or disequations) over commutative rings,
semirings, or fields.</p><p><em>Works out of the box</em>
All core numeric types and relevant Mathlib types already provide the required
type-class instances, so the solver is ready to use in most developments.</p><p>What it can decide:</p><ul><li>equalities of the form <code>p = q</code></li><li>disequalities <code>p ≠ q</code></li><li>basic reasoning under field inverses (<code>a / b := a * b⁻¹</code>)</li><li>goals that mix ring facts with other <code>grind</code> engines</li></ul><h4 id="Key-options" class="markdown-heading">Key options: <a class="hover-link" href="#Key-options">#</a></h4><ul><li><code>grind -ring</code> turn the solver off (useful when debugging)</li><li><code>grind (ringSteps := n)</code> cap the number of steps performed by this procedure.</li></ul><h4 id="Examples" class="markdown-heading">Examples <a class="hover-link" href="#Examples">#</a></h4><pre><code>open Lean Grind

example [CommRing α] (x : α) : (x + 1) * (x - 1) = x^2 - 1 := by
  grind

-- Characteristic 256 means 16 * 16 = 0.
example [CommRing α] [IsCharP α 256] (x : α) :
    (x + 16) * (x - 16) = x^2 := by
  grind

-- Works on built-in rings such as `UInt8`.
example (x : UInt8) : (x + 16) * (x - 16) = x^2 := by
  grind

example [CommRing α] (a b c : α) :
    a + b + c = 3 →
    a^2 + b^2 + c^2 = 5 →
    a^3 + b^3 + c^3 = 7 →
    a^4 + b^4 = 9 - c^4 := by
  grind

example [Field α] [NoNatZeroDivisors α] (a : α) :
    1 / a + 1 / (2 * a) = 3 / (2 * a) := by
  grind
</code></pre><h3 id="Other-options" class="markdown-heading">Other options <a class="hover-link" href="#Other-options">#</a></h3><ul><li><code>grind (splits := &lt;num&gt;)</code> caps the <em>depth</em> of the search tree.  Once a branch performs <code>num</code> splits
<code>grind</code> stops splitting further in that branch.</li><li><code>grind -splitIte</code> disables case splitting on if-then-else expressions.</li><li><code>grind -splitMatch</code> disables case splitting on <code>match</code> expressions.</li><li><code>grind +splitImp</code> instructs <code>grind</code> to split on any hypothesis <code>A → B</code> whose antecedent <code>A</code> is <strong>propositional</strong>.</li><li><code>grind -linarith</code> disables the linear arithmetic solver for (ordered) modules and rings.</li></ul><h3 id="Additional-Examples" class="markdown-heading">Additional Examples <a class="hover-link" href="#Additional-Examples">#</a></h3><pre><code>example {a b} {as bs : <a href="./Init/Prelude.html#List">List</a> α} : (as ++ bs ++ [b]).getLastD a = b := by
  grind

example (x : <a href="./Init/Prelude.html#BitVec">BitVec</a> (w+1)) : (BitVec.cons x.msb (x.setWidth w)) = x := by
  grind

example (as : <a href="./Init/Prelude.html#Array">Array</a> α) (lo hi i j : Nat) :
    lo ≤ i → i &lt; j → j ≤ hi → j &lt; as.size → min lo (as.size - 1) ≤ i := by
  grind
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Grind/Tactics.html#Lean.Parser.Tactic.grind">Init.Grind.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.grindTrace"><h2>grind?</h2><p><p><code>grind?</code> takes the same arguments as <code>grind</code>, but reports an equivalent call to <code>grind only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the <code>grind</code>
theorems in a local invocation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindTrace">Init.Grind.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.grind_linarith"><h2>grind_linarith</h2><p><p><code>grind_linarith</code> solves simple goals about linear arithmetic.</p><p>It is a implemented as a thin wrapper around the <code>grind</code> tactic, enabling only the <code>linarith</code> solver.
Please use <code>grind</code> instead if you need additional capabilities.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Grind/Tactics.html#Lean.Parser.Tactic.grind_linarith">Init.Grind.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.grind_order"><h2>grind_order</h2><p><p><code>grind_order</code> solves simple goals about partial orders and linear orders.</p><p>It is a implemented as a thin wrapper around the <code>grind</code> tactic, enabling only the <code>order</code> solver.
Please use <code>grind</code> instead if you need additional capabilities.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Grind/Tactics.html#Lean.Parser.Tactic.grind_order">Init.Grind.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.grobner"><h2>grobner</h2><p><p><code>grobner</code> solves goals that can be phrased as polynomial equations (with further polynomial equations as hypotheses)
over commutative (semi)rings, using the Grobner basis algorithm.</p><p>It is a implemented as a thin wrapper around the <code>grind</code> tactic, enabling only the <code>grobner</code> solver.
Please use <code>grind</code> instead if you need additional capabilities.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Grind/Tactics.html#Lean.Parser.Tactic.grobner">Init.Grind.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.guardExpr"><h2>guard_expr</h2><p><p>Tactic to check equality of two expressions.</p><ul><li><code>guard_expr e = e'</code> checks that <code>e</code> and <code>e'</code> are defeq at reducible transparency.</li><li><code>guard_expr e =~ e'</code> checks that <code>e</code> and <code>e'</code> are defeq at default transparency.</li><li><code>guard_expr e =ₛ e'</code> checks that <code>e</code> and <code>e'</code> are syntactically equal.</li><li><code>guard_expr e =ₐ e'</code> checks that <code>e</code> and <code>e'</code> are alpha-equivalent.</li></ul><p>Both <code>e</code> and <code>e'</code> are elaborated then have their metavariables instantiated before the equality
check. Their types are unified (using <code>isDefEqGuarded</code>) before synthetic metavariables are
processed, which helps with default instance handling.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Guard.html#Lean.Parser.Tactic.guardExpr">Init.Guard</a></dd></dl></div><div id="Lean.Parser.Tactic.guardHyp"><h2>guard_hyp</h2><p><p>Tactic to check that a named hypothesis has a given type and/or value.</p><ul><li><code>guard_hyp h : t</code> checks the type up to reducible defeq,</li><li><code>guard_hyp h :~ t</code> checks the type up to default defeq,</li><li><code>guard_hyp h :ₛ t</code> checks the type up to syntactic equality,</li><li><code>guard_hyp h :ₐ t</code> checks the type up to alpha equality.</li><li><code>guard_hyp h := v</code> checks value up to reducible defeq,</li><li><code>guard_hyp h :=~ v</code> checks value up to default defeq,</li><li><code>guard_hyp h :=ₛ v</code> checks value up to syntactic equality,</li><li><code>guard_hyp h :=ₐ v</code> checks the value up to alpha equality.</li></ul><p>The value <code>v</code> is elaborated using the type of <code>h</code> as the expected type.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Guard.html#Lean.Parser.Tactic.guardHyp">Init.Guard</a></dd></dl></div><div id="Lean.Parser.Tactic.guardTarget"><h2>guard_target</h2><p><p>Tactic to check that the target agrees with a given expression.</p><ul><li><code>guard_target = e</code> checks that the target is defeq at reducible transparency to <code>e</code>.</li><li><code>guard_target =~ e</code> checks that the target is defeq at default transparency to <code>e</code>.</li><li><code>guard_target =ₛ e</code> checks that the target is syntactically equal to <code>e</code>.</li><li><code>guard_target =ₐ e</code> checks that the target is alpha-equivalent to <code>e</code>.</li></ul><p>The term <code>e</code> is elaborated with the type of the goal as the expected type, which is mostly
useful within <code>conv</code> mode.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Guard.html#Lean.Parser.Tactic.guardTarget">Init.Guard</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticHave__"><h2>have</h2><p><p>The <code>have</code> tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the <code>let</code> tactic.</p><ul><li><code>have h : t := e</code> adds the hypothesis <code>h : t</code> if <code>e</code> is a term of type <code>t</code>.</li><li><code>have h := e</code> uses the type of <code>e</code> for <code>t</code>.</li><li><code>have : t := e</code> and <code>have := e</code> use <code>this</code> for the name of the hypothesis.</li><li><code>have pat := e</code> for a pattern <code>pat</code> is equivalent to <code>match e with | pat =&gt; _</code>,
where <code>_</code> stands for the tactics that follow this one.
It is convenient for types that have only one applicable constructor.
For example, given <code>h : p ∧ q ∧ r</code>, <code>have ⟨h₁, h₂, h₃⟩ := h</code> produces the
hypotheses <code>h₁ : p</code>, <code>h₂ : q</code>, and <code>h₃ : r</code>.</li><li>The syntax <code>have (eq := h) pat := e</code> is equivalent to <code>match h : e with | pat =&gt; _</code>,
which adds the equation <code>h : e = pat</code> to the local context.</li></ul><p>The tactic supports all the same syntax variants and options as the <code>have</code> term.</p><h2 id="Properties-and-relations" class="markdown-heading">Properties and relations <a class="hover-link" href="#Properties-and-relations">#</a></h2><ul><li>It is not possible to unfold a variable introduced using <code>have</code>, since the definition's value is forgotten.
The <code>let</code> tactic introduces definitions that can be unfolded.</li><li>The <code>have h : t := e</code> is like doing <code>let h : t := e; clear_value h</code>.</li><li>The <code>have</code> tactic is preferred for propositions, and <code>let</code> is preferred for non-propositions.</li><li>Sometimes <code>have</code> is used for non-propositions to ensure that the variable is never unfolded,
which may be important for performance reasons.
Consider using the equivalent <code>let +nondep</code> to indicate the intent.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticHave__">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticHave'"><h2>have'</h2><p><p>Similar to <code>have</code>, but using <code>refine'</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticHave'">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticHaveI__"><h2>haveI</h2><p><p><code>haveI</code> behaves like <code>have</code>, but inlines the value instead of producing a <code>have</code> term.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticHaveI__">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.unknown"><h2>ident</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Lean/Parser/Tactic.html#Lean.Parser.Tactic.unknown">Lean.Parser.Tactic</a></dd></dl></div><div id="Lean.Parser.Tactic.tacIfThenElse"><h2>if</h2><p><p>In tactic mode, <code>if t then tac1 else tac2</code> is alternative syntax for:</p><pre><code>by_cases t
· tac1
· tac2
</code></pre><p>It performs case distinction on <code>h† : t</code> or <code>h† : ¬t</code>, where <code>h†</code> is an anonymous hypothesis, and
<code>tac1</code> and <code>tac2</code> are the subproofs. (It doesn't actually use nondependent <code>if</code>, since this wouldn't
add anything to the context and hence would be useless for proving theorems. To actually insert an
<code><a href="./Init/Prelude.html#ite">ite</a></code> application use <code>refine if t then ?_ else ?_</code>.)</p><p>The assumptions in each subgoal can be named. <code>if h : t then tac1 else tac2</code> can be used as
alternative syntax for:</p><pre><code>by_cases h : t
· tac1
· tac2
</code></pre><p>It performs case distinction on <code>h : t</code> or <code>h : ¬t</code>.</p><p>You can use <code>?_</code> or <code>_</code> for either subproof to delay the goal to after the tactic, but
if a tactic sequence is provided for <code>tac1</code> or <code>tac2</code> then it will require the goal to be closed
by the end of the block.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacIfThenElse">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.induction"><h2>induction</h2><p><p>Assuming <code>x</code> is a variable in the local context with an inductive type,
<code>induction x</code> applies induction on <code>x</code> to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on <code>x</code>,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.</p><p>For example, given <code>n : <a href="./Init/Prelude.html#Nat">Nat</a></code> and a goal with a hypothesis <code>h : P n</code> and target <code>Q n</code>,
<code>induction n</code> produces one goal with hypothesis <code>h : P 0</code> and target <code>Q 0</code>,
and one goal with hypotheses <code>h : P (Nat.succ a)</code> and <code>ih₁ : P a → Q a</code> and target <code>Q (Nat.succ a)</code>.
Here the names <code>a</code> and <code>ih₁</code> are chosen automatically and are not accessible.
You can use <code>with</code> to provide the variables names for each constructor.</p><ul><li><code>induction e</code>, where <code>e</code> is an expression instead of a variable,
generalizes <code>e</code> in the goal, and then performs induction on the resulting variable.</li><li><code>induction e using r</code> allows the user to specify the principle of induction that should be used.
Here <code>r</code> should be a term whose result type must be of the form <code>C t</code>,
where <code>C</code> is a bound variable and <code>t</code> is a (possibly empty) sequence of bound variables</li><li><code>induction e generalizing z₁ ... zₙ</code>, where <code>z₁ ... zₙ</code> are variables in the local context,
generalizes over <code>z₁ ... zₙ</code> before applying the induction but then introduces them in each goal.
In other words, the net effect is that each inductive hypothesis is generalized.</li><li>Given <code>x : <a href="./Init/Prelude.html#Nat">Nat</a></code>, <code>induction x with | zero =&gt; tac₁ | succ x' ih =&gt; tac₂</code>
uses tactic <code>tac₁</code> for the <code>zero</code> case, and <code>tac₂</code> for the <code>succ</code> case.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.induction">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticInfer_instance"><h2>infer_instance</h2><p><p><code>infer_instance</code> is an abbreviation for <code>exact <a href="./Init/Prelude.html#inferInstance">inferInstance</a></code>.
It synthesizes a value of any target type by typeclass inference.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.injection"><h2>injection</h2><p><p>The <code>injection</code> tactic is based on the fact that constructors of inductive data
types are injections.
That means that if <code>c</code> is a constructor of an inductive datatype, and if <code>(c t₁)</code>
and <code>(c t₂)</code> are two terms that are equal then  <code>t₁</code> and <code>t₂</code> are equal too.
If <code>q</code> is a proof of a statement of conclusion <code>t₁ = t₂</code>, then injection applies
injectivity to derive the equality of all arguments of <code>t₁</code> and <code>t₂</code> placed in
the same positions. For example, from <code>(a::b) = (c::d)</code> we derive <code>a=c</code> and <code>b=d</code>.
To use this tactic <code>t₁</code> and <code>t₂</code> should be constructor applications of the same constructor.
Given <code>h : a::b = c::d</code>, the tactic <code>injection h</code> adds two new hypothesis with types
<code>a = c</code> and <code>b = d</code> to the main goal.
The tactic <code>injection h with h₁ h₂</code> uses the names <code>h₁</code> and <code>h₂</code> to name the new hypotheses.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.injection">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.injections"><h2>injections</h2><p><p><code>injections</code> applies <code>injection</code> to all hypotheses recursively
(since <code>injection</code> can produce new hypotheses). Useful for destructing nested
constructor equalities like <code>(a::b::c) = (d::e::f)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.injections">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.intro"><h2>intro</h2><p><p>Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must
be a <code>let</code> or function type.</p><ul><li><code>intro</code> by itself introduces one anonymous hypothesis, which can be accessed
by e.g. <code>assumption</code>. It is equivalent to <code>intro _</code>.</li><li><code>intro x y</code> introduces two hypotheses and names them. Individual hypotheses
can be anonymized via <code>_</code>, given a type ascription, or matched against a pattern:<pre><code class="language-lean">-- ... ⊢ α × β → ...
intro (a, b)
-- ..., a : α, b : β ⊢ ...
</code></pre></li><li><code>intro <a href="./Init/Prelude.html#rfl">rfl</a></code> is short for <code>intro h; subst h</code>, if <code>h</code> is an equality where the left-hand or right-hand side
is a variable.</li><li>Alternatively, <code>intro</code> can be combined with pattern matching much like <code>fun</code>:<pre><code class="language-lean">intro
| n + 1, 0 =&gt; tac
| ...
</code></pre></li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.intro">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.introDot"><h2>intro</h2><p><p>The syntax <code>intro.</code> is deprecated in favor of <code>nofun</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/NoMatch.html#Batteries.Tactic.introDot">Batteries.Tactic.NoMatch</a></dd></dl></div><div id="Lean.Parser.Tactic.intros"><h2>intros</h2><p><p><code>intros</code> repeatedly applies <code>intro</code> to introduce zero or more hypotheses
until the goal is no longer a <em>binding expression</em>
(i.e., a universal quantifier, function type, implication, or <code>have</code>/<code>let</code>),
without performing any definitional reductions (no unfolding, beta, eta, etc.).
The introduced hypotheses receive inaccessible (hygienic) names.</p><p><code>intros x y z</code> is equivalent to <code>intro x y z</code> and exists only for historical reasons.
The <code>intro</code> tactic should be preferred in this case.</p><h2 id="Properties-and-relations" class="markdown-heading">Properties and relations <a class="hover-link" href="#Properties-and-relations">#</a></h2><ul><li><p><code>intros</code> succeeds even when it introduces no hypotheses.</p></li><li><p><code>repeat intro</code> is like <code>intros</code>, but it performs definitional reductions
to expose binders, and as such it may introduce more hypotheses than <code>intros</code>.</p></li><li><p><code>intros</code> is equivalent to <code>intro _ _ … _</code>,
with the fewest trailing <code>_</code> placeholders needed so that the goal is no longer a binding expression.
The trailing introductions do not perform any definitional reductions.</p></li></ul><h2 id="Examples" class="markdown-heading">Examples <a class="hover-link" href="#Examples">#</a></h2><p>Implications:</p><pre><code class="language-lean">example (p q : Prop) : p → q → p := by
  intros
  /- Tactic state
     a✝¹ : p
     a✝ : q
     ⊢ p      -/
  assumption
</code></pre><p>Let-bindings:</p><pre><code class="language-lean">example : let n := 1; let k := 2; n + k = 3 := by
  intros
  /- n✝ : <a href="./Init/Prelude.html#Nat">Nat</a> := 1
     k✝ : <a href="./Init/Prelude.html#Nat">Nat</a> := 2
     ⊢ n✝ + k✝ = 3 -/
  <a href="./Init/Prelude.html#rfl">rfl</a>
</code></pre><p>Does not unfold definitions:</p><pre><code class="language-lean">def AllEven (f : <a href="./Init/Prelude.html#Nat">Nat</a> → Nat) := ∀ n, f n % 2 = 0

example : ∀ (f : <a href="./Init/Prelude.html#Nat">Nat</a> → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by
  intros
  /- Tactic state
     f✝ : <a href="./Init/Prelude.html#Nat">Nat</a> → <a href="./Init/Prelude.html#Nat">Nat</a>
     a✝ : AllEven f✝
     ⊢ AllEven fun k =&gt; f✝ (k + 1) -/
  sorry
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.intros">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticIterate____"><h2>iterate</h2><p><p><code>iterate n tac</code> runs <code>tac</code> exactly <code>n</code> times.
<code>iterate tac</code> runs <code>tac</code> repeatedly until failure.</p><p><code>iterate</code>'s argument is a tactic sequence,
so multiple tactics can be run using <code>iterate n (tac₁; tac₂; ⋯)</code> or</p><pre><code class="language-lean">iterate n
  tac₁
  tac₂
  ⋯
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/TacticsExtra.html#Lean.Parser.Tactic.tacticIterate____">Init.TacticsExtra</a></dd></dl></div><div id="Lean.Parser.Tactic.left"><h2>left</h2><p><p>Applies the first constructor when
the goal is an inductive type with exactly two constructors, or fails otherwise.</p><pre><code>example : <a href="./Init/Prelude.html#True">True</a> ∨ <a href="./Init/Prelude.html#False">False</a> := by
  left
  <a href="./Init/Core.html#trivial">trivial</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.left">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticLet__"><h2>let</h2><p><p>The <code>let</code> tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by <code>have</code>.</p><ul><li><code>let x : t := e</code> adds the definition <code>x : t := e</code> if <code>e</code> is a term of type <code>t</code>.</li><li><code>let x := e</code> uses the type of <code>e</code> for <code>t</code>.</li><li><code>let : t := e</code> and <code>let := e</code> use <code>this</code> for the name of the hypothesis.</li><li><code>let pat := e</code> for a pattern <code>pat</code> is equivalent to <code>match e with | pat =&gt; _</code>,
where <code>_</code> stands for the tactics that follow this one.
It is convenient for types that let only one applicable constructor.
For example, given <code>p : α × β × γ</code>, <code>let ⟨x, y, z⟩ := p</code> produces the
local variables <code>x : α</code>, <code>y : β</code>, and <code>z : γ</code>.</li><li>The syntax <code>let (eq := h) pat := e</code> is equivalent to <code>match h : e with | pat =&gt; _</code>,
which adds the equation <code>h : e = pat</code> to the local context.</li></ul><p>The tactic supports all the same syntax variants and options as the <code>let</code> term.</p><h2 id="Properties-and-relations" class="markdown-heading">Properties and relations <a class="hover-link" href="#Properties-and-relations">#</a></h2><ul><li>Unlike <code>have</code>, it is possible to unfold definitions introduced using <code>let</code>, using tactics
such as <code>simp</code>, <code>dsimp</code>, <code>unfold</code>, and <code>subst</code>.</li><li>The <code>clear_value</code> tactic turns a <code>let</code> definition into a <code>have</code> definition after the fact.
The tactic might fail if the local context depends on the value of the variable.</li><li>The <code>let</code> tactic is preferred for data (non-propositions).</li><li>Sometimes <code>have</code> is used for non-propositions to ensure that the variable is never unfolded,
which may be important for performance reasons.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticLet__">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.letrec"><h2>let rec</h2><p><p><code>let rec f : t := e</code> adds a recursive definition <code>f</code> to the current goal.
The syntax is the same as term-mode <code>let rec</code>.</p><p>The tactic supports all the same syntax variants and options as the <code>let</code> term.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.letrec">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticLet'__"><h2>let'</h2><p><p>Similar to <code>let</code>, but using <code>refine'</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticLet'__">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticLetI__"><h2>letI</h2><p><p><code>letI</code> behaves like <code>let</code>, but inlines the value instead of producing a <code>let</code> term.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticLetI__">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.letToHave"><h2>let_to_have</h2><p><p>Transforms <code>let</code> expressions into <code>have</code> expressions when possible.</p><ul><li><code>let_to_have</code> transforms <code>let</code>s in the target.</li><li><code>let_to_have at h</code> transforms <code>let</code>s in the given local hypothesis.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.letToHave">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.lia"><h2>lia</h2><p><p><code>lia</code> solves linear integer arithmetic goals.</p><p>It is a implemented as a thin wrapper around the <code>grind</code> tactic, enabling only the <code>lia</code> solver.
Please use <code>grind</code> instead if you need additional capabilities.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Grind/Tactics.html#Lean.Parser.Tactic.lia">Init.Grind.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.liftLets"><h2>lift_lets</h2><p><p>Lifts <code>let</code> and <code>have</code> expressions within a term as far out as possible.
It is like <code>extract_lets +lift</code>, but the top-level lets at the end of the procedure
are not extracted as local hypotheses.</p><ul><li><code>lift_lets</code> lifts let expressions in the target.</li><li><code>lift_lets at h</code> lifts let expressions at the given local hypothesis.</li></ul><p>For example,</p><pre><code class="language-lean">example : (let x := 1; x) = 1 := by
  lift_lets
  -- ⊢ let x := 1; x = 1
  ...
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.liftLets">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.«tacticMap_tacs[_;]»"><h2>map_tacs</h2><p><p>Assuming there are <code>n</code> goals, <code>map_tacs [t1; t2; ...; tn]</code> applies each <code>ti</code> to the respective
goal and leaves the resulting subgoals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/SeqFocus.html#Batteries.Tactic.«tacticMap_tacs[_;]»">Batteries.Tactic.SeqFocus</a></dd></dl></div><div id="Lean.Parser.Tactic.massumptionMacro"><h2>massumption</h2><p><p><code>massumption</code> is like <code>assumption</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : Q ⊢ₛ P → Q := by
  mintro _ _
  massumption
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.massumptionMacro">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.«tacticMatch_,,With.»"><h2>match</h2><p><p>The syntax <code>match ⋯ with.</code> has been deprecated in favor of <code>nomatch ⋯</code>.</p><p>Both now support multiple discriminants.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/NoMatch.html#Batteries.Tactic.«tacticMatch_,,With.»">Batteries.Tactic.NoMatch</a></dd></dl></div><div id="Lean.Parser.Tactic.match"><h2>match</h2><p><p><code>match</code> performs case analysis on one or more expressions.
See <a href="https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html">Induction and Recursion</a>.
The syntax for the <code>match</code> tactic is the same as term-mode <code>match</code>, except that
the match arms are tactics instead of expressions.</p><pre><code>example (n : Nat) : n = n := by
  match n with
  | 0 =&gt; <a href="./Init/Prelude.html#rfl">rfl</a>
  | i+1 =&gt; simp
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Lean/Parser/Tactic.html#Lean.Parser.Tactic.match">Lean.Parser.Tactic</a></dd></dl></div><div id="Lean.Parser.Tactic.mcasesMacro"><h2>mcases</h2><p><p>Like <code>rcases</code>, but operating on stateful <code>Std.Do.SPred</code> goals.
Example: Given a goal <code>h : (P ∧ (Q ∨ R) ∧ (Q → R)) ⊢ₛ R</code>,
<code>mcases h with ⟨-, ⟨hq | hr⟩, hqr⟩</code> will yield two goals:
<code>(hq : Q, hqr : Q → R) ⊢ₛ R</code> and <code>(hr : R) ⊢ₛ R</code>.</p><p>That is, <code>mcases h with pat</code> has the following semantics, based on <code>pat</code>:</p><ul><li><code>pat=□h'</code> renames <code>h</code> to <code>h'</code> in the stateful context, regardless of whether <code>h</code> is pure</li><li><code>pat=⌜h'⌝</code> introduces <code>h' : φ</code>  to the pure local context if <code>h : ⌜φ⌝</code>
(c.f. <code>Lean.Elab.Tactic.Do.ProofMode.IsPure</code>)</li><li><code>pat=h'</code> is like <code>pat=⌜h'⌝</code> if <code>h</code> is pure
(c.f. <code>Lean.Elab.Tactic.Do.ProofMode.IsPure</code>), otherwise it is like <code>pat=□h'</code>.</li><li><code>pat=_</code> renames <code>h</code> to an inaccessible name</li><li><code>pat=-</code> discards <code>h</code></li><li><code>⟨pat₁, pat₂⟩</code> matches on conjunctions and existential quantifiers and recurses via
<code>pat₁</code> and <code>pat₂</code>.</li><li><code>⟨pat₁ | pat₂⟩</code> matches on disjunctions, matching the left alternative via <code>pat₁</code> and the right
alternative via <code>pat₂</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mcasesMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mclearMacro"><h2>mclear</h2><p><p><code>mclear</code> is like <code>clear</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ Q → Q := by
  mintro HP
  mintro HQ
  mclear HP
  mexact HQ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mclearMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mconstructorMacro"><h2>mconstructor</h2><p><p><code>mconstructor</code> is like <code>constructor</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (Q : SPred σs) : Q ⊢ₛ Q ∧ Q := by
  mintro HQ
  mconstructor &lt;;&gt; mexact HQ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mconstructorMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mdup"><h2>mdup</h2><p><p>Duplicate a stateful <code><a href="./Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> hypothesis.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mdup">Std.Tactic.Do.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.mexactMacro"><h2>mexact</h2><p><p><code>mexact</code> is like <code>exact</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (Q : SPred σs) : Q ⊢ₛ Q := by
  mstart
  mintro HQ
  mexact HQ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mexactMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mexfalsoMacro"><h2>mexfalso</h2><p><p><code>mexfalso</code> is like <code>exfalso</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P : SPred σs) : ⌜False⌝ ⊢ₛ P := by
  mintro HP
  mexfalso
  mexact HP
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mexfalsoMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mexistsMacro"><h2>mexists</h2><p><p><code>mexists</code> is like <code>exists</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (ψ : <a href="./Init/Prelude.html#Nat">Nat</a> → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by
  mintro H
  mexists 42
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mexistsMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mframeMacro"><h2>mframe</h2><p><p><code>mframe</code> infers which hypotheses from the stateful context can be moved into the pure context.
This is useful because pure hypotheses &quot;survive&quot; the next application of modus ponens
(<code>Std.Do.SPred.mp</code>) and transitivity (<code>Std.Do.SPred.entails.trans</code>).</p><p>It is used as part of the <code>mspec</code> tactic.</p><pre><code class="language-lean">example (P Q : SPred σs) : ⊢ₛ ⌜p⌝ ∧ Q ∧ ⌜q⌝ ∧ ⌜r⌝ ∧ P ∧ ⌜s⌝ ∧ ⌜t⌝ → Q := by
  mintro _
  mframe
  /- `h : p ∧ q ∧ r ∧ s ∧ t` in the pure context -/
  mcases h with hP
  mexact h
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mframeMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mhaveMacro"><h2>mhave</h2><p><p><code>mhave</code> is like <code>have</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by
  mintro HP HPQ
  mhave HQ : Q := by mspecialize HPQ HP; mexact HPQ
  mexact HQ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mhaveMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mintroMacro"><h2>mintro</h2><p><p>Like <code>intro</code>, but introducing stateful hypotheses into the stateful context of the <code>Std.Do.SPred</code>
proof mode.
That is, given a stateful goal <code>(hᵢ : Hᵢ)* ⊢ₛ P → T</code>, <code>mintro h</code> transforms
into <code>(hᵢ : Hᵢ)*, (h : P) ⊢ₛ T</code>.</p><p>Furthermore, <code>mintro ∀s</code> is like <code>intro s</code>, but preserves the stateful goal.
That is, <code>mintro ∀s</code> brings the topmost state variable <code>s:σ</code> in scope and transforms
<code>(hᵢ : Hᵢ)* ⊢ₛ T</code> (where the entailment is in <code>Std.Do.SPred (σ::σs)</code>) into
<code>(hᵢ : Hᵢ s)* ⊢ₛ T s</code> (where the entailment is in <code>Std.Do.SPred σs</code>).</p><p>Beyond that, <code>mintro</code> supports the full syntax of <code>mcases</code> patterns
(<code>mintro pat = (mintro h; mcases h with pat</code>), and can perform multiple
introductions in sequence.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mintroMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mleaveMacro"><h2>mleave</h2><p><p>Leaves the stateful proof mode of <code>Std.Do.SPred</code>, tries to eta-expand through all definitions
related to the logic of the <code>Std.Do.SPred</code> and gently simplifies the resulting pure Lean
proposition. This is often the right thing to do after <code>mvcgen</code> in order for automation to prove
the goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mleaveMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mleftMacro"><h2>mleft</h2><p><p><code>mleft</code> is like <code>left</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ P ∨ Q := by
  mintro HP
  mleft
  mexact HP
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mleftMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mpureMacro"><h2>mpure</h2><p><p><code>mpure</code> moves a pure hypothesis from the stateful context into the pure context.</p><pre><code class="language-lean">example (Q : SPred σs) (ψ : φ → ⊢ₛ Q): ⌜φ⌝ ⊢ₛ Q := by
  mintro Hφ
  mpure Hφ
  mexact (ψ Hφ)
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mpureMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mpureIntroMacro"><h2>mpure_intro</h2><p><p><code>mpure_intro</code> operates on a stateful <code>Std.Do.SPred</code> goal of the form <code>P ⊢ₛ ⌜φ⌝</code>.
It leaves the stateful proof mode (thereby discarding <code>P</code>), leaving the regular goal <code>φ</code>.</p><pre><code class="language-lean">theorem simple : ⊢ₛ (⌜True⌝ : SPred σs) := by
  mpure_intro
  exact <a href="./Init/Prelude.html#True.intro">True.intro</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mpureIntroMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mrefineMacro"><h2>mrefine</h2><p><p>Like <code>refine</code>, but operating on stateful <code>Std.Do.SPred</code> goals.</p><pre><code class="language-lean">example (P Q R : SPred σs) : (P ∧ Q ∧ R) ⊢ₛ P ∧ R := by
  mintro ⟨HP, HQ, HR⟩
  mrefine ⟨HP, HR⟩

example (ψ : <a href="./Init/Prelude.html#Nat">Nat</a> → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by
  mintro H
  mrefine ⟨⌜42⌝, H⟩
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mrefineMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mrenameIMacro"><h2>mrename_i</h2><p><p><code>mrename_i</code> is like <code>rename_i</code>, but names inaccessible stateful hypotheses in a <code>Std.Do.SPred</code> goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mrenameIMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mreplaceMacro"><h2>mreplace</h2><p><p><code>mreplace</code> is like <code>replace</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by
  mintro HP HPQ
  mreplace HPQ : Q := by mspecialize HPQ HP; mexact HPQ
  mexact HPQ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mreplaceMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mrevertMacro"><h2>mrevert</h2><p><p><code>mrevert</code> is like <code>revert</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q R : SPred σs) : P ∧ Q ∧ R ⊢ₛ P → R := by
  mintro ⟨HP, HQ, HR⟩
  mrevert HR
  mrevert HP
  mintro HP'
  mintro HR'
  mexact HR'
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mrevertMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mrightMacro"><h2>mright</h2><p><p><code>mright</code> is like <code>right</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ Q ∨ P := by
  mintro HP
  mright
  mexact HP
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mrightMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mspecMacro"><h2>mspec</h2><p><p><code>mspec</code> is an <code>apply</code>-like tactic that applies a Hoare triple specification to the target of the
stateful goal.</p><p>Given a stateful goal <code>H ⊢ₛ wp⟦prog⟧ Q'</code>, <code>mspec foo_spec</code> will instantiate
<code>foo_spec : ... → ⦃P⦄ foo ⦃Q⦄</code>, match <code>foo</code> against <code>prog</code> and produce subgoals for
the verification conditions <code>?pre : H ⊢ₛ P</code> and <code>?post : Q ⊢ₚ Q'</code>.</p><ul><li>If <code>prog = x &gt;&gt;= f</code>, then <code>mspec Specs.bind</code> is tried first so that <code>foo</code> is matched against <code>x</code>
instead. Tactic <code>mspec_no_bind</code> does not attempt to do this decomposition.</li><li>If <code>?pre</code> or <code>?post</code> follow by <code>.<a href="./Init/Prelude.html#rfl">rfl</a></code>, then they are discharged automatically.</li><li><code>?post</code> is automatically simplified into constituent <code>⊢ₛ</code> entailments on
success and failure continuations.</li><li><code>?pre</code> and <code>?post.*</code> goals introduce their stateful hypothesis under an inaccessible name.
You can give it a name with the <code>mrename_i</code> tactic.</li><li>Any uninstantiated MVar arising from instantiation of <code>foo_spec</code> becomes a new subgoal.</li><li>If the target of the stateful goal looks like <code>fun s =&gt; _</code> then <code>mspec</code> will first <code>mintro ∀s</code>.</li><li>If <code>P</code> has schematic variables that can be instantiated by doing <code>mintro ∀s</code>, for example
<code>foo_spec : ∀(n:Nat), ⦃fun s =&gt; ⌜n = s⌝⦄ foo ⦃Q⦄</code>, then <code>mspec</code> will do <code>mintro ∀s</code> first to
instantiate <code>n = s</code>.</li><li>Right before applying the spec, the <code>mframe</code> tactic is used, which has the following effect:
Any hypothesis <code>Hᵢ</code> in the goal <code>h₁:H₁, h₂:H₂, ..., hₙ:Hₙ ⊢ₛ T</code> that is
pure (i.e., equivalent to some <code>⌜φᵢ⌝</code>) will be moved into the pure context as <code>hᵢ:φᵢ</code>.</li></ul><p>Additionally, <code>mspec</code> can be used without arguments or with a term argument:</p><ul><li><code>mspec</code> without argument will try and look up a spec for <code>x</code> registered with <code>@[spec]</code>.</li><li><code>mspec (foo_spec blah ?bleh)</code> will elaborate its argument as a term with expected type
<code>⦃?P⦄ x ⦃?Q⦄</code> and introduce <code>?bleh</code> as a subgoal.
This is useful to pass an invariant to e.g., <code>Specs.forIn_list</code> and leave the inductive step
as a hole.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mspecMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mspecNoBind"><h2>mspec_no_bind</h2><p><p><code>mspec_no_simp $spec</code> first tries to decompose <code><a href="./Init/Prelude.html#Bind.bind">Bind.bind</a></code>s before applying <code>$spec</code>.
This variant of <code>mspec_no_simp</code> does not; <code>mspec_no_bind $spec</code> is defined as</p><pre><code>try with_reducible mspec_no_bind <a href="./Std/Do/Triple/SpecLemmas.html#Std.Do.Spec.bind">Std.Do.Spec.bind</a>
mspec_no_bind $spec
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoBind">Std.Tactic.Do.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.mspecNoSimp"><h2>mspec_no_simp</h2><p><p>Like <code>mspec</code>, but does not attempt slight simplification and closing of trivial sub-goals.
<code>mspec $spec</code> is roughly (the set of simp lemmas below might not be up to date)</p><pre><code>mspec_no_simp $spec
all_goals
  ((try simp only [SPred.true_intro_simp, SPred.apply_pure]);
   (try mpure_intro; trivial))
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoSimp">Std.Tactic.Do.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.mspecializeMacro"><h2>mspecialize</h2><p><p><code>mspecialize</code> is like <code>specialize</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.
It specializes a hypothesis from the stateful context with hypotheses from either the pure
or stateful context or pure terms.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by
  mintro HP HPQ
  mspecialize HPQ HP
  mexact HPQ

example (y : Nat) (P Q : SPred σs) (Ψ : <a href="./Init/Prelude.html#Nat">Nat</a> → SPred σs) (hP : ⊢ₛ P) : ⊢ₛ Q → (∀ x, P → Q → Ψ x) → Ψ (y + 1) := by
  mintro HQ HΨ
  mspecialize HΨ (y + 1) hP HQ
  mexact HΨ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mspecializeMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mspecializePureMacro"><h2>mspecialize_pure</h2><p><p><code>mspecialize_pure</code> is like <code>mspecialize</code>, but it specializes a hypothesis from the
<em>pure</em> context with hypotheses from either the pure or stateful context or pure terms.</p><pre><code class="language-lean">example (y : Nat) (P Q : SPred σs) (Ψ : <a href="./Init/Prelude.html#Nat">Nat</a> → SPred σs) (hP : ⊢ₛ P) (hΨ : ∀ x, ⊢ₛ P → Q → Ψ x) : ⊢ₛ Q → Ψ (y + 1) := by
  mintro HQ
  mspecialize_pure (hΨ (y + 1)) hP HQ =&gt; HΨ
  mexact HΨ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mspecializePureMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mstartMacro"><h2>mstart</h2><p><p>Start the stateful proof mode of <code>Std.Do.SPred</code>.
This will transform a stateful goal of the form <code>H ⊢ₛ T</code> into <code>⊢ₛ H → T</code>
upon which <code>mintro</code> can be used to re-introduce <code>H</code> and give it a name.
It is often more convenient to use <code>mintro</code> directly, which will
try <code>mstart</code> automatically if necessary.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mstartMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mstopMacro"><h2>mstop</h2><p><p>Stops the stateful proof mode of <code>Std.Do.SPred</code>.
This will simply forget all the names given to stateful hypotheses and pretty-print
a bit differently.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mstopMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mvcgenMacro"><h2>mvcgen</h2><p><p><code>mvcgen</code> will break down a Hoare triple proof goal like <code>⦃P⦄ prog ⦃Q⦄</code> into verification conditions,
provided that all functions used in <code>prog</code> have specifications registered with <code>@[spec]</code>.</p><h3 id="Verification-Conditions-and-specifications" class="markdown-heading">Verification Conditions and specifications <a class="hover-link" href="#Verification-Conditions-and-specifications">#</a></h3><p>A verification condition is an entailment in the stateful logic of <code>Std.Do.SPred</code>
in which the original program <code>prog</code> no longer occurs.
Verification conditions are introduced by the <code>mspec</code> tactic; see the <code>mspec</code> tactic for what they
look like.
When there's no applicable <code>mspec</code> spec, <code>mvcgen</code> will try and rewrite an application
<code>prog = f a b c</code> with the simp set registered via <code>@[spec]</code>.</p><h3 id="Features" class="markdown-heading">Features <a class="hover-link" href="#Features">#</a></h3><p>When used like <code>mvcgen +noLetElim [foo_spec, bar_def, instBEqFloat]</code>, <code>mvcgen</code> will additionally</p><ul><li>add a Hoare triple specification <code>foo_spec : ... → ⦃P⦄ foo ... ⦃Q⦄</code> to <code>spec</code> set for a
function <code>foo</code> occurring in <code>prog</code>,</li><li>unfold a definition <code>def bar_def ... := ...</code> in <code>prog</code>,</li><li>unfold any method of the <code><a href="./Init/Data/Float.html#instBEqFloat">instBEqFloat</a> : <a href="./Init/Prelude.html#BEq">BEq</a> <a href="./Init/Data/Float.html#Float">Float</a></code> instance in <code>prog</code>.</li><li>it will no longer substitute away <code>let</code>-expressions that occur at most once in <code>P</code>, <code>Q</code> or <code>prog</code>.</li></ul><h3 id="Config-options" class="markdown-heading">Config options <a class="hover-link" href="#Config-options">#</a></h3><p><code>+noLetElim</code> is just one config option of many. Check out <code>Lean.Elab.Tactic.Do.VCGen.Config</code> for all
options. Of particular note is <code>stepLimit = some 42</code>, which is useful for bisecting bugs in
<code>mvcgen</code> and tracing its execution.</p><h3 id="Extended-syntax" class="markdown-heading">Extended syntax <a class="hover-link" href="#Extended-syntax">#</a></h3><p>Often, <code>mvcgen</code> will be used like this:</p><pre><code>mvcgen [...]
case inv1 =&gt; by exact I1
case inv2 =&gt; by exact I2
all_goals (mleave; try grind)
</code></pre><p>There is special syntax for this:</p><pre><code>mvcgen [...] invariants
· I1
· I2
with grind
</code></pre><p>When <code>I1</code> and <code>I2</code> need to refer to inaccessibles (<code>mvcgen</code> will introduce a lot of them for program
variables), you can use case label syntax:</p><pre><code>mvcgen [...] invariants
| inv1 _ acc _ =&gt; I1 acc
| _ =&gt; I2
with grind
</code></pre><p>This is more convenient than the equivalent <code>· by rename_i _ acc _; exact I1 acc</code>.</p><h3 id="Invariant-suggestions" class="markdown-heading">Invariant suggestions <a class="hover-link" href="#Invariant-suggestions">#</a></h3><p><code>mvcgen</code> will suggest invariants for you if you use the <code>invariants?</code> keyword.</p><pre><code>mvcgen [...] invariants?
</code></pre><p>This is useful if you do not recall the exact syntax to construct invariants.
Furthermore, it will suggest a concrete invariant encoding &quot;this holds at the start of the loop and
this must hold at the end of the loop&quot; by looking at the corresponding VCs.
Although the suggested invariant is a good starting point, it is too strong and requires users to
interpolate it such that the inductive step can be proved. Example:</p><pre><code>def mySum (l : <a href="./Init/Prelude.html#List">List</a> Nat) : <a href="./Init/Prelude.html#Nat">Nat</a> := <a href="./Init/Control/Id.html#Id.run">Id.run</a> do
  let mut acc := 0
  for x in l do
    acc := acc + x
  return acc

/--
info: Try this:
  invariants
    · ⇓⟨xs, letMuts⟩ =&gt; ⌜xs.prefix = [] ∧ letMuts = 0 ∨ xs.suffix = [] ∧ letMuts = l.sum⌝
-/
#guard_msgs (info) in
theorem mySum_suggest_invariant (l : <a href="./Init/Prelude.html#List">List</a> Nat) : mySum l = l.sum := by
  generalize h : mySum l = r
  apply Id.of_wp_run_eq h
  mvcgen invariants?
  all_goals admit
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mvcgenMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mvcgenHint"><h2>mvcgen?</h2><p><p>A hint tactic that expands to <code>mvcgen invariants?</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgenHint">Std.Tactic.Do.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticMvcgen_trivial"><h2>mvcgen_trivial</h2><p><p><code>mvcgen_trivial</code> is the tactic automatically called by <code>mvcgen</code> to discharge VCs.
It tries to discharge the VC by applying <code>(try mpure_intro); <a href="./Init/Core.html#trivial">trivial</a></code> and otherwise delegates to
<code>mvcgen_trivial_extensible</code>.
Users are encouraged to extend <code>mvcgen_trivial_extensible</code> instead of this tactic in order not to
override the default <code>(try mpure_intro); <a href="./Init/Core.html#trivial">trivial</a></code> behavior.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.tacticMvcgen_trivial">Std.Tactic.Do.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticMvcgen_trivial_extensible"><h2>mvcgen_trivial_extensible</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.tacticMvcgen_trivial_extensible">Std.Tactic.Do.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.nativeDecide"><h2>native_decide</h2><p><p><code>native_decide</code> is a synonym for <code>decide +native</code>.
It will attempt to prove a goal of type <code>p</code> by synthesizing an instance
of <code><a href="./Init/Prelude.html#Decidable">Decidable</a> p</code> and then evaluating it to <code>isTrue ..</code>. Unlike <code>decide</code>, this
uses <code>#eval</code> to evaluate the decidability instance.</p><p>This should be used with care because it adds the entire lean compiler to the trusted
part, and a new axiom will show up in <code>#print axioms</code> for theorems using
this method or anything that transitively depends on them. Nevertheless, because it is
compiled, this can be significantly more efficient than using <code>decide</code>, and for very
large computations this is one way to run external programs and trust the result.</p><pre><code class="language-lean">example : (List.range 1000).length = 1000 := by native_decide
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.nativeDecide">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.«tacticNext_=&gt;_»"><h2>next</h2><p><p><code>next =&gt; tac</code> focuses on the next goal and solves it using <code>tac</code>, or else fails.
<code>next x₁ ... xₙ =&gt; tac</code> additionally renames the <code>n</code> most recent hypotheses with
inaccessible names to the given names.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.«tacticNext_=&gt;_»">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticNofun"><h2>nofun</h2><p><p>The tactic <code>nofun</code> is shorthand for <code>exact nofun</code>: it introduces the assumptions, then performs an
empty pattern match, closing the goal if the introduced pattern is impossible.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticNofun">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.«tacticNomatch_,,»"><h2>nomatch</h2><p><p>The tactic <code>nomatch h</code> is shorthand for <code>exact nomatch h</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.«tacticNomatch_,,»">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticNorm_cast__"><h2>norm_cast</h2><p><p>The <code>norm_cast</code> family of tactics is used to normalize certain coercions (<em>casts</em>) in expressions.</p><ul><li><code>norm_cast</code> normalizes casts in the target.</li><li><code>norm_cast at h</code> normalizes casts in hypothesis <code>h</code>.</li></ul><p>The tactic is basically a version of <code>simp</code> with a specific set of lemmas to move casts
upwards in the expression.
Therefore even in situations where non-terminal <code>simp</code> calls are discouraged (because of fragility),
<code>norm_cast</code> is considered to be safe.
It also has special handling of numerals.</p><p>For instance, given an assumption</p><pre><code class="language-lean">a b : ℤ
h : ↑a + ↑b &lt; (10 : ℚ)
</code></pre><p>writing <code>norm_cast at h</code> will turn <code>h</code> into</p><pre><code class="language-lean">h : a + b &lt; 10
</code></pre><p>There are also variants of basic tactics that use <code>norm_cast</code> to normalize expressions during
their operation, to make them more flexible about the expressions they accept
(we say that it is a tactic <em>modulo</em> the effects of <code>norm_cast</code>):</p><ul><li><code>exact_mod_cast</code> for <code>exact</code> and <code>apply_mod_cast</code> for <code>apply</code>.
Writing <code>exact_mod_cast h</code> and <code>apply_mod_cast h</code> will normalize casts
in the goal and <code>h</code> before using <code>exact h</code> or <code>apply h</code>.</li><li><code>rw_mod_cast</code> for <code>rw</code>. It applies <code>norm_cast</code> between rewrites.</li><li><code>assumption_mod_cast</code> for <code>assumption</code>.
This is effectively <code>norm_cast at *; assumption</code>, but more efficient.
It normalizes casts in the goal and, for every hypothesis <code>h</code> in the context,
it will try to normalize casts in <code>h</code> and use <code>exact h</code>.</li></ul><p>See also <code>push_cast</code>, which moves casts inwards rather than lifting them outwards.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticNorm_cast__">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.normCast0"><h2>norm_cast0</h2><p><p>Implementation of <code>norm_cast</code> (the full <code>norm_cast</code> calls <code><a href="./Init/Core.html#trivial">trivial</a></code> afterwards).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.normCast0">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.obtain"><h2>obtain</h2><p><p>The <code>obtain</code> tactic is a combination of <code>have</code> and <code>rcases</code>. See <code>rcases</code> for
a description of supported patterns.</p><pre><code class="language-lean">obtain ⟨patt⟩ : type := proof
</code></pre><p>is equivalent to</p><pre><code class="language-lean">have h : type := proof
rcases h with ⟨patt⟩
</code></pre><p>If <code>⟨patt⟩</code> is omitted, <code>rcases</code> will try to infer the pattern.</p><p>If <code>type</code> is omitted, <code>:= proof</code> is required.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/RCases.html#Lean.Parser.Tactic.obtain">Init.RCases</a></dd></dl></div><div id="Lean.Parser.Tactic.omega"><h2>omega</h2><p><p>The <code>omega</code> tactic, for resolving integer and natural linear arithmetic problems.</p><p>It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.</p><p>We handle hypotheses of the form <code>x = y</code>, <code>x &lt; y</code>, <code>x ≤ y</code>, and <code>k ∣ x</code> for <code>x y</code> in <code><a href="./Init/Prelude.html#Nat">Nat</a></code> or <code><a href="./Init/Data/Int/Basic.html#Int">Int</a></code>
(and <code>k</code> a literal), along with negations of these statements.</p><p>We decompose the sides of the inequalities as linear combinations of atoms.</p><p>If we encounter <code>x / k</code> or <code>x % k</code> for literal integers <code>k</code> we introduce new auxiliary variables
and the relevant inequalities.</p><p>On the first pass, we do not perform case splits on natural subtraction.
If <code>omega</code> fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.</p><p>The options</p><pre><code>omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
</code></pre><p>can be used to:</p><ul><li><code>splitDisjunctions</code>: split any disjunctions found in the context,
if the problem is not otherwise solvable.</li><li><code>splitNatSub</code>: for each appearance of <code>((a - b : Nat) : Int)</code>, split on <code>a ≤ b</code> if necessary.</li><li><code>splitNatAbs</code>: for each appearance of <code><a href="./Init/Data/Int/Basic.html#Int.natAbs">Int.natAbs</a> a</code>, split on <code>0 ≤ a</code> if necessary.</li><li><code>splitMinMax</code>: for each occurrence of <code>min a b</code>, split on <code>min a b = a ∨ min a b = b</code>
Currently, all of these are on by default.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.omega">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.«tacticOn_goal-_=&gt;_»"><h2>on_goal</h2><p><p><code>on_goal n =&gt; tacSeq</code> creates a block scope for the <code>n</code>-th goal and tries the sequence
of tactics <code>tacSeq</code> on it.</p><p><code>on_goal -n =&gt; tacSeq</code> does the same, but the <code>n</code>-th goal is chosen by counting from the
bottom.</p><p>The goal is not required to be solved and any resulting subgoals are inserted back into the
list of goals, replacing the chosen goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/PermuteGoals.html#Batteries.Tactic.«tacticOn_goal-_=&gt;_»">Batteries.Tactic.PermuteGoals</a></dd></dl></div><div id="Lean.Parser.Tactic.open"><h2>open</h2><p><p><code>open Foo in tacs</code> (the tactic) acts like <code>open Foo</code> at command level,
but it opens a namespace only within the tactics <code>tacs</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Lean/Parser/Command.html#Lean.Parser.Tactic.open">Lean.Parser.Command</a></dd></dl></div><div id="Batteries.Tactic.«tacticPick_goal-_»"><h2>pick_goal</h2><p><p><code>pick_goal n</code> will move the <code>n</code>-th goal to the front.</p><p><code>pick_goal -n</code> will move the <code>n</code>-th goal (counting from the bottom) to the front.</p><p>See also <code>Tactic.rotate_goals</code>, which moves goals from the front to the back and vice-versa.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/PermuteGoals.html#Batteries.Tactic.«tacticPick_goal-_»">Batteries.Tactic.PermuteGoals</a></dd></dl></div><div id="Lean.Parser.Tactic.pushCast"><h2>push_cast</h2><p><p><code>push_cast</code> rewrites the goal to move certain coercions (<em>casts</em>) inward, toward the leaf nodes.
This uses <code>norm_cast</code> lemmas in the forward direction.
For example, <code>↑(a + b)</code> will be written to <code>↑a + ↑b</code>.</p><ul><li><code>push_cast</code> moves casts inward in the goal.</li><li><code>push_cast at h</code> moves casts inward in the hypothesis <code>h</code>.
It can be used with extra simp lemmas with, for example, <code>push_cast [Int.add_zero]</code>.</li></ul><p>Example:</p><pre><code class="language-lean">example (a b : Nat)
    (h1 : ((a + b : Nat) : Int) = 10)
    (h2 : ((a + b + 0 : Nat) : Int) = 10) :
    ((a + b : Nat) : Int) = 10 := by
  /-
  h1 : ↑(a + b) = 10
  h2 : ↑(a + b + 0) = 10
  ⊢ ↑(a + b) = 10
  -/
  push_cast
  /- Now
  ⊢ ↑a + ↑b = 10
  -/
  push_cast at h1
  push_cast [Int.add_zero] at h2
  /- Now
  h1 h2 : ↑a + ↑b = 10
  -/
  exact h1
</code></pre><p>See also <code>norm_cast</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.pushCast">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.rcases"><h2>rcases</h2><p><p><code>rcases</code> is a tactic that will perform <code>cases</code> recursively, according to a pattern. It is used to
destructure hypotheses or expressions composed of inductive types like <code>h1 : a ∧ b ∧ c ∨ d</code> or
<code>h2 : ∃ x y, trans_rel R x y</code>. Usual usage might be <code>rcases h1 with ⟨ha, hb, hc⟩ | hd</code> or
<code>rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩</code> for these examples.</p><p>Each element of an <code>rcases</code> pattern is matched against a particular local hypothesis (most of which
are generated during the execution of <code>rcases</code> and represent individual elements destructured from
the input expression). An <code>rcases</code> pattern has the following grammar:</p><ul><li>A name like <code>x</code>, which names the active hypothesis as <code>x</code>.</li><li>A blank <code>_</code>, which does nothing (letting the automatic naming system used by <code>cases</code> name the
hypothesis).</li><li>A hyphen <code>-</code>, which clears the active hypothesis and any dependents.</li><li>The keyword <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, which expects the hypothesis to be <code>h : a = b</code>, and calls <code>subst</code> on the
hypothesis (which has the effect of replacing <code>b</code> with <code>a</code> everywhere or vice versa).</li><li>A type ascription <code>p : ty</code>, which sets the type of the hypothesis to <code>ty</code> and then matches it
against <code>p</code>. (Of course, <code>ty</code> must unify with the actual type of <code>h</code> for this to work.)</li><li>A tuple pattern <code>⟨p1, p2, p3⟩</code>, which matches a constructor with many arguments, or a series
of nested conjunctions or existentials. For example if the active hypothesis is <code>a ∧ b ∧ c</code>,
then the conjunction will be destructured, and <code>p1</code> will be matched against <code>a</code>, <code>p2</code> against <code>b</code>
and so on.</li><li>A <code>@</code> before a tuple pattern as in <code>@⟨p1, p2, p3⟩</code> will bind all arguments in the constructor,
while leaving the <code>@</code> off will only use the patterns on the explicit arguments.</li><li>An alternation pattern <code>p1 | p2 | p3</code>, which matches an inductive type with multiple constructors,
or a nested disjunction like <code>a ∨ b ∨ c</code>.</li></ul><p>A pattern like <code>⟨a, b, c⟩ | ⟨d, e⟩</code> will do a split over the inductive datatype,
naming the first three parameters of the first constructor as <code>a,b,c</code> and the
first two of the second constructor <code>d,e</code>. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as <code>⟨⟨a⟩, b | c⟩ | d</code> then these will cause more case splits as necessary.
If there are too many arguments, such as <code>⟨a, b, c⟩</code> for splitting on
<code>∃ x, ∃ y, p x</code>, then it will be treated as <code>⟨a, ⟨b, c⟩⟩</code>, splitting the last
parameter as necessary.</p><p><code>rcases</code> also has special support for quotient types: quotient induction into Prop works like
matching on the constructor <code>quot.mk</code>.</p><p><code>rcases h : e with PAT</code> will do the same as <code>rcases e with PAT</code> with the exception that an
assumption <code>h : e = PAT</code> will be added to the context.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/RCases.html#Lean.Parser.Tactic.rcases">Init.RCases</a></dd></dl></div><div id="Batteries.Tactic.rcongr"><h2>rcongr</h2><p><p>Repeatedly apply <code><a href="./Init/Prelude.html#congr">congr</a></code> and <code>ext</code>, using the given patterns as arguments for <code>ext</code>.</p><p>There are two ways this tactic stops:</p><ul><li><code><a href="./Init/Prelude.html#congr">congr</a></code> fails (makes no progress), after having already applied <code>ext</code>.</li><li><code><a href="./Init/Prelude.html#congr">congr</a></code> canceled out the last usage of <code>ext</code>. In this case, the state is reverted to before
the <code><a href="./Init/Prelude.html#congr">congr</a></code> was applied.</li></ul><p>For example, when the goal is</p><pre><code>⊢ (fun x =&gt; f x + 3) '' s = (fun x =&gt; g x + 3) '' s
</code></pre><p>then <code>rcongr x</code> produces the goal</p><pre><code>x : α ⊢ f x = g x
</code></pre><p>This gives the same result as <code>congr; ext x; <a href="./Init/Prelude.html#congr">congr</a></code>.</p><p>In contrast, <code><a href="./Init/Prelude.html#congr">congr</a></code> would produce</p><pre><code>⊢ (fun x =&gt; f x + 3) = (fun x =&gt; g x + 3)
</code></pre><p>and <code><a href="./Init/Prelude.html#congr">congr</a> with x</code> (or <code>congr; ext x</code>) would produce</p><pre><code>x : α ⊢ f x + 3 = g x + 3
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Congr.html#Batteries.Tactic.rcongr">Batteries.Tactic.Congr</a></dd></dl></div><div id="Lean.Parser.Tactic.refine"><h2>refine</h2><p><p><code>refine e</code> behaves like <code>exact e</code>, except that named (<code>?x</code>) or unnamed (<code>?_</code>)
holes in <code>e</code> that are not solved by unification with the main goal's target type
are converted into new goals, using the hole's name, if any, as the goal case name.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.refine">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.refine'"><h2>refine'</h2><p><p><code>refine' e</code> behaves like <code>refine e</code>, except that unsolved placeholders (<code>_</code>)
and implicit parameters are also converted into new goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.refine'">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRefine_lift_"><h2>refine_lift</h2><p><p>Auxiliary macro for lifting have/suffices/let/...
It makes sure the &quot;continuation&quot; <code>?_</code> is the main goal after refining.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRefine_lift'_"><h2>refine_lift'</h2><p><p>Similar to <code>refine_lift</code>, but using <code>refine'</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift'_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.rename"><h2>rename</h2><p><p><code>rename t =&gt; x</code> renames the most recent hypothesis whose type matches <code>t</code>
(which may contain placeholders) to <code>x</code>, or fails if no such hypothesis could be found.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.rename">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.renameI"><h2>rename_i</h2><p><p><code>rename_i x_1 ... x_n</code> renames the last <code>n</code> inaccessible names using the given names.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.renameI">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRepeat_"><h2>repeat</h2><p><p><code>repeat tac</code> repeatedly applies <code>tac</code> so long as it succeeds.
The tactic <code>tac</code> may be a tactic sequence, and if <code>tac</code> fails at any point in its execution,
<code>repeat</code> will revert any partial changes that <code>tac</code> made to the tactic state.</p><p>The tactic <code>tac</code> should eventually fail, otherwise <code>repeat tac</code> will run indefinitely.</p><p>See also:</p><ul><li><code>try tac</code> is like <code>repeat tac</code> but will apply <code>tac</code> at most once.</li><li><code>repeat' tac</code> recursively applies <code>tac</code> to each goal.</li><li><code>first | tac1 | tac2</code> implements the backtracking used by <code>repeat</code></li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticRepeat_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.repeat'"><h2>repeat'</h2><p><p><code>repeat' tac</code> recursively applies <code>tac</code> on all of the goals so long as it succeeds.
That is to say, if <code>tac</code> produces multiple subgoals, then <code>repeat' tac</code> is applied to each of them.</p><p>See also:</p><ul><li><code>repeat tac</code> simply repeatedly applies <code>tac</code>.</li><li><code>repeat1' tac</code> is <code>repeat' tac</code> but requires that <code>tac</code> succeed for some goal at least once.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.repeat'">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.repeat1'"><h2>repeat1'</h2><p><p><code>repeat1' tac</code> recursively applies to <code>tac</code> on all of the goals so long as it succeeds,
but <code>repeat1' tac</code> fails if <code>tac</code> succeeds on none of the initial goals.</p><p>See also:</p><ul><li><code>repeat tac</code> simply applies <code>tac</code> repeatedly.</li><li><code>repeat' tac</code> is like <code>repeat1' tac</code> but it does not require that <code>tac</code> succeed at least once.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.repeat1'">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.replace"><h2>replace</h2><p><p>Acts like <code>have</code>, but removes a hypothesis with the same name as
this one if possible. For example, if the state is:</p><pre><code class="language-lean">f : α → β
h : α
⊢ goal
</code></pre><p>Then after <code>replace h := f h</code> the state will be:</p><pre><code class="language-lean">f : α → β
h : β
⊢ goal
</code></pre><p>whereas <code>have h := f h</code> would result in:</p><pre><code class="language-lean">f : α → β
h† : α
h : β
⊢ goal
</code></pre><p>This can be used to simulate the <code>specialize</code> and <code>apply at</code> tactics of Coq.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.replace">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.revert"><h2>revert</h2><p><p><code>revert x...</code> is the inverse of <code>intro x...</code>: it moves the given hypotheses
into the main goal's target type.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.revert">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.rewriteSeq"><h2>rewrite</h2><p><p><code>rewrite [e]</code> applies identity <code>e</code> as a rewrite rule to the target of the main goal.
If <code>e</code> is preceded by left arrow (<code>←</code> or <code>&lt;-</code>), the rewrite is applied in the reverse direction.
If <code>e</code> is a defined constant, then the equational theorems associated with <code>e</code> are used.
This provides a convenient way to unfold <code>e</code>.</p><ul><li><code>rewrite [e₁, ..., eₙ]</code> applies the given rules sequentially.</li><li><code>rewrite [e] at l</code> rewrites <code>e</code> at location(s) <code>l</code>, where <code>l</code> is either <code>*</code> or a
list of hypotheses in the local context. In the latter case, a turnstile <code>⊢</code> or <code>|-</code>
can also be used, to signify the target of the goal.</li></ul><p>Using <code>rw (occs := .pos L) [e]</code>,
where <code>L : <a href="./Init/Prelude.html#List">List</a> <a href="./Init/Prelude.html#Nat">Nat</a></code>, you can control which &quot;occurrences&quot; are rewritten.
(This option applies to each rule, so usually this will only be used with a single rule.)
Occurrences count from <code>1</code>.
At each allowed occurrence, arguments of the rewrite rule <code>e</code> may be instantiated,
restricting which later rewrites can be found.
(Disallowed occurrences do not result in instantiation.)
<code>(occs := .neg L)</code> allows skipping specified occurrences.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.rewriteSeq">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRfl"><h2>rfl</h2><p><p>This tactic applies to a goal whose target has the form <code>x ~ x</code>,
where <code>~</code> is equality, heterogeneous equality or any relation that
has a reflexivity lemma tagged with the attribute @[refl].</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticRfl">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRfl'"><h2>rfl'</h2><p><p><code>rfl'</code> is similar to <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, but disables smart unfolding and unfolds all kinds of definitions,
theorems included (relevant for declarations defined by well-founded recursion).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.right"><h2>right</h2><p><p>Applies the second constructor when
the goal is an inductive type with exactly two constructors, or fails otherwise.</p><pre><code>example {p q : Prop} (h : q) : p ∨ q := by
  right
  exact h
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.right">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.rintro"><h2>rintro</h2><p><p>The <code>rintro</code> tactic is a combination of the <code>intros</code> tactic with <code>rcases</code> to
allow for destructuring patterns while introducing variables. See <code>rcases</code> for
a description of supported patterns. For example, <code>rintro (a | ⟨b, c⟩) ⟨d, e⟩</code>
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables <code>a d e</code> and the other with <code>b c d e</code>.</p><p><code>rintro</code>, unlike <code>rcases</code>, also supports the form <code>(x y : ty)</code> for introducing
and type-ascripting multiple variables at once, similar to binders.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/RCases.html#Lean.Parser.Tactic.rintro">Init.RCases</a></dd></dl></div><div id="Lean.Parser.Tactic.rotateLeft"><h2>rotate_left</h2><p><p><code>rotate_left n</code> rotates goals to the left by <code>n</code>. That is, <code>rotate_left 1</code>
takes the main goal and puts it to the back of the subgoal list.
If <code>n</code> is omitted, it defaults to <code>1</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.rotateLeft">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.rotateRight"><h2>rotate_right</h2><p><p>Rotate the goals to the right by <code>n</code>. That is, take the goal at the back
and push it to the front <code>n</code> times. If <code>n</code> is omitted, it defaults to <code>1</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.rotateRight">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.runTac"><h2>run_tac</h2><p><p>The <code>run_tac doSeq</code> tactic executes code in <code>TacticM <a href="./Init/Prelude.html#Unit">Unit</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.runTac">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.rwSeq"><h2>rw</h2><p><p><code>rw</code> is like <code>rewrite</code>, but also tries to close the goal by &quot;cheap&quot; (reducible) <code><a href="./Init/Prelude.html#rfl">rfl</a></code> afterwards.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.rwSeq">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.rewrites?"><h2>rw?</h2><p><p><code>rw?</code> tries to find a lemma which can rewrite the goal.</p><p><code>rw?</code> should not be left in proofs; it is a search tool, like <code>apply?</code>.</p><p>Suggestions are printed as <code>rw [h]</code> or <code>rw [← h]</code>.</p><p>You can use <code>rw? [-my_lemma, -my_theorem]</code> to prevent <code>rw?</code> using the named lemmas.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.rewrites?">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRw_mod_cast___"><h2>rw_mod_cast</h2><p><p>Rewrites with the given rules, normalizing casts prior to each step.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/TacticsExtra.html#Lean.Parser.Tactic.tacticRw_mod_cast___">Init.TacticsExtra</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRwa__"><h2>rwa</h2><p><p><code>rwa</code> is short-hand for <code>rw; assumption</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticRwa__">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.set_option"><h2>set_option</h2><p><p><code>set_option opt val in tacs</code> (the tactic) acts like <code>set_option opt val</code> at the command level,
but it sets the option only within the tactics <code>tacs</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Lean/Parser/Command.html#Lean.Parser.Tactic.set_option">Lean.Parser.Command</a></dd></dl></div><div id="Lean.Parser.Tactic.show"><h2>show</h2><p><p><code>show t</code> finds the first goal whose target unifies with <code>t</code>. It makes that the main goal,
performs the unification, and replaces the target with the unified version of <code>t</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.show">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.showTerm"><h2>show_term</h2><p><p><code>show_term tac</code> runs <code>tac</code>, then prints the generated term in the form
&quot;exact X Y Z&quot; or &quot;refine X ?_ Z&quot; (prefixed by <code>expose_names</code> if necessary)
if there are remaining subgoals.</p><p>(For some tactics, the printed term will not be human readable.)</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.showTerm">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.simp"><h2>simp</h2><p><p>The <code>simp</code> tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:</p><ul><li><code>simp</code> simplifies the main goal target using lemmas tagged with the attribute <code>[simp]</code>.</li><li><code>simp [h₁, h₂, ..., hₙ]</code> simplifies the main goal target using the lemmas tagged
with the attribute <code>[simp]</code> and the given <code>hᵢ</code>'s, where the <code>hᵢ</code>'s are expressions.-</li><li>If an <code>hᵢ</code> is a defined constant <code>f</code>, then <code>f</code> is unfolded. If <code>f</code> has equational lemmas associated
with it (and is not a projection or a <code>reducible</code> definition), these are used to rewrite with <code>f</code>.</li><li><code>simp [*]</code> simplifies the main goal target using the lemmas tagged with the
attribute <code>[simp]</code> and all hypotheses.</li><li><code>simp only [h₁, h₂, ..., hₙ]</code> is like <code>simp [h₁, h₂, ..., hₙ]</code> but does not use <code>[simp]</code> lemmas.</li><li><code>simp [-id₁, ..., -idₙ]</code> simplifies the main goal target using the lemmas tagged
with the attribute <code>[simp]</code>, but removes the ones named <code>idᵢ</code>.</li><li><code>simp at h₁ h₂ ... hₙ</code> simplifies the hypotheses <code>h₁ : T₁</code> ... <code>hₙ : Tₙ</code>. If
the target or another hypothesis depends on <code>hᵢ</code>, a new simplified hypothesis
<code>hᵢ</code> is introduced, but the old one remains in the local context.</li><li><code>simp at *</code> simplifies all the hypotheses and the target.</li><li><code>simp [*] at *</code> simplifies target and all (propositional) hypotheses using the
other hypotheses.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.simp">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.simpAutoUnfold"><h2>simp!</h2><p><p><code>simp!</code> is shorthand for <code>simp</code> with <code>autoUnfold := true</code>.
This will unfold applications of functions defined by pattern matching, when one of the patterns applies.
This can be used to partially evaluate many definitions.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.simpAutoUnfold">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.simpTrace"><h2>simp?</h2><p><p><code>simp?</code> takes the same arguments as <code>simp</code>, but reports an equivalent call to <code>simp only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href="./Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: simp only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code>dsimp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.simpTrace">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSimp?!_"><h2>simp?!</h2><p><p><code>simp?</code> takes the same arguments as <code>simp</code>, but reports an equivalent call to <code>simp only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href="./Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: simp only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code>dsimp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSimp?!_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.simpAll"><h2>simp_all</h2><p><p><code>simp_all</code> is a stronger version of <code>simp [*] at *</code> where the hypotheses and target
are simplified multiple times until no simplification is applicable.
Only non-dependent propositional hypotheses are considered.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.simpAll">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.simpAllAutoUnfold"><h2>simp_all!</h2><p><p><code>simp_all!</code> is shorthand for <code>simp_all</code> with <code>autoUnfold := true</code>.
This will unfold applications of functions defined by pattern matching, when one of the patterns applies.
This can be used to partially evaluate many definitions.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.simpAllAutoUnfold">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.simpAllTrace"><h2>simp_all?</h2><p><p><code>simp?</code> takes the same arguments as <code>simp</code>, but reports an equivalent call to <code>simp only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href="./Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: simp only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code>dsimp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.simpAllTrace">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSimp_all?!_"><h2>simp_all?!</h2><p><p><code>simp?</code> takes the same arguments as <code>simp</code>, but reports an equivalent call to <code>simp only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href="./Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: simp only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code>dsimp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSimp_all?!_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.simpAllArith"><h2>simp_all_arith</h2><p><p><code>simp_all_arith</code> has been deprecated. It was a shorthand for <code>simp_all +arith +decide</code>.
Note that <code>+decide</code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.simpAllArith">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.simpAllArithBang"><h2>simp_all_arith!</h2><p><p><code>simp_all_arith!</code> has been deprecated. It was a shorthand for <code>simp_all! +arith +decide</code>.
Note that <code>+decide</code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.simpAllArithBang">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.simpArith"><h2>simp_arith</h2><p><p><code>simp_arith</code> has been deprecated. It was a shorthand for <code>simp +arith +decide</code>.
Note that <code>+decide</code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.simpArith">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.simpArithBang"><h2>simp_arith!</h2><p><p><code>simp_arith!</code> has been deprecated. It was a shorthand for <code>simp! +arith +decide</code>.
Note that <code>+decide</code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.simpArithBang">Init.Meta</a></dd></dl></div><div id="tacticSimp_wf"><h2>simp_wf</h2><p><p>Unfold definitions commonly used in well founded relation definitions.</p><p>Since Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the
user, and this tactic should no longer be necessary. Calls to <code>simp_wf</code> can be removed or replaced
by plain calls to <code>simp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/WFTactics.html#tacticSimp_wf">Init.WFTactics</a></dd></dl></div><div id="Lean.Parser.Tactic.simpa"><h2>simpa</h2><p><p>This is a &quot;finishing&quot; tactic modification of <code>simp</code>. It has two forms.</p><ul><li><code>simpa [rules, ⋯] using e</code> will simplify the goal and the type of
<code>e</code> using <code>rules</code>, then try to close the goal using <code>e</code>.</li></ul><p>Simplifying the type of <code>e</code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p><ul><li><code>simpa [rules, ⋯]</code> will simplify the goal and the type of a
hypothesis <code>this</code> if present in the context, then try to close the goal using
the <code>assumption</code> tactic.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.simpa">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSimpa!_"><h2>simpa!</h2><p><p>This is a &quot;finishing&quot; tactic modification of <code>simp</code>. It has two forms.</p><ul><li><code>simpa [rules, ⋯] using e</code> will simplify the goal and the type of
<code>e</code> using <code>rules</code>, then try to close the goal using <code>e</code>.</li></ul><p>Simplifying the type of <code>e</code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p><ul><li><code>simpa [rules, ⋯]</code> will simplify the goal and the type of a
hypothesis <code>this</code> if present in the context, then try to close the goal using
the <code>assumption</code> tactic.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa!_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSimpa?_"><h2>simpa?</h2><p><p>This is a &quot;finishing&quot; tactic modification of <code>simp</code>. It has two forms.</p><ul><li><code>simpa [rules, ⋯] using e</code> will simplify the goal and the type of
<code>e</code> using <code>rules</code>, then try to close the goal using <code>e</code>.</li></ul><p>Simplifying the type of <code>e</code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p><ul><li><code>simpa [rules, ⋯]</code> will simplify the goal and the type of a
hypothesis <code>this</code> if present in the context, then try to close the goal using
the <code>assumption</code> tactic.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa?_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSimpa?!_"><h2>simpa?!</h2><p><p>This is a &quot;finishing&quot; tactic modification of <code>simp</code>. It has two forms.</p><ul><li><code>simpa [rules, ⋯] using e</code> will simplify the goal and the type of
<code>e</code> using <code>rules</code>, then try to close the goal using <code>e</code>.</li></ul><p>Simplifying the type of <code>e</code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p><ul><li><code>simpa [rules, ⋯]</code> will simplify the goal and the type of a
hypothesis <code>this</code> if present in the context, then try to close the goal using
the <code>assumption</code> tactic.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa?!_">Init.Tactics</a></dd></dl></div><div id="List.tacticSizeOf_list_dec"><h2>sizeOf_list_dec</h2><p><p>This tactic, added to the <code>decreasing_trivial</code> toolbox, proves that
<code>sizeOf a &lt; sizeOf as</code> when <code>a ∈ as</code>, which is useful for well founded recursions
over a nested inductive like <code>inductive T | mk : <a href="./Init/Prelude.html#List">List</a> T → T</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Data/List/BasicAux.html#List.tacticSizeOf_list_dec">Init.Data.List.BasicAux</a></dd></dl></div><div id="Lean.Parser.Tactic.skip"><h2>skip</h2><p><p><code>skip</code> does nothing.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.skip">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.sleep"><h2>sleep</h2><p><p>The tactic <code>sleep ms</code> sleeps for <code>ms</code> milliseconds and does nothing.
It is used for debugging purposes only.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.sleep">Init.Tactics</a></dd></dl></div><div id="Lean.solveTactic"><h2>solve</h2><p><p>Similar to <code>first</code>, but succeeds only if one the given tactics solves the current goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/NotationExtra.html#Lean.solveTactic">Init.NotationExtra</a></dd></dl></div><div id="Lean.Parser.Tactic.solveByElim"><h2>solve_by_elim</h2><p><p><code>solve_by_elim</code> calls <code>apply</code> on the main goal to find an assumption whose head matches
and then repeatedly calls <code>apply</code> on the generated subgoals until no subgoals remain,
performing at most <code>maxDepth</code> (defaults to 6) recursive steps.</p><p><code>solve_by_elim</code> discharges the current goal or fails.</p><p><code>solve_by_elim</code> performs backtracking if subgoals can not be solved.</p><p>By default, the assumptions passed to <code>apply</code> are the local context, <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, <code><a href="./Init/Core.html#trivial">trivial</a></code>,
<code><a href="./Init/Prelude.html#congrFun">congrFun</a></code> and <code><a href="./Init/Prelude.html#congrArg">congrArg</a></code>.</p><p>The assumptions can be modified with similar syntax as for <code>simp</code>:</p><ul><li><code>solve_by_elim [h₁, h₂, ..., hᵣ]</code> also applies the given expressions.</li><li><code>solve_by_elim only [h₁, h₂, ..., hᵣ]</code> does not include the local context,
<code><a href="./Init/Prelude.html#rfl">rfl</a></code>, <code><a href="./Init/Core.html#trivial">trivial</a></code>, <code><a href="./Init/Prelude.html#congrFun">congrFun</a></code>, or <code><a href="./Init/Prelude.html#congrArg">congrArg</a></code> unless they are explicitly included.</li><li><code>solve_by_elim [-h₁, ... -hₙ]</code> removes the given local hypotheses.</li><li><code>solve_by_elim using [a₁, ...]</code> uses all lemmas which have been labelled
with the attributes <code>aᵢ</code> (these attributes must be created using <code>register_label_attr</code>).</li></ul><p><code>solve_by_elim*</code> tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.
(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)</p><p>Optional arguments passed via a configuration argument as <code>solve_by_elim (config := { ... })</code></p><ul><li><code>maxDepth</code>: number of attempts at discharging generated subgoals</li><li><code>symm</code>: adds all hypotheses derived by <code>symm</code> (defaults to <code>true</code>).</li><li><code>exfalso</code>: allow calling <code>exfalso</code> and trying again if <code>solve_by_elim</code> fails
(defaults to <code>true</code>).</li><li><code>transparency</code>: change the transparency mode when calling <code>apply</code>. Defaults to <code>.default</code>,
but it is often useful to change to <code>.reducible</code>,
so semireducible definitions will not be unfolded when trying to apply a lemma.</li></ul><p>See also the doc-comment for <code>Lean.Meta.Tactic.Backtrack.BacktrackConfig</code> for the options
<code>proc</code>, <code>suspend</code>, and <code>discharge</code> which allow further customization of <code>solve_by_elim</code>.
Both <code>apply_assumption</code> and <code>apply_rules</code> are implemented via these hooks.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.solveByElim">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSorry"><h2>sorry</h2><p><p>The <code>sorry</code> tactic is a temporary placeholder for an incomplete tactic proof,
closing the main goal using <code>exact sorry</code>.</p><p>This is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.
Lean will give a warning whenever a proof uses <code>sorry</code>, so you aren't likely to miss it,
but you can double check if a theorem depends on <code>sorry</code> by looking for <code><a href="./Init/Prelude.html#sorryAx">sorryAx</a></code> in the output
of the <code>#print axioms my_thm</code> command, the axiom used by the implementation of <code>sorry</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSorry">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.specialize"><h2>specialize</h2><p><p>The tactic <code>specialize h a₁ ... aₙ</code> works on local hypothesis <code>h</code>.
The premises of this hypothesis, either universal quantifications or
non-dependent implications, are instantiated by concrete terms coming
from arguments <code>a₁</code> ... <code>aₙ</code>.
The tactic adds a new hypothesis with the same name <code>h := h a₁ ... aₙ</code>
and tries to clear the previous one.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.specialize">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.split"><h2>split</h2><p><p>The <code>split</code> tactic is useful for breaking nested if-then-else and <code>match</code> expressions into separate cases.
For a <code>match</code> expression with <code>n</code> cases, the <code>split</code> tactic generates at most <code>n</code> subgoals.</p><p>For example, given <code>n : <a href="./Init/Prelude.html#Nat">Nat</a></code>, and a target <code>if n = 0 then Q else R</code>, <code>split</code> will generate
one goal with hypothesis <code>n = 0</code> and target <code>Q</code>, and a second goal with hypothesis
<code>¬n = 0</code> and target <code>R</code>.  Note that the introduced hypothesis is unnamed, and is commonly
renamed using the <code>case</code> or <code>next</code> tactics.</p><ul><li><code>split</code> will split the goal (target).</li><li><code>split at h</code> will split the hypothesis <code>h</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.split">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.tacticSplit_ands"><h2>split_ands</h2><p><p><code>split_ands</code> applies <code><a href="./Init/Prelude.html#And.intro">And.intro</a></code> until it does not make progress.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tacticSplit_ands">Batteries.Tactic.Init</a></dd></dl></div><div id="Batteries.Tactic.squeezeScope"><h2>squeeze_scope</h2><p><p>The <code>squeeze_scope</code> tactic allows aggregating multiple calls to <code>simp</code> coming from the same syntax
but in different branches of execution, such as in <code>cases x &lt;;&gt; simp</code>.
The reported <code>simp</code> call covers all simp lemmas used by this syntax.</p><pre><code>@[simp] def bar (z : Nat) := 1 + z
@[simp] def baz (z : Nat) := 1 + z

@[simp] def foo : <a href="./Init/Prelude.html#Nat">Nat</a> → <a href="./Init/Prelude.html#Nat">Nat</a> → <a href="./Init/Prelude.html#Nat">Nat</a>
  | 0, z =&gt; bar z
  | _+1, z =&gt; baz z

example : foo x y = 1 + y := by
  cases x &lt;;&gt; simp? -- two printouts:
  -- &quot;Try this: simp only [foo, bar]&quot;
  -- &quot;Try this: simp only [foo, baz]&quot;

example : foo x y = 1 + y := by
  squeeze_scope
    cases x &lt;;&gt; simp -- only one printout: &quot;Try this: simp only [foo, baz, bar]&quot;
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/SqueezeScope.html#Batteries.Tactic.squeezeScope">Batteries.Tactic.SqueezeScope</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticStop_"><h2>stop</h2><p><p><code>stop</code> is a helper tactic for &quot;discarding&quot; the rest of a proof:
it is defined as <code>repeat sorry</code>.
It is useful when working on the middle of a complex proofs,
and less messy than commenting the remainder of the proof.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticStop_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.subst"><h2>subst</h2><p><p><code>subst x...</code> substitutes each hypothesis <code>x</code> with a definition found in the local context,
then eliminates the hypothesis.</p><ul><li>If <code>x</code> is a local definition, then its definition is used.</li><li>Otherwise, if there is a hypothesis of the form <code>x = e</code> or <code>e = x</code>,
then <code>e</code> is used for the definition of <code>x</code>.</li></ul><p>If <code>h : a = b</code>, then <code>subst h</code> may be used if either <code>a</code> or <code>b</code> unfolds to a local hypothesis.
This is similar to the <code>cases h</code> tactic.</p><p>See also: <code>subst_vars</code> for substituting all local hypotheses that have a defining equation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.subst">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.substEqs"><h2>subst_eqs</h2><p><p><code>subst_eq</code> repeatedly substitutes according to the equality proof hypotheses in the context,
replacing the left side of the equality with the right, until no more progress can be made.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.substEqs">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.substVars"><h2>subst_vars</h2><p><p>Applies <code>subst</code> to all hypotheses of the form <code>h : x = t</code> or <code>h : t = x</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.substVars">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSuffices_"><h2>suffices</h2><p><p>Given a main goal <code>ctx ⊢ t</code>, <code>suffices h : t' from e</code> replaces the main goal with <code>ctx ⊢ t'</code>,
<code>e</code> must have type <code>t</code> in the context <code>ctx, h : t'</code>.</p><p>The variant <code>suffices h : t' by tac</code> is a shorthand for <code>suffices h : t' from by tac</code>.
If <code>h :</code> is omitted, the name <code>this</code> is used.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSuffices_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.suggestions"><h2>suggestions</h2><p><p><code>#suggestions</code> will suggest relevant theorems from the library for the current goal,
using the currently registered library suggestion engine.</p><p>The suggestions are printed in the order of their confidence, from highest to lowest.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.suggestions">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.tacticSwap"><h2>swap</h2><p><p><code>swap</code> is a shortcut for <code>pick_goal 2</code>, which interchanges the 1st and 2nd goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/PermuteGoals.html#Batteries.Tactic.tacticSwap">Batteries.Tactic.PermuteGoals</a></dd></dl></div><div id="Lean.Parser.Tactic.symm"><h2>symm</h2><p><ul><li><code>symm</code> applies to a goal whose target has the form <code>t ~ u</code> where <code>~</code> is a symmetric relation,
that is, a relation which has a symmetry lemma tagged with the attribute [symm].
It replaces the target with <code>u ~ t</code>.</li><li><code>symm at h</code> will rewrite a hypothesis <code>h : t ~ u</code> to <code>h : u ~ t</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.symm">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.symmSaturate"><h2>symm_saturate</h2><p><p>For every hypothesis <code>h : a ~ b</code> where a <code>@[symm]</code> lemma is available,
add a hypothesis <code>h_symm : b ~ a</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.symmSaturate">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.traceMessage"><h2>trace</h2><p><p><code>trace msg</code> displays <code>msg</code> in the info view.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.traceMessage">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.traceState"><h2>trace_state</h2><p><p><code>trace_state</code> displays the current state in the info view.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.traceState">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.tacticTrans___"><h2>trans</h2><p><p><code>trans</code> applies to a goal whose target has the form <code>t ~ u</code> where <code>~</code> is a transitive relation,
that is, a relation which has a transitivity lemma tagged with the attribute [trans].</p><ul><li><code>trans s</code> replaces the goal with the two subgoals <code>t ~ s</code> and <code>s ~ u</code>.</li><li>If <code>s</code> is omitted, then a metavariable is used instead.</li></ul><p>Additionally, <code>trans</code> also applies to a goal whose target has the form <code>t → u</code>,
in which case it replaces the goal with <code>t → s</code> and <code>s → u</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Trans.html#Batteries.Tactic.tacticTrans___">Batteries.Tactic.Trans</a></dd></dl></div><div id="Batteries.Tactic.tacticTransitivity___"><h2>transitivity</h2><p><p>Synonym for <code>trans</code> tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Trans.html#Batteries.Tactic.tacticTransitivity___">Batteries.Tactic.Trans</a></dd></dl></div><div id="Batteries.Tactic.triv"><h2>triv</h2><p><p>Deprecated variant of <code><a href="./Init/Core.html#trivial">trivial</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.triv">Batteries.Tactic.Init</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticTrivial"><h2>trivial</h2><p><p><code><a href="./Init/Core.html#trivial">trivial</a></code> tries different simple tactics (e.g., <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, <code>contradiction</code>, ...)
to close the current goal.
You can use the command <code>macro_rules</code> to extend the set of tactics used. Example:</p><pre><code>macro_rules | `(tactic| trivial) =&gt; `(tactic| simp)
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticTry_"><h2>try</h2><p><p><code>try tac</code> runs <code>tac</code> and succeeds even if <code>tac</code> failed.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticTry_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tryTrace"><h2>try?</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Try.html#Lean.Parser.Tactic.tryTrace">Init.Try</a></dd></dl></div><div id="Lean.Parser.Tactic.tryResult"><h2>try_suggestions</h2><p><p>Helper internal tactic used to implement <code>evalSuggest</code> in <code>try?</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Try.html#Lean.Parser.Tactic.tryResult">Init.Try</a></dd></dl></div><div id="Lean.Parser.Tactic.unfold"><h2>unfold</h2><p><ul><li><code>unfold <a href="./Init/Prelude.html#id">id</a></code> unfolds all occurrences of definition <code><a href="./Init/Prelude.html#id">id</a></code> in the target.</li><li><code>unfold id1 id2 ...</code> is equivalent to <code>unfold id1; unfold id2; ...</code>.</li><li><code>unfold <a href="./Init/Prelude.html#id">id</a> at h</code> unfolds at the hypothesis <code>h</code>.</li></ul><p>Definitions can be either global or local definitions.</p><p>For non-recursive global definitions, this tactic is identical to <code>delta</code>.
For recursive global definitions, it uses the &quot;unfolding lemma&quot; <code>id.eq_def</code>,
which is generated for each recursive definition, to unfold according to the recursive definition given by the user.
Only one level of unfolding is performed, in contrast to <code>simp only [id]</code>, which unfolds definition <code><a href="./Init/Prelude.html#id">id</a></code> recursively.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.unfold">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticUnhygienic_"><h2>unhygienic</h2><p><p><code>unhygienic tacs</code> runs <code>tacs</code> with name hygiene disabled.
This means that tactics that would normally create inaccessible names will instead
make regular variables. <strong>Warning</strong>: Tactics may change their variable naming
strategies at any time, so code that depends on autogenerated names is brittle.
Users should try not to use <code>unhygienic</code> if possible.</p><pre><code>example : ∀ x : Nat, x = x := by unhygienic
  intro            -- x would normally be intro'd as inaccessible
  exact <a href="./Init/Prelude.html#Eq.refl">Eq.refl</a> x  -- refer to x
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticUnhygienic_">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.unreachable"><h2>unreachable!</h2><p><p>This tactic causes a panic when run (at compile time).
(This is distinct from <code>exact unreachable!</code>, which inserts code which will panic at run time.)</p><p>It is intended for tests to assert that a tactic will never be executed, which is otherwise an
unusual thing to do (and the <code>unreachableTactic</code> linter will give a warning if you do).</p><p>The <code>unreachableTactic</code> linter has a special exception for uses of <code>unreachable!</code>.</p><pre><code>example : <a href="./Init/Prelude.html#True">True</a> := by <a href="./Init/Core.html#trivial">trivial</a> &lt;;&gt; unreachable!
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Unreachable.html#Batteries.Tactic.unreachable">Batteries.Tactic.Unreachable</a></dd></dl></div><div id="Lean.Server.Test.Cancel.tacticWait_for_unblock_async"><h2>wait_for_unblock_async</h2><p><p>Spawns a <code>logSnapshotTask</code> that waits for <code>unblock</code> to be called, which is expected to happen in a
subsequent document version that does not invalidate this tactic. Complains if cancellation token
was set before unblocking, i.e. if the tactic was invalidated after all.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Lean/Server/Test/Cancel.html#Lean.Server.Test.Cancel.tacticWait_for_unblock_async">Lean.Server.Test.Cancel</a></dd></dl></div><div id="Lean.Parser.Tactic.withReducible"><h2>with_reducible</h2><p><p><code>with_reducible tacs</code> executes <code>tacs</code> using the reducible transparency setting.
In this setting only definitions tagged as <code>[reducible]</code> are unfolded.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.withReducible">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.withReducibleAndInstances"><h2>with_reducible_and_instances</h2><p><p><code>with_reducible_and_instances tacs</code> executes <code>tacs</code> using the <code>.instances</code> transparency setting.
In this setting only definitions tagged as <code>[reducible]</code> or type class instances are unfolded.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.withReducibleAndInstances">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.withUnfoldingAll"><h2>with_unfolding_all</h2><p><p><code>with_unfolding_all tacs</code> executes <code>tacs</code> using the <code>.all</code> transparency setting.
In this setting all definitions that are not opaque are unfolded.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.withUnfoldingNone"><h2>with_unfolding_none</h2><p><p><code>with_unfolding_none tacs</code> executes <code>tacs</code> using the <code>.none</code> transparency setting.
In this setting no definitions are unfolded.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingNone">Init.Tactics</a></dd></dl></div><div id="«tactic∎»"><h2>∎</h2><p><p><code>∎</code> (typed as <code>\qed</code>) is a macro that expands to <code>try?</code> in tactic mode.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Try.html#«tactic∎»">Init.Try</a></dd></dl></div></main>
<nav class="nav"><iframe src="./navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>