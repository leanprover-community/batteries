<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Lake.Build.Topological</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Lake.Build.Topological";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lake</span>.<span class="name">Build</span>.<span class="name">Topological</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/lake/Lake/Build/Topological.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Lake/Util/Cycle.html">Lake.Util.Cycle</a></li><li><a href="../.././Lake/Util/EquipT.html">Lake.Util.EquipT</a></li><li><a href="../.././Lake/Util/Store.html">Lake.Util.Store</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lake.Build.Topological" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lake.DFetchFn"><span class="name">Lake</span>.<span class="name">DFetchFn</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.FetchFn"><span class="name">Lake</span>.<span class="name">FetchFn</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.DFetchFnT"><span class="name">Lake</span>.<span class="name">DFetchFnT</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.FetchFnT"><span class="name">Lake</span>.<span class="name">FetchFnT</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.DRecFetchFn"><span class="name">Lake</span>.<span class="name">DRecFetchFn</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.RecFetchFn"><span class="name">Lake</span>.<span class="name">RecFetchFn</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.recFetch"><span class="name">Lake</span>.<span class="name">recFetch</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.recFetchAcyclic"><span class="name">Lake</span>.<span class="name">recFetchAcyclic</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.recFetchMemoize"><span class="name">Lake</span>.<span class="name">recFetchMemoize</span></a></div></nav><main>
<div class="mod_doc"><h1 id="Topological-Suspending-Recursive-Builder" class="markdown-heading">Topological / Suspending Recursive Builder <a class="hover-link" href="#Topological-Suspending-Recursive-Builder">#</a></h1><p>This module defines a recursive build function that topologically
(ι.e., via a depth-first search with memoization) builds the elements of
a build store.</p><p>This is called a suspending scheduler in <em>Build systems à la carte</em>.</p></div><div class="mod_doc"><h2 id="Recursive-Fetching" class="markdown-heading">Recursive Fetching <a class="hover-link" href="#Recursive-Fetching">#</a></h2><p>In this section, we define the primitives that make up a builder.</p></div><div class="decl" id="Lake.DFetchFn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/lake/Lake/Build/Topological.lean#L31-L40">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.DFetchFn"><span class="name">Lake</span>.<span class="name">DFetchFn</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max u w)</div></div><p>A dependently typed monadic <em>fetch</em> function.</p><p>That is, a function within the monad <code>m</code> and takes an input <code>a : α</code>
describing what to fetch and produces some output <code>b : β a</code> (dependently
typed) or <code>b : B</code> (not) describing what was fetched. All build functions are
fetch functions, but not all fetch functions need build something.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">Lake.DFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">m</span> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>)</span></li></ul></details><details id="instances-for-list-Lake.DFetchFn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lake.FetchFn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/lake/Lake/Build/Topological.lean#L42-L44">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.FetchFn"><span class="name">Lake</span>.<span class="name">FetchFn</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max u w)</div></div><p>A <code><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">DFetchFn</a></code> that is not dependently typed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.FetchFn">Lake.FetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span>)</span></li></ul></details><details id="instances-for-list-Lake.FetchFn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>In order to nest builds / fetches within one another,
we equip the monad <code>m</code> with a fetch function of its own.</p></div><div class="decl" id="Lake.DFetchFnT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/lake/Lake/Build/Topological.lean#L51-L53">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.DFetchFnT"><span class="name">Lake</span>.<span class="name">DFetchFnT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> (max (max w u) w)</span></div></div><p>A transformer that equips a monad with a <code><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">DFetchFn</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFnT">Lake.DFetchFnT</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lake/Util/EquipT.html#Lake.EquipT">Lake.EquipT</a> <span class="fn">(<a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">Lake.DFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span>)</span> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Lake.DFetchFnT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lake.FetchFnT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/lake/Lake/Build/Topological.lean#L55-L57">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.FetchFnT"><span class="name">Lake</span>.<span class="name">FetchFnT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> (max (max w u) w)</span></div></div><p>A <code><a href="../.././Lake/Build/Topological.html#Lake.DFetchFnT">DFetchFnT</a></code> that is not dependently typed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.FetchFnT">Lake.FetchFnT</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFnT">Lake.DFetchFnT</a> <span class="fn">α</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span>)</span> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Lake.FetchFnT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>We can then use the such a monad as the basis for a fetch function itself.</p></div><div class="decl" id="Lake.DRecFetchFn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/lake/Lake/Build/Topological.lean#L68-L69">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn"><span class="name">Lake</span>.<span class="name">DRecFetchFn</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max u w u)</div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">Lake.DRecFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">Lake.DFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">(<a href="../.././Lake/Build/Topological.html#Lake.DFetchFnT">Lake.DFetchFnT</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span>)</span></span></li></ul></details><details id="instances-for-list-Lake.DRecFetchFn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lake.RecFetchFn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/lake/Lake/Build/Topological.lean#L71-L73">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.RecFetchFn"><span class="name">Lake</span>.<span class="name">RecFetchFn</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max u w)</div></div><p>A <code><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">DRecFetchFn</a></code> that is not dependently typed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.RecFetchFn">Lake.RecFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">α</span> → <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.FetchFnT">Lake.FetchFnT</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span> <span class="fn">β</span></span>)</span></li></ul></details><details id="instances-for-list-Lake.RecFetchFn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lake.recFetch"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/lake/Lake/Build/Topological.lean#L75-L78">source</a></div><div class="attributes">@[specialize #[]]</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.recFetch"><span class="name">Lake</span>.<span class="name">recFetch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u), <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn">m</span> <span class="fn">α</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">fetch</span> : <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">DRecFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">DFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span></div></div><p>A <code><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">DFetchFn</a></code> that provides its base <code><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">DRecFetchFn</a></code> with itself.</p></div></div><div class="mod_doc"><p>The basic <code><a href="../.././Lake/Build/Topological.html#Lake.recFetch">recFetch</a></code> can fail to terminate in a variety of ways,
it can even cycle (i.e., <code>a</code> fetches <code>b</code> which fetches <code>a</code>). Thus, we
define the <code>acyclicRecFetch</code> below to guard against such cases.</p></div><div class="decl" id="Lake.recFetchAcyclic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/lake/Lake/Build/Topological.lean#L86-L105">source</a></div><div class="attributes">@[specialize #[]]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.recFetchAcyclic"><span class="name">Lake</span>.<span class="name">recFetchAcyclic</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">κ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.MonadCycle">MonadCycle</a> <span class="fn">κ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">keyOf</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">κ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fetch</span> : <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">DRecFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">DFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span></div></div><p>A <code><a href="../.././Lake/Build/Topological.html#Lake.recFetch">recFetch</a></code> augmented by a <code>MonadCycle</code> to guard against recursive cycles.
If the set of visited keys is finite, this function should provably terminate.</p><p>We use <code>keyOf</code> to the derive the unique key of a fetch from its descriptor
<code>a : α</code>. We do this because descriptors may not be comparable and/or contain
more information than necessary to determine uniqueness.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lake.recFetchAcyclic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>When building, we usually do not want to build the same thing twice during
a single build pass. At the same time, separate builds may both wish to fetch
the same thing. Thus, we need to store past build results to return them upon
future fetches. This is what <code><a href="../.././Lake/Build/Topological.html#Lake.recFetchMemoize">recFetchMemoize</a></code> below does.</p></div><div class="decl" id="Lake.recFetchMemoize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/lake/Lake/Build/Topological.lean#L114-L123">source</a></div><div class="attributes">@[specialize #[]]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.recFetchMemoize"><span class="name">Lake</span>.<span class="name">recFetchMemoize</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">κ</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">κ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.MonadCycle">MonadCycle</a> <span class="fn">κ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Lake/Util/Store.html#Lake.MonadDStore">MonadDStore</a> <span class="fn">κ</span> <span class="fn">β</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">keyOf</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">κ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">compute</span> : <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">DRecFetchFn</a> <span class="fn">α</span> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">β</span> <span class="fn">(<span class="fn">keyOf</span> <span class="fn">a</span>)</span></span>)</span> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">DFetchFn</a> <span class="fn">α</span> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">β</span> <span class="fn">(<span class="fn">keyOf</span> <span class="fn">a</span>)</span></span>)</span> <span class="fn">m</span></span></div></div><p><code><a href="../.././Lake/Build/Topological.html#Lake.recFetchAcyclic">recFetchAcyclic</a></code> augmented with a <code>MonadDStore</code> to
memoize fetch results and thus avoid computing the same result twice.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.recFetchMemoize">Lake.recFetchMemoize</a> <span class="fn">keyOf</span> <span class="fn">compute</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Core.html#inline">inline</a> <span class="fn">(<a href="../.././Lake/Build/Topological.html#Lake.recFetchAcyclic">Lake.recFetchAcyclic</a> <span class="fn">keyOf</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../.././Lake/Util/Store.html#Lake.fetchOrCreate">Lake.fetchOrCreate</a> <span class="fn">(<span class="fn">keyOf</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">compute</span> <span class="fn">a</span>)</span></span></span>)</span></span></li></ul></details><details id="instances-for-list-Lake.recFetchMemoize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>