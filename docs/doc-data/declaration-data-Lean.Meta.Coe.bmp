{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.coerce?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">coerce?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr </span><span class=\"fn\">expectedType</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Lean/Data/LOption.html#Lean.LOption\">LOption</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>","info":{"doc":"Coerces `expr` to the type `expectedType`.\nReturns `.some coerced` on successful coercion,\n`.none` if the expression cannot by coerced to that type,\nor `.undef` if we need more metavariable assignments. ","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerce?","kind":"def","line":230,"name":"Lean.Meta.coerce?","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Coe.lean#L230-L241"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.coerceMonadLift?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">coerceMonadLift?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">expectedType</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>","info":{"doc":"Try coercions and monad lifts to make sure `e` has type `expectedType`.\n\nIf `expectedType` is of the form `n β`, we try monad lifts and other extensions.\n\nExtensions for monads.\n\n1. Try to unify `n` and `m`. If it succeeds, then we use\n  ```\n  coeM {m : Type u → Type v} {α β : Type u} [∀ a, CoeT α a β] [Monad m] (x : m α) : m β\n  ```\n  `n` must be a `Monad` to use this one.\n\n2. If there is monad lift from `m` to `n` and we can unify `α` and `β`, we use\n  ```\n  liftM : ∀ {m : Type u_1 → Type u_2} {n : Type u_1 → Type u_3} [self : MonadLiftT m n] {α : Type u_1}, m α → n α\n  ```\n  Note that `n` may not be a `Monad` in this case. This happens quite a bit in code such as\n  ```\n  def g (x : Nat) : IO Nat := do\n    IO.println x\n    pure x\n\n  def f {m} [MonadLiftT IO m] : m Nat :=\n    g 10\n\n  ```\n\n3. If there is a monad lift from `m` to `n` and a coercion from `α` to `β`, we use\n  ```\n  liftCoeM {m : Type u → Type v} {n : Type u → Type w} {α β : Type u} [MonadLiftT m n] [∀ a, CoeT α a β] [Monad n] (x : m α) : n β\n  ```\n\nNote that approach 3 does not subsume 1 because it is only applicable if there is a coercion from `α` to `β` for all values in `α`.\nThis is not the case for example for `pure $ x > 0` when the expected type is `IO Bool`. The given type is `IO Prop`, and\nwe only have a coercion from decidable propositions.  Approach 1 works because it constructs the coercion `CoeT (m Prop) (pure $ x > 0) (m Bool)`\nusing the instance `pureCoeDepProp`.\n\nNote that, approach 2 is more powerful than `tryCoe`.\nRecall that type class resolution never assigns metavariables created by other modules.\nNow, consider the following scenario\n```lean\ndef g (x : Nat) : IO Nat := ...\ndeg h (x : Nat) : StateT Nat IO Nat := do\nv ← g x;\nIO.Println v;\n...\n```\nLet's assume there is no other occurrence of `v` in `h`.\nThus, we have that the expected of `g x` is `StateT Nat IO ?α`,\nand the given type is `IO Nat`. So, even if we add a coercion.\n```\ninstance {α m n} [MonadLiftT m n] {α} : Coe (m α) (n α) := ...\n```\nIt is not applicable because TC would have to assign `?α := Nat`.\nOn the other hand, TC can easily solve `[MonadLiftT IO (StateT Nat IO)]`\nsince this goal does not contain any metavariables. And then, we\nconvert `g x` into `liftM $ g x`.\n","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerceMonadLift?","kind":"def","line":125,"name":"Lean.Meta.coerceMonadLift?","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Coe.lean#L125-L228"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.isMonadApp\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isMonadApp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Return `true` if `type` is of the form `m α` where `m` is a `Monad`.\nNote that we reduce `type` using transparency `[reducible]`.\n","docLink":"./Lean/Meta/Coe.html#Lean.Meta.isMonadApp","kind":"def","line":117,"name":"Lean.Meta.isMonadApp","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Coe.lean#L117-L123"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.isTypeApp?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isTypeApp?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>))</span></span></div></div>","info":{"doc":"Return `some (m, α)` if `type` can be reduced to an application of the form `m α` using `[reducible]` transparency. ","docLink":"./Lean/Meta/Coe.html#Lean.Meta.isTypeApp?","kind":"def","line":110,"name":"Lean.Meta.isTypeApp?","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Coe.lean#L110-L115"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.coerceToSort?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">coerceToSort?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>","info":{"doc":"Coerces `expr` to a type. ","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerceToSort?","kind":"def","line":96,"name":"Lean.Meta.coerceToSort?","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Coe.lean#L96-L108"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.coerceToFunction?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">coerceToFunction?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>","info":{"doc":"Coerces `expr` to a function type. ","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerceToFunction?","kind":"def","line":82,"name":"Lean.Meta.coerceToFunction?","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Coe.lean#L82-L94"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.coerceSimple?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">coerceSimple?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr </span><span class=\"fn\">expectedType</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Lean/Data/LOption.html#Lean.LOption\">LOption</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>","info":{"doc":"Coerces `expr` to `expectedType` using `CoeT`. ","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerceSimple?","kind":"def","line":67,"name":"Lean.Meta.coerceSimple?","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Coe.lean#L67-L80"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.autoLift\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">autoLift</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Coe.html#Lean.Meta.autoLift","kind":"opaque","line":62,"name":"Lean.Meta.autoLift","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Coe.lean#L62-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.expandCoe\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">expandCoe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Expand coercions occurring in `e` ","docLink":"./Lean/Meta/Coe.html#Lean.Meta.expandCoe","kind":"def","line":43,"name":"Lean.Meta.expandCoe","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Coe.lean#L43-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.isCoeDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isCoeDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">env</span> : <a href=\"./Lean/Environment.html#Lean.Environment\">Environment</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Return true iff `declName` is one of the auxiliary definitions/projections used to implement\ncoercions.\n","docLink":"./Lean/Meta/Coe.html#Lean.Meta.isCoeDecl","kind":"def","line":27,"name":"Lean.Meta.isCoeDecl","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Coe.lean#L27-L32"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Coe.html#Lean.Meta.coeDeclAttr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">coeDeclAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Attributes.html#Lean.TagAttribute\">TagAttribute</a></div></div>","info":{"doc":"Tags declarations to be unfolded during coercion elaboration.\n\nThis is mostly used to hide coercion implementation details and show the coerced result instead of\nan application of auxiliary definitions (e.g. `CoeT.coe`, `Coe.coe`). This attribute only works on\nreducible functions and instance projections.\n","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coeDeclAttr","kind":"opaque","line":16,"name":"Lean.Meta.coeDeclAttr","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Coe.lean#L16-L25"}}],"imports":["Lean.Meta.AppBuilder","Lean.ExtraModUses"],"instances":[],"name":"Lean.Meta.Coe"}