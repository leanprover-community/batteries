{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule.apply'\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">BackwardRule</span>.<span class=\"name\">apply'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rule</span> : <a href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule\">BackwardRule</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"Similar to `BackwardRule.apply', but throws an error if unification fails.\n","docLink":"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule.apply'","kind":"def","line":140,"name":"Lean.Meta.Sym.BackwardRule.apply'","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Apply.lean#L140-L146"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule.apply\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">BackwardRule</span>.<span class=\"name\">apply</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rule</span> : <a href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule\">BackwardRule</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.ApplyResult\">ApplyResult</a></span></div></div>","info":{"doc":"Applies a backward rule to a goal, returning new subgoals.\n\n1. Unifies the goal type with the rule's pattern\n2. Assigns the goal metavariable to the theorem application\n3. Returns new goals for unassigned arguments (per `resultPos`)\n\nReturns `.notApplicable` if unification fails.\n","docLink":"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule.apply","kind":"def","line":122,"name":"Lean.Meta.Sym.BackwardRule.apply","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Apply.lean#L122-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.ApplyResult.goals\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">ApplyResult</span>.<span class=\"name\">goals</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarIds</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.ApplyResult\">ApplyResult</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.ApplyResult.goals","kind":"ctor","line":120,"name":"Lean.Meta.Sym.ApplyResult.goals","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Apply.lean#L120-L120"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.ApplyResult.failed\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">ApplyResult</span>.<span class=\"name\">failed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.ApplyResult\">ApplyResult</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.ApplyResult.failed","kind":"ctor","line":119,"name":"Lean.Meta.Sym.ApplyResult.failed","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Apply.lean#L119-L119"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.ApplyResult\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">ApplyResult</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.ApplyResult","kind":"inductive","line":118,"name":"Lean.Meta.Sym.ApplyResult","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Apply.lean#L118-L120"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.mkBackwardRuleFromExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">mkBackwardRuleFromExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">levelParams</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span> := <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">num?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule\">BackwardRule</a></span></div></div>","info":{"doc":"Creates a `BackwardRule` from an expression.\n\n`levelParams` is not `[]` if the expression is supposed to be\nuniverse polymorphic.\n\nThe `num?` parameter optionally limits how many arguments are included in the pattern\n(useful for partially applying theorems).\n","docLink":"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.mkBackwardRuleFromExpr","kind":"def","line":91,"name":"Lean.Meta.Sym.mkBackwardRuleFromExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Apply.lean#L91-L104"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.mkBackwardRuleFromDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">mkBackwardRuleFromDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">num?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule\">BackwardRule</a></span></div></div>","info":{"doc":"Creates a `BackwardRule` from a declaration name.\n\nThe `num?` parameter optionally limits how many arguments are included in the pattern\n(useful for partially applying theorems).\n","docLink":"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.mkBackwardRuleFromDecl","kind":"def","line":80,"name":"Lean.Meta.Sym.mkBackwardRuleFromDecl","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Apply.lean#L80-L89"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule.resultPos\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">BackwardRule</span>.<span class=\"name\">resultPos</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule\">BackwardRule</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>","info":{"doc":"Indices of arguments that become new subgoals, ordered with\nnon-dependent goals first. ","docLink":"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule.resultPos","kind":"def","line":28,"name":"Lean.Meta.Sym.BackwardRule.resultPos","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Apply.lean#L28-L28"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule.pattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">BackwardRule</span>.<span class=\"name\">pattern</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule\">BackwardRule</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern\">Pattern</a></div></div>","info":{"doc":"Precomputed pattern for efficient unification. ","docLink":"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule.pattern","kind":"def","line":24,"name":"Lean.Meta.Sym.BackwardRule.pattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Apply.lean#L24-L24"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule.expr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">BackwardRule</span>.<span class=\"name\">expr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule\">BackwardRule</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"The theorem used to create the rule. It is often of the form `Expr.const declName`. ","docLink":"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule.expr","kind":"def","line":22,"name":"Lean.Meta.Sym.BackwardRule.expr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Apply.lean#L22-L22"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">BackwardRule</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pattern</span> : <a href=\"./Lean/Meta/Sym/Pattern.html#Lean.Meta.Sym.Pattern\">Pattern</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">resultPos</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule\">BackwardRule</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule.mk","kind":"ctor","line":20,"name":"Lean.Meta.Sym.BackwardRule.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Apply.lean#L20-L20"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">BackwardRule</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A rule for backward chaining (goal transformation).\n\nGiven a goal `... ⊢ T`, applying a `BackwardRule` derived from a theorem `∀ xs, P`\nwill unify `T` with `P`, assign the goal to the theorem application,\nand return new goals for the unassigned arguments in `xs`.\n","docLink":"./Lean/Meta/Sym/Apply.html#Lean.Meta.Sym.BackwardRule","kind":"structure","line":13,"name":"Lean.Meta.Sym.BackwardRule","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Apply.lean#L13-L28"}}],"imports":["Lean.Meta.Sym.Pattern","Lean.Util.CollectFVars","Init.Data.Range.Polymorphic.Iterators"],"instances":[],"name":"Lean.Meta.Sym.Apply"}