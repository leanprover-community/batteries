[{"userName": "cbv",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.cbv",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "cbv"}]]},
        {"text":
         " performs simplification that closely mimics call-by-value evaluation."},
        {"raw": "\n"},
        {"text":
         "It reduces terms by unfolding definitions using their defining equations and"},
        {"raw": "\n"},
        {"text":
         "applying matcher equations. The unfolding is propositional, so "},
        {"element": ["code", true, [], [{"text": "cbv"}]]},
        {"text": " also works"},
        {"raw": "\n"},
        {"text":
         "with functions defined via well-founded recursion or partial fixpoints."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "cbv"}]]},
        {"text": " has built-in support for goals of the form "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "lhs"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "rhs"}]]},
        {"text": ". It proceeds in"},
        {"raw": "\n"},
        {"text": "two passes:"}]]},
     {"element":
      ["ol",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"text": "Reduce "},
           {"element": ["code", true, [], [{"text": "lhs"}]]},
           {"text": ". If the result is definitionally equal to "},
           {"element": ["code", true, [], [{"text": "rhs"}]]},
           {"text": ", close the goal."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Otherwise, reduce "},
           {"element": ["code", true, [], [{"text": "rhs"}]]},
           {"text": ". If the result is now definitionally equal to the"},
           {"raw": "\n"},
           {"text": "reduced "},
           {"element": ["code", true, [], [{"text": "lhs"}]]},
           {"text": ", close the goal."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "If neither check succeeds, generate a new goal "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "lhs'"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "rhs'"}]]},
           {"text": ", where "},
           {"element": ["code", true, [], [{"text": "lhs'"}]]},
           {"raw": "\n"},
           {"text": "and "},
           {"element": ["code", true, [], [{"text": "rhs'"}]]},
           {"text": " are the reduced forms of the original sides."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "cbv"}]]},
        {"text":
         " is therefore not a finishing tactic in general: it may leave a new"},
        {"raw": "\n"},
        {"text":
         "(simpler) equality goal. For goals that are not equalities, "},
        {"element": ["code", true, [], [{"text": "cbv"}]]},
        {"text": " currently"},
        {"raw": "\n"},
        {"text": "leaves the goal unchanged."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "The proofs produced by "},
        {"element": ["code", true, [], [{"text": "cbv"}]]},
        {"text": " only use the three standard axioms."},
        {"raw": "\n"},
        {"text":
         "In particular, they do not require trust in the correctness of the code"},
        {"raw": "\n"},
        {"text": "generator."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "This tactic is experimental and its behavior is likely to change in upcoming"},
        {"raw": "\n"},
        {"text": "releases of Lean."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "lift_lets",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.liftLets",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Lifts "},
        {"element": ["code", true, [], [{"text": "let"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text": " expressions within a term as far out as possible."},
        {"raw": "\n"},
        {"text": "It is like "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "extract_lets"}, {"text": " "}, {"text": "+lift"}]]},
        {"text": ", but the top-level lets at the end of the procedure"},
        {"raw": "\n"},
        {"text": "are not extracted as local hypotheses."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "lift_lets"}]]},
           {"text": " lifts let expressions in the target."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "lift_lets"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "h"}]]},
           {"text":
            " lifts let expressions at the given local hypothesis."}]]}]]},
     {"element": ["p", true, [], [{"text": "For example,"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "(let"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "1;"},
           {"text": " "},
           {"text": "x)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "1"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "lift_lets"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "--"},
           {"text": " "},
           {"text": "⊢"},
           {"text": " "},
           {"text": "let"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "1;"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "1"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "..."},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "with_reducible_and_instances",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.withReducibleAndInstances",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "with_reducible_and_instances"},
           {"text": " "},
           {"text": "tacs"}]]},
        {"text": " executes "},
        {"element": ["code", true, [], [{"text": "tacs"}]]},
        {"text": " using the "},
        {"element": ["code", true, [], [{"text": ".instances"}]]},
        {"text": " transparency setting."},
        {"raw": "\n"},
        {"text": "In this setting only definitions tagged as "},
        {"element": ["code", true, [], [{"text": "[reducible]"}]]},
        {"text": " or type class instances are unfolded."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "clear_value",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.clearValue",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["p",
             true,
             [],
             [{"element":
               ["code",
                true,
                [],
                [{"text": "clear_value"}, {"text": " "}, {"text": "x..."}]]},
              {"text": " clears the values of the given local definitions."},
              {"raw": "\n"},
              {"text": "A local definition "},
              {"element":
               ["code",
                true,
                [],
                [{"text": "x"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "α"},
                 {"text": " "},
                 {"text": ":="},
                 {"text": " "},
                 {"text": "v"}]]},
              {"text": " becomes a hypothesis "},
              {"element":
               ["code",
                true,
                [],
                [{"text": "x"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "α"}]]},
              {"text": "."}]]}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["p",
             true,
             [],
             [{"element":
               ["code",
                true,
                [],
                [{"text": "clear_value"},
                 {"text": " "},
                 {"text": "(h"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "x"},
                 {"text": " "},
                 {"text": "="},
                 {"text": " "},
                 {"text": "_)"}]]},
              {"text": " adds a hypothesis "},
              {"element":
               ["code",
                true,
                [],
                [{"text": "h"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "x"},
                 {"text": " "},
                 {"text": "="},
                 {"text": " "},
                 {"text": "v"}]]},
              {"text": " before clearing the value of "},
              {"element": ["code", true, [], [{"text": "x"}]]},
              {"text": "."},
              {"raw": "\n"},
              {"text": "This is short for "},
              {"element":
               ["code",
                true,
                [],
                [{"text": "have"},
                 {"text": " "},
                 {"text": "h"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "x"},
                 {"text": " "},
                 {"text": "="},
                 {"text": " "},
                 {"text": "v"},
                 {"text": " "},
                 {"text": ":="},
                 {"text": " "},
                 {"text": "rfl;"},
                 {"text": " "},
                 {"text": "clear_value"},
                 {"text": " "},
                 {"text": "x"}]]},
              {"text": "."},
              {"raw": "\n"},
              {"text": "Any value definitionally equal to "},
              {"element": ["code", true, [], [{"text": "v"}]]},
              {"text": " can be used in place of "},
              {"element": ["code", true, [], [{"text": "_"}]]},
              {"text": "."}]]}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["p",
             true,
             [],
             [{"element":
               ["code",
                true,
                [],
                [{"text": "clear_value"}, {"text": " "}, {"text": "*"}]]},
              {"text": " clears values of all hypotheses that can be cleared."},
              {"raw": "\n"},
              {"text": "Fails if none can be cleared."}]]}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "These syntaxes can be combined. For example, "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "clear_value"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "y"},
           {"text": " "},
           {"text": "*"}]]},
        {"text": " ensures that "},
        {"element": ["code", true, [], [{"text": "x"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "y"}]]},
        {"text": " are cleared"},
        {"raw": "\n"},
        {"text": "while trying to clear all other local definitions,"},
        {"raw": "\n"},
        {"text": "and "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "clear_value"},
           {"text": " "},
           {"text": "(hx"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "_)"},
           {"text": " "},
           {"text": "y"},
           {"text": " "},
           {"text": "*"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "hx"}]]},
        {"text": " does the same while first adding the "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "hx"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "v"}]]},
        {"text": " hypothesis."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "trace_state",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.traceState",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "trace_state"}]]},
        {"text": " displays the current state in the info view."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "suggestions",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.suggestions",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "#suggestions"}]]},
        {"text":
         " will suggest relevant theorems from the library for the current goal,"},
        {"raw": "\n"},
        {"text":
         "using the currently registered library suggestion engine."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "The suggestions are printed in the order of their confidence, from highest to lowest."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "right",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.right",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Applies the second constructor when"},
        {"raw": "\n"},
        {"text":
         "the goal is an inductive type with exactly two constructors, or fails otherwise."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "example"},
           {"text": " "},
           {"text": "{p"},
           {"text": " "},
           {"text": "q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Prop}"},
           {"text": " "},
           {"text": "(h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "q)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "p"},
           {"text": " "},
           {"text": "∨"},
           {"text": " "},
           {"text": "q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "right"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "exact"},
           {"text": " "},
           {"text": "h"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "try",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticTry_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code", true, [], [{"text": "try"}, {"text": " "}, {"text": "tac"}]]},
        {"text": " runs "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " and succeeds even if "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " failed."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "rotate_right",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.rotateRight",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Rotate the goals to the right by "},
        {"element": ["code", true, [], [{"text": "n"}]]},
        {"text": ". That is, take the goal at the back"},
        {"raw": "\n"},
        {"text": "and push it to the front "},
        {"element": ["code", true, [], [{"text": "n"}]]},
        {"text": " times. If "},
        {"element": ["code", true, [], [{"text": "n"}]]},
        {"text": " is omitted, it defaults to "},
        {"element": ["code", true, [], [{"text": "1"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "let",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticLet__",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "let"}]]},
        {"text":
         " tactic is for adding definitions to the local context of the main goal."},
        {"raw": "\n"},
        {"text":
         "The definition can be unfolded, unlike definitions introduced by "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text": "."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "let"},
              {"text": " "},
              {"text": "x"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "t"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " adds the definition "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "x"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "t"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " if "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " is a term of type "},
           {"element": ["code", true, [], [{"text": "t"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "let"},
              {"text": " "},
              {"text": "x"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " uses the type of "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " for "},
           {"element": ["code", true, [], [{"text": "t"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "let"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "t"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " and "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "let"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " use "},
           {"element": ["code", true, [], [{"text": "this"}]]},
           {"text": " for the name of the hypothesis."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "let"},
              {"text": " "},
              {"text": "pat"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " for a pattern "},
           {"element": ["code", true, [], [{"text": "pat"}]]},
           {"text": " is equivalent to "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "match"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "with"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "pat"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "_"}]]},
           {"text": ","},
           {"raw": "\n"},
           {"text": "where "},
           {"element": ["code", true, [], [{"text": "_"}]]},
           {"text": " stands for the tactics that follow this one."},
           {"raw": "\n"},
           {"text":
            "It is convenient for types that let only one applicable constructor."},
           {"raw": "\n"},
           {"text": "For example, given "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "p"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "α"},
              {"text": " "},
              {"text": "×"},
              {"text": " "},
              {"text": "β"},
              {"text": " "},
              {"text": "×"},
              {"text": " "},
              {"text": "γ"}]]},
           {"text": ", "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "let"},
              {"text": " "},
              {"text": "⟨x,"},
              {"text": " "},
              {"text": "y,"},
              {"text": " "},
              {"text": "z⟩"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "p"}]]},
           {"text": " produces the"},
           {"raw": "\n"},
           {"text": "local variables "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "x"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "α"}]]},
           {"text": ", "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "y"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "β"}]]},
           {"text": ", and "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "z"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "γ"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "The syntax "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "let"},
              {"text": " "},
              {"text": "(eq"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "h)"},
              {"text": " "},
              {"text": "pat"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " is equivalent to "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "match"},
              {"text": " "},
              {"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "with"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "pat"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "_"}]]},
           {"text": ","},
           {"raw": "\n"},
           {"text": "which adds the equation "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "pat"}]]},
           {"text": " to the local context."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "The tactic supports all the same syntax variants and options as the "},
        {"element": ["code", true, [], [{"text": "let"}]]},
        {"text": " term."}]]},
     {"element":
      ["h2",
       true,
       [["id", "Properties-and-relations"], ["class", "markdown-heading"]],
       [{"text": "Properties and relations"},
        {"text": " "},
        {"element":
         ["a",
          true,
          [["class", "hover-link"], ["href", "#Properties-and-relations"]],
          [{"text": "#"}]]}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"text": "Unlike "},
           {"element": ["code", true, [], [{"text": "have"}]]},
           {"text": ", it is possible to unfold definitions introduced using "},
           {"element": ["code", true, [], [{"text": "let"}]]},
           {"text": ", using tactics"},
           {"raw": "\n"},
           {"text": "such as "},
           {"element": ["code", true, [], [{"text": "simp"}]]},
           {"text": ", "},
           {"element": ["code", true, [], [{"text": "dsimp"}]]},
           {"text": ", "},
           {"element": ["code", true, [], [{"text": "unfold"}]]},
           {"text": ", and "},
           {"element": ["code", true, [], [{"text": "subst"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "The "},
           {"element": ["code", true, [], [{"text": "clear_value"}]]},
           {"text": " tactic turns a "},
           {"element": ["code", true, [], [{"text": "let"}]]},
           {"text": " definition into a "},
           {"element": ["code", true, [], [{"text": "have"}]]},
           {"text": " definition after the fact."},
           {"raw": "\n"},
           {"text":
            "The tactic might fail if the local context depends on the value of the variable."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "The "},
           {"element": ["code", true, [], [{"text": "let"}]]},
           {"text": " tactic is preferred for data (non-propositions)."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Sometimes "},
           {"element": ["code", true, [], [{"text": "have"}]]},
           {"text":
            " is used for non-propositions to ensure that the variable is never unfolded,"},
           {"raw": "\n"},
           {"text": "which may be important for performance reasons."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "have'",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticHave'",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Similar to "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text": ", but using "},
        {"element": ["code", true, [], [{"text": "refine'"}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "infer_instance",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticInfer_instance",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "infer_instance"}]]},
        {"text": " is an abbreviation for "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "exact"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#inferInstance"]],
             [{"text": "inferInstance"}]]}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text":
         "It synthesizes a value of any target type by typeclass inference."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "fail_if_success",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.failIfSuccess",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "fail_if_success"}, {"text": " "}, {"text": "t"}]]},
        {"text": " fails if the tactic "},
        {"element": ["code", true, [], [{"text": "t"}]]},
        {"text": " succeeds."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "subst_vars",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.substVars",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Applies "},
        {"element": ["code", true, [], [{"text": "subst"}]]},
        {"text": " to all hypotheses of the form "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "t"}]]},
        {"text": " or "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "t"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "x"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "rfl'",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticRfl'",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "rfl'"}]]},
        {"text": " is similar to "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#rfl"]],
             [{"text": "rfl"}]]}]]},
        {"text":
         ", but disables smart unfolding and unfolds all kinds of definitions,"},
        {"raw": "\n"},
        {"text":
         "theorems included (relevant for declarations defined by well-founded recursion)."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "change",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.change",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "change"}, {"text": " "}, {"text": "tgt'"}]]},
           {"text": " will change the goal from "},
           {"element": ["code", true, [], [{"text": "tgt"}]]},
           {"text": " to "},
           {"element": ["code", true, [], [{"text": "tgt'"}]]},
           {"text": ","},
           {"raw": "\n"},
           {"text": "assuming these are definitionally equal."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "change"},
              {"text": " "},
              {"text": "t'"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "h"}]]},
           {"text": " will change hypothesis "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "t"}]]},
           {"text": " to have type "},
           {"element": ["code", true, [], [{"text": "t'"}]]},
           {"text": ", assuming"},
           {"raw": "\n"},
           {"text": "assuming "},
           {"element": ["code", true, [], [{"text": "t"}]]},
           {"text": " and "},
           {"element": ["code", true, [], [{"text": "t'"}]]},
           {"text": " are definitionally equal."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "change"},
              {"text": " "},
              {"text": "a"},
              {"text": " "},
              {"text": "with"},
              {"text": " "},
              {"text": "b"}]]},
           {"text": " will change occurrences of "},
           {"element": ["code", true, [], [{"text": "a"}]]},
           {"text": " to "},
           {"element": ["code", true, [], [{"text": "b"}]]},
           {"text": " in the goal,"},
           {"raw": "\n"},
           {"text": "assuming "},
           {"element": ["code", true, [], [{"text": "a"}]]},
           {"text": " and "},
           {"element": ["code", true, [], [{"text": "b"}]]},
           {"text": " are definitionally equal."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "change"},
              {"text": " "},
              {"text": "a"},
              {"text": " "},
              {"text": "with"},
              {"text": " "},
              {"text": "b"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "h"}]]},
           {"text": " similarly changes "},
           {"element": ["code", true, [], [{"text": "a"}]]},
           {"text": " to "},
           {"element": ["code", true, [], [{"text": "b"}]]},
           {"text": " in the type of hypothesis "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": "."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mstart",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mstartMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Start the stateful proof mode of "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "This will transform a stateful goal of the form "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "H"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "T"}]]},
        {"text": " into "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⊢ₛ"},
           {"text": " "},
           {"text": "H"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "T"}]]},
        {"raw": "\n"},
        {"text": "upon which "},
        {"element": ["code", true, [], [{"text": "mintro"}]]},
        {"text": " can be used to re-introduce "},
        {"element": ["code", true, [], [{"text": "H"}]]},
        {"text": " and give it a name."},
        {"raw": "\n"},
        {"text": "It is often more convenient to use "},
        {"element": ["code", true, [], [{"text": "mintro"}]]},
        {"text": " directly, which will"},
        {"raw": "\n"},
        {"text": "try "},
        {"element": ["code", true, [], [{"text": "mstart"}]]},
        {"text": " automatically if necessary."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mexists",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mexistsMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mexists"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "exists"}]]},
        {"text": ", but operating on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(ψ"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "ψ"},
           {"text": " "},
           {"text": "42"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "∃"},
           {"text": " "},
           {"text": "x,"},
           {"text": " "},
           {"text": "ψ"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "H"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexists"},
           {"text": " "},
           {"text": "42"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "simpa?",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticSimpa?_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "This is a \"finishing\" tactic modification of "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": ". It has two forms."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simpa"},
              {"text": " "},
              {"text": "[rules,"},
              {"text": " "},
              {"text": "⋯]"},
              {"text": " "},
              {"text": "using"},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " will simplify the goal and the type of"},
           {"raw": "\n"},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " using "},
           {"element": ["code", true, [], [{"text": "rules"}]]},
           {"text": ", then try to close the goal using "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": "."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Simplifying the type of "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text": " makes it more likely to match the goal"},
        {"raw": "\n"},
        {"text":
         "(which has also been simplified). This construction also tends to be"},
        {"raw": "\n"},
        {"text": "more robust under changes to the simp lemma set."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simpa"},
              {"text": " "},
              {"text": "[rules,"},
              {"text": " "},
              {"text": "⋯]"}]]},
           {"text": " will simplify the goal and the type of a"},
           {"raw": "\n"},
           {"text": "hypothesis "},
           {"element": ["code", true, [], [{"text": "this"}]]},
           {"text":
            " if present in the context, then try to close the goal using"},
           {"raw": "\n"},
           {"text": "the "},
           {"element": ["code", true, [], [{"text": "assumption"}]]},
           {"text": " tactic."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "injections",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.injections",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "injections"}]]},
        {"text": " applies "},
        {"element": ["code", true, [], [{"text": "injection"}]]},
        {"text": " to all hypotheses recursively"},
        {"raw": "\n"},
        {"text": "(since "},
        {"element": ["code", true, [], [{"text": "injection"}]]},
        {"text": " can produce new hypotheses). Useful for destructing nested"},
        {"raw": "\n"},
        {"text": "constructor equalities like "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "(a::b::c)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "(d::e::f)"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "extract_lets",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.extractLets",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Extracts "},
        {"element": ["code", true, [], [{"text": "let"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text": " expressions from within the target or a local hypothesis,"},
        {"raw": "\n"},
        {"text": "introducing new local definitions."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "extract_lets"}]]},
           {"text": " extracts all the lets from the target."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "extract_lets"},
              {"text": " "},
              {"text": "x"},
              {"text": " "},
              {"text": "y"},
              {"text": " "},
              {"text": "z"}]]},
           {"text": " extracts all the lets from the target and uses "},
           {"element": ["code", true, [], [{"text": "x"}]]},
           {"text": ", "},
           {"element": ["code", true, [], [{"text": "y"}]]},
           {"text": ", and "},
           {"element": ["code", true, [], [{"text": "z"}]]},
           {"text": " for the first names."},
           {"raw": "\n"},
           {"text": "Using "},
           {"element": ["code", true, [], [{"text": "_"}]]},
           {"text": " for a name leaves it unnamed."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "extract_lets"},
              {"text": " "},
              {"text": "x"},
              {"text": " "},
              {"text": "y"},
              {"text": " "},
              {"text": "z"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "h"}]]},
           {"text": " operates on the local hypothesis "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": " instead of the target."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "For example, given a local hypotheses if the form "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "let"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "v;"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "x"}]]},
        {"text": ", then "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "extract_lets"},
           {"text": " "},
           {"text": "z"},
           {"text": " "},
           {"text": "at"},
           {"text": " "},
           {"text": "h"}]]},
        {"raw": "\n"},
        {"text": "introduces a new local definition "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "z"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "v"}]]},
        {"text": " and changes "},
        {"element": ["code", true, [], [{"text": "h"}]]},
        {"text": " to be "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "z"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mpure",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mpureMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mpure"}]]},
        {"text":
         " moves a pure hypothesis from the stateful context into the pure context."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": "(ψ"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "φ"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "Q):"},
           {"text": " "},
           {"text": "⌜φ⌝"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "Hφ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mpure"},
           {"text": " "},
           {"text": "Hφ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "(ψ"},
           {"text": " "},
           {"text": "Hφ)"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mexfalso",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mexfalsoMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mexfalso"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "exfalso"}]]},
        {"text": ", but operating on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "⌜False⌝"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HP"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexfalso"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HP"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "with_reducible",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.withReducible",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "with_reducible"}, {"text": " "}, {"text": "tacs"}]]},
        {"text": " executes "},
        {"element": ["code", true, [], [{"text": "tacs"}]]},
        {"text": " using the reducible transparency setting."},
        {"raw": "\n"},
        {"text": "In this setting only definitions tagged as "},
        {"element": ["code", true, [], [{"text": "[reducible]"}]]},
        {"text": " are unfolded."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "simp?",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.simpTrace",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "simp?"}]]},
        {"text": " takes the same arguments as "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": ", but reports an equivalent call to "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "simp"}, {"text": " "}, {"text": "only"}]]},
        {"raw": "\n"},
        {"text":
         "that would be sufficient to close the goal. This is useful for reducing the size of the simp"},
        {"raw": "\n"},
        {"text": "set in a local invocation to speed up processing."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "example"},
           {"text": " "},
           {"text": "(x"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "(if"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#True"]],
             [{"text": "True"}]]},
           {"text": " "},
           {"text": "then"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": "else"},
           {"text": " "},
           {"text": "3)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "simp?"},
           {"text": " "},
           {"text": "--"},
           {"text": " "},
           {"text": "prints"},
           {"text": " "},
           {"text": "\"Try"},
           {"text": " "},
           {"text": "this:"},
           {"text": " "},
           {"text": "simp"},
           {"text": " "},
           {"text": "only"},
           {"text": " "},
           {"text": "[ite_true]\""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "This command can also be used in "},
        {"element": ["code", true, [], [{"text": "simp_all"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "dsimp"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "simp_all",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.simpAll",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "simp_all"}]]},
        {"text": " is a stronger version of "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "simp"},
           {"text": " "},
           {"text": "[*]"},
           {"text": " "},
           {"text": "at"},
           {"text": " "},
           {"text": "*"}]]},
        {"text": " where the hypotheses and target"},
        {"raw": "\n"},
        {"text":
         "are simplified multiple times until no simplification is applicable."},
        {"raw": "\n"},
        {"text":
         "Only non-dependent propositional hypotheses are considered."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "simpa?!",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticSimpa?!_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "This is a \"finishing\" tactic modification of "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": ". It has two forms."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simpa"},
              {"text": " "},
              {"text": "[rules,"},
              {"text": " "},
              {"text": "⋯]"},
              {"text": " "},
              {"text": "using"},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " will simplify the goal and the type of"},
           {"raw": "\n"},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " using "},
           {"element": ["code", true, [], [{"text": "rules"}]]},
           {"text": ", then try to close the goal using "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": "."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Simplifying the type of "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text": " makes it more likely to match the goal"},
        {"raw": "\n"},
        {"text":
         "(which has also been simplified). This construction also tends to be"},
        {"raw": "\n"},
        {"text": "more robust under changes to the simp lemma set."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simpa"},
              {"text": " "},
              {"text": "[rules,"},
              {"text": " "},
              {"text": "⋯]"}]]},
           {"text": " will simplify the goal and the type of a"},
           {"raw": "\n"},
           {"text": "hypothesis "},
           {"element": ["code", true, [], [{"text": "this"}]]},
           {"text":
            " if present in the context, then try to close the goal using"},
           {"raw": "\n"},
           {"text": "the "},
           {"element": ["code", true, [], [{"text": "assumption"}]]},
           {"text": " tactic."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "cases",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.cases",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Assuming "},
        {"element": ["code", true, [], [{"text": "x"}]]},
        {"text": " is a variable in the local context with an inductive type,"},
        {"raw": "\n"},
        {"element":
         ["code", true, [], [{"text": "cases"}, {"text": " "}, {"text": "x"}]]},
        {"text":
         " splits the main goal, producing one goal for each constructor of the"},
        {"raw": "\n"},
        {"text":
         "inductive type, in which the target is replaced by a general instance of that constructor."},
        {"raw": "\n"},
        {"text": "If the type of an element in the local context depends on "},
        {"element": ["code", true, [], [{"text": "x"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"text": "that element is reverted and reintroduced afterward,"},
        {"raw": "\n"},
        {"text": "so that the case split affects that hypothesis as well."},
        {"raw": "\n"},
        {"element": ["code", true, [], [{"text": "cases"}]]},
        {"text":
         " detects unreachable cases and closes them automatically."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "For example, given "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "n"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]}]]},
        {"text": " and a goal with a hypothesis "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "n"}]]},
        {"text": " and target "},
        {"element":
         ["code", true, [], [{"text": "Q"}, {"text": " "}, {"text": "n"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"element":
         ["code", true, [], [{"text": "cases"}, {"text": " "}, {"text": "n"}]]},
        {"text": " produces one goal with hypothesis "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "0"}]]},
        {"text": " and target "},
        {"element":
         ["code", true, [], [{"text": "Q"}, {"text": " "}, {"text": "0"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"text": "and one goal with hypothesis "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "(Nat.succ"},
           {"text": " "},
           {"text": "a)"}]]},
        {"text": " and target "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "Q"},
           {"text": " "},
           {"text": "(Nat.succ"},
           {"text": " "},
           {"text": "a)"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "Here the name "},
        {"element": ["code", true, [], [{"text": "a"}]]},
        {"text": " is chosen automatically and is not accessible."},
        {"raw": "\n"},
        {"text": "You can use "},
        {"element": ["code", true, [], [{"text": "with"}]]},
        {"text": " to provide the variables names for each constructor."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "cases"}, {"text": " "}, {"text": "e"}]]},
           {"text": ", where "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " is an expression instead of a variable, generalizes "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " in the goal,"},
           {"raw": "\n"},
           {"text": "and then cases on the resulting variable."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Given "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "as"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#List"]],
                [{"text": "List"}]]},
              {"text": " "},
              {"text": "α"}]]},
           {"text": ", "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "cases"},
              {"text": " "},
              {"text": "as"},
              {"text": " "},
              {"text": "with"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "nil"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "tac₁"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "cons"},
              {"text": " "},
              {"text": "a"},
              {"text": " "},
              {"text": "as'"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "tac₂"}]]},
           {"text": ","},
           {"raw": "\n"},
           {"text": "uses tactic "},
           {"element": ["code", true, [], [{"text": "tac₁"}]]},
           {"text": " for the "},
           {"element": ["code", true, [], [{"text": "nil"}]]},
           {"text": " case, and "},
           {"element": ["code", true, [], [{"text": "tac₂"}]]},
           {"text": " for the "},
           {"element": ["code", true, [], [{"text": "cons"}]]},
           {"text": " case,"},
           {"raw": "\n"},
           {"text": "and "},
           {"element": ["code", true, [], [{"text": "a"}]]},
           {"text": " and "},
           {"element": ["code", true, [], [{"text": "as'"}]]},
           {"text": " are used as names for the new variables introduced."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "cases"},
              {"text": " "},
              {"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "e"}]]},
           {"text": ", where "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " is a variable or an expression,"},
           {"raw": "\n"},
           {"text": "performs cases on "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " as above, but also adds a hypothesis "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "..."}]]},
           {"text": " to each goal,"},
           {"raw": "\n"},
           {"text": "where "},
           {"element": ["code", true, [], [{"text": "..."}]]},
           {"text":
            " is the constructor instance for that particular case."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "simpa",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.simpa",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "This is a \"finishing\" tactic modification of "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": ". It has two forms."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simpa"},
              {"text": " "},
              {"text": "[rules,"},
              {"text": " "},
              {"text": "⋯]"},
              {"text": " "},
              {"text": "using"},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " will simplify the goal and the type of"},
           {"raw": "\n"},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " using "},
           {"element": ["code", true, [], [{"text": "rules"}]]},
           {"text": ", then try to close the goal using "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": "."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Simplifying the type of "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text": " makes it more likely to match the goal"},
        {"raw": "\n"},
        {"text":
         "(which has also been simplified). This construction also tends to be"},
        {"raw": "\n"},
        {"text": "more robust under changes to the simp lemma set."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simpa"},
              {"text": " "},
              {"text": "[rules,"},
              {"text": " "},
              {"text": "⋯]"}]]},
           {"text": " will simplify the goal and the type of a"},
           {"raw": "\n"},
           {"text": "hypothesis "},
           {"element": ["code", true, [], [{"text": "this"}]]},
           {"text":
            " if present in the context, then try to close the goal using"},
           {"raw": "\n"},
           {"text": "the "},
           {"element": ["code", true, [], [{"text": "assumption"}]]},
           {"text": " tactic."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "expose_names",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.exposeNames",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "expose_names"}]]},
        {"text":
         " renames all inaccessible variables with accessible names, making them available"},
        {"raw": "\n"},
        {"text":
         "for reference in generated tactics. However, this renaming introduces machine-generated names"},
        {"raw": "\n"},
        {"text": "that are not fully under user control. "},
        {"element": ["code", true, [], [{"text": "expose_names"}]]},
        {"text": " is primarily intended as a preamble for"},
        {"raw": "\n"},
        {"text":
         "auto-generated end-game tactic scripts. It is also useful as an alternative to"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "set_option"},
           {"text": " "},
           {"text": "tactic.hygienic"},
           {"text": " "},
           {"text": "false"}]]},
        {"text": ". If explicit control over renaming is needed in the"},
        {"raw": "\n"},
        {"text":
         "middle of a tactic script, consider using structured tactic scripts with"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "match"},
           {"text": " "},
           {"text": ".."},
           {"text": " "},
           {"text": "with"}]]},
        {"text": ", "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "induction"},
           {"text": " "},
           {"text": ".."},
           {"text": " "},
           {"text": "with"}]]},
        {"text": ", or "},
        {"element": ["code", true, [], [{"text": "intro"}]]},
        {"text": " with explicit user-defined names,"},
        {"raw": "\n"},
        {"text": "as well as tactics such as "},
        {"element": ["code", true, [], [{"text": "next"}]]},
        {"text": ", "},
        {"element": ["code", true, [], [{"text": "case"}]]},
        {"text": ", and "},
        {"element": ["code", true, [], [{"text": "rename_i"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "decide_cbv",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.decide_cbv",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "decide_cbv"}]]},
        {"text": " is a finishing tactic that closes goals of the form "},
        {"element": ["code", true, [], [{"text": "p"}]]},
        {"text": ", where "},
        {"element": ["code", true, [], [{"text": "p"}]]},
        {"raw": "\n"},
        {"text": "is a "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Decidable"]],
             [{"text": "Decidable"}]]}]]},
        {"text": " proposition. It proceeds in two steps:"}]]},
     {"element":
      ["ol",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"text": "Apply "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#of_decide_eq_true"]],
                [{"text": "of_decide_eq_true"}]]}]]},
           {"text": " to transform the goal into "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "decide"},
              {"text": " "},
              {"text": "p"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "true"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Reduce "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "decide"}, {"text": " "}, {"text": "p"}]]},
           {"text": " via call-by-value normalization. If the result is"},
           {"raw": "\n"},
           {"text": "definitionally equal to "},
           {"element": ["code", true, [], [{"text": "true"}]]},
           {"text": ", the goal is closed."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "decide_cbv"}]]},
        {"text": " fails with an error if "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "decide"}, {"text": " "}, {"text": "p"}]]},
        {"text": " does not reduce to "},
        {"element": ["code", true, [], [{"text": "true"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "Unlike "},
        {"element": ["code", true, [], [{"text": "cbv"}]]},
        {"text": ", "},
        {"element": ["code", true, [], [{"text": "decide_cbv"}]]},
        {"text": " is a terminal tactic: it either closes the goal or"},
        {"raw": "\n"},
        {"text": "fails."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "The proofs produced by "},
        {"element": ["code", true, [], [{"text": "decide_cbv"}]]},
        {"text": " only use the three standard axioms."},
        {"raw": "\n"},
        {"text":
         "In particular, they do not require trust in the correctness of the code"},
        {"raw": "\n"},
        {"text": "generator."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "This tactic is experimental and its behavior is likely to change in upcoming"},
        {"raw": "\n"},
        {"text": "releases of Lean."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "rewrite",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.rewriteSeq",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "rewrite"}, {"text": " "}, {"text": "[e]"}]]},
        {"text": " applies identity "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text": " as a rewrite rule to the target of the main goal."},
        {"raw": "\n"},
        {"text": "If "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text": " is preceded by left arrow ("},
        {"element": ["code", true, [], [{"text": "←"}]]},
        {"text": " or "},
        {"element": ["code", true, [], [{"text": "<-"}]]},
        {"text": "), the rewrite is applied in the reverse direction."},
        {"raw": "\n"},
        {"text": "If "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text":
         " is a defined constant, then the equational theorems associated with "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text": " are used."},
        {"raw": "\n"},
        {"text": "This provides a convenient way to unfold "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text": "."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "rewrite"},
              {"text": " "},
              {"text": "[e₁,"},
              {"text": " "},
              {"text": "...,"},
              {"text": " "},
              {"text": "eₙ]"}]]},
           {"text": " applies the given rules sequentially."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "rewrite"},
              {"text": " "},
              {"text": "[e]"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "l"}]]},
           {"text": " rewrites "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " at location(s) "},
           {"element": ["code", true, [], [{"text": "l"}]]},
           {"text": ", where "},
           {"element": ["code", true, [], [{"text": "l"}]]},
           {"text": " is either "},
           {"element": ["code", true, [], [{"text": "*"}]]},
           {"text": " or a"},
           {"raw": "\n"},
           {"text":
            "list of hypotheses in the local context. In the latter case, a turnstile "},
           {"element": ["code", true, [], [{"text": "⊢"}]]},
           {"text": " or "},
           {"element": ["code", true, [], [{"text": "|-"}]]},
           {"raw": "\n"},
           {"text":
            "can also be used, to signify the target of the goal."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Using "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "rw"},
           {"text": " "},
           {"text": "(occs"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": ".pos"},
           {"text": " "},
           {"text": "L)"},
           {"text": " "},
           {"text": "[e]"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"text": "where "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "L"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#List"]],
             [{"text": "List"}]]},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]}]]},
        {"text": ", you can control which \"occurrences\" are rewritten."},
        {"raw": "\n"},
        {"text":
         "(This option applies to each rule, so usually this will only be used with a single rule.)"},
        {"raw": "\n"},
        {"text": "Occurrences count from "},
        {"element": ["code", true, [], [{"text": "1"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "At each allowed occurrence, arguments of the rewrite rule "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text": " may be instantiated,"},
        {"raw": "\n"},
        {"text": "restricting which later rewrites can be found."},
        {"raw": "\n"},
        {"text": "(Disallowed occurrences do not result in instantiation.)"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "(occs"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": ".neg"},
           {"text": " "},
           {"text": "L)"}]]},
        {"text": " allows skipping specified occurrences."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "case'",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.case'",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "case'"}]]},
        {"text": " is similar to the "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "case"},
           {"text": " "},
           {"text": "tag"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "tac"}]]},
        {"text": " tactic, but does not ensure the goal"},
        {"raw": "\n"},
        {"text": "has been solved after applying "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": ", nor admits the goal if "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " failed."},
        {"raw": "\n"},
        {"text": "Recall that "},
        {"element": ["code", true, [], [{"text": "case"}]]},
        {"text": " closes the goal using "},
        {"element": ["code", true, [], [{"text": "sorry"}]]},
        {"text": " when "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " fails, and"},
        {"raw": "\n"},
        {"text": "the tactic execution is not interrupted."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "apply_assumption",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.applyAssumption",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "apply_assumption"}]]},
        {"text": " looks for an assumption of the form "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "..."},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "∀"},
           {"text": " "},
           {"text": "_,"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "head"}]]},
        {"raw": "\n"},
        {"text": "where "},
        {"element": ["code", true, [], [{"text": "head"}]]},
        {"text": " matches the current goal."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "You can specify additional rules to apply using "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "apply_assumption"}, {"text": " "}, {"text": "[...]"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "By default "},
        {"element": ["code", true, [], [{"text": "apply_assumption"}]]},
        {"text": " will also try "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#rfl"]],
             [{"text": "rfl"}]]}]]},
        {"text": ", "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Core.html#trivial"]],
             [{"text": "trivial"}]]}]]},
        {"text": ", "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#congrFun"]],
             [{"text": "congrFun"}]]}]]},
        {"text": ", and "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#congrArg"]],
             [{"text": "congrArg"}]]}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text":
         "If you don't want these, or don't want to use all hypotheses, use "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "apply_assumption"},
           {"text": " "},
           {"text": "only"},
           {"text": " "},
           {"text": "[...]"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "You can use "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "apply_assumption"}, {"text": " "}, {"text": "[-h]"}]]},
        {"text": " to omit a local hypothesis."},
        {"raw": "\n"},
        {"text": "You can use "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "apply_assumption"},
           {"text": " "},
           {"text": "using"},
           {"text": " "},
           {"text": "[a₁,"},
           {"text": " "},
           {"text": "...]"}]]},
        {"text": " to use all lemmas which have been labelled"},
        {"raw": "\n"},
        {"text": "with the attributes "},
        {"element": ["code", true, [], [{"text": "aᵢ"}]]},
        {"text": " (these attributes must be created using "},
        {"element": ["code", true, [], [{"text": "register_label_attr"}]]},
        {"text": ")."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "apply_assumption"}]]},
        {"text": " will use consequences of local hypotheses obtained via "},
        {"element": ["code", true, [], [{"text": "symm"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "If "},
        {"element": ["code", true, [], [{"text": "apply_assumption"}]]},
        {"text": " fails, it will call "},
        {"element": ["code", true, [], [{"text": "exfalso"}]]},
        {"text": " and try again."},
        {"raw": "\n"},
        {"text": "Thus if there is an assumption of the form "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "P"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "¬"},
           {"text": " "},
           {"text": "Q"}]]},
        {"text": ", the new tactic state"},
        {"raw": "\n"},
        {"text": "will have two goals, "},
        {"element": ["code", true, [], [{"text": "P"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "Q"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "You can pass a further configuration via the syntax "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "apply_rules"},
           {"text": " "},
           {"text": "(config"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "{...})"},
           {"text": " "},
           {"text": "lemmas"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "The options supported are the same as for "},
        {"element": ["code", true, [], [{"text": "solve_by_elim"}]]},
        {"text": " (and include all the options for "},
        {"element": ["code", true, [], [{"text": "apply"}]]},
        {"text": ")."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "with_unfolding_all",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.withUnfoldingAll",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "with_unfolding_all"}, {"text": " "}, {"text": "tacs"}]]},
        {"text": " executes "},
        {"element": ["code", true, [], [{"text": "tacs"}]]},
        {"text": " using the "},
        {"element": ["code", true, [], [{"text": ".all"}]]},
        {"text": " transparency setting."},
        {"raw": "\n"},
        {"text":
         "In this setting all definitions that are not opaque are unfolded."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mvcgen",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mvcgenMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mvcgen"}]]},
        {"text": " will break down a Hoare triple proof goal like "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⦃P⦄"},
           {"text": " "},
           {"text": "prog"},
           {"text": " "},
           {"text": "⦃Q⦄"}]]},
        {"text": " into verification conditions,"},
        {"raw": "\n"},
        {"text": "provided that all functions used in "},
        {"element": ["code", true, [], [{"text": "prog"}]]},
        {"text": " have specifications registered with "},
        {"element": ["code", true, [], [{"text": "@[spec]"}]]},
        {"text": "."}]]},
     {"element":
      ["h3",
       true,
       [["id", "Verification-Conditions-and-specifications"],
        ["class", "markdown-heading"]],
       [{"text": "Verification Conditions and specifications"},
        {"text": " "},
        {"element":
         ["a",
          true,
          [["class", "hover-link"],
           ["href", "#Verification-Conditions-and-specifications"]],
          [{"text": "#"}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "A verification condition is an entailment in the stateful logic of "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"raw": "\n"},
        {"text": "in which the original program "},
        {"element": ["code", true, [], [{"text": "prog"}]]},
        {"text": " no longer occurs."},
        {"raw": "\n"},
        {"text": "Verification conditions are introduced by the "},
        {"element": ["code", true, [], [{"text": "mspec"}]]},
        {"text": " tactic; see the "},
        {"element": ["code", true, [], [{"text": "mspec"}]]},
        {"text": " tactic for what they"},
        {"raw": "\n"},
        {"text": "look like."},
        {"raw": "\n"},
        {"text": "When there's no applicable "},
        {"element": ["code", true, [], [{"text": "mspec"}]]},
        {"text": " spec, "},
        {"element": ["code", true, [], [{"text": "mvcgen"}]]},
        {"text": " will try and rewrite an application"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "prog"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "c"}]]},
        {"text": " with the simp set registered via "},
        {"element": ["code", true, [], [{"text": "@[spec]"}]]},
        {"text": "."}]]},
     {"element":
      ["h3",
       true,
       [["id", "Features"], ["class", "markdown-heading"]],
       [{"text": "Features"},
        {"text": " "},
        {"element":
         ["a",
          true,
          [["class", "hover-link"], ["href", "#Features"]],
          [{"text": "#"}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "When used like "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "mvcgen"},
           {"text": " "},
           {"text": "+noLetElim"},
           {"text": " "},
           {"text": "[foo_spec,"},
           {"text": " "},
           {"text": "bar_def,"},
           {"text": " "},
           {"text": "instBEqFloat]"}]]},
        {"text": ", "},
        {"element": ["code", true, [], [{"text": "mvcgen"}]]},
        {"text": " will additionally"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"text": "add a Hoare triple specification "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "foo_spec"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "..."},
              {"text": " "},
              {"text": "→"},
              {"text": " "},
              {"text": "⦃P⦄"},
              {"text": " "},
              {"text": "foo"},
              {"text": " "},
              {"text": "..."},
              {"text": " "},
              {"text": "⦃Q⦄"}]]},
           {"text": " to "},
           {"element": ["code", true, [], [{"text": "spec"}]]},
           {"text": " set for a"},
           {"raw": "\n"},
           {"text": "function "},
           {"element": ["code", true, [], [{"text": "foo"}]]},
           {"text": " occurring in "},
           {"element": ["code", true, [], [{"text": "prog"}]]},
           {"text": ","}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "unfold a definition "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "def"},
              {"text": " "},
              {"text": "bar_def"},
              {"text": " "},
              {"text": "..."},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "..."}]]},
           {"text": " in "},
           {"element": ["code", true, [], [{"text": "prog"}]]},
           {"text": ","}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "unfold any method of the "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Data/Float.html#instBEqFloat"]],
                [{"text": "instBEqFloat"}]]},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#BEq"]],
                [{"text": "BEq"}]]},
              {"text": " "},
              {"element":
               ["a",
                true,
                [["href", "./Init/Data/Float.html#Float"]],
                [{"text": "Float"}]]}]]},
           {"text": " instance in "},
           {"element": ["code", true, [], [{"text": "prog"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "it will no longer substitute away "},
           {"element": ["code", true, [], [{"text": "let"}]]},
           {"text": "-expressions that occur at most once in "},
           {"element": ["code", true, [], [{"text": "P"}]]},
           {"text": ", "},
           {"element": ["code", true, [], [{"text": "Q"}]]},
           {"text": " or "},
           {"element": ["code", true, [], [{"text": "prog"}]]},
           {"text": "."}]]}]]},
     {"element":
      ["h3",
       true,
       [["id", "Config-options"], ["class", "markdown-heading"]],
       [{"text": "Config options"},
        {"text": " "},
        {"element":
         ["a",
          true,
          [["class", "hover-link"], ["href", "#Config-options"]],
          [{"text": "#"}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "+noLetElim"}]]},
        {"text": " is just one config option of many. Check out "},
        {"element":
         ["code", true, [], [{"text": "Lean.Elab.Tactic.Do.VCGen.Config"}]]},
        {"text": " for all"},
        {"raw": "\n"},
        {"text": "options. Of particular note is "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "stepLimit"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "some"},
           {"text": " "},
           {"text": "42"}]]},
        {"text": ", which is useful for bisecting bugs in"},
        {"raw": "\n"},
        {"element": ["code", true, [], [{"text": "mvcgen"}]]},
        {"text": " and tracing its execution."}]]},
     {"element":
      ["h3",
       true,
       [["id", "Extended-syntax"], ["class", "markdown-heading"]],
       [{"text": "Extended syntax"},
        {"text": " "},
        {"element":
         ["a",
          true,
          [["class", "hover-link"], ["href", "#Extended-syntax"]],
          [{"text": "#"}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Often, "},
        {"element": ["code", true, [], [{"text": "mvcgen"}]]},
        {"text": " will be used like this:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "mvcgen"},
           {"text": " "},
           {"text": "[...]"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "case"},
           {"text": " "},
           {"text": "inv1"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "exact"},
           {"text": " "},
           {"text": "I1"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "case"},
           {"text": " "},
           {"text": "inv2"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "exact"},
           {"text": " "},
           {"text": "I2"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "all_goals"},
           {"text": " "},
           {"text": "(mleave;"},
           {"text": " "},
           {"text": "try"},
           {"text": " "},
           {"text": "grind)"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p", true, [], [{"text": "There is special syntax for this:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "mvcgen"},
           {"text": " "},
           {"text": "[...]"},
           {"text": " "},
           {"text": "invariants"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "·"},
           {"text": " "},
           {"text": "I1"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "·"},
           {"text": " "},
           {"text": "I2"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "with"},
           {"text": " "},
           {"text": "grind"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "When "},
        {"element": ["code", true, [], [{"text": "I1"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "I2"}]]},
        {"text": " need to refer to inaccessibles ("},
        {"element": ["code", true, [], [{"text": "mvcgen"}]]},
        {"text": " will introduce a lot of them for program"},
        {"raw": "\n"},
        {"text": "variables), you can use case label syntax:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "mvcgen"},
           {"text": " "},
           {"text": "[...]"},
           {"text": " "},
           {"text": "invariants"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "|"},
           {"text": " "},
           {"text": "inv1"},
           {"text": " "},
           {"text": "_"},
           {"text": " "},
           {"text": "acc"},
           {"text": " "},
           {"text": "_"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "I1"},
           {"text": " "},
           {"text": "acc"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "|"},
           {"text": " "},
           {"text": "_"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "I2"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "with"},
           {"text": " "},
           {"text": "grind"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "This is more convenient than the equivalent "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "·"},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "rename_i"},
           {"text": " "},
           {"text": "_"},
           {"text": " "},
           {"text": "acc"},
           {"text": " "},
           {"text": "_;"},
           {"text": " "},
           {"text": "exact"},
           {"text": " "},
           {"text": "I1"},
           {"text": " "},
           {"text": "acc"}]]},
        {"text": "."}]]},
     {"element":
      ["h3",
       true,
       [["id", "Invariant-suggestions"], ["class", "markdown-heading"]],
       [{"text": "Invariant suggestions"},
        {"text": " "},
        {"element":
         ["a",
          true,
          [["class", "hover-link"], ["href", "#Invariant-suggestions"]],
          [{"text": "#"}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mvcgen"}]]},
        {"text": " will suggest invariants for you if you use the "},
        {"element": ["code", true, [], [{"text": "invariants?"}]]},
        {"text": " keyword."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "mvcgen"},
           {"text": " "},
           {"text": "[...]"},
           {"text": " "},
           {"text": "invariants?"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "This is useful if you do not recall the exact syntax to construct invariants."},
        {"raw": "\n"},
        {"text":
         "Furthermore, it will suggest a concrete invariant encoding \"this holds at the start of the loop and"},
        {"raw": "\n"},
        {"text":
         "this must hold at the end of the loop\" by looking at the corresponding VCs."},
        {"raw": "\n"},
        {"text":
         "Although the suggested invariant is a good starting point, it is too strong and requires users to"},
        {"raw": "\n"},
        {"text":
         "interpolate it such that the inductive step can be proved. Example:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "def"},
           {"text": " "},
           {"text": "mySum"},
           {"text": " "},
           {"text": "(l"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#List"]],
             [{"text": "List"}]]},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Control/Id.html#Id.run"]],
             [{"text": "Id.run"}]]},
           {"text": " "},
           {"text": "do"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "let"},
           {"text": " "},
           {"text": "mut"},
           {"text": " "},
           {"text": "acc"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "0"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "for"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "in"},
           {"text": " "},
           {"text": "l"},
           {"text": " "},
           {"text": "do"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "acc"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "acc"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "x"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "return"},
           {"text": " "},
           {"text": "acc"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "/--"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "info:"},
           {"text": " "},
           {"text": "Try"},
           {"text": " "},
           {"text": "this:"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "invariants"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "·"},
           {"text": " "},
           {"text": "⇓⟨xs,"},
           {"text": " "},
           {"text": "letMuts⟩"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "⌜xs.prefix"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "[]"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "letMuts"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "0"},
           {"text": " "},
           {"text": "∨"},
           {"text": " "},
           {"text": "xs.suffix"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "[]"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "letMuts"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "l.sum⌝"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "-/"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "#guard_msgs"},
           {"text": " "},
           {"text": "(info)"},
           {"text": " "},
           {"text": "in"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "theorem"},
           {"text": " "},
           {"text": "mySum_suggest_invariant"},
           {"text": " "},
           {"text": "(l"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#List"]],
             [{"text": "List"}]]},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "mySum"},
           {"text": " "},
           {"text": "l"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "l.sum"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "generalize"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "mySum"},
           {"text": " "},
           {"text": "l"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "r"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "apply"},
           {"text": " "},
           {"text": "Id.of_wp_run_eq"},
           {"text": " "},
           {"text": "h"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mvcgen"},
           {"text": " "},
           {"text": "invariants?"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "all_goals"},
           {"text": " "},
           {"text": "admit"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "eq_refl",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.eqRefl",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "eq_refl"}]]},
        {"text": " is equivalent to "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "exact"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#rfl"]],
             [{"text": "rfl"}]]}]]},
        {"text": ", but has a few optimizations."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "focus",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.focus",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "focus"}, {"text": " "}, {"text": "tac"}]]},
        {"text":
         " focuses on the main goal, suppressing all other goals, and runs "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " on it."},
        {"raw": "\n"},
        {"text": "Usually "},
        {"element":
         ["code", true, [], [{"text": "·"}, {"text": " "}, {"text": "tac"}]]},
        {"text": ", which enforces that the goal is closed by "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": ", should be preferred."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "left",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.left",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Applies the first constructor when"},
        {"raw": "\n"},
        {"text":
         "the goal is an inductive type with exactly two constructors, or fails otherwise."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#True"]],
             [{"text": "True"}]]},
           {"text": " "},
           {"text": "∨"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#False"]],
             [{"text": "False"}]]},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "left"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"element":
            ["a",
             true,
             [["href", "./Init/Core.html#trivial"]],
             [{"text": "trivial"}]]},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mframe",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mframeMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mframe"}]]},
        {"text":
         " infers which hypotheses from the stateful context can be moved into the pure context."},
        {"raw": "\n"},
        {"text":
         "This is useful because pure hypotheses \"survive\" the next application of modus ponens"},
        {"raw": "\n"},
        {"text": "("},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred.mp"}]]},
        {"text": ") and transitivity ("},
        {"element":
         ["code", true, [], [{"text": "Std.Do.SPred.entails.trans"}]]},
        {"text": ")."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "It is used as part of the "},
        {"element": ["code", true, [], [{"text": "mspec"}]]},
        {"text": " tactic."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "⌜p⌝"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "⌜q⌝"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "⌜r⌝"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "⌜s⌝"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "⌜t⌝"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "_"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mframe"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "/-"},
           {"text": " "},
           {"text": "`h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "p"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "q"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "r"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "s"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "t`"},
           {"text": " "},
           {"text": "in"},
           {"text": " "},
           {"text": "the"},
           {"text": " "},
           {"text": "pure"},
           {"text": " "},
           {"text": "context"},
           {"text": " "},
           {"text": "-/"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mcases"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "hP"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "h"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "induction",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.induction",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Assuming "},
        {"element": ["code", true, [], [{"text": "x"}]]},
        {"text": " is a variable in the local context with an inductive type,"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "induction"}, {"text": " "}, {"text": "x"}]]},
        {"text": " applies induction on "},
        {"element": ["code", true, [], [{"text": "x"}]]},
        {"text": " to the main goal,"},
        {"raw": "\n"},
        {"text":
         "producing one goal for each constructor of the inductive type,"},
        {"raw": "\n"},
        {"text":
         "in which the target is replaced by a general instance of that constructor"},
        {"raw": "\n"},
        {"text":
         "and an inductive hypothesis is added for each recursive argument to the constructor."},
        {"raw": "\n"},
        {"text": "If the type of an element in the local context depends on "},
        {"element": ["code", true, [], [{"text": "x"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"text": "that element is reverted and reintroduced afterward,"},
        {"raw": "\n"},
        {"text":
         "so that the inductive hypothesis incorporates that hypothesis as well."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "For example, given "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "n"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]}]]},
        {"text": " and a goal with a hypothesis "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "n"}]]},
        {"text": " and target "},
        {"element":
         ["code", true, [], [{"text": "Q"}, {"text": " "}, {"text": "n"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "induction"}, {"text": " "}, {"text": "n"}]]},
        {"text": " produces one goal with hypothesis "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "0"}]]},
        {"text": " and target "},
        {"element":
         ["code", true, [], [{"text": "Q"}, {"text": " "}, {"text": "0"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"text": "and one goal with hypotheses "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "(Nat.succ"},
           {"text": " "},
           {"text": "a)"}]]},
        {"text": " and "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "ih₁"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "a"}]]},
        {"text": " and target "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "Q"},
           {"text": " "},
           {"text": "(Nat.succ"},
           {"text": " "},
           {"text": "a)"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "Here the names "},
        {"element": ["code", true, [], [{"text": "a"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "ih₁"}]]},
        {"text": " are chosen automatically and are not accessible."},
        {"raw": "\n"},
        {"text": "You can use "},
        {"element": ["code", true, [], [{"text": "with"}]]},
        {"text": " to provide the variables names for each constructor."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "induction"}, {"text": " "}, {"text": "e"}]]},
           {"text": ", where "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " is an expression instead of a variable,"},
           {"raw": "\n"},
           {"text": "generalizes "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text":
            " in the goal, and then performs induction on the resulting variable."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "induction"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "using"},
              {"text": " "},
              {"text": "r"}]]},
           {"text":
            " allows the user to specify the principle of induction that should be used."},
           {"raw": "\n"},
           {"text": "Here "},
           {"element": ["code", true, [], [{"text": "r"}]]},
           {"text": " should be a term whose result type must be of the form "},
           {"element":
            ["code", true, [], [{"text": "C"}, {"text": " "}, {"text": "t"}]]},
           {"text": ","},
           {"raw": "\n"},
           {"text": "where "},
           {"element": ["code", true, [], [{"text": "C"}]]},
           {"text": " is a bound variable and "},
           {"element": ["code", true, [], [{"text": "t"}]]},
           {"text": " is a (possibly empty) sequence of bound variables"}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "induction"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "generalizing"},
              {"text": " "},
              {"text": "z₁"},
              {"text": " "},
              {"text": "..."},
              {"text": " "},
              {"text": "zₙ"}]]},
           {"text": ", where "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "z₁"},
              {"text": " "},
              {"text": "..."},
              {"text": " "},
              {"text": "zₙ"}]]},
           {"text": " are variables in the local context,"},
           {"raw": "\n"},
           {"text": "generalizes over "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "z₁"},
              {"text": " "},
              {"text": "..."},
              {"text": " "},
              {"text": "zₙ"}]]},
           {"text":
            " before applying the induction but then introduces them in each goal."},
           {"raw": "\n"},
           {"text":
            "In other words, the net effect is that each inductive hypothesis is generalized."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Given "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "x"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#Nat"]],
                [{"text": "Nat"}]]}]]},
           {"text": ", "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "induction"},
              {"text": " "},
              {"text": "x"},
              {"text": " "},
              {"text": "with"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "zero"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "tac₁"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "succ"},
              {"text": " "},
              {"text": "x'"},
              {"text": " "},
              {"text": "ih"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "tac₂"}]]},
           {"raw": "\n"},
           {"text": "uses tactic "},
           {"element": ["code", true, [], [{"text": "tac₁"}]]},
           {"text": " for the "},
           {"element": ["code", true, [], [{"text": "zero"}]]},
           {"text": " case, and "},
           {"element": ["code", true, [], [{"text": "tac₂"}]]},
           {"text": " for the "},
           {"element": ["code", true, [], [{"text": "succ"}]]},
           {"text": " case."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "suffices",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticSuffices_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Given a main goal "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "ctx"},
           {"text": " "},
           {"text": "⊢"},
           {"text": " "},
           {"text": "t"}]]},
        {"text": ", "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "suffices"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "t'"},
           {"text": " "},
           {"text": "from"},
           {"text": " "},
           {"text": "e"}]]},
        {"text": " replaces the main goal with "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "ctx"},
           {"text": " "},
           {"text": "⊢"},
           {"text": " "},
           {"text": "t'"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text": " must have type "},
        {"element": ["code", true, [], [{"text": "t"}]]},
        {"text": " in the context "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "ctx,"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "t'"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "The variant "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "suffices"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "t'"},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "tac"}]]},
        {"text": " is a shorthand for "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "suffices"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "t'"},
           {"text": " "},
           {"text": "from"},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "tac"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "If "},
        {"element":
         ["code", true, [], [{"text": "h"}, {"text": " "}, {"text": ":"}]]},
        {"text": " is omitted, the name "},
        {"element": ["code", true, [], [{"text": "this"}]]},
        {"text": " is used."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "fun_induction",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.funInduction",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "fun_induction"}]]},
        {"text": " tactic is a convenience wrapper around the "},
        {"element": ["code", true, [], [{"text": "induction"}]]},
        {"text": " tactic to use the"},
        {"raw": "\n"},
        {"text": "functional induction principle."}]]},
     {"element": ["p", true, [], [{"text": "The tactic invocation"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "fun_induction"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "x₁"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "xₙ"},
           {"text": " "},
           {"text": "y₁"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "yₘ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "where "},
        {"element": ["code", true, [], [{"text": "f"}]]},
        {"text":
         " is a function defined by non-mutual structural or well-founded recursion, is equivalent to"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "induction"},
           {"text": " "},
           {"text": "y₁,"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "yₘ"},
           {"text": " "},
           {"text": "using"},
           {"text": " "},
           {"text": "f.induct_unfolding"},
           {"text": " "},
           {"text": "x₁"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "xₙ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "where the arguments of "},
        {"element": ["code", true, [], [{"text": "f"}]]},
        {"text": " are used as arguments to "},
        {"element": ["code", true, [], [{"text": "f.induct_unfolding"}]]},
        {"text": " or targets of the"},
        {"raw": "\n"},
        {"text": "induction, as appropriate."}]]},
     {"element": ["p", true, [], [{"text": "The form"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "fun_induction"},
           {"text": " "},
           {"text": "f"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "(with no arguments to "},
        {"element": ["code", true, [], [{"text": "f"}]]},
        {"text": ") searches the goal for a unique eligible application of "},
        {"element": ["code", true, [], [{"text": "f"}]]},
        {"text": ", and uses"},
        {"raw": "\n"},
        {"text": "these arguments. An application of "},
        {"element": ["code", true, [], [{"text": "f"}]]},
        {"text": " is eligible if it is saturated and the arguments that will"},
        {"raw": "\n"},
        {"text": "become targets are free variables."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "The forms "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "fun_induction"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "y"},
           {"text": " "},
           {"text": "generalizing"},
           {"text": " "},
           {"text": "z₁"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "zₙ"}]]},
        {"text": " and"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "fun_induction"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "y"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "case1"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "tac₁"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "case2"},
           {"text": " "},
           {"text": "x'"},
           {"text": " "},
           {"text": "ih"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "tac₂"}]]},
        {"text": " work like with "},
        {"element": ["code", true, [], [{"text": "induction."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Under "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "set_option"},
           {"text": " "},
           {"text": "tactic.fun_induction.unfolding"},
           {"text": " "},
           {"text": "true"}]]},
        {"text": " (the default), "},
        {"element": ["code", true, [], [{"text": "fun_induction"}]]},
        {"text": " uses the"},
        {"raw": "\n"},
        {"element": ["code", true, [], [{"text": "f.induct_unfolding"}]]},
        {"text":
         " induction principle, which will try to automatically unfold the call to "},
        {"element": ["code", true, [], [{"text": "f"}]]},
        {"text": " in"},
        {"raw": "\n"},
        {"text": "the goal. With "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "set_option"},
           {"text": " "},
           {"text": "tactic.fun_induction.unfolding"},
           {"text": " "},
           {"text": "false"}]]},
        {"text": ", it uses "},
        {"element": ["code", true, [], [{"text": "f.induct"}]]},
        {"text": " instead."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "rename",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.rename",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "rename"},
           {"text": " "},
           {"text": "t"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "x"}]]},
        {"text": " renames the most recent hypothesis whose type matches "},
        {"element": ["code", true, [], [{"text": "t"}]]},
        {"raw": "\n"},
        {"text": "(which may contain placeholders) to "},
        {"element": ["code", true, [], [{"text": "x"}]]},
        {"text": ", or fails if no such hypothesis could be found."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "repeat'",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.repeat'",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "repeat'"}, {"text": " "}, {"text": "tac"}]]},
        {"text": " recursively applies "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " on all of the goals so long as it succeeds."},
        {"raw": "\n"},
        {"text": "That is to say, if "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " produces multiple subgoals, then "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "repeat'"}, {"text": " "}, {"text": "tac"}]]},
        {"text": " is applied to each of them."}]]},
     {"element": ["p", true, [], [{"text": "See also:"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "repeat"}, {"text": " "}, {"text": "tac"}]]},
           {"text": " simply repeatedly applies "},
           {"element": ["code", true, [], [{"text": "tac"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "repeat1'"}, {"text": " "}, {"text": "tac"}]]},
           {"text": " is "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "repeat'"}, {"text": " "}, {"text": "tac"}]]},
           {"text": " but requires that "},
           {"element": ["code", true, [], [{"text": "tac"}]]},
           {"text": " succeed for some goal at least once."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mspecialize_pure",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mspecializePureMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mspecialize_pure"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "mspecialize"}]]},
        {"text": ", but it specializes a hypothesis from the"},
        {"raw": "\n"},
        {"element": ["em", true, [], [{"text": "pure"}]]},
        {"text":
         " context with hypotheses from either the pure or stateful context or pure terms."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(y"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": "(Ψ"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": "(hP"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "P)"},
           {"text": " "},
           {"text": "(hΨ"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "∀"},
           {"text": " "},
           {"text": "x,"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Ψ"},
           {"text": " "},
           {"text": "x)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Ψ"},
           {"text": " "},
           {"text": "(y"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "1)"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mspecialize_pure"},
           {"text": " "},
           {"text": "(hΨ"},
           {"text": " "},
           {"text": "(y"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "1))"},
           {"text": " "},
           {"text": "hP"},
           {"text": " "},
           {"text": "HQ"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "HΨ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HΨ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mhave",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mhaveMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mhave"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text": ", but operating on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Q)"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HP"},
           {"text": " "},
           {"text": "HPQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mhave"},
           {"text": " "},
           {"text": "HQ"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "mspecialize"},
           {"text": " "},
           {"text": "HPQ"},
           {"text": " "},
           {"text": "HP;"},
           {"text": " "},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HPQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "with_unfolding_none",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.withUnfoldingNone",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "with_unfolding_none"}, {"text": " "}, {"text": "tacs"}]]},
        {"text": " executes "},
        {"element": ["code", true, [], [{"text": "tacs"}]]},
        {"text": " using the "},
        {"element": ["code", true, [], [{"text": ".none"}]]},
        {"text": " transparency setting."},
        {"raw": "\n"},
        {"text": "In this setting no definitions are unfolded."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "unfold",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.unfold",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "unfold"},
              {"text": " "},
              {"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#id"]],
                [{"text": "id"}]]}]]},
           {"text": " unfolds all occurrences of definition "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#id"]],
                [{"text": "id"}]]}]]},
           {"text": " in the target."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "unfold"},
              {"text": " "},
              {"text": "id1"},
              {"text": " "},
              {"text": "id2"},
              {"text": " "},
              {"text": "..."}]]},
           {"text": " is equivalent to "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "unfold"},
              {"text": " "},
              {"text": "id1;"},
              {"text": " "},
              {"text": "unfold"},
              {"text": " "},
              {"text": "id2;"},
              {"text": " "},
              {"text": "..."}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "unfold"},
              {"text": " "},
              {"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#id"]],
                [{"text": "id"}]]},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "h"}]]},
           {"text": " unfolds at the hypothesis "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": "."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Definitions can be either global or local definitions."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "For non-recursive global definitions, this tactic is identical to "},
        {"element": ["code", true, [], [{"text": "delta"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text":
         "For recursive global definitions, it uses the \"unfolding lemma\" "},
        {"element": ["code", true, [], [{"text": "id.eq_def"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"text":
         "which is generated for each recursive definition, to unfold according to the recursive definition given by the user."},
        {"raw": "\n"},
        {"text": "Only one level of unfolding is performed, in contrast to "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "simp"},
           {"text": " "},
           {"text": "only"},
           {"text": " "},
           {"text": "[id]"}]]},
        {"text": ", which unfolds definition "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#id"]],
             [{"text": "id"}]]}]]},
        {"text": " recursively."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "subst",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.subst",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "subst"}, {"text": " "}, {"text": "x..."}]]},
        {"text": " substitutes each hypothesis "},
        {"element": ["code", true, [], [{"text": "x"}]]},
        {"text": " with a definition found in the local context,"},
        {"raw": "\n"},
        {"text": "then eliminates the hypothesis."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"text": "If "},
           {"element": ["code", true, [], [{"text": "x"}]]},
           {"text": " is a local definition, then its definition is used."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Otherwise, if there is a hypothesis of the form "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "x"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " or "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "e"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "x"}]]},
           {"text": ","},
           {"raw": "\n"},
           {"text": "then "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " is used for the definition of "},
           {"element": ["code", true, [], [{"text": "x"}]]},
           {"text": "."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "If "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "b"}]]},
        {"text": ", then "},
        {"element":
         ["code", true, [], [{"text": "subst"}, {"text": " "}, {"text": "h"}]]},
        {"text": " may be used if either "},
        {"element": ["code", true, [], [{"text": "a"}]]},
        {"text": " or "},
        {"element": ["code", true, [], [{"text": "b"}]]},
        {"text": " unfolds to a local hypothesis."},
        {"raw": "\n"},
        {"text": "This is similar to the "},
        {"element":
         ["code", true, [], [{"text": "cases"}, {"text": " "}, {"text": "h"}]]},
        {"text": " tactic."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "See also: "},
        {"element": ["code", true, [], [{"text": "subst_vars"}]]},
        {"text":
         " for substituting all local hypotheses that have a defining equation."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "split",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.split",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "split"}]]},
        {"text": " tactic is useful for breaking nested if-then-else and "},
        {"element": ["code", true, [], [{"text": "match"}]]},
        {"text": " expressions into separate cases."},
        {"raw": "\n"},
        {"text": "For a "},
        {"element": ["code", true, [], [{"text": "match"}]]},
        {"text": " expression with "},
        {"element": ["code", true, [], [{"text": "n"}]]},
        {"text": " cases, the "},
        {"element": ["code", true, [], [{"text": "split"}]]},
        {"text": " tactic generates at most "},
        {"element": ["code", true, [], [{"text": "n"}]]},
        {"text": " subgoals."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "For example, given "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "n"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]}]]},
        {"text": ", and a target "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "if"},
           {"text": " "},
           {"text": "n"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "0"},
           {"text": " "},
           {"text": "then"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "else"},
           {"text": " "},
           {"text": "R"}]]},
        {"text": ", "},
        {"element": ["code", true, [], [{"text": "split"}]]},
        {"text": " will generate"},
        {"raw": "\n"},
        {"text": "one goal with hypothesis "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "n"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "0"}]]},
        {"text": " and target "},
        {"element": ["code", true, [], [{"text": "Q"}]]},
        {"text": ", and a second goal with hypothesis"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "¬n"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "0"}]]},
        {"text": " and target "},
        {"element": ["code", true, [], [{"text": "R"}]]},
        {"text":
         ".  Note that the introduced hypothesis is unnamed, and is commonly"},
        {"raw": "\n"},
        {"text": "renamed using the "},
        {"element": ["code", true, [], [{"text": "case"}]]},
        {"text": " or "},
        {"element": ["code", true, [], [{"text": "next"}]]},
        {"text": " tactics."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "split"}]]},
           {"text": " will split the goal (target)."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "split"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "h"}]]},
           {"text": " will split the hypothesis "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": "."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "nofun",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticNofun",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The tactic "},
        {"element": ["code", true, [], [{"text": "nofun"}]]},
        {"text": " is shorthand for "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "exact"}, {"text": " "}, {"text": "nofun"}]]},
        {"text": ": it introduces the assumptions, then performs an"},
        {"raw": "\n"},
        {"text":
         "empty pattern match, closing the goal if the introduced pattern is impossible."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "any_goals",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.anyGoals",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "any_goals"}, {"text": " "}, {"text": "tac"}]]},
        {"text": " applies the tactic "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " to every goal,"},
        {"raw": "\n"},
        {"text":
         "concatenating the resulting goals for successful tactic applications."},
        {"raw": "\n"},
        {"text": "If the tactic fails on all of the goals, the entire "},
        {"element": ["code", true, [], [{"text": "any_goals"}]]},
        {"text": " tactic fails."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "This tactic is like "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "all_goals"},
           {"text": " "},
           {"text": "try"},
           {"text": " "},
           {"text": "tac"}]]},
        {"text": " except that it fails if none of the applications of "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " succeeds."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "congr",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.congr",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Apply congruence (recursively) to goals of the form "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⊢"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "as"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "bs"}]]},
        {"text": " and "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⊢"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "as"},
           {"text": " "},
           {"text": "≍"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "bs"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text":
         "The optional parameter is the depth of the recursive applications."},
        {"raw": "\n"},
        {"text": "This is useful when "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#congr"]],
             [{"text": "congr"}]]}]]},
        {"text": " is too aggressive in breaking down the goal."},
        {"raw": "\n"},
        {"text": "For example, given "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⊢"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "(g"},
           {"text": " "},
           {"text": "(x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "y))"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "(g"},
           {"text": " "},
           {"text": "(y"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "x))"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#congr"]],
             [{"text": "congr"}]]}]]},
        {"text": " produces the goals "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⊢"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "y"}]]},
        {"text": " and "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⊢"},
           {"text": " "},
           {"text": "y"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "x"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"text": "while "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#congr"]],
             [{"text": "congr"}]]},
           {"text": " "},
           {"text": "2"}]]},
        {"text": " produces the intended "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⊢"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "y"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "y"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "x"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "rfl",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticRfl",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "This tactic applies to a goal whose target has the form "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "x"},
           {"text": " "},
           {"text": "~"},
           {"text": " "},
           {"text": "x"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"text": "where "},
        {"element": ["code", true, [], [{"text": "~"}]]},
        {"text": " is equality, heterogeneous equality or any relation that"},
        {"raw": "\n"},
        {"text":
         "has a reflexivity lemma tagged with the attribute @[refl]."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "intro",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.intro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text":
         "Introduces one or more hypotheses, optionally naming and/or pattern-matching them."},
        {"raw": "\n"},
        {"text":
         "For each hypothesis to be introduced, the remaining main goal's target type must"},
        {"raw": "\n"},
        {"text": "be a "},
        {"element": ["code", true, [], [{"text": "let"}]]},
        {"text": " or function type."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "intro"}]]},
           {"text":
            " by itself introduces one anonymous hypothesis, which can be accessed"},
           {"raw": "\n"},
           {"text": "by e.g. "},
           {"element": ["code", true, [], [{"text": "assumption"}]]},
           {"text": ". It is equivalent to "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "intro"}, {"text": " "}, {"text": "_"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "intro"},
              {"text": " "},
              {"text": "x"},
              {"text": " "},
              {"text": "y"}]]},
           {"text":
            " introduces two hypotheses and names them. Individual hypotheses"},
           {"raw": "\n"},
           {"text": "can be anonymized via "},
           {"element": ["code", true, [], [{"text": "_"}]]},
           {"text": ", given a type ascription, or matched against a pattern:"},
           {"element":
            ["pre",
             true,
             [],
             [{"element":
               ["code",
                true,
                [["class", "language-lean"]],
                [{"text": "--"},
                 {"text": " "},
                 {"text": "..."},
                 {"text": " "},
                 {"text": "⊢"},
                 {"text": " "},
                 {"text": "α"},
                 {"text": " "},
                 {"text": "×"},
                 {"text": " "},
                 {"text": "β"},
                 {"text": " "},
                 {"text": "→"},
                 {"text": " "},
                 {"text": "..."},
                 {"text": ""},
                 {"text": "\n"},
                 {"text": ""},
                 {"text": "intro"},
                 {"text": " "},
                 {"text": "(a,"},
                 {"text": " "},
                 {"text": "b)"},
                 {"text": ""},
                 {"text": "\n"},
                 {"text": ""},
                 {"text": "--"},
                 {"text": " "},
                 {"text": "...,"},
                 {"text": " "},
                 {"text": "a"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "α,"},
                 {"text": " "},
                 {"text": "b"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "β"},
                 {"text": " "},
                 {"text": "⊢"},
                 {"text": " "},
                 {"text": "..."},
                 {"text": ""},
                 {"text": "\n"},
                 {"text": ""}]]}]]}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "intro"},
              {"text": " "},
              {"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#rfl"]],
                [{"text": "rfl"}]]}]]},
           {"text": " is short for "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "intro"},
              {"text": " "},
              {"text": "h;"},
              {"text": " "},
              {"text": "subst"},
              {"text": " "},
              {"text": "h"}]]},
           {"text": ", if "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": " is an equality where the left-hand or right-hand side"},
           {"raw": "\n"},
           {"text": "is a variable."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Alternatively, "},
           {"element": ["code", true, [], [{"text": "intro"}]]},
           {"text": " can be combined with pattern matching much like "},
           {"element": ["code", true, [], [{"text": "fun"}]]},
           {"text": ":"},
           {"element":
            ["pre",
             true,
             [],
             [{"element":
               ["code",
                true,
                [["class", "language-lean"]],
                [{"text": "intro"},
                 {"text": ""},
                 {"text": "\n"},
                 {"text": ""},
                 {"text": "|"},
                 {"text": " "},
                 {"text": "n"},
                 {"text": " "},
                 {"text": "+"},
                 {"text": " "},
                 {"text": "1,"},
                 {"text": " "},
                 {"text": "0"},
                 {"text": " "},
                 {"text": "=>"},
                 {"text": " "},
                 {"text": "tac"},
                 {"text": ""},
                 {"text": "\n"},
                 {"text": ""},
                 {"text": "|"},
                 {"text": " "},
                 {"text": "..."},
                 {"text": ""},
                 {"text": "\n"},
                 {"text": ""}]]}]]}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "symm",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.symm",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "symm"}]]},
           {"text": " applies to a goal whose target has the form "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "t"},
              {"text": " "},
              {"text": "~"},
              {"text": " "},
              {"text": "u"}]]},
           {"text": " where "},
           {"element": ["code", true, [], [{"text": "~"}]]},
           {"text": " is a symmetric relation,"},
           {"raw": "\n"},
           {"text":
            "that is, a relation which has a symmetry lemma tagged with the attribute [symm]."},
           {"raw": "\n"},
           {"text": "It replaces the target with "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "u"},
              {"text": " "},
              {"text": "~"},
              {"text": " "},
              {"text": "t"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "symm"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "h"}]]},
           {"text": " will rewrite a hypothesis "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "t"},
              {"text": " "},
              {"text": "~"},
              {"text": " "},
              {"text": "u"}]]},
           {"text": " to "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "u"},
              {"text": " "},
              {"text": "~"},
              {"text": " "},
              {"text": "t"}]]},
           {"text": "."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mexact",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mexactMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mexact"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "exact"}]]},
        {"text": ", but operating on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mstart"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "all_goals",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.allGoals",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "all_goals"}, {"text": " "}, {"text": "tac"}]]},
        {"text": " runs "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " on each goal, concatenating the resulting goals."},
        {"raw": "\n"},
        {"text": "If the tactic fails on any goal, the entire "},
        {"element": ["code", true, [], [{"text": "all_goals"}]]},
        {"text": " tactic fails."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "See also "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "any_goals"}, {"text": " "}, {"text": "tac"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mreplace",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mreplaceMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mreplace"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "replace"}]]},
        {"text": ", but operating on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Q)"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HP"},
           {"text": " "},
           {"text": "HPQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mreplace"},
           {"text": " "},
           {"text": "HPQ"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "mspecialize"},
           {"text": " "},
           {"text": "HPQ"},
           {"text": " "},
           {"text": "HP;"},
           {"text": " "},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HPQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HPQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mleave",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mleaveMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Leaves the stateful proof mode of "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": ", tries to eta-expand through all definitions"},
        {"raw": "\n"},
        {"text": "related to the logic of the "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " and gently simplifies the resulting pure Lean"},
        {"raw": "\n"},
        {"text": "proposition. This is often the right thing to do after "},
        {"element": ["code", true, [], [{"text": "mvcgen"}]]},
        {"text": " in order for automation to prove"},
        {"raw": "\n"},
        {"text": "the goal."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "exact?",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.exact?",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text":
         "Searches environment for definitions or theorems that can solve the goal using "},
        {"element": ["code", true, [], [{"text": "exact"}]]},
        {"raw": "\n"},
        {"text": "with conditions resolved by "},
        {"element": ["code", true, [], [{"text": "solve_by_elim"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "The optional "},
        {"element": ["code", true, [], [{"text": "using"}]]},
        {"text":
         " clause provides identifiers in the local context that must be"},
        {"raw": "\n"},
        {"text": "used by "},
        {"element": ["code", true, [], [{"text": "exact?"}]]},
        {"text":
         " when closing the goal.  This is most useful if there are multiple"},
        {"raw": "\n"},
        {"text":
         "ways to resolve the goal, and one wants to guide which lemma is used."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Use "},
        {"element": ["code", true, [], [{"text": "+grind"}]]},
        {"text": " to enable "},
        {"element": ["code", true, [], [{"text": "grind"}]]},
        {"text": " as a fallback discharger for subgoals."},
        {"raw": "\n"},
        {"text": "Use "},
        {"element": ["code", true, [], [{"text": "+try?"}]]},
        {"text": " to enable "},
        {"element": ["code", true, [], [{"text": "try?"}]]},
        {"text": " as a fallback discharger for subgoals."},
        {"raw": "\n"},
        {"text": "Use "},
        {"element": ["code", true, [], [{"text": "-star"}]]},
        {"text": " to disable fallback to star-indexed lemmas (like "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Core.html#Empty.elim"]],
             [{"text": "Empty.elim"}]]}]]},
        {"text": ", "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#And.left"]],
             [{"text": "And.left"}]]}]]},
        {"text": ")."},
        {"raw": "\n"},
        {"text": "Use "},
        {"element": ["code", true, [], [{"text": "+all"}]]},
        {"text":
         " to collect all successful lemmas instead of stopping at the first."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mspecialize",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mspecializeMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mspecialize"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "specialize"}]]},
        {"text": ", but operating on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."},
        {"raw": "\n"},
        {"text":
         "It specializes a hypothesis from the stateful context with hypotheses from either the pure"},
        {"raw": "\n"},
        {"text": "or stateful context or pure terms."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Q)"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HP"},
           {"text": " "},
           {"text": "HPQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mspecialize"},
           {"text": " "},
           {"text": "HPQ"},
           {"text": " "},
           {"text": "HP"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HPQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "example"},
           {"text": " "},
           {"text": "(y"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": "(Ψ"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": "(hP"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "P)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "(∀"},
           {"text": " "},
           {"text": "x,"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Ψ"},
           {"text": " "},
           {"text": "x)"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Ψ"},
           {"text": " "},
           {"text": "(y"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "1)"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HQ"},
           {"text": " "},
           {"text": "HΨ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mspecialize"},
           {"text": " "},
           {"text": "HΨ"},
           {"text": " "},
           {"text": "(y"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "1)"},
           {"text": " "},
           {"text": "hP"},
           {"text": " "},
           {"text": "HQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HΨ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "omega",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.omega",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "omega"}]]},
        {"text":
         " tactic, for resolving integer and natural linear arithmetic problems."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "It is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),"},
        {"raw": "\n"},
        {"text": "but should be effective on many problems."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "We handle hypotheses of the form "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "x"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "y"}]]},
        {"text": ", "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "x"},
           {"text": " "},
           {"text": "<"},
           {"text": " "},
           {"text": "y"}]]},
        {"text": ", "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "x"},
           {"text": " "},
           {"text": "≤"},
           {"text": " "},
           {"text": "y"}]]},
        {"text": ", and "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "k"},
           {"text": " "},
           {"text": "∣"},
           {"text": " "},
           {"text": "x"}]]},
        {"text": " for "},
        {"element":
         ["code", true, [], [{"text": "x"}, {"text": " "}, {"text": "y"}]]},
        {"text": " in "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]}]]},
        {"text": " or "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Data/Int/Basic.html#Int"]],
             [{"text": "Int"}]]}]]},
        {"raw": "\n"},
        {"text": "(and "},
        {"element": ["code", true, [], [{"text": "k"}]]},
        {"text": " a literal), along with negations of these statements."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "We decompose the sides of the inequalities as linear combinations of atoms."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "If we encounter "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "x"},
           {"text": " "},
           {"text": "/"},
           {"text": " "},
           {"text": "k"}]]},
        {"text": " or "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "x"},
           {"text": " "},
           {"text": "%"},
           {"text": " "},
           {"text": "k"}]]},
        {"text": " for literal integers "},
        {"element": ["code", true, [], [{"text": "k"}]]},
        {"text": " we introduce new auxiliary variables"},
        {"raw": "\n"},
        {"text": "and the relevant inequalities."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "On the first pass, we do not perform case splits on natural subtraction."},
        {"raw": "\n"},
        {"text": "If "},
        {"element": ["code", true, [], [{"text": "omega"}]]},
        {"text": " fails, we recursively perform a case split on"},
        {"raw": "\n"},
        {"text":
         "a natural subtraction appearing in a hypothesis, and try again."}]]},
     {"element": ["p", true, [], [{"text": "The options"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "omega"},
           {"text": " "},
           {"text": "+splitDisjunctions"},
           {"text": " "},
           {"text": "+splitNatSub"},
           {"text": " "},
           {"text": "+splitNatAbs"},
           {"text": " "},
           {"text": "+splitMinMax"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element": ["p", true, [], [{"text": "can be used to:"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "splitDisjunctions"}]]},
           {"text": ": split any disjunctions found in the context,"},
           {"raw": "\n"},
           {"text": "if the problem is not otherwise solvable."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "splitNatSub"}]]},
           {"text": ": for each appearance of "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "((a"},
              {"text": " "},
              {"text": "-"},
              {"text": " "},
              {"text": "b"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "Nat)"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "Int)"}]]},
           {"text": ", split on "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "a"},
              {"text": " "},
              {"text": "≤"},
              {"text": " "},
              {"text": "b"}]]},
           {"text": " if necessary."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "splitNatAbs"}]]},
           {"text": ": for each appearance of "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Data/Int/Basic.html#Int.natAbs"]],
                [{"text": "Int.natAbs"}]]},
              {"text": " "},
              {"text": "a"}]]},
           {"text": ", split on "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "0"},
              {"text": " "},
              {"text": "≤"},
              {"text": " "},
              {"text": "a"}]]},
           {"text": " if necessary."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "splitMinMax"}]]},
           {"text": ": for each occurrence of "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "min"},
              {"text": " "},
              {"text": "a"},
              {"text": " "},
              {"text": "b"}]]},
           {"text": ", split on "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "min"},
              {"text": " "},
              {"text": "a"},
              {"text": " "},
              {"text": "b"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "a"},
              {"text": " "},
              {"text": "∨"},
              {"text": " "},
              {"text": "min"},
              {"text": " "},
              {"text": "a"},
              {"text": " "},
              {"text": "b"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "b"}]]},
           {"raw": "\n"},
           {"text": "Currently, all of these are on by default."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "apply",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.apply",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code", true, [], [{"text": "apply"}, {"text": " "}, {"text": "e"}]]},
        {"text": " tries to match the current goal against the conclusion of "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text": "'s type."},
        {"raw": "\n"},
        {"text":
         "If it succeeds, then the tactic returns as many subgoals as the number of premises that"},
        {"raw": "\n"},
        {"text":
         "have not been fixed by type inference or type class resolution."},
        {"raw": "\n"},
        {"text": "Non-dependent premises are added before dependent ones."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "apply"}]]},
        {"text":
         " tactic uses higher-order pattern matching, type class resolution,"},
        {"raw": "\n"},
        {"text": "and first-order unification with dependent types."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "subst_eqs",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.substEqs",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "subst_eq"}]]},
        {"text":
         " repeatedly substitutes according to the equality proof hypotheses in the context,"},
        {"raw": "\n"},
        {"text":
         "replacing the left side of the equality with the right, until no more progress can be made."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "dbg_trace",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.dbgTrace",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "dbg_trace"}, {"text": " "}, {"text": "\"foo\""}]]},
        {"text": " prints "},
        {"element": ["code", true, [], [{"text": "foo"}]]},
        {"text": " when elaborated."},
        {"raw": "\n"},
        {"text": "Useful for debugging tactic control flow:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#False"]],
             [{"text": "False"}]]},
           {"text": " "},
           {"text": "∨"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#True"]],
             [{"text": "True"}]]},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "first"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "|"},
           {"text": " "},
           {"text": "apply"},
           {"text": " "},
           {"text": "Or.inl;"},
           {"text": " "},
           {"text": "trivial;"},
           {"text": " "},
           {"text": "dbg_trace"},
           {"text": " "},
           {"text": "\"left\""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "|"},
           {"text": " "},
           {"text": "apply"},
           {"text": " "},
           {"text": "Or.inr;"},
           {"text": " "},
           {"text": "trivial;"},
           {"text": " "},
           {"text": "dbg_trace"},
           {"text": " "},
           {"text": "\"right\""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "fun_cases",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.funCases",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "fun_cases"}]]},
        {"text": " tactic is a convenience wrapper of the "},
        {"element": ["code", true, [], [{"text": "cases"}]]},
        {"text": " tactic when using a functional"},
        {"raw": "\n"},
        {"text": "cases principle."}]]},
     {"element": ["p", true, [], [{"text": "The tactic invocation"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "fun_cases"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "y"},
           {"text": " "},
           {"text": "...`"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element": ["p", true, [], [{"text": "is equivalent to"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "cases"},
           {"text": " "},
           {"text": "y,"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "using"},
           {"text": " "},
           {"text": "f.fun_cases_unfolding"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "..."},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "where the arguments of "},
        {"element": ["code", true, [], [{"text": "f"}]]},
        {"text": " are used as arguments to "},
        {"element": ["code", true, [], [{"text": "f.fun_cases_unfolding"}]]},
        {"text": " or targets of the case"},
        {"raw": "\n"},
        {"text": "analysis, as appropriate."}]]},
     {"element": ["p", true, [], [{"text": "The form"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "fun_cases"},
           {"text": " "},
           {"text": "f"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "(with no arguments to "},
        {"element": ["code", true, [], [{"text": "f"}]]},
        {"text": ") searches the goal for a unique eligible application of "},
        {"element": ["code", true, [], [{"text": "f"}]]},
        {"text": ", and uses"},
        {"raw": "\n"},
        {"text": "these arguments. An application of "},
        {"element": ["code", true, [], [{"text": "f"}]]},
        {"text": " is eligible if it is saturated and the arguments that will"},
        {"raw": "\n"},
        {"text": "become targets are free variables."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "The form "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "fun_cases"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "y"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "case1"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "tac₁"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "case2"},
           {"text": " "},
           {"text": "x'"},
           {"text": " "},
           {"text": "ih"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "tac₂"}]]},
        {"text": " works like with "},
        {"element": ["code", true, [], [{"text": "cases"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Under "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "set_option"},
           {"text": " "},
           {"text": "tactic.fun_induction.unfolding"},
           {"text": " "},
           {"text": "true"}]]},
        {"text": " (the default), "},
        {"element": ["code", true, [], [{"text": "fun_induction"}]]},
        {"text": " uses the"},
        {"raw": "\n"},
        {"element": ["code", true, [], [{"text": "f.fun_cases_unfolding"}]]},
        {"text":
         " theorem, which will try to automatically unfold the call to "},
        {"element": ["code", true, [], [{"text": "f"}]]},
        {"text": " in"},
        {"raw": "\n"},
        {"text": "the goal. With "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "set_option"},
           {"text": " "},
           {"text": "tactic.fun_induction.unfolding"},
           {"text": " "},
           {"text": "false"}]]},
        {"text": ", it uses "},
        {"element": ["code", true, [], [{"text": "f.fun_cases"}]]},
        {"text": " instead."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mleft",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mleftMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mleft"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "left"}]]},
        {"text": ", but operating on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "∨"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HP"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mleft"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HP"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "bv_omega",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticBv_omega",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "bv_omega"}]]},
        {"text": " is "},
        {"element": ["code", true, [], [{"text": "omega"}]]},
        {"text":
         " with an additional preprocessor that turns statements about "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#BitVec"]],
             [{"text": "BitVec"}]]}]]},
        {"text": " into statements about "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "Currently the preprocessor is implemented as "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "try"},
           {"text": " "},
           {"text": "simp"},
           {"text": " "},
           {"text": "only"},
           {"text": " "},
           {"text": "[bitvec_to_nat]"},
           {"text": " "},
           {"text": "at"},
           {"text": " "},
           {"text": "*"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"element": ["code", true, [], [{"text": "bitvec_to_nat"}]]},
        {"text": " is a "},
        {"element": ["code", true, [], [{"text": "@[simp]"}]]},
        {"text":
         " attribute that you can (cautiously) add to more theorems."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "refine'",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.refine'",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "refine'"}, {"text": " "}, {"text": "e"}]]},
        {"text": " behaves like "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "refine"}, {"text": " "}, {"text": "e"}]]},
        {"text": ", except that unsolved placeholders ("},
        {"element": ["code", true, [], [{"text": "_"}]]},
        {"text": ")"},
        {"raw": "\n"},
        {"text":
         "and implicit parameters are also converted into new goals."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "norm_cast",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticNorm_cast__",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "norm_cast"}]]},
        {"text": " family of tactics is used to normalize certain coercions ("},
        {"element": ["em", true, [], [{"text": "casts"}]]},
        {"text": ") in expressions."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "norm_cast"}]]},
           {"text": " normalizes casts in the target."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "norm_cast"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "h"}]]},
           {"text": " normalizes casts in hypothesis "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": "."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "The tactic is basically a version of "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": " with a specific set of lemmas to move casts"},
        {"raw": "\n"},
        {"text": "upwards in the expression."},
        {"raw": "\n"},
        {"text": "Therefore even in situations where non-terminal "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": " calls are discouraged (because of fragility),"},
        {"raw": "\n"},
        {"element": ["code", true, [], [{"text": "norm_cast"}]]},
        {"text": " is considered to be safe."},
        {"raw": "\n"},
        {"text": "It also has special handling of numerals."}]]},
     {"element":
      ["p", true, [], [{"text": "For instance, given an assumption"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "a"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "ℤ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "↑a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "↑b"},
           {"text": " "},
           {"text": "<"},
           {"text": " "},
           {"text": "(10"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "ℚ)"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "writing "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "norm_cast"},
           {"text": " "},
           {"text": "at"},
           {"text": " "},
           {"text": "h"}]]},
        {"text": " will turn "},
        {"element": ["code", true, [], [{"text": "h"}]]},
        {"text": " into"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "<"},
           {"text": " "},
           {"text": "10"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "There are also variants of basic tactics that use "},
        {"element": ["code", true, [], [{"text": "norm_cast"}]]},
        {"text": " to normalize expressions during"},
        {"raw": "\n"},
        {"text":
         "their operation, to make them more flexible about the expressions they accept"},
        {"raw": "\n"},
        {"text": "(we say that it is a tactic "},
        {"element": ["em", true, [], [{"text": "modulo"}]]},
        {"text": " the effects of "},
        {"element": ["code", true, [], [{"text": "norm_cast"}]]},
        {"text": "):"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "exact_mod_cast"}]]},
           {"text": " for "},
           {"element": ["code", true, [], [{"text": "exact"}]]},
           {"text": " and "},
           {"element": ["code", true, [], [{"text": "apply_mod_cast"}]]},
           {"text": " for "},
           {"element": ["code", true, [], [{"text": "apply"}]]},
           {"text": "."},
           {"raw": "\n"},
           {"text": "Writing "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "exact_mod_cast"}, {"text": " "}, {"text": "h"}]]},
           {"text": " and "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "apply_mod_cast"}, {"text": " "}, {"text": "h"}]]},
           {"text": " will normalize casts"},
           {"raw": "\n"},
           {"text": "in the goal and "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": " before using "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "exact"}, {"text": " "}, {"text": "h"}]]},
           {"text": " or "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "apply"}, {"text": " "}, {"text": "h"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "rw_mod_cast"}]]},
           {"text": " for "},
           {"element": ["code", true, [], [{"text": "rw"}]]},
           {"text": ". It applies "},
           {"element": ["code", true, [], [{"text": "norm_cast"}]]},
           {"text": " between rewrites."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "assumption_mod_cast"}]]},
           {"text": " for "},
           {"element": ["code", true, [], [{"text": "assumption"}]]},
           {"text": "."},
           {"raw": "\n"},
           {"text": "This is effectively "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "norm_cast"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "*;"},
              {"text": " "},
              {"text": "assumption"}]]},
           {"text": ", but more efficient."},
           {"raw": "\n"},
           {"text":
            "It normalizes casts in the goal and, for every hypothesis "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": " in the context,"},
           {"raw": "\n"},
           {"text": "it will try to normalize casts in "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": " and use "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "exact"}, {"text": " "}, {"text": "h"}]]},
           {"text": "."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "See also "},
        {"element": ["code", true, [], [{"text": "push_cast"}]]},
        {"text":
         ", which moves casts inwards rather than lifting them outwards."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "exact",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.exact",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code", true, [], [{"text": "exact"}, {"text": " "}, {"text": "e"}]]},
        {"text": " closes the main goal if its target type matches that of "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "push_cast",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.pushCast",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "push_cast"}]]},
        {"text": " rewrites the goal to move certain coercions ("},
        {"element": ["em", true, [], [{"text": "casts"}]]},
        {"text": ") inward, toward the leaf nodes."},
        {"raw": "\n"},
        {"text": "This uses "},
        {"element": ["code", true, [], [{"text": "norm_cast"}]]},
        {"text": " lemmas in the forward direction."},
        {"raw": "\n"},
        {"text": "For example, "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "↑(a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "b)"}]]},
        {"text": " will be written to "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "↑a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "↑b"}]]},
        {"text": "."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "push_cast"}]]},
           {"text": " moves casts inward in the goal."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "push_cast"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "h"}]]},
           {"text": " moves casts inward in the hypothesis "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": "."},
           {"raw": "\n"},
           {"text":
            "It can be used with extra simp lemmas with, for example, "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "push_cast"},
              {"text": " "},
              {"text": "[Int.add_zero]"}]]},
           {"text": "."}]]}]]},
     {"element": ["p", true, [], [{"text": "Example:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(a"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "(h1"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "((a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Int)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "10)"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "(h2"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "((a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "0"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Int)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "10)"},
           {"text": " "},
           {"text": ":"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "((a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Int)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "10"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "/-"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "h1"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "↑(a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "b)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "10"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "h2"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "↑(a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "0)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "10"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "⊢"},
           {"text": " "},
           {"text": "↑(a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "b)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "10"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "-/"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "push_cast"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "/-"},
           {"text": " "},
           {"text": "Now"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "⊢"},
           {"text": " "},
           {"text": "↑a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "↑b"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "10"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "-/"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "push_cast"},
           {"text": " "},
           {"text": "at"},
           {"text": " "},
           {"text": "h1"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "push_cast"},
           {"text": " "},
           {"text": "[Int.add_zero]"},
           {"text": " "},
           {"text": "at"},
           {"text": " "},
           {"text": "h2"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "/-"},
           {"text": " "},
           {"text": "Now"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "h1"},
           {"text": " "},
           {"text": "h2"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "↑a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "↑b"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "10"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "-/"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "exact"},
           {"text": " "},
           {"text": "h1"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "See also "},
        {"element": ["code", true, [], [{"text": "norm_cast"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mpure_intro",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mpureIntroMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mpure_intro"}]]},
        {"text": " operates on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal of the form "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "P"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "⌜φ⌝"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "It leaves the stateful proof mode (thereby discarding "},
        {"element": ["code", true, [], [{"text": "P"}]]},
        {"text": "), leaving the regular goal "},
        {"element": ["code", true, [], [{"text": "φ"}]]},
        {"text": "."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "theorem"},
           {"text": " "},
           {"text": "simple"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "(⌜True⌝"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mpure_intro"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "exact"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#True.intro"]],
             [{"text": "True.intro"}]]},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "revert",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.revert",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "revert"}, {"text": " "}, {"text": "x..."}]]},
        {"text": " is the inverse of "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "intro"}, {"text": " "}, {"text": "x..."}]]},
        {"text": ": it moves the given hypotheses"},
        {"raw": "\n"},
        {"text": "into the main goal's target type."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "refine_lift",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticRefine_lift_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Auxiliary macro for lifting have/suffices/let/..."},
        {"raw": "\n"},
        {"text": "It makes sure the \"continuation\" "},
        {"element": ["code", true, [], [{"text": "?_"}]]},
        {"text": " is the main goal after refining."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "let rec",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.letrec",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "let"},
           {"text": " "},
           {"text": "rec"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "t"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "e"}]]},
        {"text": " adds a recursive definition "},
        {"element": ["code", true, [], [{"text": "f"}]]},
        {"text": " to the current goal."},
        {"raw": "\n"},
        {"text": "The syntax is the same as term-mode "},
        {"element":
         ["code", true, [], [{"text": "let"}, {"text": " "}, {"text": "rec"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "The tactic supports all the same syntax variants and options as the "},
        {"element": ["code", true, [], [{"text": "let"}]]},
        {"text": " term."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "refine_lift'",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticRefine_lift'_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Similar to "},
        {"element": ["code", true, [], [{"text": "refine_lift"}]]},
        {"text": ", but using "},
        {"element": ["code", true, [], [{"text": "refine'"}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "norm_cast0",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.normCast0",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Implementation of "},
        {"element": ["code", true, [], [{"text": "norm_cast"}]]},
        {"text": " (the full "},
        {"element": ["code", true, [], [{"text": "norm_cast"}]]},
        {"text": " calls "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Core.html#trivial"]],
             [{"text": "trivial"}]]}]]},
        {"text": " afterwards)."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "get_elem_tactic",
  "tags": [],
  "internalName": "tacticGet_elem_tactic",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "get_elem_tactic"}]]},
        {"text": " is the tactic automatically called by the notation "},
        {"element": ["code", true, [], [{"text": "arr[i]"}]]},
        {"raw": "\n"},
        {"text":
         "to prove any side conditions that arise when constructing the term"},
        {"raw": "\n"},
        {"text":
         "(e.g. the index is in bounds of the array). It just delegates to"},
        {"raw": "\n"},
        {"element":
         ["code", true, [], [{"text": "get_elem_tactic_extensible"}]]},
        {"text": " and gives a diagnostic error message otherwise;"},
        {"raw": "\n"},
        {"text": "users are encouraged to extend "},
        {"element":
         ["code", true, [], [{"text": "get_elem_tactic_extensible"}]]},
        {"text": " instead of this tactic."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "simp_all?!",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticSimp_all?!_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "simp?"}]]},
        {"text": " takes the same arguments as "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": ", but reports an equivalent call to "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "simp"}, {"text": " "}, {"text": "only"}]]},
        {"raw": "\n"},
        {"text":
         "that would be sufficient to close the goal. This is useful for reducing the size of the simp"},
        {"raw": "\n"},
        {"text": "set in a local invocation to speed up processing."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "example"},
           {"text": " "},
           {"text": "(x"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "(if"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#True"]],
             [{"text": "True"}]]},
           {"text": " "},
           {"text": "then"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": "else"},
           {"text": " "},
           {"text": "3)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "simp?"},
           {"text": " "},
           {"text": "--"},
           {"text": " "},
           {"text": "prints"},
           {"text": " "},
           {"text": "\"Try"},
           {"text": " "},
           {"text": "this:"},
           {"text": " "},
           {"text": "simp"},
           {"text": " "},
           {"text": "only"},
           {"text": " "},
           {"text": "[ite_true]\""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "This command can also be used in "},
        {"element": ["code", true, [], [{"text": "simp_all"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "dsimp"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "delta",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.delta",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "delta"},
           {"text": " "},
           {"text": "id1"},
           {"text": " "},
           {"text": "id2"},
           {"text": " "},
           {"text": "..."}]]},
        {"text": " delta-expands the definitions "},
        {"element": ["code", true, [], [{"text": "id1"}]]},
        {"text": ", "},
        {"element": ["code", true, [], [{"text": "id2"}]]},
        {"text": ", ...."},
        {"raw": "\n"},
        {"text":
         "This is a low-level tactic, it will expose how recursive definitions have been"},
        {"raw": "\n"},
        {"text": "compiled by Lean."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "apply_rfl",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.applyRfl",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The same as "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#rfl"]],
             [{"text": "rfl"}]]}]]},
        {"text": ", but without trying "},
        {"element": ["code", true, [], [{"text": "eq_refl"}]]},
        {"text": " at the end."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "rw?",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.rewrites?",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "rw?"}]]},
        {"text": " tries to find a lemma which can rewrite the goal."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "rw?"}]]},
        {"text": " should not be left in proofs; it is a search tool, like "},
        {"element": ["code", true, [], [{"text": "apply?"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Suggestions are printed as "},
        {"element":
         ["code", true, [], [{"text": "rw"}, {"text": " "}, {"text": "[h]"}]]},
        {"text": " or "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "rw"},
           {"text": " "},
           {"text": "[←"},
           {"text": " "},
           {"text": "h]"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "You can use "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "rw?"},
           {"text": " "},
           {"text": "[-my_lemma,"},
           {"text": " "},
           {"text": "-my_theorem]"}]]},
        {"text": " to prevent "},
        {"element": ["code", true, [], [{"text": "rw?"}]]},
        {"text": " using the named lemmas."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "constructor",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.constructor",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "If the main goal's target type is an inductive type, "},
        {"element": ["code", true, [], [{"text": "constructor"}]]},
        {"text": " solves it with"},
        {"raw": "\n"},
        {"text": "the first matching constructor, or else fails."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "specialize",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.specialize",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The tactic "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "specialize"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": "a₁"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "aₙ"}]]},
        {"text": " works on local hypothesis "},
        {"element": ["code", true, [], [{"text": "h"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text":
         "The premises of this hypothesis, either universal quantifications or"},
        {"raw": "\n"},
        {"text":
         "non-dependent implications, are instantiated by concrete terms coming"},
        {"raw": "\n"},
        {"text": "from arguments "},
        {"element": ["code", true, [], [{"text": "a₁"}]]},
        {"text": " ... "},
        {"element": ["code", true, [], [{"text": "aₙ"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "The tactic adds a new hypothesis with the same name "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": "a₁"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "aₙ"}]]},
        {"raw": "\n"},
        {"text": "and tries to clear the previous one."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "assumption",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.assumption",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "assumption"}]]},
        {"text":
         " tries to solve the main goal using a hypothesis of compatible type, or else fails."},
        {"raw": "\n"},
        {"text": "Note also the "},
        {"element": ["code", true, [], [{"text": "‹t›"}]]},
        {"text": " term notation, which is a shorthand for "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "show"},
           {"text": " "},
           {"text": "t"},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "assumption"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "contradiction",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.contradiction",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "contradiction"}]]},
        {"text":
         " closes the main goal if its hypotheses are \"trivially contradictory\"."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"text": "Inductive type/family with no applicable constructors"},
           {"element":
            ["pre",
             true,
             [],
             [{"element":
               ["code",
                true,
                [["class", "language-lean"]],
                [{"text": "example"},
                 {"text": " "},
                 {"text": "(h"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "False)"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "p"},
                 {"text": " "},
                 {"text": ":="},
                 {"text": " "},
                 {"text": "by"},
                 {"text": " "},
                 {"text": "contradiction"},
                 {"text": ""},
                 {"text": "\n"},
                 {"text": ""}]]}]]}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Injectivity of constructors"},
           {"element":
            ["pre",
             true,
             [],
             [{"element":
               ["code",
                true,
                [["class", "language-lean"]],
                [{"text": "example"},
                 {"text": " "},
                 {"text": "(h"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "none"},
                 {"text": " "},
                 {"text": "="},
                 {"text": " "},
                 {"text": "some"},
                 {"text": " "},
                 {"text": "true)"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "p"},
                 {"text": " "},
                 {"text": ":="},
                 {"text": " "},
                 {"text": "by"},
                 {"text": " "},
                 {"text": "contradiction"},
                 {"text": " "},
                 {"text": ""},
                 {"text": " "},
                 {"text": "--"},
                 {"text": ""},
                 {"text": "\n"},
                 {"text": ""}]]}]]}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Decidable false proposition"},
           {"element":
            ["pre",
             true,
             [],
             [{"element":
               ["code",
                true,
                [["class", "language-lean"]],
                [{"text": "example"},
                 {"text": " "},
                 {"text": "(h"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "2"},
                 {"text": " "},
                 {"text": "+"},
                 {"text": " "},
                 {"text": "2"},
                 {"text": " "},
                 {"text": "="},
                 {"text": " "},
                 {"text": "3)"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "p"},
                 {"text": " "},
                 {"text": ":="},
                 {"text": " "},
                 {"text": "by"},
                 {"text": " "},
                 {"text": "contradiction"},
                 {"text": ""},
                 {"text": "\n"},
                 {"text": ""}]]}]]}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Contradictory hypotheses"},
           {"element":
            ["pre",
             true,
             [],
             [{"element":
               ["code",
                true,
                [["class", "language-lean"]],
                [{"text": "example"},
                 {"text": " "},
                 {"text": "(h"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "p)"},
                 {"text": " "},
                 {"text": "(h'"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "¬"},
                 {"text": " "},
                 {"text": "p)"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "q"},
                 {"text": " "},
                 {"text": ":="},
                 {"text": " "},
                 {"text": "by"},
                 {"text": " "},
                 {"text": "contradiction"},
                 {"text": ""},
                 {"text": "\n"},
                 {"text": ""}]]}]]}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Other simple contradictions such as"},
           {"element":
            ["pre",
             true,
             [],
             [{"element":
               ["code",
                true,
                [["class", "language-lean"]],
                [{"text": "example"},
                 {"text": " "},
                 {"text": "(x"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "Nat)"},
                 {"text": " "},
                 {"text": "(h"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "x"},
                 {"text": " "},
                 {"text": "≠"},
                 {"text": " "},
                 {"text": "x)"},
                 {"text": " "},
                 {"text": ":"},
                 {"text": " "},
                 {"text": "p"},
                 {"text": " "},
                 {"text": ":="},
                 {"text": " "},
                 {"text": "by"},
                 {"text": " "},
                 {"text": "contradiction"},
                 {"text": ""},
                 {"text": "\n"},
                 {"text": ""}]]}]]}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "apply_rules",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.applyRules",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "apply_rules"},
           {"text": " "},
           {"text": "[l₁,"},
           {"text": " "},
           {"text": "l₂,"},
           {"text": " "},
           {"text": "...]"}]]},
        {"text": " tries to solve the main goal by iteratively"},
        {"raw": "\n"},
        {"text": "applying the list of lemmas "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "[l₁,"},
           {"text": " "},
           {"text": "l₂,"},
           {"text": " "},
           {"text": "...]"}]]},
        {"text": " or by applying a local hypothesis."},
        {"raw": "\n"},
        {"text": "If "},
        {"element": ["code", true, [], [{"text": "apply"}]]},
        {"text": " generates new goals, "},
        {"element": ["code", true, [], [{"text": "apply_rules"}]]},
        {"text": " iteratively tries to solve those goals."},
        {"raw": "\n"},
        {"text": "You can use "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "apply_rules"}, {"text": " "}, {"text": "[-h]"}]]},
        {"text": " to omit a local hypothesis."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "apply_rules"}]]},
        {"text": " will also use "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#rfl"]],
             [{"text": "rfl"}]]}]]},
        {"text": ", "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Core.html#trivial"]],
             [{"text": "trivial"}]]}]]},
        {"text": ", "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#congrFun"]],
             [{"text": "congrFun"}]]}]]},
        {"text": " and "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#congrArg"]],
             [{"text": "congrArg"}]]}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "These can be disabled, as can local hypotheses, by using "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "apply_rules"},
           {"text": " "},
           {"text": "only"},
           {"text": " "},
           {"text": "[...]"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "You can use "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "apply_rules"},
           {"text": " "},
           {"text": "using"},
           {"text": " "},
           {"text": "[a₁,"},
           {"text": " "},
           {"text": "...]"}]]},
        {"text": " to use all lemmas which have been labelled"},
        {"raw": "\n"},
        {"text": "with the attributes "},
        {"element": ["code", true, [], [{"text": "aᵢ"}]]},
        {"text": " (these attributes must be created using "},
        {"element": ["code", true, [], [{"text": "register_label_attr"}]]},
        {"text": ")."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "You can pass a further configuration via the syntax "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "apply_rules"},
           {"text": " "},
           {"text": "(config"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "{...})"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "The options supported are the same as for "},
        {"element": ["code", true, [], [{"text": "solve_by_elim"}]]},
        {"text": " (and include all the options for "},
        {"element": ["code", true, [], [{"text": "apply"}]]},
        {"text": ")."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "apply_rules"}]]},
        {"text": " will try calling "},
        {"element": ["code", true, [], [{"text": "symm"}]]},
        {"text": " on hypotheses and "},
        {"element": ["code", true, [], [{"text": "exfalso"}]]},
        {"text": " on the goal as needed."},
        {"raw": "\n"},
        {"text": "This can be disabled with "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "apply_rules"},
           {"text": " "},
           {"text": "(config"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "{symm"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "false,"},
           {"text": " "},
           {"text": "exfalso"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "false})"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "You can bound the iteration depth using the syntax "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "apply_rules"},
           {"text": " "},
           {"text": "(config"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "{maxDepth"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "n})"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Unlike "},
        {"element": ["code", true, [], [{"text": "solve_by_elim"}]]},
        {"text": ", "},
        {"element": ["code", true, [], [{"text": "apply_rules"}]]},
        {"text": " does not perform backtracking, and greedily applies"},
        {"raw": "\n"},
        {"text": "a lemma from the list until it gets stuck."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "let'",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticLet'__",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Similar to "},
        {"element": ["code", true, [], [{"text": "let"}]]},
        {"text": ", but using "},
        {"element": ["code", true, [], [{"text": "refine'"}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "haveI",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticHaveI__",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "haveI"}]]},
        {"text": " behaves like "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text": ", but inlines the value instead of producing a "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text": " term."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mclear",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mclearMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mclear"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "clear"}]]},
        {"text": ", but operating on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HP"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mclear"},
           {"text": " "},
           {"text": "HP"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "done",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.done",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "done"}]]},
        {"text": " succeeds iff there are no remaining goals."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "refine",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.refine",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "refine"}, {"text": " "}, {"text": "e"}]]},
        {"text": " behaves like "},
        {"element":
         ["code", true, [], [{"text": "exact"}, {"text": " "}, {"text": "e"}]]},
        {"text": ", except that named ("},
        {"element": ["code", true, [], [{"text": "?x"}]]},
        {"text": ") or unnamed ("},
        {"element": ["code", true, [], [{"text": "?_"}]]},
        {"text": ")"},
        {"raw": "\n"},
        {"text": "holes in "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text":
         " that are not solved by unification with the main goal's target type"},
        {"raw": "\n"},
        {"text":
         "are converted into new goals, using the hole's name, if any, as the goal case name."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "bv_decide?",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.bvTraceMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Suggest a proof script for a "},
        {"element": ["code", true, [], [{"text": "bv_decide"}]]},
        {"text": " tactic call. Useful for caching LRAT proofs."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Note: include "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "import"},
           {"text": " "},
           {"text": "Std.Tactic.BVDecide"}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "replace",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.replace",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Acts like "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text": ", but removes a hypothesis with the same name as"},
        {"raw": "\n"},
        {"text": "this one if possible. For example, if the state is:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "f"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "α"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "β"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "α"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "⊢"},
           {"text": " "},
           {"text": "goal"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Then after "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "replace"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "h"}]]},
        {"text": " the state will be:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "f"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "α"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "β"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "β"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "⊢"},
           {"text": " "},
           {"text": "goal"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "whereas "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "have"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "h"}]]},
        {"text": " would result in:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "f"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "α"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "β"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "h†"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "α"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "β"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "⊢"},
           {"text": " "},
           {"text": "goal"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "This can be used to simulate the "},
        {"element": ["code", true, [], [{"text": "specialize"}]]},
        {"text": " and "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "apply"}, {"text": " "}, {"text": "at"}]]},
        {"text": " tactics of Coq."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "rw",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.rwSeq",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "rw"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "rewrite"}]]},
        {"text":
         ", but also tries to close the goal by \"cheap\" (reducible) "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#rfl"]],
             [{"text": "rfl"}]]}]]},
        {"text": " afterwards."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "simp",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.simp",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text":
         " tactic uses lemmas and hypotheses to simplify the main goal target or"},
        {"raw": "\n"},
        {"text": "non-dependent hypotheses. It has many variants:"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "simp"}]]},
           {"text":
            " simplifies the main goal target using lemmas tagged with the attribute "},
           {"element": ["code", true, [], [{"text": "[simp]"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simp"},
              {"text": " "},
              {"text": "[h₁,"},
              {"text": " "},
              {"text": "h₂,"},
              {"text": " "},
              {"text": "...,"},
              {"text": " "},
              {"text": "hₙ]"}]]},
           {"text": " simplifies the main goal target using the lemmas tagged"},
           {"raw": "\n"},
           {"text": "with the attribute "},
           {"element": ["code", true, [], [{"text": "[simp]"}]]},
           {"text": " and the given "},
           {"element": ["code", true, [], [{"text": "hᵢ"}]]},
           {"text": "'s, where the "},
           {"element": ["code", true, [], [{"text": "hᵢ"}]]},
           {"text": "'s are expressions.-"}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "If an "},
           {"element": ["code", true, [], [{"text": "hᵢ"}]]},
           {"text": " is a defined constant "},
           {"element": ["code", true, [], [{"text": "f"}]]},
           {"text": ", then "},
           {"element": ["code", true, [], [{"text": "f"}]]},
           {"text": " is unfolded. If "},
           {"element": ["code", true, [], [{"text": "f"}]]},
           {"text": " has equational lemmas associated"},
           {"raw": "\n"},
           {"text": "with it (and is not a projection or a "},
           {"element": ["code", true, [], [{"text": "reducible"}]]},
           {"text": " definition), these are used to rewrite with "},
           {"element": ["code", true, [], [{"text": "f"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simp"}, {"text": " "}, {"text": "[*]"}]]},
           {"text":
            " simplifies the main goal target using the lemmas tagged with the"},
           {"raw": "\n"},
           {"text": "attribute "},
           {"element": ["code", true, [], [{"text": "[simp]"}]]},
           {"text": " and all hypotheses."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simp"},
              {"text": " "},
              {"text": "only"},
              {"text": " "},
              {"text": "[h₁,"},
              {"text": " "},
              {"text": "h₂,"},
              {"text": " "},
              {"text": "...,"},
              {"text": " "},
              {"text": "hₙ]"}]]},
           {"text": " is like "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "simp"},
              {"text": " "},
              {"text": "[h₁,"},
              {"text": " "},
              {"text": "h₂,"},
              {"text": " "},
              {"text": "...,"},
              {"text": " "},
              {"text": "hₙ]"}]]},
           {"text": " but does not use "},
           {"element": ["code", true, [], [{"text": "[simp]"}]]},
           {"text": " lemmas."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simp"},
              {"text": " "},
              {"text": "[-id₁,"},
              {"text": " "},
              {"text": "...,"},
              {"text": " "},
              {"text": "-idₙ]"}]]},
           {"text": " simplifies the main goal target using the lemmas tagged"},
           {"raw": "\n"},
           {"text": "with the attribute "},
           {"element": ["code", true, [], [{"text": "[simp]"}]]},
           {"text": ", but removes the ones named "},
           {"element": ["code", true, [], [{"text": "idᵢ"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simp"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "h₁"},
              {"text": " "},
              {"text": "h₂"},
              {"text": " "},
              {"text": "..."},
              {"text": " "},
              {"text": "hₙ"}]]},
           {"text": " simplifies the hypotheses "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h₁"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "T₁"}]]},
           {"text": " ... "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "hₙ"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "Tₙ"}]]},
           {"text": ". If"},
           {"raw": "\n"},
           {"text": "the target or another hypothesis depends on "},
           {"element": ["code", true, [], [{"text": "hᵢ"}]]},
           {"text": ", a new simplified hypothesis"},
           {"raw": "\n"},
           {"element": ["code", true, [], [{"text": "hᵢ"}]]},
           {"text":
            " is introduced, but the old one remains in the local context."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simp"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "*"}]]},
           {"text": " simplifies all the hypotheses and the target."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simp"},
              {"text": " "},
              {"text": "[*]"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "*"}]]},
           {"text":
            " simplifies target and all (propositional) hypotheses using the"},
           {"raw": "\n"},
           {"text": "other hypotheses."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "exists",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.«tacticExists_,,»",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "exists"},
           {"text": " "},
           {"text": "e₁,"},
           {"text": " "},
           {"text": "e₂,"},
           {"text": " "},
           {"text": "..."}]]},
        {"text": " is shorthand for "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "refine"},
           {"text": " "},
           {"text": "⟨e₁,"},
           {"text": " "},
           {"text": "e₂,"},
           {"text": " "},
           {"text": "...⟩;"},
           {"text": " "},
           {"text": "try"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Core.html#trivial"]],
             [{"text": "trivial"}]]}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "It is useful for existential goals."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "symm_saturate",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.symmSaturate",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "For every hypothesis "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": "~"},
           {"text": " "},
           {"text": "b"}]]},
        {"text": " where a "},
        {"element": ["code", true, [], [{"text": "@[symm]"}]]},
        {"text": " lemma is available,"},
        {"raw": "\n"},
        {"text": "add a hypothesis "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h_symm"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "~"},
           {"text": " "},
           {"text": "a"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "ac_nf0",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.acNf0",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Implementation of "},
        {"element": ["code", true, [], [{"text": "ac_nf"}]]},
        {"text": " (the full "},
        {"element": ["code", true, [], [{"text": "ac_nf"}]]},
        {"text": " calls "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Core.html#trivial"]],
             [{"text": "trivial"}]]}]]},
        {"text": " afterwards)."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "exfalso",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticExfalso",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "exfalso"}]]},
        {"text": " converts a goal "},
        {"element":
         ["code", true, [], [{"text": "⊢"}, {"text": " "}, {"text": "tgt"}]]},
        {"text": " into "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⊢"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#False"]],
             [{"text": "False"}]]}]]},
        {"text": " by applying "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#False.elim"]],
             [{"text": "False.elim"}]]}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "rename_i",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.renameI",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "rename_i"},
           {"text": " "},
           {"text": "x_1"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "x_n"}]]},
        {"text": " renames the last "},
        {"element": ["code", true, [], [{"text": "n"}]]},
        {"text": " inaccessible names using the given names."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "skip",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.skip",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "skip"}]]},
        {"text": " does nothing."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "trace",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.traceMessage",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "trace"}, {"text": " "}, {"text": "msg"}]]},
        {"text": " displays "},
        {"element": ["code", true, [], [{"text": "msg"}]]},
        {"text": " in the info view."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mstop",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mstopMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Stops the stateful proof mode of "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text":
         "This will simply forget all the names given to stateful hypotheses and pretty-print"},
        {"raw": "\n"},
        {"text": "a bit differently."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "(",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.paren",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "(tacs)"}]]},
        {"text":
         " executes a list of tactics in sequence, without requiring that"},
        {"raw": "\n"},
        {"text": "the goal be closed at the end like "},
        {"element":
         ["code", true, [], [{"text": "·"}, {"text": " "}, {"text": "tacs"}]]},
        {"text": ". Like "},
        {"element": ["code", true, [], [{"text": "by"}]]},
        {"text": " itself, the tactics"},
        {"raw": "\n"},
        {"text": "can be either separated by newlines or "},
        {"element": ["code", true, [], [{"text": ";"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "repeat",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticRepeat_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "repeat"}, {"text": " "}, {"text": "tac"}]]},
        {"text": " repeatedly applies "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " so long as it succeeds."},
        {"raw": "\n"},
        {"text": "The tactic "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " may be a tactic sequence, and if "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " fails at any point in its execution,"},
        {"raw": "\n"},
        {"element": ["code", true, [], [{"text": "repeat"}]]},
        {"text": " will revert any partial changes that "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " made to the tactic state."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "The tactic "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " should eventually fail, otherwise "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "repeat"}, {"text": " "}, {"text": "tac"}]]},
        {"text": " will run indefinitely."}]]},
     {"element": ["p", true, [], [{"text": "See also:"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "try"}, {"text": " "}, {"text": "tac"}]]},
           {"text": " is like "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "repeat"}, {"text": " "}, {"text": "tac"}]]},
           {"text": " but will apply "},
           {"element": ["code", true, [], [{"text": "tac"}]]},
           {"text": " at most once."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "repeat'"}, {"text": " "}, {"text": "tac"}]]},
           {"text": " recursively applies "},
           {"element": ["code", true, [], [{"text": "tac"}]]},
           {"text": " to each goal."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "first"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "tac1"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "tac2"}]]},
           {"text": " implements the backtracking used by "},
           {"element": ["code", true, [], [{"text": "repeat"}]]}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "dsimp?",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.dsimpTrace",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "simp?"}]]},
        {"text": " takes the same arguments as "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": ", but reports an equivalent call to "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "simp"}, {"text": " "}, {"text": "only"}]]},
        {"raw": "\n"},
        {"text":
         "that would be sufficient to close the goal. This is useful for reducing the size of the simp"},
        {"raw": "\n"},
        {"text": "set in a local invocation to speed up processing."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "example"},
           {"text": " "},
           {"text": "(x"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "(if"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#True"]],
             [{"text": "True"}]]},
           {"text": " "},
           {"text": "then"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": "else"},
           {"text": " "},
           {"text": "3)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "simp?"},
           {"text": " "},
           {"text": "--"},
           {"text": " "},
           {"text": "prints"},
           {"text": " "},
           {"text": "\"Try"},
           {"text": " "},
           {"text": "this:"},
           {"text": " "},
           {"text": "simp"},
           {"text": " "},
           {"text": "only"},
           {"text": " "},
           {"text": "[ite_true]\""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "This command can also be used in "},
        {"element": ["code", true, [], [{"text": "simp_all"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "dsimp"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "decide",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.decide",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "decide"}]]},
        {"text": " attempts to prove the main goal (with target type "},
        {"element": ["code", true, [], [{"text": "p"}]]},
        {"text": ") by synthesizing an instance of "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Decidable"]],
             [{"text": "Decidable"}]]},
           {"text": " "},
           {"text": "p"}]]},
        {"raw": "\n"},
        {"text":
         "and then reducing that instance to evaluate the truth value of "},
        {"element": ["code", true, [], [{"text": "p"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "If it reduces to "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "isTrue"}, {"text": " "}, {"text": "h"}]]},
        {"text": ", then "},
        {"element": ["code", true, [], [{"text": "h"}]]},
        {"text": " is a proof of "},
        {"element": ["code", true, [], [{"text": "p"}]]},
        {"text": " that closes the goal."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "The target is not allowed to contain local variables or metavariables."},
        {"raw": "\n"},
        {"text": "If there are local variables, you can first try using the "},
        {"element": ["code", true, [], [{"text": "revert"}]]},
        {"text":
         " tactic with these local variables to move them into the target,"},
        {"raw": "\n"},
        {"text": "or you can use the "},
        {"element": ["code", true, [], [{"text": "+revert"}]]},
        {"text": " option, described below."}]]},
     {"element": ["p", true, [], [{"text": "Options:"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "decide"}, {"text": " "}, {"text": "+revert"}]]},
           {"text":
            " begins by reverting local variables that the target depends on,"},
           {"raw": "\n"},
           {"text":
            "after cleaning up the local context of irrelevant variables."},
           {"raw": "\n"},
           {"text": "A variable is "},
           {"element": ["em", true, [], [{"text": "relevant"}]]},
           {"text":
            " if it appears in the target, if it appears in a relevant variable,"},
           {"raw": "\n"},
           {"text":
            "or if it is a proposition that refers to a relevant variable."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "decide"}, {"text": " "}, {"text": "+kernel"}]]},
           {"text": " uses kernel for reduction instead of the elaborator."},
           {"raw": "\n"},
           {"text":
            "It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,"},
           {"raw": "\n"},
           {"text": "and (2) it reduces the "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#Decidable"]],
                [{"text": "Decidable"}]]}]]},
           {"text": " instance only once instead of twice."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "decide"}, {"text": " "}, {"text": "+native"}]]},
           {"text": " uses the native code compiler ("},
           {"element": ["code", true, [], [{"text": "#eval"}]]},
           {"text": ") to evaluate the "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#Decidable"]],
                [{"text": "Decidable"}]]}]]},
           {"text": " instance,"},
           {"raw": "\n"},
           {"text":
            "admitting the result via an axiom. This can be significantly more efficient than using reduction, but it is at the cost of increasing the size"},
           {"raw": "\n"},
           {"text":
            "This can be significantly more efficient than using reduction, but it is at the cost of increasing the size"},
           {"raw": "\n"},
           {"text": "of the trusted code base."},
           {"raw": "\n"},
           {"text":
            "Namely, it depends on the correctness of the Lean compiler and all definitions with an "},
           {"element": ["code", true, [], [{"text": "@[implemented_by]"}]]},
           {"text": " attribute."},
           {"raw": "\n"},
           {"text": "Like with "},
           {"element": ["code", true, [], [{"text": "+kernel"}]]},
           {"text": ", the "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#Decidable"]],
                [{"text": "Decidable"}]]}]]},
           {"text": " instance is evaluated only once."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Limitation: In the default mode or "},
        {"element": ["code", true, [], [{"text": "+kernel"}]]},
        {"text": " mode, since "},
        {"element": ["code", true, [], [{"text": "decide"}]]},
        {"text": " uses reduction to evaluate the term,"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Decidable"]],
             [{"text": "Decidable"}]]}]]},
        {"text":
         " instances defined by well-founded recursion might not work because evaluating them requires reducing proofs."},
        {"raw": "\n"},
        {"text": "Reduction can also get stuck on "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Decidable"]],
             [{"text": "Decidable"}]]}]]},
        {"text": " instances with "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Eq.rec"]],
             [{"text": "Eq.rec"}]]}]]},
        {"text": " terms."},
        {"raw": "\n"},
        {"text":
         "These can appear in instances defined using tactics (such as "},
        {"element": ["code", true, [], [{"text": "rw"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": ")."},
        {"raw": "\n"},
        {"text":
         "To avoid this, create such instances using definitions such as "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/PropLemmas.html#decidable_of_iff"]],
             [{"text": "decidable_of_iff"}]]}]]},
        {"text": " instead."}]]},
     {"element":
      ["h2",
       true,
       [["id", "Examples"], ["class", "markdown-heading"]],
       [{"text": "Examples"},
        {"text": " "},
        {"element":
         ["a",
          true,
          [["class", "hover-link"], ["href", "#Examples"]],
          [{"text": "#"}]]}]]},
     {"element": ["p", true, [], [{"text": "Proving inequalities:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": "≠"},
           {"text": " "},
           {"text": "5"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "decide"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p", true, [], [{"text": "Trying to prove a false proposition:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "1"},
           {"text": " "},
           {"text": "≠"},
           {"text": " "},
           {"text": "1"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "decide"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "/-"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "tactic"},
           {"text": " "},
           {"text": "'decide'"},
           {"text": " "},
           {"text": "proved"},
           {"text": " "},
           {"text": "that"},
           {"text": " "},
           {"text": "the"},
           {"text": " "},
           {"text": "proposition"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "1"},
           {"text": " "},
           {"text": "≠"},
           {"text": " "},
           {"text": "1"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "is"},
           {"text": " "},
           {"text": "false"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "-/"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Trying to prove a proposition whose "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Decidable"]],
             [{"text": "Decidable"}]]}]]},
        {"text": " instance fails to reduce"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "opaque"},
           {"text": " "},
           {"text": "unknownProp"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Prop"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "open"},
           {"text": " "},
           {"text": "scoped"},
           {"text": " "},
           {"text": "Classical"},
           {"text": " "},
           {"text": "in"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "unknownProp"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "decide"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "/-"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "tactic"},
           {"text": " "},
           {"text": "'decide'"},
           {"text": " "},
           {"text": "failed"},
           {"text": " "},
           {"text": "for"},
           {"text": " "},
           {"text": "proposition"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "unknownProp"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "since"},
           {"text": " "},
           {"text": "its"},
           {"text": " "},
           {"text": "'Decidable'"},
           {"text": " "},
           {"text": "instance"},
           {"text": " "},
           {"text": "reduced"},
           {"text": " "},
           {"text": "to"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Classical.choice"]],
             [{"text": "Classical.choice"}]]},
           {"text": " "},
           {"text": "⋯"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "rather"},
           {"text": " "},
           {"text": "than"},
           {"text": " "},
           {"text": "to"},
           {"text": " "},
           {"text": "the"},
           {"text": " "},
           {"text": "'isTrue'"},
           {"text": " "},
           {"text": "constructor."},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "-/"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["h2",
       true,
       [["id", "Properties-and-relations"], ["class", "markdown-heading"]],
       [{"text": "Properties and relations"},
        {"text": " "},
        {"element":
         ["a",
          true,
          [["class", "hover-link"], ["href", "#Properties-and-relations"]],
          [{"text": "#"}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "For equality goals for types with decidable equality, usually "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#rfl"]],
             [{"text": "rfl"}]]}]]},
        {"text": " can be used in place of "},
        {"element": ["code", true, [], [{"text": "decide"}]]},
        {"text": "."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "1"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "1"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "decide"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "1"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "1"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#rfl"]],
             [{"text": "rfl"}]]},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "false_or_by_contra",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.falseOrByContra",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Changes the goal to "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#False"]],
             [{"text": "False"}]]}]]},
        {"text": ", retaining as much information as possible:"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"text": "If the goal is "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#False"]],
                [{"text": "False"}]]}]]},
           {"text": ", do nothing."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text":
            "If the goal is an implication or a function type, introduce the argument and restart."},
           {"raw": "\n"},
           {"text": "(In particular, if the goal is "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "x"},
              {"text": " "},
              {"text": "≠"},
              {"text": " "},
              {"text": "y"}]]},
           {"text": ", introduce "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "x"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "y"}]]},
           {"text": ".)"}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Otherwise, for a propositional goal "},
           {"element": ["code", true, [], [{"text": "P"}]]},
           {"text": ", replace it with "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "¬"},
              {"text": " "},
              {"text": "¬"},
              {"text": " "},
              {"text": "P"}]]},
           {"raw": "\n"},
           {"text": "(attempting to find a "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#Decidable"]],
                [{"text": "Decidable"}]]}]]},
           {"text":
            " instance, but otherwise falling back to working classically)"},
           {"raw": "\n"},
           {"text": "and introduce "},
           {"element":
            ["code", true, [], [{"text": "¬"}, {"text": " "}, {"text": "P"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "For a non-propositional goal use "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#False.elim"]],
                [{"text": "False.elim"}]]}]]},
           {"text": "."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "nomatch",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.«tacticNomatch_,,»",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The tactic "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "nomatch"}, {"text": " "}, {"text": "h"}]]},
        {"text": " is shorthand for "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "exact"},
           {"text": " "},
           {"text": "nomatch"},
           {"text": " "},
           {"text": "h"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "native_decide",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.nativeDecide",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "native_decide"}]]},
        {"text": " is a synonym for "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "decide"}, {"text": " "}, {"text": "+native"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "It will attempt to prove a goal of type "},
        {"element": ["code", true, [], [{"text": "p"}]]},
        {"text": " by synthesizing an instance"},
        {"raw": "\n"},
        {"text": "of "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Decidable"]],
             [{"text": "Decidable"}]]},
           {"text": " "},
           {"text": "p"}]]},
        {"text": " and then evaluating it to "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "isTrue"}, {"text": " "}, {"text": ".."}]]},
        {"text": ". Unlike "},
        {"element": ["code", true, [], [{"text": "decide"}]]},
        {"text": ", this"},
        {"raw": "\n"},
        {"text": "uses "},
        {"element": ["code", true, [], [{"text": "#eval"}]]},
        {"text": " to evaluate the decidability instance."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "This should be used with care because it adds the entire lean compiler to the trusted"},
        {"raw": "\n"},
        {"text": "part, and a new axiom will show up in "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "#print"}, {"text": " "}, {"text": "axioms"}]]},
        {"text": " for theorems using"},
        {"raw": "\n"},
        {"text":
         "this method or anything that transitively depends on them. Nevertheless, because it is"},
        {"raw": "\n"},
        {"text":
         "compiled, this can be significantly more efficient than using "},
        {"element": ["code", true, [], [{"text": "decide"}]]},
        {"text": ", and for very"},
        {"raw": "\n"},
        {"text":
         "large computations this is one way to run external programs and trust the result."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "(List.range"},
           {"text": " "},
           {"text": "1000).length"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "1000"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "native_decide"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "unhygienic",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticUnhygienic_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "unhygienic"}, {"text": " "}, {"text": "tacs"}]]},
        {"text": " runs "},
        {"element": ["code", true, [], [{"text": "tacs"}]]},
        {"text": " with name hygiene disabled."},
        {"raw": "\n"},
        {"text":
         "This means that tactics that would normally create inaccessible names will instead"},
        {"raw": "\n"},
        {"text": "make regular variables. "},
        {"element": ["strong", true, [], [{"text": "Warning"}]]},
        {"text": ": Tactics may change their variable naming"},
        {"raw": "\n"},
        {"text":
         "strategies at any time, so code that depends on autogenerated names is brittle."},
        {"raw": "\n"},
        {"text": "Users should try not to use "},
        {"element": ["code", true, [], [{"text": "unhygienic"}]]},
        {"text": " if possible."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "∀"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat,"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "unhygienic"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "intro"},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": "--"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "would"},
           {"text": " "},
           {"text": "normally"},
           {"text": " "},
           {"text": "be"},
           {"text": " "},
           {"text": "intro'd"},
           {"text": " "},
           {"text": "as"},
           {"text": " "},
           {"text": "inaccessible"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "exact"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Eq.refl"]],
             [{"text": "Eq.refl"}]]},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": "--"},
           {"text": " "},
           {"text": "refer"},
           {"text": " "},
           {"text": "to"},
           {"text": " "},
           {"text": "x"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "dsimp",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.dsimp",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "dsimp"}]]},
        {"text": " tactic is the definitional simplifier. It is similar to "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": " but only"},
        {"raw": "\n"},
        {"text":
         "applies theorems that hold by reflexivity. Thus, the result is guaranteed to be"},
        {"raw": "\n"},
        {"text": "definitionally equal to the input."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "injection",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.injection",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "injection"}]]},
        {"text":
         " tactic is based on the fact that constructors of inductive data"},
        {"raw": "\n"},
        {"text": "types are injections."},
        {"raw": "\n"},
        {"text": "That means that if "},
        {"element": ["code", true, [], [{"text": "c"}]]},
        {"text": " is a constructor of an inductive datatype, and if "},
        {"element":
         ["code", true, [], [{"text": "(c"}, {"text": " "}, {"text": "t₁)"}]]},
        {"raw": "\n"},
        {"text": "and "},
        {"element":
         ["code", true, [], [{"text": "(c"}, {"text": " "}, {"text": "t₂)"}]]},
        {"text": " are two terms that are equal then  "},
        {"element": ["code", true, [], [{"text": "t₁"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "t₂"}]]},
        {"text": " are equal too."},
        {"raw": "\n"},
        {"text": "If "},
        {"element": ["code", true, [], [{"text": "q"}]]},
        {"text": " is a proof of a statement of conclusion "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "t₁"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "t₂"}]]},
        {"text": ", then injection applies"},
        {"raw": "\n"},
        {"text": "injectivity to derive the equality of all arguments of "},
        {"element": ["code", true, [], [{"text": "t₁"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "t₂"}]]},
        {"text": " placed in"},
        {"raw": "\n"},
        {"text": "the same positions. For example, from "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "(a::b)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "(c::d)"}]]},
        {"text": " we derive "},
        {"element": ["code", true, [], [{"text": "a=c"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "b=d"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "To use this tactic "},
        {"element": ["code", true, [], [{"text": "t₁"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "t₂"}]]},
        {"text":
         " should be constructor applications of the same constructor."},
        {"raw": "\n"},
        {"text": "Given "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "a::b"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "c::d"}]]},
        {"text": ", the tactic "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "injection"}, {"text": " "}, {"text": "h"}]]},
        {"text": " adds two new hypothesis with types"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "a"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "c"}]]},
        {"text": " and "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "b"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "d"}]]},
        {"text": " to the main goal."},
        {"raw": "\n"},
        {"text": "The tactic "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "injection"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "h₁"},
           {"text": " "},
           {"text": "h₂"}]]},
        {"text": " uses the names "},
        {"element": ["code", true, [], [{"text": "h₁"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "h₂"}]]},
        {"text": " to name the new hypotheses."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "bv_normalize",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.bvNormalizeMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Run the normalization procedure of "},
        {"element": ["code", true, [], [{"text": "bv_decide"}]]},
        {"text": " only. Sometimes this is enough to solve basic"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#BitVec"]],
             [{"text": "BitVec"}]]}]]},
        {"text": " goals already."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Note: include "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "import"},
           {"text": " "},
           {"text": "Std.Tactic.BVDecide"}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mrename_i",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mrenameIMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mrename_i"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "rename_i"}]]},
        {"text": ", but names inaccessible stateful hypotheses in a "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mright",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mrightMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mright"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "right"}]]},
        {"text": ", but operating on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "∨"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HP"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mright"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HP"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "show",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.show",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code", true, [], [{"text": "show"}, {"text": " "}, {"text": "t"}]]},
        {"text": " finds the first goal whose target unifies with "},
        {"element": ["code", true, [], [{"text": "t"}]]},
        {"text": ". It makes that the main goal,"},
        {"raw": "\n"},
        {"text":
         "performs the unification, and replaces the target with the unified version of "},
        {"element": ["code", true, [], [{"text": "t"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "case",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.case",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "case"},
              {"text": " "},
              {"text": "tag"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "tac"}]]},
           {"text": " focuses on the goal with case name "},
           {"element": ["code", true, [], [{"text": "tag"}]]},
           {"text": " and solves it using "},
           {"element": ["code", true, [], [{"text": "tac"}]]},
           {"text": ","},
           {"raw": "\n"},
           {"text": "or else fails."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "case"},
              {"text": " "},
              {"text": "tag"},
              {"text": " "},
              {"text": "x₁"},
              {"text": " "},
              {"text": "..."},
              {"text": " "},
              {"text": "xₙ"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "tac"}]]},
           {"text": " additionally renames the "},
           {"element": ["code", true, [], [{"text": "n"}]]},
           {"text": " most recent hypotheses"},
           {"raw": "\n"},
           {"text": "with inaccessible names to the given names."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "case"},
              {"text": " "},
              {"text": "tag₁"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "tag₂"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "tac"}]]},
           {"text": " is equivalent to "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "(case"},
              {"text": " "},
              {"text": "tag₁"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "tac);"},
              {"text": " "},
              {"text": "(case"},
              {"text": " "},
              {"text": "tag₂"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "tac)"}]]},
           {"text": "."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "dsimp?!",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticDsimp?!_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "simp?"}]]},
        {"text": " takes the same arguments as "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": ", but reports an equivalent call to "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "simp"}, {"text": " "}, {"text": "only"}]]},
        {"raw": "\n"},
        {"text":
         "that would be sufficient to close the goal. This is useful for reducing the size of the simp"},
        {"raw": "\n"},
        {"text": "set in a local invocation to speed up processing."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "example"},
           {"text": " "},
           {"text": "(x"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "(if"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#True"]],
             [{"text": "True"}]]},
           {"text": " "},
           {"text": "then"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": "else"},
           {"text": " "},
           {"text": "3)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "simp?"},
           {"text": " "},
           {"text": "--"},
           {"text": " "},
           {"text": "prints"},
           {"text": " "},
           {"text": "\"Try"},
           {"text": " "},
           {"text": "this:"},
           {"text": " "},
           {"text": "simp"},
           {"text": " "},
           {"text": "only"},
           {"text": " "},
           {"text": "[ite_true]\""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "This command can also be used in "},
        {"element": ["code", true, [], [{"text": "simp_all"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "dsimp"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "as_aux_lemma",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.as_aux_lemma",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "as_aux_lemma"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "tac"}]]},
        {"text": " does the same as "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": ", except that it wraps the resulting expression"},
        {"raw": "\n"},
        {"text":
         "into an auxiliary lemma. In some cases, this significantly reduces the size of expressions"},
        {"raw": "\n"},
        {"text": "because the proof term is not duplicated."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "have",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticHave__",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text":
         " tactic is for adding opaque definitions and hypotheses to the local context of the main goal."},
        {"raw": "\n"},
        {"text":
         "The definitions forget their associated value and cannot be unfolded, unlike definitions added by the "},
        {"element": ["code", true, [], [{"text": "let"}]]},
        {"text": " tactic."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "have"},
              {"text": " "},
              {"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "t"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " adds the hypothesis "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "t"}]]},
           {"text": " if "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " is a term of type "},
           {"element": ["code", true, [], [{"text": "t"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "have"},
              {"text": " "},
              {"text": "h"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " uses the type of "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " for "},
           {"element": ["code", true, [], [{"text": "t"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "have"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "t"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " and "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "have"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " use "},
           {"element": ["code", true, [], [{"text": "this"}]]},
           {"text": " for the name of the hypothesis."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "have"},
              {"text": " "},
              {"text": "pat"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " for a pattern "},
           {"element": ["code", true, [], [{"text": "pat"}]]},
           {"text": " is equivalent to "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "match"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "with"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "pat"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "_"}]]},
           {"text": ","},
           {"raw": "\n"},
           {"text": "where "},
           {"element": ["code", true, [], [{"text": "_"}]]},
           {"text": " stands for the tactics that follow this one."},
           {"raw": "\n"},
           {"text":
            "It is convenient for types that have only one applicable constructor."},
           {"raw": "\n"},
           {"text": "For example, given "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "p"},
              {"text": " "},
              {"text": "∧"},
              {"text": " "},
              {"text": "q"},
              {"text": " "},
              {"text": "∧"},
              {"text": " "},
              {"text": "r"}]]},
           {"text": ", "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "have"},
              {"text": " "},
              {"text": "⟨h₁,"},
              {"text": " "},
              {"text": "h₂,"},
              {"text": " "},
              {"text": "h₃⟩"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "h"}]]},
           {"text": " produces the"},
           {"raw": "\n"},
           {"text": "hypotheses "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h₁"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "p"}]]},
           {"text": ", "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h₂"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "q"}]]},
           {"text": ", and "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h₃"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "r"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "The syntax "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "have"},
              {"text": " "},
              {"text": "(eq"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "h)"},
              {"text": " "},
              {"text": "pat"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " is equivalent to "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "match"},
              {"text": " "},
              {"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "with"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "pat"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "_"}]]},
           {"text": ","},
           {"raw": "\n"},
           {"text": "which adds the equation "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "pat"}]]},
           {"text": " to the local context."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "The tactic supports all the same syntax variants and options as the "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text": " term."}]]},
     {"element":
      ["h2",
       true,
       [["id", "Properties-and-relations"], ["class", "markdown-heading"]],
       [{"text": "Properties and relations"},
        {"text": " "},
        {"element":
         ["a",
          true,
          [["class", "hover-link"], ["href", "#Properties-and-relations"]],
          [{"text": "#"}]]}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"text":
            "It is not possible to unfold a variable introduced using "},
           {"element": ["code", true, [], [{"text": "have"}]]},
           {"text": ", since the definition's value is forgotten."},
           {"raw": "\n"},
           {"text": "The "},
           {"element": ["code", true, [], [{"text": "let"}]]},
           {"text": " tactic introduces definitions that can be unfolded."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "The "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "have"},
              {"text": " "},
              {"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "t"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " is like doing "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "let"},
              {"text": " "},
              {"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "t"},
              {"text": " "},
              {"text": ":="},
              {"text": " "},
              {"text": "e;"},
              {"text": " "},
              {"text": "clear_value"},
              {"text": " "},
              {"text": "h"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "The "},
           {"element": ["code", true, [], [{"text": "have"}]]},
           {"text": " tactic is preferred for propositions, and "},
           {"element": ["code", true, [], [{"text": "let"}]]},
           {"text": " is preferred for non-propositions."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Sometimes "},
           {"element": ["code", true, [], [{"text": "have"}]]},
           {"text":
            " is used for non-propositions to ensure that the variable is never unfolded,"},
           {"raw": "\n"},
           {"text": "which may be important for performance reasons."},
           {"raw": "\n"},
           {"text": "Consider using the equivalent "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "let"}, {"text": " "}, {"text": "+nondep"}]]},
           {"text": " to indicate the intent."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "assumption_mod_cast",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticAssumption_mod_cast_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "assumption_mod_cast"}]]},
        {"text": " is a variant of "},
        {"element": ["code", true, [], [{"text": "assumption"}]]},
        {"text": " that solves the goal"},
        {"raw": "\n"},
        {"text": "using a hypothesis. Unlike "},
        {"element": ["code", true, [], [{"text": "assumption"}]]},
        {"text": ", it first pre-processes the goal and"},
        {"raw": "\n"},
        {"text":
         "each hypothesis to move casts as far outwards as possible, so it can be used"},
        {"raw": "\n"},
        {"text": "in more situations."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Concretely, it runs "},
        {"element": ["code", true, [], [{"text": "norm_cast"}]]},
        {"text": " on the goal. For each local hypothesis "},
        {"element": ["code", true, [], [{"text": "h"}]]},
        {"text": ", it also"},
        {"raw": "\n"},
        {"text": "normalizes "},
        {"element": ["code", true, [], [{"text": "h"}]]},
        {"text": " with "},
        {"element": ["code", true, [], [{"text": "norm_cast"}]]},
        {"text": " and tries to use that to close the goal."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "get_elem_tactic_trivial",
  "tags": [],
  "internalName": "tacticGet_elem_tactic_trivial",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "get_elem_tactic_trivial"}]]},
        {"text": " has been deprecated in favour of "},
        {"element":
         ["code", true, [], [{"text": "get_elem_tactic_extensible"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "ac_nf",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticAc_nf_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "ac_nf"}]]},
        {"text":
         " normalizes equalities up to application of an associative and commutative operator."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "ac_nf"}]]},
           {"text":
            " normalizes all hypotheses and the goal target of the goal."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "ac_nf"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "l"}]]},
           {"text": " normalizes at location(s) "},
           {"element": ["code", true, [], [{"text": "l"}]]},
           {"text": ", where "},
           {"element": ["code", true, [], [{"text": "l"}]]},
           {"text": " is either "},
           {"element": ["code", true, [], [{"text": "*"}]]},
           {"text": " or a"},
           {"raw": "\n"},
           {"text":
            "list of hypotheses in the local context. In the latter case, a turnstile "},
           {"element": ["code", true, [], [{"text": "⊢"}]]},
           {"text": " or "},
           {"element": ["code", true, [], [{"text": "|-"}]]},
           {"raw": "\n"},
           {"text":
            "can also be used, to signify the target of the goal."}]]}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "instance"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Core.html#Std.Associative"]],
             [{"text": "Std.Associative"}]]},
           {"text": " "},
           {"text": "(α"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": "(.+.)"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "⟨Nat.add_assoc⟩"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "instance"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Core.html#Std.Commutative"]],
             [{"text": "Std.Commutative"}]]},
           {"text": " "},
           {"text": "(α"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": "(.+.)"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "⟨Nat.add_comm⟩"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "example"},
           {"text": " "},
           {"text": "(a"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "c"},
           {"text": " "},
           {"text": "d"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "c"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "d"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "d"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "(b"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "c)"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "ac_nf"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "--"},
           {"text": " "},
           {"text": "goal:"},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "(b"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "(c"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "d))"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "(b"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "(c"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "d))"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "massumption",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.massumptionMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "massumption"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "assumption"}]]},
        {"text": ", but operating on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "_"},
           {"text": " "},
           {"text": "_"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "massumption"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mintro",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mintroMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Like "},
        {"element": ["code", true, [], [{"text": "intro"}]]},
        {"text":
         ", but introducing stateful hypotheses into the stateful context of the "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"raw": "\n"},
        {"text": "proof mode."},
        {"raw": "\n"},
        {"text": "That is, given a stateful goal "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "(hᵢ"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Hᵢ)*"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "T"}]]},
        {"text": ", "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "mintro"}, {"text": " "}, {"text": "h"}]]},
        {"text": " transforms"},
        {"raw": "\n"},
        {"text": "into "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "(hᵢ"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Hᵢ)*,"},
           {"text": " "},
           {"text": "(h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P)"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "T"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Furthermore, "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "mintro"}, {"text": " "}, {"text": "∀s"}]]},
        {"text": " is like "},
        {"element":
         ["code", true, [], [{"text": "intro"}, {"text": " "}, {"text": "s"}]]},
        {"text": ", but preserves the stateful goal."},
        {"raw": "\n"},
        {"text": "That is, "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "mintro"}, {"text": " "}, {"text": "∀s"}]]},
        {"text": " brings the topmost state variable "},
        {"element": ["code", true, [], [{"text": "s:σ"}]]},
        {"text": " in scope and transforms"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "(hᵢ"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Hᵢ)*"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "T"}]]},
        {"text": " (where the entailment is in "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "Std.Do.SPred"}, {"text": " "}, {"text": "(σ::σs)"}]]},
        {"text": ") into"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "(hᵢ"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Hᵢ"},
           {"text": " "},
           {"text": "s)*"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "T"},
           {"text": " "},
           {"text": "s"}]]},
        {"text": " (where the entailment is in "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "Std.Do.SPred"}, {"text": " "}, {"text": "σs"}]]},
        {"text": ")."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Beyond that, "},
        {"element": ["code", true, [], [{"text": "mintro"}]]},
        {"text": " supports the full syntax of "},
        {"element": ["code", true, [], [{"text": "mcases"}]]},
        {"text": " patterns"},
        {"raw": "\n"},
        {"text": "("},
        {"element":
         ["code",
          true,
          [],
          [{"text": "mintro"},
           {"text": " "},
           {"text": "pat"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "(mintro"},
           {"text": " "},
           {"text": "h;"},
           {"text": " "},
           {"text": "mcases"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "pat"}]]},
        {"text": "), and can perform multiple"},
        {"raw": "\n"},
        {"text": "introductions in sequence."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "next",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.«tacticNext_=>_»",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "next"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "tac"}]]},
        {"text": " focuses on the next goal and solves it using "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": ", or else fails."},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "next"},
           {"text": " "},
           {"text": "x₁"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "xₙ"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "tac"}]]},
        {"text": " additionally renames the "},
        {"element": ["code", true, [], [{"text": "n"}]]},
        {"text": " most recent hypotheses with"},
        {"raw": "\n"},
        {"text": "inaccessible names to the given names."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "if",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacIfThenElse",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "In tactic mode, "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "if"},
           {"text": " "},
           {"text": "t"},
           {"text": " "},
           {"text": "then"},
           {"text": " "},
           {"text": "tac1"},
           {"text": " "},
           {"text": "else"},
           {"text": " "},
           {"text": "tac2"}]]},
        {"text": " is alternative syntax for:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "by_cases"},
           {"text": " "},
           {"text": "t"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "·"},
           {"text": " "},
           {"text": "tac1"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "·"},
           {"text": " "},
           {"text": "tac2"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "It performs case distinction on "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h†"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "t"}]]},
        {"text": " or "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h†"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "¬t"}]]},
        {"text": ", where "},
        {"element": ["code", true, [], [{"text": "h†"}]]},
        {"text": " is an anonymous hypothesis, and"},
        {"raw": "\n"},
        {"element": ["code", true, [], [{"text": "tac1"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "tac2"}]]},
        {"text": " are the subproofs. (It doesn't actually use nondependent "},
        {"element": ["code", true, [], [{"text": "if"}]]},
        {"text": ", since this wouldn't"},
        {"raw": "\n"},
        {"text":
         "add anything to the context and hence would be useless for proving theorems. To actually insert an"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#ite"]],
             [{"text": "ite"}]]}]]},
        {"text": " application use "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "refine"},
           {"text": " "},
           {"text": "if"},
           {"text": " "},
           {"text": "t"},
           {"text": " "},
           {"text": "then"},
           {"text": " "},
           {"text": "?_"},
           {"text": " "},
           {"text": "else"},
           {"text": " "},
           {"text": "?_"}]]},
        {"text": ".)"}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "The assumptions in each subgoal can be named. "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "if"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "t"},
           {"text": " "},
           {"text": "then"},
           {"text": " "},
           {"text": "tac1"},
           {"text": " "},
           {"text": "else"},
           {"text": " "},
           {"text": "tac2"}]]},
        {"text": " can be used as"},
        {"raw": "\n"},
        {"text": "alternative syntax for:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "by_cases"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "t"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "·"},
           {"text": " "},
           {"text": "tac1"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "·"},
           {"text": " "},
           {"text": "tac2"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "It performs case distinction on "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "t"}]]},
        {"text": " or "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "¬t"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "You can use "},
        {"element": ["code", true, [], [{"text": "?_"}]]},
        {"text": " or "},
        {"element": ["code", true, [], [{"text": "_"}]]},
        {"text":
         " for either subproof to delay the goal to after the tactic, but"},
        {"raw": "\n"},
        {"text": "if a tactic sequence is provided for "},
        {"element": ["code", true, [], [{"text": "tac1"}]]},
        {"text": " or "},
        {"element": ["code", true, [], [{"text": "tac2"}]]},
        {"text": " then it will require the goal to be closed"},
        {"raw": "\n"},
        {"text": "by the end of the block."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "intros",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.intros",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "intros"}]]},
        {"text": " repeatedly applies "},
        {"element": ["code", true, [], [{"text": "intro"}]]},
        {"text": " to introduce zero or more hypotheses"},
        {"raw": "\n"},
        {"text": "until the goal is no longer a "},
        {"element": ["em", true, [], [{"text": "binding expression"}]]},
        {"raw": "\n"},
        {"text":
         "(i.e., a universal quantifier, function type, implication, or "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text": "/"},
        {"element": ["code", true, [], [{"text": "let"}]]},
        {"text": "),"},
        {"raw": "\n"},
        {"text":
         "without performing any definitional reductions (no unfolding, beta, eta, etc.)."},
        {"raw": "\n"},
        {"text":
         "The introduced hypotheses receive inaccessible (hygienic) names."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "intros"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "y"},
           {"text": " "},
           {"text": "z"}]]},
        {"text": " is equivalent to "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "intro"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "y"},
           {"text": " "},
           {"text": "z"}]]},
        {"text": " and exists only for historical reasons."},
        {"raw": "\n"},
        {"text": "The "},
        {"element": ["code", true, [], [{"text": "intro"}]]},
        {"text": " tactic should be preferred in this case."}]]},
     {"element":
      ["h2",
       true,
       [["id", "Properties-and-relations"], ["class", "markdown-heading"]],
       [{"text": "Properties and relations"},
        {"text": " "},
        {"element":
         ["a",
          true,
          [["class", "hover-link"], ["href", "#Properties-and-relations"]],
          [{"text": "#"}]]}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["p",
             true,
             [],
             [{"element": ["code", true, [], [{"text": "intros"}]]},
              {"text":
               " succeeds even when it introduces no hypotheses."}]]}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["p",
             true,
             [],
             [{"element":
               ["code",
                true,
                [],
                [{"text": "repeat"}, {"text": " "}, {"text": "intro"}]]},
              {"text": " is like "},
              {"element": ["code", true, [], [{"text": "intros"}]]},
              {"text": ", but it performs definitional reductions"},
              {"raw": "\n"},
              {"text":
               "to expose binders, and as such it may introduce more hypotheses than "},
              {"element": ["code", true, [], [{"text": "intros"}]]},
              {"text": "."}]]}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["p",
             true,
             [],
             [{"element": ["code", true, [], [{"text": "intros"}]]},
              {"text": " is equivalent to "},
              {"element":
               ["code",
                true,
                [],
                [{"text": "intro"},
                 {"text": " "},
                 {"text": "_"},
                 {"text": " "},
                 {"text": "_"},
                 {"text": " "},
                 {"text": "…"},
                 {"text": " "},
                 {"text": "_"}]]},
              {"text": ","},
              {"raw": "\n"},
              {"text": "with the fewest trailing "},
              {"element": ["code", true, [], [{"text": "_"}]]},
              {"text":
               " placeholders needed so that the goal is no longer a binding expression."},
              {"raw": "\n"},
              {"text":
               "The trailing introductions do not perform any definitional reductions."}]]}]]}]]},
     {"element":
      ["h2",
       true,
       [["id", "Examples"], ["class", "markdown-heading"]],
       [{"text": "Examples"},
        {"text": " "},
        {"element":
         ["a",
          true,
          [["class", "hover-link"], ["href", "#Examples"]],
          [{"text": "#"}]]}]]},
     {"element": ["p", true, [], [{"text": "Implications:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(p"},
           {"text": " "},
           {"text": "q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Prop)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "p"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "q"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "p"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "intros"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "/-"},
           {"text": " "},
           {"text": "Tactic"},
           {"text": " "},
           {"text": "state"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "a✝¹"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "p"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "a✝"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "q"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "⊢"},
           {"text": " "},
           {"text": "p"},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": "-/"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "assumption"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element": ["p", true, [], [{"text": "Let-bindings:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "let"},
           {"text": " "},
           {"text": "n"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "1;"},
           {"text": " "},
           {"text": "let"},
           {"text": " "},
           {"text": "k"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "2;"},
           {"text": " "},
           {"text": "n"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "k"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "3"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "intros"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "/-"},
           {"text": " "},
           {"text": "n✝"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "1"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "k✝"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "2"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "⊢"},
           {"text": " "},
           {"text": "n✝"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "k✝"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "3"},
           {"text": " "},
           {"text": "-/"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#rfl"]],
             [{"text": "rfl"}]]},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element": ["p", true, [], [{"text": "Does not unfold definitions:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "def"},
           {"text": " "},
           {"text": "AllEven"},
           {"text": " "},
           {"text": "(f"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "∀"},
           {"text": " "},
           {"text": "n,"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "n"},
           {"text": " "},
           {"text": "%"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "0"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "∀"},
           {"text": " "},
           {"text": "(f"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "Nat),"},
           {"text": " "},
           {"text": "AllEven"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "AllEven"},
           {"text": " "},
           {"text": "(fun"},
           {"text": " "},
           {"text": "k"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "f"},
           {"text": " "},
           {"text": "(k"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "1))"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "intros"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "/-"},
           {"text": " "},
           {"text": "Tactic"},
           {"text": " "},
           {"text": "state"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "f✝"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "a✝"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "AllEven"},
           {"text": " "},
           {"text": "f✝"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "⊢"},
           {"text": " "},
           {"text": "AllEven"},
           {"text": " "},
           {"text": "fun"},
           {"text": " "},
           {"text": "k"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "f✝"},
           {"text": " "},
           {"text": "(k"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "1)"},
           {"text": " "},
           {"text": "-/"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "sorry"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "stop",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticStop_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "stop"}]]},
        {"text": " is a helper tactic for \"discarding\" the rest of a proof:"},
        {"raw": "\n"},
        {"text": "it is defined as "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "repeat"}, {"text": " "}, {"text": "sorry"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text":
         "It is useful when working on the middle of a complex proofs,"},
        {"raw": "\n"},
        {"text":
         "and less messy than commenting the remainder of the proof."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "first",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.first",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "first"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "tac"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "..."}]]},
        {"text": " runs each "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " until one succeeds, or else fails."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "bv_decide",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.bvDecideMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Close fixed-width "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#BitVec"]],
             [{"text": "BitVec"}]]}]]},
        {"text": " and "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Bool"]],
             [{"text": "Bool"}]]}]]},
        {"text": " goals by obtaining a proof from an external SAT solver and"},
        {"raw": "\n"},
        {"text":
         "verifying it inside Lean. The solvable goals are currently limited to"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"text": "the Lean equivalent of "},
           {"element":
            ["a",
             true,
             [["href", "https://smt-lib.org/logics-all.shtml#QF_BV"]],
             [{"element": ["code", true, [], [{"text": "QF_BV"}]]}]]}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "automatically splitting up "},
           {"element": ["code", true, [], [{"text": "structure"}]]},
           {"text": "s that contain information about "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#BitVec"]],
                [{"text": "BitVec"}]]}]]},
           {"text": " or "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#Bool"]],
                [{"text": "Bool"}]]}]]}]]}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "∀"},
           {"text": " "},
           {"text": "(a"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#BitVec"]],
             [{"text": "BitVec"}]]},
           {"text": " "},
           {"text": "64),"},
           {"text": " "},
           {"text": "(a"},
           {"text": " "},
           {"text": "&&&"},
           {"text": " "},
           {"text": "b)"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "(a"},
           {"text": " "},
           {"text": "^^^"},
           {"text": " "},
           {"text": "b)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": "|||"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "intros"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "bv_decide"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "If "},
        {"element": ["code", true, [], [{"text": "bv_decide"}]]},
        {"text":
         " encounters an unknown definition it will be treated like an unconstrained "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#BitVec"]],
             [{"text": "BitVec"}]]}]]},
        {"raw": "\n"},
        {"text":
         "variable. Sometimes this enables solving goals despite not understanding the definition because"},
        {"raw": "\n"},
        {"text":
         "the precise properties of the definition do not matter in the specific proof."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "If "},
        {"element": ["code", true, [], [{"text": "bv_decide"}]]},
        {"text":
         " fails to close a goal it provides a counter-example, containing assignments for all"},
        {"raw": "\n"},
        {"text": "terms that were considered as variables."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "In order to avoid calling a SAT solver every time, the proof can be cached with "},
        {"element": ["code", true, [], [{"text": "bv_decide?"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "If solving your problem relies inherently on using associativity or commutativity, consider enabling"},
        {"raw": "\n"},
        {"text": "the "},
        {"element": ["code", true, [], [{"text": "bv.ac_nf"}]]},
        {"text": " option."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Note: "},
        {"element": ["code", true, [], [{"text": "bv_decide"}]]},
        {"text":
         " trusts the correctness of the code generator and adds a axioms asserting its result."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Note: include "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "import"},
           {"text": " "},
           {"text": "Std.Tactic.BVDecide"}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "sleep",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.sleep",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The tactic "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "sleep"}, {"text": " "}, {"text": "ms"}]]},
        {"text": " sleeps for "},
        {"element": ["code", true, [], [{"text": "ms"}]]},
        {"text": " milliseconds and does nothing."},
        {"raw": "\n"},
        {"text": "It is used for debugging purposes only."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "and_intros",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticAnd_intros",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "and_intros"}]]},
        {"text": " applies "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#And.intro"]],
             [{"text": "And.intro"}]]}]]},
        {"text": " until it does not make progress."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mrevert",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mrevertMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mrevert"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "revert"}]]},
        {"text": ", but operating on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "R"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "R"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "R"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "⟨HP,"},
           {"text": " "},
           {"text": "HQ,"},
           {"text": " "},
           {"text": "HR⟩"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mrevert"},
           {"text": " "},
           {"text": "HR"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mrevert"},
           {"text": " "},
           {"text": "HP"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HP'"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HR'"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HR'"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "trivial",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticTrivial",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Core.html#trivial"]],
             [{"text": "trivial"}]]}]]},
        {"text": " tries different simple tactics (e.g., "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#rfl"]],
             [{"text": "rfl"}]]}]]},
        {"text": ", "},
        {"element": ["code", true, [], [{"text": "contradiction"}]]},
        {"text": ", ...)"},
        {"raw": "\n"},
        {"text": "to close the current goal."},
        {"raw": "\n"},
        {"text": "You can use the command "},
        {"element": ["code", true, [], [{"text": "macro_rules"}]]},
        {"text": " to extend the set of tactics used. Example:"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "macro_rules"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "`(tactic|"},
           {"text": " "},
           {"text": "trivial)"},
           {"text": " "},
           {"text": "=>"},
           {"text": " "},
           {"text": "`(tactic|"},
           {"text": " "},
           {"text": "simp)"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "run_tac",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.runTac",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "run_tac"}, {"text": " "}, {"text": "doSeq"}]]},
        {"text": " tactic executes code in "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "TacticM"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Unit"]],
             [{"text": "Unit"}]]}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mcases",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mcasesMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Like "},
        {"element": ["code", true, [], [{"text": "rcases"}]]},
        {"text": ", but operating on stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goals."},
        {"raw": "\n"},
        {"text": "Example: Given a goal "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "(Q"},
           {"text": " "},
           {"text": "∨"},
           {"text": " "},
           {"text": "R)"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "(Q"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "R))"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "R"}]]},
        {"text": ","},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "mcases"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "⟨-,"},
           {"text": " "},
           {"text": "⟨hq"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "hr⟩,"},
           {"text": " "},
           {"text": "hqr⟩"}]]},
        {"text": " will yield two goals:"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "(hq"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Q,"},
           {"text": " "},
           {"text": "hqr"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "R)"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "R"}]]},
        {"text": " and "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "(hr"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "R)"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "R"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "That is, "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "mcases"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "pat"}]]},
        {"text": " has the following semantics, based on "},
        {"element": ["code", true, [], [{"text": "pat"}]]},
        {"text": ":"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "pat=□h'"}]]},
           {"text": " renames "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": " to "},
           {"element": ["code", true, [], [{"text": "h'"}]]},
           {"text": " in the stateful context, regardless of whether "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": " is pure"}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "pat=⌜h'⌝"}]]},
           {"text": " introduces "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h'"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "φ"}]]},
           {"text": "  to the pure local context if "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "⌜φ⌝"}]]},
           {"raw": "\n"},
           {"text": "(c.f. "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "Lean.Elab.Tactic.Do.ProofMode.IsPure"}]]},
           {"text": ")"}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "pat=h'"}]]},
           {"text": " is like "},
           {"element": ["code", true, [], [{"text": "pat=⌜h'⌝"}]]},
           {"text": " if "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": " is pure"},
           {"raw": "\n"},
           {"text": "(c.f. "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "Lean.Elab.Tactic.Do.ProofMode.IsPure"}]]},
           {"text": "), otherwise it is like "},
           {"element": ["code", true, [], [{"text": "pat=□h'"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "pat=_"}]]},
           {"text": " renames "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": " to an inaccessible name"}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "pat=-"}]]},
           {"text": " discards "},
           {"element": ["code", true, [], [{"text": "h"}]]}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "⟨pat₁,"}, {"text": " "}, {"text": "pat₂⟩"}]]},
           {"text":
            " matches on conjunctions and existential quantifiers and recurses via"},
           {"raw": "\n"},
           {"element": ["code", true, [], [{"text": "pat₁"}]]},
           {"text": " and "},
           {"element": ["code", true, [], [{"text": "pat₂"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "⟨pat₁"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "pat₂⟩"}]]},
           {"text":
            " matches on disjunctions, matching the left alternative via "},
           {"element": ["code", true, [], [{"text": "pat₁"}]]},
           {"text": " and the right"},
           {"raw": "\n"},
           {"text": "alternative via "},
           {"element": ["code", true, [], [{"text": "pat₂"}]]},
           {"text": "."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "repeat1'",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.repeat1'",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "repeat1'"}, {"text": " "}, {"text": "tac"}]]},
        {"text": " recursively applies to "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " on all of the goals so long as it succeeds,"},
        {"raw": "\n"},
        {"text": "but "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "repeat1'"}, {"text": " "}, {"text": "tac"}]]},
        {"text": " fails if "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " succeeds on none of the initial goals."}]]},
     {"element": ["p", true, [], [{"text": "See also:"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "repeat"}, {"text": " "}, {"text": "tac"}]]},
           {"text": " simply applies "},
           {"element": ["code", true, [], [{"text": "tac"}]]},
           {"text": " repeatedly."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "repeat'"}, {"text": " "}, {"text": "tac"}]]},
           {"text": " is like "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "repeat1'"}, {"text": " "}, {"text": "tac"}]]},
           {"text": " but it does not require that "},
           {"element": ["code", true, [], [{"text": "tac"}]]},
           {"text": " succeed at least once."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "fail",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.fail",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "fail"}, {"text": " "}, {"text": "msg"}]]},
        {"text":
         " is a tactic that always fails, and produces an error using the given message."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "ac_rfl",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.acRfl",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "ac_rfl"}]]},
        {"text":
         " proves equalities up to application of an associative and commutative operator."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "instance"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Core.html#Std.Associative"]],
             [{"text": "Std.Associative"}]]},
           {"text": " "},
           {"text": "(α"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": "(.+.)"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "⟨Nat.add_assoc⟩"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "instance"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Core.html#Std.Commutative"]],
             [{"text": "Std.Commutative"}]]},
           {"text": " "},
           {"text": "(α"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": "(.+.)"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "⟨Nat.add_comm⟩"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "example"},
           {"text": " "},
           {"text": "(a"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "c"},
           {"text": " "},
           {"text": "d"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "c"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "d"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "d"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "(b"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "c)"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": " "},
           {"text": "ac_rfl"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "let_to_have",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.letToHave",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Transforms "},
        {"element": ["code", true, [], [{"text": "let"}]]},
        {"text": " expressions into "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text": " expressions when possible."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "let_to_have"}]]},
           {"text": " transforms "},
           {"element": ["code", true, [], [{"text": "let"}]]},
           {"text": "s in the target."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "let_to_have"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "h"}]]},
           {"text": " transforms "},
           {"element": ["code", true, [], [{"text": "let"}]]},
           {"text": "s in the given local hypothesis."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mrefine",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mrefineMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "Like "},
        {"element": ["code", true, [], [{"text": "refine"}]]},
        {"text": ", but operating on stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goals."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "R"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "(P"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "R)"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "P"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "R"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "⟨HP,"},
           {"text": " "},
           {"text": "HQ,"},
           {"text": " "},
           {"text": "HR⟩"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mrefine"},
           {"text": " "},
           {"text": "⟨HP,"},
           {"text": " "},
           {"text": "HR⟩"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "example"},
           {"text": " "},
           {"text": "(ψ"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#Nat"]],
             [{"text": "Nat"}]]},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "ψ"},
           {"text": " "},
           {"text": "42"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "∃"},
           {"text": " "},
           {"text": "x,"},
           {"text": " "},
           {"text": "ψ"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "H"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mrefine"},
           {"text": " "},
           {"text": "⟨⌜42⌝,"},
           {"text": " "},
           {"text": "H⟩"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "simpa!",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticSimpa!_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "This is a \"finishing\" tactic modification of "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": ". It has two forms."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simpa"},
              {"text": " "},
              {"text": "[rules,"},
              {"text": " "},
              {"text": "⋯]"},
              {"text": " "},
              {"text": "using"},
              {"text": " "},
              {"text": "e"}]]},
           {"text": " will simplify the goal and the type of"},
           {"raw": "\n"},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " using "},
           {"element": ["code", true, [], [{"text": "rules"}]]},
           {"text": ", then try to close the goal using "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": "."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Simplifying the type of "},
        {"element": ["code", true, [], [{"text": "e"}]]},
        {"text": " makes it more likely to match the goal"},
        {"raw": "\n"},
        {"text":
         "(which has also been simplified). This construction also tends to be"},
        {"raw": "\n"},
        {"text": "more robust under changes to the simp lemma set."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "simpa"},
              {"text": " "},
              {"text": "[rules,"},
              {"text": " "},
              {"text": "⋯]"}]]},
           {"text": " will simplify the goal and the type of a"},
           {"raw": "\n"},
           {"text": "hypothesis "},
           {"element": ["code", true, [], [{"text": "this"}]]},
           {"text":
            " if present in the context, then try to close the goal using"},
           {"raw": "\n"},
           {"text": "the "},
           {"element": ["code", true, [], [{"text": "assumption"}]]},
           {"text": " tactic."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "admit",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticAdmit",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "admit"}]]},
        {"text": " is a synonym for "},
        {"element": ["code", true, [], [{"text": "sorry"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "rwa",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticRwa__",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "rwa"}]]},
        {"text": " is short-hand for "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "rw;"}, {"text": " "}, {"text": "assumption"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mconstructor",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mconstructorMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mconstructor"}]]},
        {"text": " is like "},
        {"element": ["code", true, [], [{"text": "constructor"}]]},
        {"text": ", but operating on a stateful "},
        {"element": ["code", true, [], [{"text": "Std.Do.SPred"}]]},
        {"text": " goal."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "example"},
           {"text": " "},
           {"text": "(Q"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "SPred"},
           {"text": " "},
           {"text": "σs)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mintro"},
           {"text": " "},
           {"text": "HQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "mconstructor"},
           {"text": " "},
           {"text": "<;>"},
           {"text": " "},
           {"text": "mexact"},
           {"text": " "},
           {"text": "HQ"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "mspec",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.mspecMacro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "mspec"}]]},
        {"text": " is an "},
        {"element": ["code", true, [], [{"text": "apply"}]]},
        {"text":
         "-like tactic that applies a Hoare triple specification to the target of the"},
        {"raw": "\n"},
        {"text": "stateful goal."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Given a stateful goal "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "H"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "wp⟦prog⟧"},
           {"text": " "},
           {"text": "Q'"}]]},
        {"text": ", "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "mspec"}, {"text": " "}, {"text": "foo_spec"}]]},
        {"text": " will instantiate"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "foo_spec"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "→"},
           {"text": " "},
           {"text": "⦃P⦄"},
           {"text": " "},
           {"text": "foo"},
           {"text": " "},
           {"text": "⦃Q⦄"}]]},
        {"text": ", match "},
        {"element": ["code", true, [], [{"text": "foo"}]]},
        {"text": " against "},
        {"element": ["code", true, [], [{"text": "prog"}]]},
        {"text": " and produce subgoals for"},
        {"raw": "\n"},
        {"text": "the verification conditions "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "?pre"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "H"},
           {"text": " "},
           {"text": "⊢ₛ"},
           {"text": " "},
           {"text": "P"}]]},
        {"text": " and "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "?post"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Q"},
           {"text": " "},
           {"text": "⊢ₚ"},
           {"text": " "},
           {"text": "Q'"}]]},
        {"text": "."}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"text": "If "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "prog"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "x"},
              {"text": " "},
              {"text": ">>="},
              {"text": " "},
              {"text": "f"}]]},
           {"text": ", then "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "mspec"}, {"text": " "}, {"text": "Specs.bind"}]]},
           {"text": " is tried first so that "},
           {"element": ["code", true, [], [{"text": "foo"}]]},
           {"text": " is matched against "},
           {"element": ["code", true, [], [{"text": "x"}]]},
           {"raw": "\n"},
           {"text": "instead. Tactic "},
           {"element": ["code", true, [], [{"text": "mspec_no_bind"}]]},
           {"text": " does not attempt to do this decomposition."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "If "},
           {"element": ["code", true, [], [{"text": "?pre"}]]},
           {"text": " or "},
           {"element": ["code", true, [], [{"text": "?post"}]]},
           {"text": " follow by "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "."},
              {"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#rfl"]],
                [{"text": "rfl"}]]}]]},
           {"text": ", then they are discharged automatically."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "?post"}]]},
           {"text": " is automatically simplified into constituent "},
           {"element": ["code", true, [], [{"text": "⊢ₛ"}]]},
           {"text": " entailments on"},
           {"raw": "\n"},
           {"text": "success and failure continuations."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "?pre"}]]},
           {"text": " and "},
           {"element": ["code", true, [], [{"text": "?post.*"}]]},
           {"text":
            " goals introduce their stateful hypothesis under an inaccessible name."},
           {"raw": "\n"},
           {"text": "You can give it a name with the "},
           {"element": ["code", true, [], [{"text": "mrename_i"}]]},
           {"text": " tactic."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Any uninstantiated MVar arising from instantiation of "},
           {"element": ["code", true, [], [{"text": "foo_spec"}]]},
           {"text": " becomes a new subgoal."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "If the target of the stateful goal looks like "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "fun"},
              {"text": " "},
              {"text": "s"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "_"}]]},
           {"text": " then "},
           {"element": ["code", true, [], [{"text": "mspec"}]]},
           {"text": " will first "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "mintro"}, {"text": " "}, {"text": "∀s"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "If "},
           {"element": ["code", true, [], [{"text": "P"}]]},
           {"text":
            " has schematic variables that can be instantiated by doing "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "mintro"}, {"text": " "}, {"text": "∀s"}]]},
           {"text": ", for example"},
           {"raw": "\n"},
           {"element":
            ["code",
             true,
             [],
             [{"text": "foo_spec"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "∀(n:Nat),"},
              {"text": " "},
              {"text": "⦃fun"},
              {"text": " "},
              {"text": "s"},
              {"text": " "},
              {"text": "=>"},
              {"text": " "},
              {"text": "⌜n"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "s⌝⦄"},
              {"text": " "},
              {"text": "foo"},
              {"text": " "},
              {"text": "⦃Q⦄"}]]},
           {"text": ", then "},
           {"element": ["code", true, [], [{"text": "mspec"}]]},
           {"text": " will do "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "mintro"}, {"text": " "}, {"text": "∀s"}]]},
           {"text": " first to"},
           {"raw": "\n"},
           {"text": "instantiate "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "n"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "s"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "Right before applying the spec, the "},
           {"element": ["code", true, [], [{"text": "mframe"}]]},
           {"text": " tactic is used, which has the following effect:"},
           {"raw": "\n"},
           {"text": "Any hypothesis "},
           {"element": ["code", true, [], [{"text": "Hᵢ"}]]},
           {"text": " in the goal "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h₁:H₁,"},
              {"text": " "},
              {"text": "h₂:H₂,"},
              {"text": " "},
              {"text": "...,"},
              {"text": " "},
              {"text": "hₙ:Hₙ"},
              {"text": " "},
              {"text": "⊢ₛ"},
              {"text": " "},
              {"text": "T"}]]},
           {"text": " that is"},
           {"raw": "\n"},
           {"text": "pure (i.e., equivalent to some "},
           {"element": ["code", true, [], [{"text": "⌜φᵢ⌝"}]]},
           {"text": ") will be moved into the pure context as "},
           {"element": ["code", true, [], [{"text": "hᵢ:φᵢ"}]]},
           {"text": "."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Additionally, "},
        {"element": ["code", true, [], [{"text": "mspec"}]]},
        {"text": " can be used without arguments or with a term argument:"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "mspec"}]]},
           {"text": " without argument will try and look up a spec for "},
           {"element": ["code", true, [], [{"text": "x"}]]},
           {"text": " registered with "},
           {"element": ["code", true, [], [{"text": "@[spec]"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "mspec"},
              {"text": " "},
              {"text": "(foo_spec"},
              {"text": " "},
              {"text": "blah"},
              {"text": " "},
              {"text": "?bleh)"}]]},
           {"text":
            " will elaborate its argument as a term with expected type"},
           {"raw": "\n"},
           {"element":
            ["code",
             true,
             [],
             [{"text": "⦃?P⦄"},
              {"text": " "},
              {"text": "x"},
              {"text": " "},
              {"text": "⦃?Q⦄"}]]},
           {"text": " and introduce "},
           {"element": ["code", true, [], [{"text": "?bleh"}]]},
           {"text": " as a subgoal."},
           {"raw": "\n"},
           {"text": "This is useful to pass an invariant to e.g., "},
           {"element": ["code", true, [], [{"text": "Specs.forIn_list"}]]},
           {"text": " and leave the inductive step"},
           {"raw": "\n"},
           {"text": "as a hole."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "classical",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.classical",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "classical"}, {"text": " "}, {"text": "tacs"}]]},
        {"text": " runs "},
        {"element": ["code", true, [], [{"text": "tacs"}]]},
        {"text": " in a scope where "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Classical.html#Classical.propDecidable"]],
             [{"text": "Classical.propDecidable"}]]}]]},
        {"text": " is a low priority"},
        {"raw": "\n"},
        {"text": "local instance."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Note that "},
        {"element": ["code", true, [], [{"text": "classical"}]]},
        {"text": " is a scoping tactic: it adds the instance only within the"},
        {"raw": "\n"},
        {"text": "scope of the tactic."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "show_term",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.showTerm",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "show_term"}, {"text": " "}, {"text": "tac"}]]},
        {"text": " runs "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": ", then prints the generated term in the form"},
        {"raw": "\n"},
        {"text": "\"exact X Y Z\" or \"refine X ?_ Z\" (prefixed by "},
        {"element": ["code", true, [], [{"text": "expose_names"}]]},
        {"text": " if necessary)"},
        {"raw": "\n"},
        {"text": "if there are remaining subgoals."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "(For some tactics, the printed term will not be human readable.)"}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "get_elem_tactic_extensible",
  "tags": [],
  "internalName": "tacticGet_elem_tactic_extensible",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code", true, [], [{"text": "get_elem_tactic_extensible"}]]},
        {"text": " is an extensible tactic automatically called"},
        {"raw": "\n"},
        {"text": "by the notation "},
        {"element": ["code", true, [], [{"text": "arr[i]"}]]},
        {"text": " to prove any side conditions that arise when"},
        {"raw": "\n"},
        {"text":
         "constructing the term (e.g. the index is in bounds of the array)."},
        {"raw": "\n"},
        {"text": "The default behavior is to try "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "simp"}, {"text": " "}, {"text": "+arith"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "omega"}]]},
        {"raw": "\n"},
        {"text": "(for doing linear arithmetic in the index)."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "(Note that the core tactic "},
        {"element": ["code", true, [], [{"text": "get_elem_tactic"}]]},
        {"text": " has already tried"},
        {"raw": "\n"},
        {"element": ["code", true, [], [{"text": "done"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "assumption"}]]},
        {"text": " before the extensible tactic is called.)"}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "clear",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.clear",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "clear"}, {"text": " "}, {"text": "x..."}]]},
        {"text":
         " removes the given hypotheses, or fails if there are remaining"},
        {"raw": "\n"},
        {"text": "references to a hypothesis."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "simp_all?",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.simpAllTrace",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "simp?"}]]},
        {"text": " takes the same arguments as "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": ", but reports an equivalent call to "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "simp"}, {"text": " "}, {"text": "only"}]]},
        {"raw": "\n"},
        {"text":
         "that would be sufficient to close the goal. This is useful for reducing the size of the simp"},
        {"raw": "\n"},
        {"text": "set in a local invocation to speed up processing."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "example"},
           {"text": " "},
           {"text": "(x"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "(if"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#True"]],
             [{"text": "True"}]]},
           {"text": " "},
           {"text": "then"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": "else"},
           {"text": " "},
           {"text": "3)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "simp?"},
           {"text": " "},
           {"text": "--"},
           {"text": " "},
           {"text": "prints"},
           {"text": " "},
           {"text": "\"Try"},
           {"text": " "},
           {"text": "this:"},
           {"text": " "},
           {"text": "simp"},
           {"text": " "},
           {"text": "only"},
           {"text": " "},
           {"text": "[ite_true]\""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "This command can also be used in "},
        {"element": ["code", true, [], [{"text": "simp_all"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "dsimp"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "sorry",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticSorry",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "sorry"}]]},
        {"text":
         " tactic is a temporary placeholder for an incomplete tactic proof,"},
        {"raw": "\n"},
        {"text": "closing the main goal using "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "exact"}, {"text": " "}, {"text": "sorry"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text":
         "This is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton."},
        {"raw": "\n"},
        {"text": "Lean will give a warning whenever a proof uses "},
        {"element": ["code", true, [], [{"text": "sorry"}]]},
        {"text": ", so you aren't likely to miss it,"},
        {"raw": "\n"},
        {"text": "but you can double check if a theorem depends on "},
        {"element": ["code", true, [], [{"text": "sorry"}]]},
        {"text": " by looking for "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#sorryAx"]],
             [{"text": "sorryAx"}]]}]]},
        {"text": " in the output"},
        {"raw": "\n"},
        {"text": "of the "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "#print"},
           {"text": " "},
           {"text": "axioms"},
           {"text": " "},
           {"text": "my_thm"}]]},
        {"text": " command, the axiom used by the implementation of "},
        {"element": ["code", true, [], [{"text": "sorry"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "letI",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticLetI__",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "letI"}]]},
        {"text": " behaves like "},
        {"element": ["code", true, [], [{"text": "let"}]]},
        {"text": ", but inlines the value instead of producing a "},
        {"element": ["code", true, [], [{"text": "let"}]]},
        {"text": " term."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "simp?!",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.tacticSimp?!_",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "simp?"}]]},
        {"text": " takes the same arguments as "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": ", but reports an equivalent call to "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "simp"}, {"text": " "}, {"text": "only"}]]},
        {"raw": "\n"},
        {"text":
         "that would be sufficient to close the goal. This is useful for reducing the size of the simp"},
        {"raw": "\n"},
        {"text": "set in a local invocation to speed up processing."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "example"},
           {"text": " "},
           {"text": "(x"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "Nat)"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "(if"},
           {"text": " "},
           {"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#True"]],
             [{"text": "True"}]]},
           {"text": " "},
           {"text": "then"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": "else"},
           {"text": " "},
           {"text": "3)"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "+"},
           {"text": " "},
           {"text": "2"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "by"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": " "},
           {"text": ""},
           {"text": "simp?"},
           {"text": " "},
           {"text": "--"},
           {"text": " "},
           {"text": "prints"},
           {"text": " "},
           {"text": "\"Try"},
           {"text": " "},
           {"text": "this:"},
           {"text": " "},
           {"text": "simp"},
           {"text": " "},
           {"text": "only"},
           {"text": " "},
           {"text": "[ite_true]\""},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "This command can also be used in "},
        {"element": ["code", true, [], [{"text": "simp_all"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "dsimp"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "rotate_left",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.rotateLeft",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "rotate_left"}, {"text": " "}, {"text": "n"}]]},
        {"text": " rotates goals to the left by "},
        {"element": ["code", true, [], [{"text": "n"}]]},
        {"text": ". That is, "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "rotate_left"}, {"text": " "}, {"text": "1"}]]},
        {"raw": "\n"},
        {"text":
         "takes the main goal and puts it to the back of the subgoal list."},
        {"raw": "\n"},
        {"text": "If "},
        {"element": ["code", true, [], [{"text": "n"}]]},
        {"text": " is omitted, it defaults to "},
        {"element": ["code", true, [], [{"text": "1"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "generalize",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.generalize",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "generalize"},
              {"text": " "},
              {"text": "([h"},
              {"text": " "},
              {"text": ":]"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "x),+"}]]},
           {"text": " replaces all occurrences "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": "s in the main goal"},
           {"raw": "\n"},
           {"text": "with a fresh hypothesis "},
           {"element": ["code", true, [], [{"text": "x"}]]},
           {"text": "s. If "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": " is given, "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "x"}]]},
           {"text": " is introduced as well."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "generalize"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "x"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "h₁"},
              {"text": " "},
              {"text": "..."},
              {"text": " "},
              {"text": "hₙ"}]]},
           {"text": " also generalizes occurrences of "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"raw": "\n"},
           {"text": "inside "},
           {"element": ["code", true, [], [{"text": "h₁"}]]},
           {"text": ", ..., "},
           {"element": ["code", true, [], [{"text": "hₙ"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "generalize"},
              {"text": " "},
              {"text": "e"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "x"},
              {"text": " "},
              {"text": "at"},
              {"text": " "},
              {"text": "*"}]]},
           {"text": " will generalize occurrences of "},
           {"element": ["code", true, [], [{"text": "e"}]]},
           {"text": " everywhere."}]]}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "solve_by_elim",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.solveByElim",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "solve_by_elim"}]]},
        {"text": " calls "},
        {"element": ["code", true, [], [{"text": "apply"}]]},
        {"text": " on the main goal to find an assumption whose head matches"},
        {"raw": "\n"},
        {"text": "and then repeatedly calls "},
        {"element": ["code", true, [], [{"text": "apply"}]]},
        {"text": " on the generated subgoals until no subgoals remain,"},
        {"raw": "\n"},
        {"text": "performing at most "},
        {"element": ["code", true, [], [{"text": "maxDepth"}]]},
        {"text": " (defaults to 6) recursive steps."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "solve_by_elim"}]]},
        {"text": " discharges the current goal or fails."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "solve_by_elim"}]]},
        {"text": " performs backtracking if subgoals can not be solved."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "By default, the assumptions passed to "},
        {"element": ["code", true, [], [{"text": "apply"}]]},
        {"text": " are the local context, "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#rfl"]],
             [{"text": "rfl"}]]}]]},
        {"text": ", "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Core.html#trivial"]],
             [{"text": "trivial"}]]}]]},
        {"text": ","},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#congrFun"]],
             [{"text": "congrFun"}]]}]]},
        {"text": " and "},
        {"element":
         ["code",
          true,
          [],
          [{"element":
            ["a",
             true,
             [["href", "./Init/Prelude.html#congrArg"]],
             [{"text": "congrArg"}]]}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "The assumptions can be modified with similar syntax as for "},
        {"element": ["code", true, [], [{"text": "simp"}]]},
        {"text": ":"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "solve_by_elim"},
              {"text": " "},
              {"text": "[h₁,"},
              {"text": " "},
              {"text": "h₂,"},
              {"text": " "},
              {"text": "...,"},
              {"text": " "},
              {"text": "hᵣ]"}]]},
           {"text": " also applies the given expressions."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "solve_by_elim"},
              {"text": " "},
              {"text": "only"},
              {"text": " "},
              {"text": "[h₁,"},
              {"text": " "},
              {"text": "h₂,"},
              {"text": " "},
              {"text": "...,"},
              {"text": " "},
              {"text": "hᵣ]"}]]},
           {"text": " does not include the local context,"},
           {"raw": "\n"},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#rfl"]],
                [{"text": "rfl"}]]}]]},
           {"text": ", "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Core.html#trivial"]],
                [{"text": "trivial"}]]}]]},
           {"text": ", "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#congrFun"]],
                [{"text": "congrFun"}]]}]]},
           {"text": ", or "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#congrArg"]],
                [{"text": "congrArg"}]]}]]},
           {"text": " unless they are explicitly included."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "solve_by_elim"},
              {"text": " "},
              {"text": "[-h₁,"},
              {"text": " "},
              {"text": "..."},
              {"text": " "},
              {"text": "-hₙ]"}]]},
           {"text": " removes the given local hypotheses."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element":
            ["code",
             true,
             [],
             [{"text": "solve_by_elim"},
              {"text": " "},
              {"text": "using"},
              {"text": " "},
              {"text": "[a₁,"},
              {"text": " "},
              {"text": "...]"}]]},
           {"text": " uses all lemmas which have been labelled"},
           {"raw": "\n"},
           {"text": "with the attributes "},
           {"element": ["code", true, [], [{"text": "aᵢ"}]]},
           {"text": " (these attributes must be created using "},
           {"element": ["code", true, [], [{"text": "register_label_attr"}]]},
           {"text": ")."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "solve_by_elim*"}]]},
        {"text":
         " tries to solve all goals together, using backtracking if a solution for one goal"},
        {"raw": "\n"},
        {"text": "makes other goals impossible."},
        {"raw": "\n"},
        {"text":
         "(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)"}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Optional arguments passed via a configuration argument as "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "solve_by_elim"},
           {"text": " "},
           {"text": "(config"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "{"},
           {"text": " "},
           {"text": "..."},
           {"text": " "},
           {"text": "})"}]]}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "maxDepth"}]]},
           {"text":
            ": number of attempts at discharging generated subgoals"}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "symm"}]]},
           {"text": ": adds all hypotheses derived by "},
           {"element": ["code", true, [], [{"text": "symm"}]]},
           {"text": " (defaults to "},
           {"element": ["code", true, [], [{"text": "true"}]]},
           {"text": ")."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "exfalso"}]]},
           {"text": ": allow calling "},
           {"element": ["code", true, [], [{"text": "exfalso"}]]},
           {"text": " and trying again if "},
           {"element": ["code", true, [], [{"text": "solve_by_elim"}]]},
           {"text": " fails"},
           {"raw": "\n"},
           {"text": "(defaults to "},
           {"element": ["code", true, [], [{"text": "true"}]]},
           {"text": ")."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"element": ["code", true, [], [{"text": "transparency"}]]},
           {"text": ": change the transparency mode when calling "},
           {"element": ["code", true, [], [{"text": "apply"}]]},
           {"text": ". Defaults to "},
           {"element": ["code", true, [], [{"text": ".default"}]]},
           {"text": ","},
           {"raw": "\n"},
           {"text": "but it is often useful to change to "},
           {"element": ["code", true, [], [{"text": ".reducible"}]]},
           {"text": ","},
           {"raw": "\n"},
           {"text":
            "so semireducible definitions will not be unfolded when trying to apply a lemma."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "See also the doc-comment for "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "Lean.Meta.Tactic.Backtrack.BacktrackConfig"}]]},
        {"text": " for the options"},
        {"raw": "\n"},
        {"element": ["code", true, [], [{"text": "proc"}]]},
        {"text": ", "},
        {"element": ["code", true, [], [{"text": "suspend"}]]},
        {"text": ", and "},
        {"element": ["code", true, [], [{"text": "discharge"}]]},
        {"text": " which allow further customization of "},
        {"element": ["code", true, [], [{"text": "solve_by_elim"}]]},
        {"text": "."},
        {"raw": "\n"},
        {"text": "Both "},
        {"element": ["code", true, [], [{"text": "apply_assumption"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "apply_rules"}]]},
        {"text": " are implemented via these hooks."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "<;>",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.«tactic_<;>_»",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "tac"},
           {"text": " "},
           {"text": "<;>"},
           {"text": " "},
           {"text": "tac'"}]]},
        {"text": " runs "},
        {"element": ["code", true, [], [{"text": "tac"}]]},
        {"text": " on the main goal and "},
        {"element": ["code", true, [], [{"text": "tac'"}]]},
        {"text": " on each produced goal,"},
        {"raw": "\n"},
        {"text": "concatenating all goals produced by "},
        {"element": ["code", true, [], [{"text": "tac'"}]]},
        {"text": "."}]]}]]},
  "definingModule": "Init.Tactics"},
 {"userName": "apply?",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.apply?",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text":
         "Searches environment for definitions or theorems that can refine the goal using "},
        {"element": ["code", true, [], [{"text": "apply"}]]},
        {"raw": "\n"},
        {"text": "with conditions resolved when possible with "},
        {"element": ["code", true, [], [{"text": "solve_by_elim"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "The optional "},
        {"element": ["code", true, [], [{"text": "using"}]]},
        {"text":
         " clause provides identifiers in the local context that must be"},
        {"raw": "\n"},
        {"text": "used when closing the goal."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Use "},
        {"element": ["code", true, [], [{"text": "+grind"}]]},
        {"text": " to enable "},
        {"element": ["code", true, [], [{"text": "grind"}]]},
        {"text": " as a fallback discharger for subgoals."},
        {"raw": "\n"},
        {"text": "Use "},
        {"element": ["code", true, [], [{"text": "+try?"}]]},
        {"text": " to enable "},
        {"element": ["code", true, [], [{"text": "try?"}]]},
        {"text": " as a fallback discharger for subgoals."},
        {"raw": "\n"},
        {"text": "Use "},
        {"element": ["code", true, [], [{"text": "-star"}]]},
        {"text": " to disable fallback to star-indexed lemmas."},
        {"raw": "\n"},
        {"text": "Use "},
        {"element": ["code", true, [], [{"text": "+all"}]]},
        {"text":
         " to collect all successful lemmas instead of stopping at the first."}]]}]]},
  "definingModule": "Init.Tactics"}]