{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_convertLRAT_unsat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">unsat_of_convertLRAT_unsat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnf</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Entails.html#Std.Tactic.BVDecide.LRAT.Internal.Unsatisfiable\">Unsatisfiable</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> (<span class=\"fn\"><span class=\"fn\">cnf</span>.<a href=\"./Std/Sat/CNF/RelabelFin.html#Std.Sat.CNF.numLiterals\">numLiterals</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>))</span> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT\">convertLRAT</a> <span class=\"fn\">cnf</span>)</span></span> → <span class=\"fn\"><span class=\"fn\">cnf</span>.<a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Unsat\">Unsat</a></span></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_convertLRAT_unsat","kind":"theorem","line":121,"name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_convertLRAT_unsat","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L121-L150"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.unsat_of_cons_none_unsat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">unsat_of_cons_none_unsat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">clauses</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">DefaultClause</a> <span class=\"fn\">n</span>)</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Entails.html#Std.Tactic.BVDecide.LRAT.Internal.Unsatisfiable\">Unsatisfiable</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Implementation.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.ofArray\">DefaultFormula.ofArray</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option.none\">none</a> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\">clauses</span>).<a href=\"./Init/Prelude.html#List.toArray\">toArray</a></span>)</span></span> →\n  <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Entails.html#Std.Tactic.BVDecide.LRAT.Internal.Unsatisfiable\">Unsatisfiable</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Implementation.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.ofArray\">DefaultFormula.ofArray</a> <span class=\"fn\"><span class=\"fn\">clauses</span>.<a href=\"./Init/Prelude.html#List.toArray\">toArray</a></span>)</span></span></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.unsat_of_cons_none_unsat","kind":"theorem","line":111,"name":"Std.Tactic.BVDecide.LRAT.Internal.unsat_of_cons_none_unsat","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L111-L119"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRatAdd\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">convertLRAT_readyForRatAdd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnf</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT\">convertLRAT</a> <span class=\"fn\">cnf</span>)</span>.<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Lemmas.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.ReadyForRatAdd\">ReadyForRatAdd</a></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRatAdd","kind":"theorem","line":106,"name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRatAdd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L106-L109"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRupAdd\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">convertLRAT_readyForRupAdd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnf</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT\">convertLRAT</a> <span class=\"fn\">cnf</span>)</span>.<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Lemmas.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.ReadyForRupAdd\">ReadyForRupAdd</a></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRupAdd","kind":"theorem","line":101,"name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT_readyForRupAdd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L101-L104"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">convertLRAT</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnf</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Formula/Implementation.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula\">DefaultFormula</a> (<span class=\"fn\"><span class=\"fn\">cnf</span>.<a href=\"./Std/Sat/CNF/RelabelFin.html#Std.Sat.CNF.numLiterals\">numLiterals</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>)</span></div></div>","info":{"doc":"Convert a `CNF Nat` with a certain maximum variable number into the `DefaultFormula`\nformat for usage with `bv_decide`'s `LRAT.Internal`.\n\nNotably this:\n1. Increments all variables as DIMACS variables start at 1 instead of 0\n2. Adds a leading `none` clause. This clause *must* be persistent as the LRAT checker wants to have\n  the DIMACS file line by line and the DIMACS file begins with the `p cnf x y` meta instruction.\n","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT","kind":"def","line":87,"name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L87-L99"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT_sat_of_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">Clause</span>.<span class=\"name\">convertLRAT_sat_of_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">lratClause</span> : <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">DefaultClause</a> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">assign</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">clause</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Clause\">Sat.CNF.Clause</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'\">convertLRAT'</a> <span class=\"fn\">clause</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option.some\">some</a> <span class=\"fn\">lratClause</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Clause.eval\">Sat.CNF.Clause.eval</a> <span class=\"fn\">assign</span> <span class=\"fn\">clause</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> → <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Entails.html#Std.Tactic.BVDecide.LRAT.Internal.Entails.eval\">Entails.eval</a> <span class=\"fn\">assign</span> <span class=\"fn\">lratClause</span></span></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT_sat_of_sat","kind":"theorem","line":73,"name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT_sat_of_sat","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L73-L85"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">Clause</span>.<span class=\"name\">mem_lrat_of_mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Literal.html#Std.Sat.Literal\">Sat.Literal</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">lratClause</span> : <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">DefaultClause</a> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">clause</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Clause\">Sat.CNF.Clause</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h1</span> : <span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">clause</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h2</span> : <span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause.ofArray\">DefaultClause.ofArray</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List.toArray\">List.toArray</a> <span class=\"fn\">clause</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option.some\">some</a> <span class=\"fn\">lratClause</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">l</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><span class=\"fn\">lratClause</span>.<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause.clause\">clause</a></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem","kind":"theorem","line":63,"name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L63-L71"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">convertLRAT'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">clauses</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">DefaultClause</a> <span class=\"fn\">n</span>)</span>)</span></span></div></div>","info":{"doc":"Turn a `CNF PosFin` into the representation used by the LRAT checker.\n","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT'","kind":"def","line":51,"name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.convertLRAT'","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L51-L61"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">Clause</span>.<span class=\"name\">convertLRAT'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">clause</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Clause\">Sat.CNF.Clause</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClause\">DefaultClause</a> <span class=\"fn\">n</span>)</span></span></div></div>","info":{"doc":"Turn a `CNF.Clause PosFin` into the representation used by the LRAT checker.\n","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'","kind":"def","line":45,"name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.convertLRAT'","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L45-L49"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_lift_unsat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">unsat_of_lift_unsat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnf</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.lift\">lift</a> <span class=\"fn\">cnf</span>)</span>.<a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Unsat\">Unsat</a></span> → <span class=\"fn\"><span class=\"fn\">cnf</span>.<a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF.Unsat\">Unsat</a></span></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_lift_unsat","kind":"theorem","line":33,"name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.unsat_of_lift_unsat","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L33-L43"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.lift\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">CNF</span>.<span class=\"name\">lift</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnf</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Sat/CNF/Basic.html#Std.Sat.CNF\">Sat.CNF</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> (<span class=\"fn\"><span class=\"fn\">cnf</span>.<a href=\"./Std/Sat/CNF/RelabelFin.html#Std.Sat.CNF.numLiterals\">numLiterals</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>))</span></span></div></div>","info":{"doc":"Turn a `CNF Nat`, that might contain `0` as a variable, to a `CNF PosFin`.\nThis representation is guaranteed to not have `0` and is limited to an upper bound of\nvariable indices.\n","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Convert.html#Std.Tactic.BVDecide.LRAT.Internal.CNF.lift","kind":"def","line":24,"name":"Std.Tactic.BVDecide.LRAT.Internal.CNF.lift","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Tactic/BVDecide/LRAT/Internal/Convert.lean#L24-L31"}}],"imports":["Std.Sat.CNF.RelabelFin","Std.Tactic.BVDecide.LRAT.Internal.Formula","Init.Data.Array.Bootstrap"],"instances":[],"name":"Std.Tactic.BVDecide.LRAT.Internal.Convert"}