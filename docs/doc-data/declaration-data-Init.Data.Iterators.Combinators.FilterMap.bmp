{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.map\"><span class=\"name\">Std</span>.<span class=\"name\">Iter</span>.<span class=\"name\">map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β </span><span class=\"fn\">γ</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterator\">Iterator</a> <span class=\"fn\">α</span> <a href=\"./Init/Control/Id.html#Id\">Id</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">γ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">it</span> : <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iter\">Iter</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iter\">Iter</a> <span class=\"fn\">γ</span></span></div></div>","info":{"doc":"If `it` is an iterator, then `it.map f` is another iterator that applies a\nfunction `f` to all values emitted by `it` and emits the result.\n\nIn situations where `f` is monadic, use `mapM` instead.\n\n**Marble diagram:**\n\n```text\nit         ---a --b --c --d -e ----⊥\nit.map     ---a'--b'--c'--d'-e'----⊥\n```\n\n(given that `f a = a'`, `f b = b'` etc.)\n\n**Termination properties:**\n\n* `Finite` instance: only if `it` is finite\n* `Productive` instance: only if `it` is productive\n\n**Performance:**\n\nFor each value emitted by the base iterator `it`, this combinator calls `f`.\n","docLink":"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.map","kind":"def","line":295,"name":"Std.Iter.map","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Iterators/Combinators/FilterMap.lean#L295-L298"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.filter\"><span class=\"name\">Std</span>.<span class=\"name\">Iter</span>.<span class=\"name\">filter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterator\">Iterator</a> <span class=\"fn\">α</span> <a href=\"./Init/Control/Id.html#Id\">Id</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">it</span> : <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iter\">Iter</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iter\">Iter</a> <span class=\"fn\">β</span></span></div></div>","info":{"doc":"If `it` is an iterator, then `it.filter f` is another iterator that applies a\npredicate `f` to all values emitted by `it` and emits them only if they are accepted by `f`.\n\nIn situations where `f` is monadic, use `filterM` instead.\n\n**Marble diagram (without monadic effects):**\n\n```text\nit            ---a--b--c--d-e--⊥\nit.filter     ---a-----c-------⊥\n```\n\n(given that `f a = f c = true` and `f b = f d = d e = false`)\n\n**Termination properties:**\n\n* `Finite` instance: only if `it` is finite\n* `Productive` instance: only if `it` is finite`\n\nFor certain mapping functions `f`, the resulting iterator will be productive even though\nno `Productive` instance is provided. For example, if `f` always returns `True`, the resulting\niterator will be productive as long as `it` is. In such situations, the missing instance needs to\nbe proved manually.\n\n**Performance:**\n\nFor each value emitted by the base iterator `it`, this combinator calls `f` and matches on the\nreturned value.\n","docLink":"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.filter","kind":"def","line":290,"name":"Std.Iter.filter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Iterators/Combinators/FilterMap.lean#L290-L293"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.filterMap\"><span class=\"name\">Std</span>.<span class=\"name\">Iter</span>.<span class=\"name\">filterMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β </span><span class=\"fn\">γ</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterator\">Iterator</a> <span class=\"fn\">α</span> <a href=\"./Init/Control/Id.html#Id\">Id</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">γ</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">it</span> : <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iter\">Iter</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iter\">Iter</a> <span class=\"fn\">γ</span></span></div></div>","info":{"doc":"If `it` is an iterator, then `it.filterMap f` is another iterator that applies a function `f` to all\nvalues emitted by `it`. `f` is expected to return an `Option`. If it returns `none`, then nothing is\nemitted; if it returns `some x`, then `x` is emitted.\n\nIn situations where `f` is monadic, use `filterMapM` instead.\n\n**Marble diagram:**\n\n```text\nit               ---a --b--c --d-e--⊥\nit.filterMap     ---a'-----c'-------⊥\n```\n\n(given that `f a = some a'`, `f c = c'` and `f b = f d = d e = none`)\n\n**Termination properties:**\n\n* `Finite` instance: only if `it` is finite\n* `Productive` instance: only if `it` is finite`\n\nFor certain mapping functions `f`, the resulting iterator will be productive even though\nno `Productive` instance is provided. For example, if `f` never returns `none`, then\nthis combinator will preserve productiveness. In such situations, the missing instance needs to\nbe proved manually.\n\n**Performance:**\n\nFor each value emitted by the base iterator `it`, this combinator calls `f` and matches on the\nreturned `Option` value.\n","docLink":"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.filterMap","kind":"def","line":285,"name":"Std.Iter.filterMap","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Iterators/Combinators/FilterMap.lean#L285-L288"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.mapM\"><span class=\"name\">Std</span>.<span class=\"name\">Iter</span>.<span class=\"name\">mapM</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β </span><span class=\"fn\">γ</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterator\">Iterator</a> <span class=\"fn\">α</span> <a href=\"./Init/Control/Id.html#Id\">Id</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">γ</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">it</span> : <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iter\">Iter</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.IterM\">IterM</a> <span class=\"fn\">m</span> <span class=\"fn\">γ</span></span></div></div>","info":{"doc":"If `it` is an iterator, then `it.mapM f` is another iterator that applies a monadic\nfunction `f` to all values emitted by `it` and emits the result.\n\nThe base iterator `it` being monadic in `m`, `f` can return values in any monad `n` for which a\n`MonadLiftT m n` instance is available.\n\nIf `f` is pure, then the simpler variant `it.map` can be used instead.\n\n**Marble diagram (without monadic effects):**\n\n```text\nit          ---a --b --c --d -e ----⊥\nit.mapM     ---a'--b'--c'--d'-e'----⊥\n```\n\n(given that `f a = pure a'`, `f b = pure b'` etc.)\n\n**Termination properties:**\n\n* `Finite` instance: only if `it` is finite\n* `Productive` instance: only if `it` is productive\n\nFor certain mapping functions `f`, the resulting iterator will be finite (or productive) even though\nno `Finite` (or `Productive`) instance is provided. For example, if `f` is an `ExceptT` monad and\nwill always fail, then `it.mapM` will be finite even if `it` isn't. In such cases, the termination\nproof needs to be done manually.\n\n**Performance:**\n\nFor each value emitted by the base iterator `it`, this combinator calls `f`.\n","docLink":"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.mapM","kind":"def","line":248,"name":"Std.Iter.mapM","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Iterators/Combinators/FilterMap.lean#L248-L283"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.filterM\"><span class=\"name\">Std</span>.<span class=\"name\">Iter</span>.<span class=\"name\">filterM</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterator\">Iterator</a> <span class=\"fn\">α</span> <a href=\"./Init/Control/Id.html#Id\">Id</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#ULift\">ULift</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">it</span> : <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iter\">Iter</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.IterM\">IterM</a> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>","info":{"doc":"If `it` is an iterator, then `it.filterM f` is another iterator that applies a monadic\npredicate `f` to all values emitted by `it` and emits them only if they are accepted by `f`.\n\nIf `f` is pure, then the simpler variant `it.filter` can be used instead.\n\n**Marble diagram (without monadic effects):**\n\n```text\nit             ---a--b--c--d-e--⊥\nit.filterM     ---a-----c-------⊥\n```\n\n(given that `f a = f c = pure true` and `f b = f d = d e = pure false`)\n\n**Termination properties:**\n\n* `Finite` instance: only if `it` is finite\n* `Productive` instance: only if `it` is finite`\n\nFor certain mapping functions `f`, the resulting iterator will be finite (or productive) even though\nno `Finite` (or `Productive`) instance is provided. For example, if `f` is an `ExceptT` monad and\nwill always fail, then `it.filterWithPostcondition` will be finite -- and productive -- even if `it`\nisn't. In such cases, the termination proof needs to be done manually.\n\n**Performance:**\n\nFor each value emitted by the base iterator `it`, this combinator calls `f`.\n","docLink":"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.filterM","kind":"def","line":214,"name":"Std.Iter.filterM","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Iterators/Combinators/FilterMap.lean#L214-L246"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.filterMapM\"><span class=\"name\">Std</span>.<span class=\"name\">Iter</span>.<span class=\"name\">filterMapM</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β </span><span class=\"fn\">γ</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterator\">Iterator</a> <span class=\"fn\">α</span> <a href=\"./Init/Control/Id.html#Id\">Id</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">γ</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">it</span> : <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iter\">Iter</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.IterM\">IterM</a> <span class=\"fn\">m</span> <span class=\"fn\">γ</span></span></div></div>","info":{"doc":"If `it` is an iterator, then `it.filterMapM f` is another iterator that applies a monadic\nfunction `f` to all values emitted by `it`. `f` is expected to return an `Option` inside the monad.\nIf `f` returns `none`, then nothing is emitted; if it returns `some x`, then `x` is emitted.\n\nIf `f` is pure, then the simpler variant `it.filterMap` can be used instead.\n\n**Marble diagram (without monadic effects):**\n\n```text\nit                ---a --b--c --d-e--⊥\nit.filterMapM     ---a'-----c'-------⊥\n```\n\n(given that `f a = pure (some a)'`, `f c = pure (some c')` and `f b = f d = d e = pure none`)\n\n**Termination properties:**\n\n* `Finite` instance: only if `it` is finite\n* `Productive` instance: only if `it` is finite`\n\nFor certain mapping functions `f`, the resulting iterator will be finite (or productive) even though\nno `Finite` (or `Productive`) instance is provided. For example, if `f` never returns `none`, then\nthis combinator will preserve productiveness. If `f` is an `ExceptT` monad and will always fail,\nthen `it.filterMapM` will be finite even if `it` isn't. In such cases, the termination proof needs\nto be done manually.\n\n**Performance:**\n\nFor each value emitted by the base iterator `it`, this combinator calls `f` and matches on the\nreturned `Option` value.\n","docLink":"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.filterMapM","kind":"def","line":177,"name":"Std.Iter.filterMapM","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Iterators/Combinators/FilterMap.lean#L177-L212"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.mapWithPostcondition\"><span class=\"name\">Std</span>.<span class=\"name\">Iter</span>.<span class=\"name\">mapWithPostcondition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β </span><span class=\"fn\">γ</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterator\">Iterator</a> <span class=\"fn\">α</span> <a href=\"./Init/Control/Id.html#Id\">Id</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><a href=\"./Init/Data/Iterators/PostconditionMonad.html#Std.Iterators.PostconditionT\">Iterators.PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">γ</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">it</span> : <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iter\">Iter</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.IterM\">IterM</a> <span class=\"fn\">m</span> <span class=\"fn\">γ</span></span></div></div>","info":{"doc":"*Note: This is a very general combinator that requires an advanced understanding of monads,\ndependent types and termination proofs. The variants `map` and `mapM` are easier to use and\nsufficient for most use cases.*\n\nIf `it` is an iterator, then `it.mapWithPostcondition f` is another iterator that applies a monadic\nfunction `f` to all values emitted by `it` and emits the result.\n\n`f` is expected to return `PostconditionT n _`, where `n` is an arbitrary monad.\nThe `PostconditionT` transformer allows the caller to intrinsically prove properties about\n`f`'s return value in the monad `n`, enabling termination proofs depending on the specific behavior\nof `f`.\n\n**Marble diagram (without monadic effects):**\n\n```text\nit                          ---a --b --c --d -e ----⊥\nit.mapWithPostcondition     ---a'--b'--c'--d'-e'----⊥\n```\n\n(given that `f a = pure a'`, `f b = pure b'` etc.)\n\n**Termination properties:**\n\n* `Finite` instance: only if `it` is finite\n* `Productive` instance: only if `it` is productive\n\nFor certain mapping functions `f`, the resulting iterator will be finite (or productive) even though\nno `Finite` (or `Productive`) instance is provided. For example, if `f` is an `ExceptT` monad and\nwill always fail, then `it.mapWithPostcondition` will be finite even if `it` isn't.\n\nIn such situations, the missing instances can be proved manually if the postcondition bundled in\nthe `PostconditionT n` monad is strong enough. In the given example, a suitable postcondition might\nbe `fun _ => False`.\n\n**Performance:**\n\nFor each value emitted by the base iterator `it`, this combinator calls `f`.\n","docLink":"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.mapWithPostcondition","kind":"def","line":133,"name":"Std.Iter.mapWithPostcondition","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Iterators/Combinators/FilterMap.lean#L133-L175"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.filterWithPostcondition\"><span class=\"name\">Std</span>.<span class=\"name\">Iter</span>.<span class=\"name\">filterWithPostcondition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterator\">Iterator</a> <span class=\"fn\">α</span> <a href=\"./Init/Control/Id.html#Id\">Id</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><a href=\"./Init/Data/Iterators/PostconditionMonad.html#Std.Iterators.PostconditionT\">Iterators.PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#ULift\">ULift</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">it</span> : <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iter\">Iter</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.IterM\">IterM</a> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>","info":{"doc":"*Note: This is a very general combinator that requires an advanced understanding of monads,\ndependent types and termination proofs. The variants `filter` and `filterM` are easier to use and\nsufficient for most use cases.*\n\nIf `it` is an iterator, then `it.filterWithPostcondition f` is another iterator that applies a monadic\npredicate `f` to all values emitted by `it` and emits them only if they are accepted by `f`.\n\n`f` is expected to return `PostconditionT n (ULift Bool)`, where `n` is an arbitrary monad.\nThe `PostconditionT` transformer allows the caller to intrinsically prove properties about\n`f`'s return value in the monad `n`, enabling termination proofs depending on the specific behavior\nof `f`.\n\n**Marble diagram (without monadic effects):**\n\n```text\nit                             ---a--b--c--d-e--⊥\nit.filterWithPostcondition     ---a-----c-------⊥\n```\n\n(given that `f a = f c = pure true` and `f b = f d = d e = pure false`)\n\n**Termination properties:**\n\n* `Finite` instance: only if `it` is finite\n* `Productive` instance: only if `it` is finite`\n\nFor certain mapping functions `f`, the resulting iterator will be finite (or productive) even though\nno `Finite` (or `Productive`) instance is provided. For example, if `f` is an `ExceptT` monad and\nwill always fail, then `it.filterWithPostcondition` will be finite -- and productive -- even if `it`\nisn't.\n\nIn such situations, the missing instances can be proved manually if the postcondition bundled in\nthe `PostconditionT n` monad is strong enough. In the given example, a suitable postcondition might\nbe `fun _ => False`.\n\n**Performance:**\n\nFor each value emitted by the base iterator `it`, this combinator calls `f`.\n","docLink":"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.filterWithPostcondition","kind":"def","line":88,"name":"Std.Iter.filterWithPostcondition","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Iterators/Combinators/FilterMap.lean#L88-L131"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.filterMapWithPostcondition\"><span class=\"name\">Std</span>.<span class=\"name\">Iter</span>.<span class=\"name\">filterMapWithPostcondition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β </span><span class=\"fn\">γ</span> : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iterator\">Iterator</a> <span class=\"fn\">α</span> <a href=\"./Init/Control/Id.html#Id\">Id</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> w → <a href=\"./foundational_types.html\">Type</a> w'</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><a href=\"./Init/Data/Iterators/PostconditionMonad.html#Std.Iterators.PostconditionT\">Iterators.PostconditionT</a> <span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">γ</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">it</span> : <span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.Iter\">Iter</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Iterators/Basic.html#Std.IterM\">IterM</a> <span class=\"fn\">m</span> <span class=\"fn\">γ</span></span></div></div>","info":{"doc":"*Note: This is a very general combinator that requires an advanced understanding of monads,\ndependent types and termination proofs. The variants `filterMap` and `filterMapM` are easier to use\nand sufficient for most use cases.*\n\nIf `it` is an iterator, then `it.filterMapWithPostcondition f` is another iterator that applies a monadic\nfunction `f` to all values emitted by `it`. `f` is expected to return an `Option` inside the monad.\nIf `f` returns `none`, then nothing is emitted; if it returns `some x`, then `x` is emitted.\n\n`f` is expected to return `PostconditionT n (Option _)`, where `n` is an arbitrary monad.\nThe `PostconditionT` transformer allows the caller to intrinsically prove properties about\n`f`'s return value in the monad `n`, enabling termination proofs depending on the specific behavior\nof `f`.\n\n**Marble diagram (without monadic effects):**\n\n```text\nit                                ---a --b--c --d-e--⊥\nit.filterMapWithPostcondition     ---a'-----c'-------⊥\n```\n\n(given that `f a = pure (some a')`, `f c = pure (some c')` and `f b = f d = d e = pure none`)\n\n**Termination properties:**\n\n* `Finite` instance: only if `it` is finite\n* `Productive` instance: only if `it` is finite\n\nFor certain mapping functions `f`, the resulting iterator will be finite (or productive) even though\nno `Finite` (or `Productive`) instance is provided. For example, if `f` never returns `none`, then\nthis combinator will preserve productiveness. If `f` is an `ExceptT` monad and will always fail,\nthen `it.filterMapWithPostcondition` will be finite even if `it` isn't. In the first case, consider\nusing the `map`/`mapM`/`mapWithPostcondition` combinators instead, which provide more instances out of\nthe box.\n\nIn such situations, the missing instances can be proved manually if the postcondition bundled in\nthe `PostconditionT n` monad is strong enough. If `f` always returns `some _`, a suitable\npostcondition is `fun x => x.isSome`; if `f` always fails, a suitable postcondition might be\n`fun _ => False`.\n\n**Performance:**\n\nFor each value emitted by the base iterator `it`, this combinator calls `f` and matches on the\nreturned `Option` value.\n","docLink":"./Init/Data/Iterators/Combinators/FilterMap.html#Std.Iter.filterMapWithPostcondition","kind":"def","line":38,"name":"Std.Iter.filterMapWithPostcondition","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Iterators/Combinators/FilterMap.lean#L38-L86"}}],"imports":["Init.Data.Iterators.Combinators.Monadic.FilterMap"],"instances":[],"name":"Init.Data.Iterators.Combinators.FilterMap"}