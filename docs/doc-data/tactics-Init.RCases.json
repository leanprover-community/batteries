[{"userName": "rintro",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.rintro",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "rintro"}]]},
        {"text": " tactic is a combination of the "},
        {"element": ["code", true, [], [{"text": "intros"}]]},
        {"text": " tactic with "},
        {"element": ["code", true, [], [{"text": "rcases"}]]},
        {"text": " to"},
        {"raw": "\n"},
        {"text":
         "allow for destructuring patterns while introducing variables. See "},
        {"element": ["code", true, [], [{"text": "rcases"}]]},
        {"text": " for"},
        {"raw": "\n"},
        {"text": "a description of supported patterns. For example, "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "rintro"},
           {"text": " "},
           {"text": "(a"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "⟨b,"},
           {"text": " "},
           {"text": "c⟩)"},
           {"text": " "},
           {"text": "⟨d,"},
           {"text": " "},
           {"text": "e⟩"}]]},
        {"raw": "\n"},
        {"text":
         "will introduce two variables, and then do case splits on both of them producing"},
        {"raw": "\n"},
        {"text": "two subgoals, one with variables "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "a"},
           {"text": " "},
           {"text": "d"},
           {"text": " "},
           {"text": "e"}]]},
        {"text": " and the other with "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "b"},
           {"text": " "},
           {"text": "c"},
           {"text": " "},
           {"text": "d"},
           {"text": " "},
           {"text": "e"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "rintro"}]]},
        {"text": ", unlike "},
        {"element": ["code", true, [], [{"text": "rcases"}]]},
        {"text": ", also supports the form "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "(x"},
           {"text": " "},
           {"text": "y"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "ty)"}]]},
        {"text": " for introducing"},
        {"raw": "\n"},
        {"text":
         "and type-ascripting multiple variables at once, similar to binders."}]]}]]},
  "definingModule": "Init.RCases"},
 {"userName": "obtain",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.obtain",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"text": "The "},
        {"element": ["code", true, [], [{"text": "obtain"}]]},
        {"text": " tactic is a combination of "},
        {"element": ["code", true, [], [{"text": "have"}]]},
        {"text": " and "},
        {"element": ["code", true, [], [{"text": "rcases"}]]},
        {"text": ". See "},
        {"element": ["code", true, [], [{"text": "rcases"}]]},
        {"text": " for"},
        {"raw": "\n"},
        {"text": "a description of supported patterns."}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "obtain"},
           {"text": " "},
           {"text": "⟨patt⟩"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "type"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "proof"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element": ["p", true, [], [{"text": "is equivalent to"}]]},
     {"element":
      ["pre",
       true,
       [],
       [{"element":
         ["code",
          true,
          [["class", "language-lean"]],
          [{"text": "have"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "type"},
           {"text": " "},
           {"text": ":="},
           {"text": " "},
           {"text": "proof"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""},
           {"text": "rcases"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "⟨patt⟩"},
           {"text": ""},
           {"text": "\n"},
           {"text": ""}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "If "},
        {"element": ["code", true, [], [{"text": "⟨patt⟩"}]]},
        {"text": " is omitted, "},
        {"element": ["code", true, [], [{"text": "rcases"}]]},
        {"text": " will try to infer the pattern."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "If "},
        {"element": ["code", true, [], [{"text": "type"}]]},
        {"text": " is omitted, "},
        {"element":
         ["code",
          true,
          [],
          [{"text": ":="}, {"text": " "}, {"text": "proof"}]]},
        {"text": " is required."}]]}]]},
  "definingModule": "Init.RCases"},
 {"userName": "rcases",
  "tags": [],
  "internalName": "Lean.Parser.Tactic.rcases",
  "docString":
  {"element":
   ["p",
    true,
    [],
    [{"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "rcases"}]]},
        {"text": " is a tactic that will perform "},
        {"element": ["code", true, [], [{"text": "cases"}]]},
        {"text": " recursively, according to a pattern. It is used to"},
        {"raw": "\n"},
        {"text":
         "destructure hypotheses or expressions composed of inductive types like "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h1"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "a"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "∧"},
           {"text": " "},
           {"text": "c"},
           {"text": " "},
           {"text": "∨"},
           {"text": " "},
           {"text": "d"}]]},
        {"text": " or"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h2"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "∃"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "y,"},
           {"text": " "},
           {"text": "trans_rel"},
           {"text": " "},
           {"text": "R"},
           {"text": " "},
           {"text": "x"},
           {"text": " "},
           {"text": "y"}]]},
        {"text": ". Usual usage might be "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "rcases"},
           {"text": " "},
           {"text": "h1"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "⟨ha,"},
           {"text": " "},
           {"text": "hb,"},
           {"text": " "},
           {"text": "hc⟩"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "hd"}]]},
        {"text": " or"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "rcases"},
           {"text": " "},
           {"text": "h2"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "⟨x,"},
           {"text": " "},
           {"text": "y,"},
           {"text": " "},
           {"text": "_"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "⟨z,"},
           {"text": " "},
           {"text": "hxz,"},
           {"text": " "},
           {"text": "hzy⟩⟩"}]]},
        {"text": " for these examples."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "Each element of an "},
        {"element": ["code", true, [], [{"text": "rcases"}]]},
        {"text":
         " pattern is matched against a particular local hypothesis (most of which"},
        {"raw": "\n"},
        {"text": "are generated during the execution of "},
        {"element": ["code", true, [], [{"text": "rcases"}]]},
        {"text": " and represent individual elements destructured from"},
        {"raw": "\n"},
        {"text": "the input expression). An "},
        {"element": ["code", true, [], [{"text": "rcases"}]]},
        {"text": " pattern has the following grammar:"}]]},
     {"element":
      ["ul",
       true,
       [],
       [{"element":
         ["li",
          true,
          [],
          [{"text": "A name like "},
           {"element": ["code", true, [], [{"text": "x"}]]},
           {"text": ", which names the active hypothesis as "},
           {"element": ["code", true, [], [{"text": "x"}]]},
           {"text": "."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "A blank "},
           {"element": ["code", true, [], [{"text": "_"}]]},
           {"text":
            ", which does nothing (letting the automatic naming system used by "},
           {"element": ["code", true, [], [{"text": "cases"}]]},
           {"text": " name the"},
           {"raw": "\n"},
           {"text": "hypothesis)."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "A hyphen "},
           {"element": ["code", true, [], [{"text": "-"}]]},
           {"text":
            ", which clears the active hypothesis and any dependents."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "The keyword "},
           {"element":
            ["code",
             true,
             [],
             [{"element":
               ["a",
                true,
                [["href", "./Init/Prelude.html#rfl"]],
                [{"text": "rfl"}]]}]]},
           {"text": ", which expects the hypothesis to be "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "h"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "a"},
              {"text": " "},
              {"text": "="},
              {"text": " "},
              {"text": "b"}]]},
           {"text": ", and calls "},
           {"element": ["code", true, [], [{"text": "subst"}]]},
           {"text": " on the"},
           {"raw": "\n"},
           {"text": "hypothesis (which has the effect of replacing "},
           {"element": ["code", true, [], [{"text": "b"}]]},
           {"text": " with "},
           {"element": ["code", true, [], [{"text": "a"}]]},
           {"text": " everywhere or vice versa)."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "A type ascription "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "p"},
              {"text": " "},
              {"text": ":"},
              {"text": " "},
              {"text": "ty"}]]},
           {"text": ", which sets the type of the hypothesis to "},
           {"element": ["code", true, [], [{"text": "ty"}]]},
           {"text": " and then matches it"},
           {"raw": "\n"},
           {"text": "against "},
           {"element": ["code", true, [], [{"text": "p"}]]},
           {"text": ". (Of course, "},
           {"element": ["code", true, [], [{"text": "ty"}]]},
           {"text": " must unify with the actual type of "},
           {"element": ["code", true, [], [{"text": "h"}]]},
           {"text": " for this to work.)"}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "A tuple pattern "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "⟨p1,"},
              {"text": " "},
              {"text": "p2,"},
              {"text": " "},
              {"text": "p3⟩"}]]},
           {"text":
            ", which matches a constructor with many arguments, or a series"},
           {"raw": "\n"},
           {"text":
            "of nested conjunctions or existentials. For example if the active hypothesis is "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "a"},
              {"text": " "},
              {"text": "∧"},
              {"text": " "},
              {"text": "b"},
              {"text": " "},
              {"text": "∧"},
              {"text": " "},
              {"text": "c"}]]},
           {"text": ","},
           {"raw": "\n"},
           {"text": "then the conjunction will be destructured, and "},
           {"element": ["code", true, [], [{"text": "p1"}]]},
           {"text": " will be matched against "},
           {"element": ["code", true, [], [{"text": "a"}]]},
           {"text": ", "},
           {"element": ["code", true, [], [{"text": "p2"}]]},
           {"text": " against "},
           {"element": ["code", true, [], [{"text": "b"}]]},
           {"raw": "\n"},
           {"text": "and so on."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "A "},
           {"element": ["code", true, [], [{"text": "@"}]]},
           {"text": " before a tuple pattern as in "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "@⟨p1,"},
              {"text": " "},
              {"text": "p2,"},
              {"text": " "},
              {"text": "p3⟩"}]]},
           {"text": " will bind all arguments in the constructor,"},
           {"raw": "\n"},
           {"text": "while leaving the "},
           {"element": ["code", true, [], [{"text": "@"}]]},
           {"text":
            " off will only use the patterns on the explicit arguments."}]]},
        {"element":
         ["li",
          true,
          [],
          [{"text": "An alternation pattern "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "p1"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "p2"},
              {"text": " "},
              {"text": "|"},
              {"text": " "},
              {"text": "p3"}]]},
           {"text":
            ", which matches an inductive type with multiple constructors,"},
           {"raw": "\n"},
           {"text": "or a nested disjunction like "},
           {"element":
            ["code",
             true,
             [],
             [{"text": "a"},
              {"text": " "},
              {"text": "∨"},
              {"text": " "},
              {"text": "b"},
              {"text": " "},
              {"text": "∨"},
              {"text": " "},
              {"text": "c"}]]},
           {"text": "."}]]}]]},
     {"element":
      ["p",
       true,
       [],
       [{"text": "A pattern like "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⟨a,"},
           {"text": " "},
           {"text": "b,"},
           {"text": " "},
           {"text": "c⟩"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "⟨d,"},
           {"text": " "},
           {"text": "e⟩"}]]},
        {"text": " will do a split over the inductive datatype,"},
        {"raw": "\n"},
        {"text":
         "naming the first three parameters of the first constructor as "},
        {"element": ["code", true, [], [{"text": "a,b,c"}]]},
        {"text": " and the"},
        {"raw": "\n"},
        {"text": "first two of the second constructor "},
        {"element": ["code", true, [], [{"text": "d,e"}]]},
        {"text": ". If the list is not as long as the"},
        {"raw": "\n"},
        {"text":
         "number of arguments to the constructor or the number of constructors, the"},
        {"raw": "\n"},
        {"text":
         "remaining variables will be automatically named. If there are nested brackets"},
        {"raw": "\n"},
        {"text": "such as "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⟨⟨a⟩,"},
           {"text": " "},
           {"text": "b"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "c⟩"},
           {"text": " "},
           {"text": "|"},
           {"text": " "},
           {"text": "d"}]]},
        {"text": " then these will cause more case splits as necessary."},
        {"raw": "\n"},
        {"text": "If there are too many arguments, such as "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⟨a,"},
           {"text": " "},
           {"text": "b,"},
           {"text": " "},
           {"text": "c⟩"}]]},
        {"text": " for splitting on"},
        {"raw": "\n"},
        {"element":
         ["code",
          true,
          [],
          [{"text": "∃"},
           {"text": " "},
           {"text": "x,"},
           {"text": " "},
           {"text": "∃"},
           {"text": " "},
           {"text": "y,"},
           {"text": " "},
           {"text": "p"},
           {"text": " "},
           {"text": "x"}]]},
        {"text": ", then it will be treated as "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "⟨a,"},
           {"text": " "},
           {"text": "⟨b,"},
           {"text": " "},
           {"text": "c⟩⟩"}]]},
        {"text": ", splitting the last"},
        {"raw": "\n"},
        {"text": "parameter as necessary."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element": ["code", true, [], [{"text": "rcases"}]]},
        {"text":
         " also has special support for quotient types: quotient induction into Prop works like"},
        {"raw": "\n"},
        {"text": "matching on the constructor "},
        {"element": ["code", true, [], [{"text": "quot.mk"}]]},
        {"text": "."}]]},
     {"element":
      ["p",
       true,
       [],
       [{"element":
         ["code",
          true,
          [],
          [{"text": "rcases"},
           {"text": " "},
           {"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "e"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "PAT"}]]},
        {"text": " will do the same as "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "rcases"},
           {"text": " "},
           {"text": "e"},
           {"text": " "},
           {"text": "with"},
           {"text": " "},
           {"text": "PAT"}]]},
        {"text": " with the exception that an"},
        {"raw": "\n"},
        {"text": "assumption "},
        {"element":
         ["code",
          true,
          [],
          [{"text": "h"},
           {"text": " "},
           {"text": ":"},
           {"text": " "},
           {"text": "e"},
           {"text": " "},
           {"text": "="},
           {"text": " "},
           {"text": "PAT"}]]},
        {"text": " will be added to the context."}]]}]]},
  "definingModule": "Init.RCases"}]