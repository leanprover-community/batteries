{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/SameCtorUtils.html#Lean.Meta.withSharedCtorIndices\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">withSharedCtorIndices</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctor</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Given a constructor (applied to the parameters already), brings its fields into scope twice,\nbut uses the same variable for fields that appear in the result type, so that the resulting\nconstructor applications have the same type.\n\nPasses to `k`\n* the new variables\n* the indices to the type class\n* the fields of the first constructor application\n* the fields of the second constructor application\n","docLink":"./Lean/Meta/SameCtorUtils.html#Lean.Meta.withSharedCtorIndices","kind":"def","line":65,"name":"Lean.Meta.withSharedCtorIndices","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/SameCtorUtils.lean#L65-L98"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/SameCtorUtils.html#Lean.Meta.occursInCtorTypeMask\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">occursInCtorTypeMask</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctorName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span></div></div>","info":{"doc":"Given a constructor, returns a mask of its fields, where `true` means that this field\noccurs in the result type of the constructor.\n","docLink":"./Lean/Meta/SameCtorUtils.html#Lean.Meta.occursInCtorTypeMask","kind":"def","line":52,"name":"Lean.Meta.occursInCtorTypeMask","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/SameCtorUtils.lean#L52-L63"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/SameCtorUtils.html#Lean.Meta.occursOrInType\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">occursOrInType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lctx</span> : <a href=\"./Lean/LocalContext.html#Lean.LocalContext\">LocalContext</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">t</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Returns true if `e` occurs either in `t`, or in the type of a sub-expression of `t`.\n\nConsider the following example:\n```lean\ninductive Tyₛ : Type (u+1)\n| SPi : (T : Type u) -> (T -> Tyₛ) -> Tyₛ\n\ninductive Tmₛ.{u} :  Tyₛ.{u} -> Type (u+1)\n| app : Tmₛ (.SPi T A) -> (arg : T) -> Tmₛ (A arg)```\n```\nWhen looking for fixed arguments in `Tmₛ.app`, if we only consider occurrences in the term `Tmₛ (A arg)`,\n`T` is considered non-fixed despite the fact that `A : T -> Tyₛ`.\nThis leads to an ill-typed injectivity theorem signature:\n```lean\ntheorem Tmₛ.app.inj {T : Type u} {A : T → Tyₛ} {a : Tmₛ (Tyₛ.SPi T A)} {arg : T} {T_1 : Type u} {a_1 : Tmₛ (Tyₛ.SPi T_1 A)} :\nTmₛ.app a arg = Tmₛ.app a_1 arg →\n  T = T_1 ∧ a ≍ a_1 := fun x => Tmₛ.noConfusion x fun T_eq A_eq a_eq arg_eq => eq_of_heq a_eq\n```\nInstead of checking the type of every subterm, we only need to check the type of free variables, since free variables introduced in\nthe constructor may only appear in the type of other free variables introduced after them.\n","docLink":"./Lean/Meta/SameCtorUtils.html#Lean.Meta.occursOrInType","kind":"def","line":22,"name":"Lean.Meta.occursOrInType","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/SameCtorUtils.lean#L22-L50"}}],"imports":["Lean.Meta.Basic","Lean.Meta.Transform"],"instances":[],"name":"Lean.Meta.SameCtorUtils"}