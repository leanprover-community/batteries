{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.«termRegister_parser_alias(Kind:=_)______»\"><span class=\"name\">Lean</span>.<span class=\"name\">«termRegister_parser_alias(Kind:=_)______»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.«termRegister_parser_alias(Kind:=_)______»","kind":"def","line":323,"name":"Lean.«termRegister_parser_alias(Kind:=_)______»","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L323-L323"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppHardLineUnlessUngrouped.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppHardLineUnlessUngrouped</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.ppHardLineUnlessUngrouped.formatter","kind":"def","line":304,"name":"Lean.ppHardLineUnlessUngrouped.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L304-L308"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppDedentIfGrouped.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppDedentIfGrouped</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.ppDedentIfGrouped.formatter","kind":"def","line":299,"name":"Lean.ppDedentIfGrouped.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L299-L303"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppAllowUngrouped.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppAllowUngrouped</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.ppAllowUngrouped.formatter","kind":"def","line":297,"name":"Lean.ppAllowUngrouped.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L297-L298"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppDedent.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppDedent</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.ppDedent.formatter","kind":"def","line":293,"name":"Lean.ppDedent.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L293-L295"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppIndent.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppIndent</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.ppIndent.formatter","kind":"def","line":292,"name":"Lean.ppIndent.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L292-L292"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppRealGroup.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppRealGroup</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.ppRealGroup.formatter","kind":"def","line":291,"name":"Lean.ppRealGroup.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L291-L291"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppRealFill.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppRealFill</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.ppRealFill.formatter","kind":"def","line":290,"name":"Lean.ppRealFill.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L290-L290"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppLine.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppLine</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.ppLine.formatter","kind":"def","line":289,"name":"Lean.ppLine.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L289-L289"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppSpace.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppSpace</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.ppSpace.formatter","kind":"def","line":288,"name":"Lean.ppSpace.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L288-L288"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.ppHardSpace.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">ppHardSpace</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.ppHardSpace.formatter","kind":"def","line":287,"name":"Lean.ppHardSpace.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L287-L287"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppHardLineUnlessUngrouped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppHardLineUnlessUngrouped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"No-op parser combinator that prints a line break.\nThe line break is soft if the combinator is followed\nby an ungrouped parser (see ppAllowUngrouped), otherwise hard. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppHardLineUnlessUngrouped","kind":"def","line":276,"name":"Lean.Parser.ppHardLineUnlessUngrouped","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L276-L280"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppDedentIfGrouped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppDedentIfGrouped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></span></div></div>","info":{"doc":"No-op parser combinator that advises the pretty printer to dedent the given syntax,\nif it was grouped by the category parser.\nDedenting can in particular be used to counteract automatic indentation. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppDedentIfGrouped","kind":"def","line":270,"name":"Lean.Parser.ppDedentIfGrouped","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L270-L274"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppAllowUngrouped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppAllowUngrouped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"No-op parser combinator that allows the pretty printer to omit the group and\nindent operation in the enclosing category parser.\n```\nsyntax ppAllowUngrouped \"by \" tacticSeq : term\n-- allows a `by` after `:=` without linebreak in between:\ntheorem foo : True := by\n  trivial\n```\n","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppAllowUngrouped","kind":"def","line":258,"name":"Lean.Parser.ppAllowUngrouped","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L258-L268"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppDedent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppDedent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></span></div></div>","info":{"doc":"No-op parser combinator that advises the pretty printer to dedent the given syntax.\nDedenting can in particular be used to counteract automatic indentation. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppDedent","kind":"def","line":253,"name":"Lean.Parser.ppDedent","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L253-L256"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppGroup\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppGroup</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"No-op parser combinator that advises the pretty printer to group and indent the given syntax.\nBy default, only syntax categories are grouped. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppGroup","kind":"def","line":249,"name":"Lean.Parser.ppGroup","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L249-L252"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppIndent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppIndent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></span></div></div>","info":{"doc":"No-op parser combinator that advises the pretty printer to indent the given syntax without grouping it. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppIndent","kind":"def","line":247,"name":"Lean.Parser.ppIndent","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L247-L248"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppRealGroup\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppRealGroup</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></span></div></div>","info":{"doc":"No-op parser combinator that advises the pretty printer to emit a `Format.group` node. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppRealGroup","kind":"def","line":245,"name":"Lean.Parser.ppRealGroup","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L245-L246"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppRealFill\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppRealFill</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></span></div></div>","info":{"doc":"No-op parser combinator that advises the pretty printer to emit a `Format.fill` node. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppRealFill","kind":"def","line":243,"name":"Lean.Parser.ppRealFill","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L243-L244"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppLine\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppLine</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"No-op parser that advises the pretty printer to emit a hard line break. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppLine","kind":"def","line":241,"name":"Lean.Parser.ppLine","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L241-L242"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppSpace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppSpace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"No-op parser that advises the pretty printer to emit a space/soft line break. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppSpace","kind":"def","line":239,"name":"Lean.Parser.ppSpace","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L239-L240"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ppHardSpace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ppHardSpace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"No-op parser that advises the pretty printer to emit a non-breaking space. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ppHardSpace","kind":"def","line":237,"name":"Lean.Parser.ppHardSpace","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L237-L238"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.patternIgnore\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">patternIgnore</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> → <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></span></div></div>","info":{"doc":"No-op parser combinator that annotates subtrees to be ignored in syntax patterns. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.patternIgnore","kind":"def","line":233,"name":"Lean.Parser.patternIgnore","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L233-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.notSymbol\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">notSymbol</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.Parser.notSymbol","kind":"def","line":230,"name":"Lean.Parser.notSymbol","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L230-L231"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">sepBy1Indent</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_sep</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pSep</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent.formatter","kind":"def","line":226,"name":"Lean.Parser.sepBy1Indent.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L226-L226"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.sepByIndent.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">sepByIndent</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_sep</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pSep</span> : <a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.Parser.sepByIndent.formatter","kind":"def","line":211,"name":"Lean.Parser.sepByIndent.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L211-L224"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">sepBy1Indent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sep</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">psep</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> := <span class=\"fn\"><a href=\"./Lean/Parser/Basic.html#Lean.Parser.symbol\">symbol</a> <span class=\"fn\">sep</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowTrailingSep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent","kind":"def","line":206,"name":"Lean.Parser.sepBy1Indent","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L206-L208"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.sepByIndent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">sepByIndent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sep</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">psep</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> := <span class=\"fn\"><a href=\"./Lean/Parser/Basic.html#Lean.Parser.symbol\">symbol</a> <span class=\"fn\">sep</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowTrailingSep</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.Parser.sepByIndent","kind":"def","line":202,"name":"Lean.Parser.sepByIndent","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L202-L204"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.manyIndent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">manyIndent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `manyIndent(p)` is equivalent to `withPosition((colGe p)*)`. This has the effect of\nparsing zero or more occurrences of `p`, where each subsequent `p` parse needs to be indented\nthe same or more than the first parse.\n\nThis parser has arity 1, and returns a list of the results from `p`.\n`p` is \"auto-grouped\" if it is not arity 1. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.manyIndent","kind":"def","line":193,"name":"Lean.Parser.manyIndent","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L193-L200"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.many1Indent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">many1Indent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `many1Indent(p)` is equivalent to `withPosition((colGe p)+)`. This has the effect of\nparsing one or more occurrences of `p`, where each subsequent `p` parse needs to be indented\nthe same or more than the first parse.\n\nThis parser has arity 1, and returns a list of the results from `p`.\n`p` is \"auto-grouped\" if it is not arity 1. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.many1Indent","kind":"def","line":184,"name":"Lean.Parser.many1Indent","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L184-L191"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.group\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">group</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `group(p)` parses the same thing as `p`, but it wraps the results in a `groupKind`\nnode.\n\nThis parser always has arity 1, even if `p` does not. Parsers like `p*` are automatically\nrewritten to `group(p)*` if `p` does not have arity 1, so that the results from separate invocations\nof `p` can be differentiated. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.group","kind":"def","line":175,"name":"Lean.Parser.group","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L175-L182"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.nameLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">nameLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `name` parses a name literal like `` `foo``. The syntax is the same as for identifiers\n(see `ident`) but with a leading backquote.\n\nThis parser has arity 1: it produces a `nameLitKind` node containing the raw literal\n(including the backquote).\nYou can use `TSyntax.getName` to extract the name from the resulting syntax object. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.nameLit","kind":"def","line":166,"name":"Lean.Parser.nameLit","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L166-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.charLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">charLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `char` parses a character literal, such as `'a'` or `'\\n'`. Character literals can\ncontain C-style escapes like `\\n`, `\\\"`, `\\x00` or `\\u2665`, as well as literal unicode characters\nlike `∈`, but must evaluate to a single unicode codepoint, so `'♥'` is allowed but `'❤️'` is not\n(since it is two codepoints but one grapheme cluster).\n\nThis parser has arity 1: it produces a `charLitKind` node containing an atom with the raw\nliteral (including the quote marks and without interpreting the escapes).\nYou can use `TSyntax.getChar` to decode the string from the resulting syntax object. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.charLit","kind":"def","line":155,"name":"Lean.Parser.charLit","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L155-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.strLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">strLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `str` parses a string literal, such as `\"foo\"` or `\"\\r\\n\"`. Strings can contain\nC-style escapes like `\\n`, `\\\"`, `\\x00` or `\\u2665`, as well as literal unicode characters like `∈`.\nNewlines in a string are interpreted literally.\n\nThis parser has arity 1: it produces a `strLitKind` node containing an atom with the raw\nliteral (including the quote marks and without interpreting the escapes).\nYou can use `TSyntax.getString` to decode the string from the resulting syntax object. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.strLit","kind":"def","line":145,"name":"Lean.Parser.strLit","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L145-L153"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.scientificLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">scientificLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `scientific` parses a scientific-notation literal, such as `1.3e-24`.\n\nThis parser has arity 1: it produces a `scientificLitKind` node containing an atom with the text\nof the literal.\nYou can use `TSyntax.getScientific` to extract the parts from the resulting syntax object. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.scientificLit","kind":"def","line":137,"name":"Lean.Parser.scientificLit","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L137-L143"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.hexnum\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">hexnum</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `hexnum` parses a hexadecimal numeric literal not containing the `0x` prefix.\n\nIt produces a `hexnumKind` node containing an atom with the text of the\nliteral. This parser is mainly used for creating atoms such `#<hexnum>`. Recall that `hexnum`\nis not a token and this parser must be prefixed by another parser.\n\nFor numerals such as `0xadef100a`, you should use `numLit`.\n","docLink":"./Lean/Parser/Extra.html#Lean.Parser.hexnum","kind":"def","line":126,"name":"Lean.Parser.hexnum","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L126-L135"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.numLit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">numLit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `num` parses a numeric literal in several bases:\n\n* Decimal: `129`\n* Hexadecimal: `0xdeadbeef`\n* Octal: `0o755`\n* Binary: `0b1101`\n\nThis parser has arity 1: it produces a `numLitKind` node containing an atom with the text of the\nliteral.\nYou can use `TSyntax.getNat` to extract the number from the resulting syntax object. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.numLit","kind":"def","line":113,"name":"Lean.Parser.numLit","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L113-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.hygieneInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">hygieneInfo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `hygieneInfo` parses no text, but creates a `hygieneInfoKind` node\ncontaining an anonymous identifier as if it were parsed at the current position.\nThis identifier is modified by syntax quotations to add macro scopes like a regular identifier.\n\nThis is used to implement `have := ...` syntax: the `hygieneInfo` between the `have` and `:=`\ncollects macro scopes, which we can apply to `this` when expanding to `have this := ...`.\nSee [the language reference](https://lean-lang.org/doc/reference/4.29.0-rc1/find/?domain=Verso.Genre.Manual.section&name=macro-hygiene) for more information about\nmacro hygiene.\n\nThis is also used to implement cdot functions such as `(1 + ·)`. The opening parenthesis contains\na `hygieneInfo` node as does the cdot, which lets cdot expansion hygienically associate parentheses to cdots.\n\nThis parser has arity 1: it produces a `hygieneInfoKind` node containing an anonymous `Syntax.ident`.\nYou can use `HygieneInfo.mkIdent` to create an `Ident` from the syntax object,\nbut you can also use `TSyntax.getHygieneInfo` to get the raw name from the identifier. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.hygieneInfo","kind":"def","line":94,"name":"Lean.Parser.hygieneInfo","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L94-L111"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.rawIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">rawIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.Parser.rawIdent","kind":"def","line":91,"name":"Lean.Parser.rawIdent","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L91-L92"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.identWithPartialTrailingDot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">identWithPartialTrailingDot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Extra.html#Lean.Parser.identWithPartialTrailingDot","kind":"def","line":87,"name":"Lean.Parser.identWithPartialTrailingDot","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L87-L88"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.ident\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">ident</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `ident` parses a single identifier, possibly with namespaces, such as `foo` or\n`bar.baz`. The identifier must not be a declared token, so for example it will not match `\"def\"`\nbecause `def` is a keyword token. Tokens are implicitly declared by using them in string literals\nin parser declarations, so `syntax foo := \"bla\"` will make `bla` no longer legal as an identifier.\n\nIdentifiers can contain special characters or keywords if they are escaped using the `«»` characters:\n`«def»` is an identifier named `def`, and `«x»` is treated the same as `x`. This is useful for\nusing disallowed characters in identifiers such as `«foo.bar».baz` or `«hello world»`.\n\nThis parser has arity 1: it produces a `Syntax.ident` node containing the parsed identifier.\nYou can use `TSyntax.getId` to extract the name from the resulting syntax object. ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.ident","kind":"def","line":69,"name":"Lean.Parser.ident","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L69-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.many1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">many1</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `many1(p)`, or `p+`, repeats `p` until it fails, and returns the list of results.\n`p` must succeed at least once, or this parser will fail.\n\nNote that this parser produces the same parse tree as the `many(p)` / `p*` combinator,\nand one matches both `p*` and `p+` using `$[ .. ]*` syntax in a syntax match.\n(There is no `$[ .. ]+` syntax.)\n\nThe argument `p` is \"auto-grouped\", meaning that if the arity is greater than 1 it will be\nautomatically replaced by `group(p)` to ensure that it produces exactly 1 value.\n\nThis parser has arity 1: it produces a `nullKind` node containing one argument for each\ninvocation of `p` (or `group(p)`). ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.many1","kind":"def","line":54,"name":"Lean.Parser.many1","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L54-L67"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.many\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">many</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `many(p)`, or `p*`, repeats `p` until it fails, and returns the list of results.\n\nThe argument `p` is \"auto-grouped\", meaning that if the arity is greater than 1 it will be\nautomatically replaced by `group(p)` to ensure that it produces exactly 1 value.\n\nThis parser has arity 1: it produces a `nullKind` node containing one argument for each\ninvocation of `p` (or `group(p)`). ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.many","kind":"def","line":44,"name":"Lean.Parser.many","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L44-L52"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Extra.html#Lean.Parser.optional\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">optional</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The parser `optional(p)`, or `(p)?`, parses `p` if it succeeds,\notherwise it succeeds with no value.\n\nNote that because `?` is a legal identifier character, one must write `(p)?` or `p ?` for\nit to parse correctly. `ident?` will not work; one must write `(ident)?` instead.\n\nThis parser has arity 1: it produces a `nullKind` node containing either zero arguments\n(for the `none` case) or the list of arguments produced by `p`.\n(In particular, if `p` has arity 0 then the two cases are not differentiated!) ","docLink":"./Lean/Parser/Extra.html#Lean.Parser.optional","kind":"def","line":32,"name":"Lean.Parser.optional","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Parser/Extra.lean#L32-L42"}}],"imports":["Lean.PrettyPrinter.Formatter","Lean.PrettyPrinter.Parenthesizer","Lean.Parser.Types","Lean.Parser.Basic","Lean.Parser.Extension","Lean.Hygiene"],"instances":[],"name":"Lean.Parser.Extra"}