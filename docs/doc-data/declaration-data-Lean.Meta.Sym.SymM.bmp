{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isDefEqI\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">isDefEqI</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s </span><span class=\"fn\">t</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Similar to `Meta.isDefEqI`, but the result is cache using pointer equality. ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isDefEqI","kind":"def","line":224,"name":"Lean.Meta.Sym.isDefEqI","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L224-L231"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isDebugEnabled\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">isDebugEnabled</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Returns `true` if `sym.debug` is set ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isDebugEnabled","kind":"def","line":220,"name":"Lean.Meta.Sym.isDebugEnabled","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L220-L222"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.share\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">share</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Incremental variant of `shareCommon` for expressions constructed from already-shared subterms.\n\nUse this when an expression `e` was produced by a Lean API (e.g., `inferType`, `mkApp4`) that\ndoes not preserve maximal sharing, but the inputs to that API were already maximally shared.\n\nUnlike `shareCommon`, this function does not use a local `Std.HashMap ExprPtr Expr` to\ntrack visited nodes. This is more efficient when the number of new (unshared) nodes is small,\nwhich is the common case when wrapping API calls that build a few constructor nodes around\nshared inputs.\n\nExample:\n```\n-- `a` and `b` are already maximally shared\nlet result := mkApp2 f a b  -- result is not maximally shared\nlet result ← shareCommonInc result -- efficiently restore sharing\n```\n","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.share","kind":"def","line":216,"name":"Lean.Meta.Sym.share","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L216-L218"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommonInc\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">shareCommonInc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Incremental variant of `shareCommon` for expressions constructed from already-shared subterms.\n\nUse this when an expression `e` was produced by a Lean API (e.g., `inferType`, `mkApp4`) that\ndoes not preserve maximal sharing, but the inputs to that API were already maximally shared.\n\nUnlike `shareCommon`, this function does not use a local `Std.HashMap ExprPtr Expr` to\ntrack visited nodes. This is more efficient when the number of new (unshared) nodes is small,\nwhich is the common case when wrapping API calls that build a few constructor nodes around\nshared inputs.\n\nExample:\n```\n-- `a` and `b` are already maximally shared\nlet result := mkApp2 f a b  -- result is not maximally shared\nlet result ← shareCommonInc result -- efficiently restore sharing\n```\n","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommonInc","kind":"def","line":192,"name":"Lean.Meta.Sym.shareCommonInc","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L192-L214"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommon\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">shareCommon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Applies hash-consing to `e`. Recall that all expressions in a `grind` goal have\nbeen hash-consed. We perform this step before we internalize expressions.\n","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.shareCommon","kind":"def","line":182,"name":"Lean.Meta.Sym.shareCommon","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L182-L190"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getIntExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">getIntExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Returns the internalized `Int`.  ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getIntExpr","kind":"def","line":179,"name":"Lean.Meta.Sym.getIntExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L179-L180"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getOrderingEqExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">getOrderingEqExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Returns the internalized `Ordering.eq`.  ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getOrderingEqExpr","kind":"def","line":177,"name":"Lean.Meta.Sym.getOrderingEqExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L177-L178"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getNatZeroExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">getNatZeroExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Returns the internalized `0 : Nat` numeral.  ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getNatZeroExpr","kind":"def","line":175,"name":"Lean.Meta.Sym.getNatZeroExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L175-L176"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isBoolFalseExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">isBoolFalseExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Returns `true` if `e` is the internalized `Bool.false` expression.  ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isBoolFalseExpr","kind":"def","line":173,"name":"Lean.Meta.Sym.isBoolFalseExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L173-L174"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getBoolFalseExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">getBoolFalseExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Returns the internalized `Bool.false`.  ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getBoolFalseExpr","kind":"def","line":171,"name":"Lean.Meta.Sym.getBoolFalseExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L171-L172"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isBoolTrueExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">isBoolTrueExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Returns `true` if `e` is the internalized `Bool.true` expression.  ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isBoolTrueExpr","kind":"def","line":169,"name":"Lean.Meta.Sym.isBoolTrueExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L169-L170"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getBoolTrueExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">getBoolTrueExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Returns the internalized `Bool.true`.  ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getBoolTrueExpr","kind":"def","line":167,"name":"Lean.Meta.Sym.getBoolTrueExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L167-L168"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isFalseExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">isFalseExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Returns `true` if `e` is the internalized `False` expression.  ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isFalseExpr","kind":"def","line":165,"name":"Lean.Meta.Sym.isFalseExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L165-L166"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getFalseExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">getFalseExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Returns the internalized `False` constant.  ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getFalseExpr","kind":"def","line":163,"name":"Lean.Meta.Sym.getFalseExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L163-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isTrueExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">isTrueExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Returns `true` if `e` is the internalized `True` expression.  ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.isTrueExpr","kind":"def","line":161,"name":"Lean.Meta.Sym.isTrueExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L161-L162"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getTrueExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">getTrueExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Returns the internalized `True` constant.  ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getTrueExpr","kind":"def","line":159,"name":"Lean.Meta.Sym.getTrueExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L159-L160"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getSharedExprs\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">getSharedExprs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs\">SharedExprs</a></span></div></div>","info":{"doc":"Returns maximally shared commonly used terms ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.getSharedExprs","kind":"def","line":155,"name":"Lean.Meta.Sym.getSharedExprs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L155-L157"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM.run\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">SymM</span>.<span class=\"name\">run</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM.run","kind":"def","line":150,"name":"Lean.Meta.Sym.SymM.run","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L150-L153"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">SymM</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM","kind":"def","line":138,"name":"Lean.Meta.Sym.SymM","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L138-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.debug\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">State</span>.<span class=\"name\">debug</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.debug","kind":"def","line":136,"name":"Lean.Meta.Sym.State.debug","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L136-L136"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.defEqI\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">State</span>.<span class=\"name\">defEqI</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> (<a href=\"./Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr\">ExprPtr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr\">ExprPtr</a>) <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Cache for `isDefEqI` results ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.defEqI","kind":"def","line":135,"name":"Lean.Meta.Sym.State.defEqI","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L135-L135"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.congrInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">State</span>.<span class=\"name\">congrInfo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr\">ExprPtr</a> <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo\">CongrInfo</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.congrInfo","kind":"def","line":133,"name":"Lean.Meta.Sym.State.congrInfo","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L133-L133"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.getLevel\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">State</span>.<span class=\"name\">getLevel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr\">ExprPtr</a> <a href=\"./Lean/Level.html#Lean.Level\">Level</a></span></div></div>","info":{"doc":"Cache for `getLevel` results, keyed by pointer equality.\n","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.getLevel","kind":"def","line":132,"name":"Lean.Meta.Sym.State.getLevel","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L132-L132"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.inferType\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">State</span>.<span class=\"name\">inferType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr\">ExprPtr</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Cache for `inferType` results, keyed by pointer equality.\n`SymM` uses a fixed configuration, so we can use a simpler key than `MetaM`.\nRemark: type inference is a bottleneck on `Meta.Tactic.Simp` simplifier.\n","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.inferType","kind":"def","line":128,"name":"Lean.Meta.Sym.State.inferType","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L128-L128"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.proofInstInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">State</span>.<span class=\"name\">proofInstInfo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo\">ProofInstInfo</a>)</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.proofInstInfo","kind":"def","line":122,"name":"Lean.Meta.Sym.State.proofInstInfo","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L122-L122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.maxFVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">State</span>.<span class=\"name\">maxFVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr\">ExprPtr</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span></div></div>","info":{"doc":"Maps expressions to their maximal free variable (by declaration index).\n\n- `maxFVar[e] = some fvarId` means `fvarId` is the free variable with the largest declaration\n  index occurring in `e`.\n- `maxFVar[e] = none` means `e` contains no free variables (but may contain metavariables).\n\nRecall that if `e` contains a metavariable `?m`, then we assume `e` may contain any free variable\nin the local context associated with `?m`.\n\nThis mapping enables O(1) local context compatibility checks during metavariable assignment.\nInstead of traversing local contexts with `isSubPrefixOf`, we check if the maximal free variable\nin the assigned value is in scope of the metavariable's local context.\n\n**Note**: We considered using a mapping `PHashMap ExprPtr FVarId`. However, there is a corner\ncase that is not supported by this representation. `e` contains a metavariable (with an empty local context),\nand no free variables.\n","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.maxFVar","kind":"def","line":121,"name":"Lean.Meta.Sym.State.maxFVar","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L121-L121"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.share\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">State</span>.<span class=\"name\">share</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/AlphaShareCommon.html#Lean.Meta.Sym.AlphaShareCommon.State\">AlphaShareCommon.State</a></div></div>","info":{"doc":"`ShareCommon` (aka `Hash-consing`) state. ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.share","kind":"def","line":102,"name":"Lean.Meta.Sym.State.share","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L102-L102"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">State</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">share</span> : <a href=\"./Lean/Meta/Sym/AlphaShareCommon.html#Lean.Meta.Sym.AlphaShareCommon.State\">AlphaShareCommon.State</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">maxFVar</span> : <span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr\">ExprPtr</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proofInstInfo</span> : <span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo\">ProofInstInfo</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inferType</span> : <span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr\">ExprPtr</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">getLevel</span> : <span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr\">ExprPtr</a> <a href=\"./Lean/Level.html#Lean.Level\">Level</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">congrInfo</span> : <span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr\">ExprPtr</a> <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo\">CongrInfo</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">defEqI</span> : <span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> (<a href=\"./Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr\">ExprPtr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Meta/Sym/ExprPtr.html#Lean.Meta.Sym.ExprPtr\">ExprPtr</a>) <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">debug</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State\">State</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State.mk","kind":"ctor","line":100,"name":"Lean.Meta.Sym.State.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L100-L100"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">State</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Mutable state for the symbolic computation framework. ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.State","kind":"structure","line":99,"name":"Lean.Meta.Sym.State","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L99-L136"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.Context.sharedExprs\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">Context</span>.<span class=\"name\">sharedExprs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs\">SharedExprs</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.Context.sharedExprs","kind":"def","line":97,"name":"Lean.Meta.Sym.Context.sharedExprs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L97-L97"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.Context.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">Context</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sharedExprs</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs\">SharedExprs</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.Context\">Context</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.Context.mk","kind":"ctor","line":96,"name":"Lean.Meta.Sym.Context.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L96-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.Context\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">Context</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Readonly context for the symbolic computation framework. ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.Context","kind":"structure","line":95,"name":"Lean.Meta.Sym.Context","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L95-L97"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.intExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">SharedExprs</span>.<span class=\"name\">intExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs\">SharedExprs</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.intExpr","kind":"def","line":93,"name":"Lean.Meta.Sym.SharedExprs.intExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L93-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.ordEqExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">SharedExprs</span>.<span class=\"name\">ordEqExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs\">SharedExprs</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.ordEqExpr","kind":"def","line":92,"name":"Lean.Meta.Sym.SharedExprs.ordEqExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L92-L92"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.bfalseExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">SharedExprs</span>.<span class=\"name\">bfalseExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs\">SharedExprs</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.bfalseExpr","kind":"def","line":91,"name":"Lean.Meta.Sym.SharedExprs.bfalseExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L91-L91"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.btrueExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">SharedExprs</span>.<span class=\"name\">btrueExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs\">SharedExprs</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.btrueExpr","kind":"def","line":90,"name":"Lean.Meta.Sym.SharedExprs.btrueExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L90-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.natZExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">SharedExprs</span>.<span class=\"name\">natZExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs\">SharedExprs</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.natZExpr","kind":"def","line":89,"name":"Lean.Meta.Sym.SharedExprs.natZExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L89-L89"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.falseExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">SharedExprs</span>.<span class=\"name\">falseExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs\">SharedExprs</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.falseExpr","kind":"def","line":88,"name":"Lean.Meta.Sym.SharedExprs.falseExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L88-L88"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.trueExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">SharedExprs</span>.<span class=\"name\">trueExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs\">SharedExprs</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.trueExpr","kind":"def","line":87,"name":"Lean.Meta.Sym.SharedExprs.trueExpr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L87-L87"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">SharedExprs</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">trueExpr </span><span class=\"fn\">falseExpr </span><span class=\"fn\">natZExpr </span><span class=\"fn\">btrueExpr </span><span class=\"fn\">bfalseExpr </span><span class=\"fn\">ordEqExpr </span><span class=\"fn\">intExpr</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs\">SharedExprs</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs.mk","kind":"ctor","line":86,"name":"Lean.Meta.Sym.SharedExprs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L86-L86"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">SharedExprs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Pre-shared expressions for commonly used terms. ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SharedExprs","kind":"structure","line":85,"name":"Lean.Meta.Sym.SharedExprs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L85-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo.congrTheorem\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">CongrInfo</span>.<span class=\"name\">congrTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">thm</span> : <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">CongrTheorem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo\">CongrInfo</a></div></div>","info":{"doc":"For functions that have proofs and `Decidable` arguments. For this kind of function we generate\na custom theorem.\nExample: `Array.eraseIdx {α : Type u} (xs : Array α) (i : Nat) (h : i < xs.size) : Array α`.\nThe proof argument `h` depends on `xs` and `i`. To be able to rewrite `xs` and `i`, we use the\nauto-generated theorem.\n```\nArray.eraseIdx.congr_simp {α : Type u} (xs xs' : Array α) (e_xs : xs = xs')\n    (i i' : Nat) (e_i : i = i') (h : i < xs.size) : xs.eraseIdx i h = xs'.eraseIdx i' ⋯\n```\n","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo.congrTheorem","kind":"ctor","line":72,"name":"Lean.Meta.Sym.CongrInfo.congrTheorem","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L72-L83"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo.interlaced\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">CongrInfo</span>.<span class=\"name\">interlaced</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rewritable</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo\">CongrInfo</a></div></div>","info":{"doc":"For functions with interlaced rewritable and non-rewritable arguments.\nEach element indicates whether the corresponding argument position can be rewritten.\n\nExample: For `HEq {α : Sort u} (a : α) {β : Sort u} (b : β)`, the mask would be\n`#[false, true, false, true]` — we can rewrite `a` and `b`, but not `α` or `β`.\n","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo.interlaced","kind":"ctor","line":64,"name":"Lean.Meta.Sym.CongrInfo.interlaced","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L64-L71"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo.fixedPrefix\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">CongrInfo</span>.<span class=\"name\">fixedPrefix</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prefixSize </span><span class=\"fn\">suffixSize</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo\">CongrInfo</a></div></div>","info":{"doc":"For functions with a fixed prefix of implicit/instance arguments followed by\nexplicit non-dependent arguments that can be rewritten independently.\n\n- `prefixSize`: Number of leading arguments (types, instances) that are determined\n  by the suffix arguments and should not be rewritten directly.\n- `suffixSize`: Number of trailing arguments that can be rewritten using simple congruence.\n\nExamples (showing `prefixSize`, `suffixSize`):\n- `HAdd.hAdd {α β γ} [HAdd α β γ] (a : α) (b : β)`: `(4, 2)` — rewrite `a` and `b`\n- `And (p q : Prop)`: `(0, 2)` — rewrite both propositions\n- `Eq {α} (a b : α)`: `(1, 2)` — rewrite `a` and `b`, type `α` is fixed\n- `Neg.neg {α} [Neg α] (a : α)`: `(2, 1)` — rewrite just `a`\n","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo.fixedPrefix","kind":"ctor","line":49,"name":"Lean.Meta.Sym.CongrInfo.fixedPrefix","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L49-L63"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo.none\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">CongrInfo</span>.<span class=\"name\">none</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo\">CongrInfo</a></div></div>","info":{"doc":"None of the arguments of the function can be rewritten. ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo.none","kind":"ctor","line":47,"name":"Lean.Meta.Sym.CongrInfo.none","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L47-L48"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">CongrInfo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Information on how to build congruence proofs for function applications.\nThis enables efficient rewriting of subterms without repeatedly inferring types or instances.\n","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.CongrInfo","kind":"inductive","line":42,"name":"Lean.Meta.Sym.CongrInfo","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L42-L83"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstInfo.default\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">instInhabitedProofInstInfo</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo\">ProofInstInfo</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstInfo.default","kind":"def","line":40,"name":"Lean.Meta.Sym.instInhabitedProofInstInfo.default","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L40-L40"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">instInhabitedProofInstInfo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo\">ProofInstInfo</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstInfo","kind":"instance","line":40,"name":"Lean.Meta.Sym.instInhabitedProofInstInfo","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L40-L40"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo.argsInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">ProofInstInfo</span>.<span class=\"name\">argsInfo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo\">ProofInstInfo</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo\">ProofInstArgInfo</a></span></div></div>","info":{"doc":"Information about each argument position. ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo.argsInfo","kind":"def","line":39,"name":"Lean.Meta.Sym.ProofInstInfo.argsInfo","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L39-L39"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">ProofInstInfo</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">argsInfo</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo\">ProofInstArgInfo</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo\">ProofInstInfo</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo.mk","kind":"ctor","line":37,"name":"Lean.Meta.Sym.ProofInstInfo.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L37-L37"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">ProofInstInfo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Information about a function symbol. It stores which argument positions are proofs or instances,\nenabling optimizations during pattern matching and structural definitional equality tests\nsuch as skipping proof arguments or deferring instance synthesis.\n","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstInfo","kind":"structure","line":32,"name":"Lean.Meta.Sym.ProofInstInfo","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L32-L40"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstArgInfo.default\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">instInhabitedProofInstArgInfo</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo\">ProofInstArgInfo</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstArgInfo.default","kind":"def","line":30,"name":"Lean.Meta.Sym.instInhabitedProofInstArgInfo.default","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L30-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstArgInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">instInhabitedProofInstArgInfo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo\">ProofInstArgInfo</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.instInhabitedProofInstArgInfo","kind":"instance","line":30,"name":"Lean.Meta.Sym.instInhabitedProofInstArgInfo","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L30-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo.isInstance\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">ProofInstArgInfo</span>.<span class=\"name\">isInstance</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo\">ProofInstArgInfo</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"`true` if this argument is a type class instance. ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo.isInstance","kind":"def","line":29,"name":"Lean.Meta.Sym.ProofInstArgInfo.isInstance","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L29-L29"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo.isProof\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">ProofInstArgInfo</span>.<span class=\"name\">isProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo\">ProofInstArgInfo</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"`true` if this argument is a proof (its type is a `Prop`). ","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo.isProof","kind":"def","line":27,"name":"Lean.Meta.Sym.ProofInstArgInfo.isProof","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L27-L27"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">ProofInstArgInfo</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isProof </span><span class=\"fn\">isInstance</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo\">ProofInstArgInfo</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo.mk","kind":"ctor","line":25,"name":"Lean.Meta.Sym.ProofInstArgInfo.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L25-L25"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">ProofInstArgInfo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Information about a single argument position in a function's type signature.\n\nThis is used during pattern matching and structural definitional equality tests\nto identify arguments that can be skipped or handled specially\n(e.g., instance arguments can be synthesized, proof arguments can be inferred).\n","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.ProofInstArgInfo","kind":"structure","line":18,"name":"Lean.Meta.Sym.ProofInstArgInfo","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L18-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.sym.debug\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">sym</span>.<span class=\"name\">debug</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.sym.debug","kind":"opaque","line":13,"name":"Lean.Meta.Sym.sym.debug","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/SymM.lean#L13-L16"}}],"imports":["Lean.Meta.Sym.AlphaShareCommon","Lean.Meta.CongrTheorems"],"instances":[{"className":"Inhabited","name":"Lean.Meta.Sym.instInhabitedProofInstArgInfo","typeNames":["Lean.Meta.Sym.ProofInstArgInfo"]},{"className":"Inhabited","name":"Lean.Meta.Sym.instInhabitedProofInstInfo","typeNames":["Lean.Meta.Sym.ProofInstInfo"]}],"name":"Lean.Meta.Sym.SymM"}