{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Actions.html#Std.Tactic.BVDecide.LRAT.Internal.intActionToDefaultClauseAction\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">intActionToDefaultClauseAction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Actions.html#Std.Tactic.BVDecide.LRAT.IntAction\">IntAction</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Actions.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClauseAction\">DefaultClauseAction</a> <span class=\"fn\">n</span>)</span></span></span></div></div>","info":{"doc":"Since `IntAction` is a convenient parsing target and `DefaultClauseAction` is a useful Action type\nfor working with default clauses, an expected workflow pattern is to parse an external LRAT proof\ninto a list of `IntAction`s, and then use this function to convert that list of `IntAction`s to\n`DefaultClauseAction`s.\n\nThis function returns an `Option` type so that `none` can be returned if converting from the\n`IntAction` to `DefaultClauseAction` fails. This can occur if any of the literals in the `IntAction`\nare 0 or ≥ n.\n","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Actions.html#Std.Tactic.BVDecide.LRAT.Internal.intActionToDefaultClauseAction","kind":"def","line":60,"name":"Std.Tactic.BVDecide.LRAT.Internal.intActionToDefaultClauseAction","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/BVDecide/LRAT/Internal/Actions.lean#L60-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Actions.html#Std.Tactic.BVDecide.LRAT.Internal.intToLiteral\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">intToLiteral</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Std/Sat/CNF/Literal.html#Std.Sat.Literal\">Sat.Literal</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Actions.html#Std.Tactic.BVDecide.LRAT.Internal.intToLiteral","kind":"def","line":50,"name":"Std.Tactic.BVDecide.LRAT.Internal.intToLiteral","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/BVDecide/LRAT/Internal/Actions.lean#L50-L58"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Actions.html#Std.Tactic.BVDecide.LRAT.Internal.natLiteralToPosFinLiteral\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">natLiteralToPosFinLiteral</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Std/Sat/CNF/Literal.html#Std.Sat.Literal\">Sat.Literal</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Std/Sat/CNF/Literal.html#Std.Sat.Literal\">Sat.Literal</a> <span class=\"fn\">(<a href=\"./Std/Tactic/BVDecide/LRAT/Internal/PosFin.html#Std.Tactic.BVDecide.LRAT.Internal.PosFin\">PosFin</a> <span class=\"fn\">n</span>)</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Actions.html#Std.Tactic.BVDecide.LRAT.Internal.natLiteralToPosFinLiteral","kind":"def","line":43,"name":"Std.Tactic.BVDecide.LRAT.Internal.natLiteralToPosFinLiteral","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/BVDecide/LRAT/Internal/Actions.lean#L43-L48"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Actions.html#Std.Tactic.BVDecide.LRAT.Internal.WellFormedAction\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">WellFormedAction</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Internal/Clause.html#Std.Tactic.BVDecide.LRAT.Internal.Clause\">Clause</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/BVDecide/LRAT/Actions.html#Std.Tactic.BVDecide.LRAT.Action\">Action</a> <span class=\"fn\">β</span> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>","info":{"doc":"A predicate for Actions that ensures that the pivot of a clause is always included in the clause.\nIn the LRAT format, the clause's pivot is always its first literal. However, from an interface\nperspective, it is awkward to require that all `Clause` implementations preserve the ordering of\ntheir literals. It is also awkward to have the pivot in the `addRat` action not included in the\nclause itself, since then the pivot would need to be readded to the clause when it is added to the\nformula. So to avoid imposing awkward constraints on the `Clause` interface, and to avoid requiring\n`Formula` implementations to add pivots to the clauses provided by the `addRat` action, we use this\npredicate to indicate that the pivot provided by the `addRat` action is indeed in the provided\nclause.\n","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Actions.html#Std.Tactic.BVDecide.LRAT.Internal.WellFormedAction","kind":"def","line":27,"name":"Std.Tactic.BVDecide.LRAT.Internal.WellFormedAction","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/BVDecide/LRAT/Internal/Actions.lean#L27-L41"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/BVDecide/LRAT/Internal/Actions.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClauseAction\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BVDecide</span>.<span class=\"name\">LRAT</span>.<span class=\"name\">Internal</span>.<span class=\"name\">DefaultClauseAction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"`Action` where variables have type `PosFin n`, clauses are `DefaultClause`, and ids are `Nat`.\nThis Action type is meant to be usable for verifying LRAT proofs that operate on default formulas.\n","docLink":"./Std/Tactic/BVDecide/LRAT/Internal/Actions.html#Std.Tactic.BVDecide.LRAT.Internal.DefaultClauseAction","kind":"def","line":21,"name":"Std.Tactic.BVDecide.LRAT.Internal.DefaultClauseAction","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/BVDecide/LRAT/Internal/Actions.lean#L21-L25"}}],"imports":["Std.Tactic.BVDecide.LRAT.Actions","Std.Tactic.BVDecide.LRAT.Internal.Clause"],"instances":[],"name":"Std.Tactic.BVDecide.LRAT.Internal.Actions"}