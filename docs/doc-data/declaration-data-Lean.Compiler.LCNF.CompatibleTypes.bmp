{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypes\"><span class=\"name\">Lean</span>.<span class=\"name\">Compiler</span>.<span class=\"name\">LCNF</span>.<span class=\"name\">InferType</span>.<span class=\"name\">compatibleTypes</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.InferTypeM\">InferTypeM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Return true if the LCNF types `a` and `b` are compatible.\nRemark: `a` and `b` can be type formers (e.g., `List`, or `fun (α : Type) => Nat → Nat × α`)\nRemark: We may need to eta-expand type formers to establish whether they are compatible or not.\nFor example, suppose we have\n```\nfun (x : B) => Id B ◾ ◾\nId B ◾\n```\nWe must eta-expand `Id B ◾` to `fun (x : B) => Id B ◾ x`. Note that, we use `x` instead of `◾` to\nmake the implementation simpler and skip the check whether `B` is a type former type. However,\nthis simplification should not affect correctness since `◾` is compatible with everything.\nRemark: see comment at `isErasedCompatible`.\nRemark: because of \"erasure confusion\" see note above, we assume `◾` (aka `lcErasure`) is compatible with everything.\nThis is a simplification. We used to use `isErasedCompatible`, but this only address item 1.\nFor item 2, we would have to modify the `toLCNFType` function and make sure a type former is erased if the expected\ntype is not always a type former (see `S.mk` type and example in the note above).\n","docLink":"./Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypes","kind":"def","line":126,"name":"Lean.Compiler.LCNF.InferType.compatibleTypes","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Compiler/LCNF/CompatibleTypes.lean#L126-L148"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypesFull\"><span class=\"name\">Lean</span>.<span class=\"name\">Compiler</span>.<span class=\"name\">LCNF</span>.<span class=\"name\">InferType</span>.<span class=\"name\">compatibleTypesFull</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.InferTypeM\">InferTypeM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Complete check for `compatibleTypes`. It eta-expands type formers. See comment at `compatibleTypes`.\n","docLink":"./Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypesFull","kind":"opaque","line":75,"name":"Lean.Compiler.LCNF.InferType.compatibleTypesFull","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Compiler/LCNF/CompatibleTypes.lean#L75-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.compatibleTypesQuick\"><span class=\"name\">Lean</span>.<span class=\"name\">Compiler</span>.<span class=\"name\">LCNF</span>.<span class=\"name\">compatibleTypesQuick</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Quick check for `compatibleTypes`. It is not monadic, but it is incomplete\nbecause it does not eta-expand type formers. See comment at `compatibleTypes`.\nRemark: if the result is `true`, then `a` and `b` are indeed compatible.\nIf it is `false`, we must use the full-check.\n","docLink":"./Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.compatibleTypesQuick","kind":"opaque","line":48,"name":"Lean.Compiler.LCNF.compatibleTypesQuick","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Compiler/LCNF/CompatibleTypes.lean#L48-L73"}}],"imports":["Lean.Compiler.LCNF.InferType"],"instances":[],"name":"Lean.Compiler.LCNF.CompatibleTypes"}