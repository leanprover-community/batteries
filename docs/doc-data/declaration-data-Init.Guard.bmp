{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Command.guardCmd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">guardCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Command to check that an expression evaluates to `true`.\n\n`#guard e` elaborates `e` ensuring its type is `Bool` then evaluates `e` and checks that\nthe result is `true`. The term is elaborated *without* variables declared using `variable`, since\nthese cannot be evaluated.\n\nSince this makes use of coercions, so long as a proposition `p` is decidable, one can write\n`#guard p` rather than `#guard decide p`. A consequence to this is that if there is decidable\nequality one can write `#guard a = b`. Note that this is not exactly the same as checking\nif `a` and `b` evaluate to the same thing since it uses the `DecidableEq` instance to do\nthe evaluation.\n\nNote: this uses the untrusted evaluator, so `#guard` passing is *not* a proof that the\nexpression equals `true`. ","docLink":"./Init/Guard.html#Lean.Parser.Command.guardCmd","kind":"def","line":112,"name":"Lean.Parser.Command.guardCmd","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L112-L127"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Command.guardExprCmd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">guardExprCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Command to check equality of two expressions.\n* `#guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `#guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `#guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `#guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nThis is a command version of the `guard_expr` tactic. ","docLink":"./Init/Guard.html#Lean.Parser.Command.guardExprCmd","kind":"def","line":102,"name":"Lean.Parser.Command.guardExprCmd","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L102-L110"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Tactic.guardHypConv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">guardHypConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n","docLink":"./Init/Guard.html#Lean.Parser.Tactic.guardHypConv","kind":"def","line":95,"name":"Lean.Parser.Tactic.guardHypConv","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L95-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Tactic.guardHyp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">guardHyp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n","docLink":"./Init/Guard.html#Lean.Parser.Tactic.guardHyp","kind":"def","line":79,"name":"Lean.Parser.Tactic.guardHyp","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L79-L94"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Tactic.guardTargetConv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">guardTargetConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n","docLink":"./Init/Guard.html#Lean.Parser.Tactic.guardTargetConv","kind":"def","line":76,"name":"Lean.Parser.Tactic.guardTargetConv","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L76-L77"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Tactic.guardTarget\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">guardTarget</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n","docLink":"./Init/Guard.html#Lean.Parser.Tactic.guardTarget","kind":"def","line":65,"name":"Lean.Parser.Tactic.guardTarget","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L65-L75"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Tactic.guardExprConv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">guardExprConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n","docLink":"./Init/Guard.html#Lean.Parser.Tactic.guardExprConv","kind":"def","line":62,"name":"Lean.Parser.Tactic.guardExprConv","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L62-L63"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.Tactic.guardExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">guardExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n","docLink":"./Init/Guard.html#Lean.Parser.Tactic.guardExpr","kind":"def","line":50,"name":"Lean.Parser.Tactic.guardExpr","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L50-L61"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.equal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">equal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `guard_expr` matching specifier, one of `=`, `=~`, `=ₛ`, `=ₐ` ","docLink":"./Init/Guard.html#Lean.Parser.equal","kind":"def","line":45,"name":"Lean.Parser.equal","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L45-L46"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.equalA\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">equalA</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Alpha-eq matching for `guard_expr` ","docLink":"./Init/Guard.html#Lean.Parser.equalA","kind":"def","line":43,"name":"Lean.Parser.equalA","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L43-L44"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.equalS\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">equalS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Syntactic matching for `guard_expr` ","docLink":"./Init/Guard.html#Lean.Parser.equalS","kind":"def","line":41,"name":"Lean.Parser.equalS","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L41-L42"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.equalD\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">equalD</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Default-reducibility defeq matching for `guard_expr` ","docLink":"./Init/Guard.html#Lean.Parser.equalD","kind":"def","line":39,"name":"Lean.Parser.equalD","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L39-L40"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.equalR\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">equalR</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Reducible defeq matching for `guard_expr` ","docLink":"./Init/Guard.html#Lean.Parser.equalR","kind":"def","line":37,"name":"Lean.Parser.equalR","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L37-L38"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonEq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `guard_hyp` value specifier, one of `:=`, `:=~`, `:=ₛ`, `:=ₐ` ","docLink":"./Init/Guard.html#Lean.Parser.colonEq","kind":"def","line":34,"name":"Lean.Parser.colonEq","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L34-L35"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonEqA\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonEqA</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Alpha-eq matching for `guard_hyp` values ","docLink":"./Init/Guard.html#Lean.Parser.colonEqA","kind":"def","line":32,"name":"Lean.Parser.colonEqA","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L32-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonEqS\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonEqS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Syntactic matching for `guard_hyp` values ","docLink":"./Init/Guard.html#Lean.Parser.colonEqS","kind":"def","line":30,"name":"Lean.Parser.colonEqS","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L30-L31"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonEqD\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonEqD</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Default-reducibility defeq matching for `guard_hyp` values ","docLink":"./Init/Guard.html#Lean.Parser.colonEqD","kind":"def","line":28,"name":"Lean.Parser.colonEqD","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L28-L29"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonEqR\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonEqR</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Reducible defeq matching for `guard_hyp` values ","docLink":"./Init/Guard.html#Lean.Parser.colonEqR","kind":"def","line":26,"name":"Lean.Parser.colonEqR","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L26-L27"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colon</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `guard_hyp` type specifier, one of `:`, `:~`, `:ₛ`, `:ₐ` ","docLink":"./Init/Guard.html#Lean.Parser.colon","kind":"def","line":23,"name":"Lean.Parser.colon","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L23-L24"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonA\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonA</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Alpha-eq matching for `guard_hyp` types ","docLink":"./Init/Guard.html#Lean.Parser.colonA","kind":"def","line":21,"name":"Lean.Parser.colonA","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L21-L22"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonS\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Syntactic matching for `guard_hyp` types ","docLink":"./Init/Guard.html#Lean.Parser.colonS","kind":"def","line":19,"name":"Lean.Parser.colonS","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L19-L20"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonD\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonD</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Default-reducibility defeq matching for `guard_hyp` types ","docLink":"./Init/Guard.html#Lean.Parser.colonD","kind":"def","line":17,"name":"Lean.Parser.colonD","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L17-L18"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Guard.html#Lean.Parser.colonR\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">colonR</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Reducible defeq matching for `guard_hyp` types ","docLink":"./Init/Guard.html#Lean.Parser.colonR","kind":"def","line":15,"name":"Lean.Parser.colonR","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Guard.lean#L15-L16"}}],"imports":["Init.NotationExtra"],"instances":[],"name":"Init.Guard"}