{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">quotSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq","kind":"def","line":1023,"name":"Lean.Parser.Tactic.quotSeq","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L1023-L1024"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot","kind":"def","line":1021,"name":"Lean.Parser.Tactic.quot","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L1021-L1022"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.logNamedWarningAtMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">logNamedWarningAtMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Logs a warning, tagging the message as a named diagnostic with the specified name and validating\nthat an associated error explanation exists. The error name must be followed by a `Syntax` at which\nthe warning is to be logged. The message is the final argument and may be passed as an interpolated\nstring or a `MessageData` term.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.logNamedWarningAtMacro","kind":"def","line":1010,"name":"Lean.Parser.Term.logNamedWarningAtMacro","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L1010-L1017"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.logNamedWarningMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">logNamedWarningMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Logs a warning, tagging the message as a named diagnostic with the specified name and validating\nthat an associated error explanation exists. The message may be passed as an interpolated string or\na `MessageData` term. The result of `getRef` is used as position information.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.logNamedWarningMacro","kind":"def","line":1002,"name":"Lean.Parser.Term.logNamedWarningMacro","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L1002-L1008"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.logNamedErrorAtMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">logNamedErrorAtMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Logs an error, tagging the message as a named error with the specified name and validating that an\nassociated error explanation exists. The error name must be followed by a `Syntax` at which the\nerror is to be logged. The message is the final argument and may be passed as an interpolated string\nor a `MessageData` term.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.logNamedErrorAtMacro","kind":"def","line":993,"name":"Lean.Parser.Term.logNamedErrorAtMacro","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L993-L1000"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.logNamedErrorMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">logNamedErrorMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Logs an error, tagging the message as a named error with the specified name and validating that an\nassociated error explanation exists. The message may be passed as an interpolated string or a\n`MessageData` term. The result of `getRef` is used as position information.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.logNamedErrorMacro","kind":"def","line":985,"name":"Lean.Parser.Term.logNamedErrorMacro","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L985-L991"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.throwNamedErrorAtMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">throwNamedErrorAtMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Throws an error exception, tagging the associated message as a named error with the specified name\nand validating that an associated error explanation exists. The error name must be followed by a\n`Syntax` at which the error is to be thrown. The message is the final argument and may be passed as\nan interpolated string or a `MessageData` term.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.throwNamedErrorAtMacro","kind":"def","line":976,"name":"Lean.Parser.Term.throwNamedErrorAtMacro","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L976-L983"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.throwNamedErrorMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">throwNamedErrorMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Throws an error exception, tagging the associated message as a named error with the specified name\nand validating that an associated error explanation exists. The message may be passed as an\ninterpolated string or a `MessageData` term. The result of `getRef` is used as position information.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.throwNamedErrorMacro","kind":"def","line":968,"name":"Lean.Parser.Term.throwNamedErrorMacro","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L968-L974"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letExpr","kind":"def","line":965,"name":"Lean.Parser.Term.letExpr","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L965-L966"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchExpr","kind":"def","line":962,"name":"Lean.Parser.Term.matchExpr","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L962-L963"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchExprAlts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rhsParser</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlts","kind":"def","line":958,"name":"Lean.Parser.Term.matchExprAlts","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L958-L961"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprElseAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchExprElseAlt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rhsParser</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprElseAlt","kind":"def","line":957,"name":"Lean.Parser.Term.matchExprElseAlt","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L957-L957"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchExprAlt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rhsParser</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlt","kind":"def","line":956,"name":"Lean.Parser.Term.matchExprAlt","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L956-L956"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchExprPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchExprPat","kind":"def","line":955,"name":"Lean.Parser.Term.matchExprPat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L955-L955"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.showTermElabImpl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">showTermElabImpl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Implementation of the `show_term` term elaborator.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.showTermElabImpl","kind":"def","line":945,"name":"Lean.Parser.Term.showTermElabImpl","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L945-L949"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dotIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent","kind":"def","line":942,"name":"Lean.Parser.Term.dotIdent","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L942-L943"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dynamicQuot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot","kind":"def","line":939,"name":"Lean.Parser.Term.dynamicQuot","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L939-L940"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">stateRefT</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A state monad that uses an actual mutable reference cell (i.e. an `ST.Ref`).\n\nThis is syntax, rather than a function, to make it easier to use. Its elaborator synthesizes an\nappropriate parameter for the underlying monad's `ST` effects, then passes it to `StateRefT'`.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT","kind":"def","line":929,"name":"Lean.Parser.Term.stateRefT","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L929-L937"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroLastArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg","kind":"def","line":927,"name":"Lean.Parser.Term.macroLastArg","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L927-L927"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroDollarArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg","kind":"def","line":926,"name":"Lean.Parser.Term.macroDollarArg","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L926-L926"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg","kind":"def","line":925,"name":"Lean.Parser.Term.macroArg","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L925-L925"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.debugAssert\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">debugAssert</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`debug_assert! cond` panics if `cond` evaluates to `false` and the executing code has been built\nwith debug assertions enabled (see the `debugAssertions` option).\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.debugAssert","kind":"def","line":918,"name":"Lean.Parser.Term.debugAssert","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L918-L923"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.assert\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">assert</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`assert! cond` panics if `cond` evaluates to `false`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.assert","kind":"def","line":915,"name":"Lean.Parser.Term.assert","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L915-L917"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dbgTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace","kind":"def","line":908,"name":"Lean.Parser.Term.dbgTrace","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L908-L914"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">unreachable</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A shorthand for `panic! \"unreachable code has been reached\"`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable","kind":"def","line":905,"name":"Lean.Parser.Term.unreachable","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L905-L907"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.panic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">panic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.panic","kind":"def","line":895,"name":"Lean.Parser.Term.panic","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L895-L904"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinderF</span>) (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span>)</span></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1","kind":"instance","line":893,"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L893-L893"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">bracketedBinderF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF","kind":"def","line":892,"name":"Lean.Parser.Term.bracketedBinderF","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L892-L892"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.subst\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">subst</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">TrailingParser</a></div></div>","info":{"doc":"`h ▸ e` is a macro built on top of `Eq.rec` and `Eq.symm` definitions.\nGiven `h : a = b` and `e : p a`, the term `h ▸ e` has type `p b`.\nYou can also view `h ▸ e` as a \"type casting\" operation\nwhere you change the type of `e` by using `h`.\n\nThe macro tries both orientations of `h`. If the context provides an\nexpected type, it rewrites the expected type, else it rewrites the type of e`.\n\nSee the Chapter \"Quantifiers and Equality\" in the manual\n\"Theorem Proving in Lean\" for additional information.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.subst","kind":"def","line":877,"name":"Lean.Parser.Term.subst","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L877-L890"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">pipeCompletion</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">TrailingParser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion","kind":"def","line":874,"name":"Lean.Parser.Term.pipeCompletion","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L874-L875"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">pipeProj</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">TrailingParser</a></div></div>","info":{"doc":"`e |>.x` is a shorthand for `(e).x`.\nIt is especially useful for avoiding parentheses with repeated applications.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj","kind":"def","line":868,"name":"Lean.Parser.Term.pipeProj","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L868-L873"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">namedPattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">TrailingParser</a></div></div>","info":{"doc":"`x@e` or `x@h:e` matches the pattern `e` and binds its value to the identifier `x`.\nIf present, the identifier `h` is bound to a proof of `x = e`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern","kind":"def","line":861,"name":"Lean.Parser.Term.namedPattern","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L861-L866"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicitUniv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">TrailingParser</a></div></div>","info":{"doc":"`x.{u, ...}` explicitly specifies the universes `u, ...` of the constant `x`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv","kind":"def","line":856,"name":"Lean.Parser.Term.explicitUniv","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L856-L860"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">isIdent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent","kind":"def","line":852,"name":"Lean.Parser.Term.isIdent","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L852-L854"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.identProjKind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">identProjKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Name</a></div></div>","info":{"doc":"Syntax kind for syntax nodes representing the field of a projection in the `InfoTree`.\nSpecifically, the `InfoTree` node for a projection `s.f` contains a child `InfoTree` node\nwith syntax ``(Syntax.node .none identProjKind #[`f])``.\n\nThis is necessary because projection syntax cannot always be detected purely syntactically\n(`s.f` may refer to either the identifier `s.f` or a projection `s.f` depending on\nthe available context).\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.identProjKind","kind":"def","line":841,"name":"Lean.Parser.Term.identProjKind","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L841-L850"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.arrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">arrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">TrailingParser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.arrow","kind":"def","line":838,"name":"Lean.Parser.Term.arrow","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L838-L839"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.completion\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">completion</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">TrailingParser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.completion","kind":"def","line":836,"name":"Lean.Parser.Term.completion","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L836-L837"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.proj\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">proj</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">TrailingParser</a></div></div>","info":{"doc":"The *extended field notation* `e.f` is roughly short for `T.f e` where `T` is the type of `e`.\nMore precisely,\n* if `e` is of a function type, `e.f` is translated to `Function.f (p := e)`\n  where `p` is the first explicit parameter of function type\n* if `e` is of a named type `T ...` and there is a declaration `T.f` (possibly from `export`),\n  `e.f` is translated to `T.f (p := e)` where `p` is the first explicit parameter of type `T ...`\n* otherwise, if `e` is of a structure type,\n  the above is repeated for every base type of the structure.\n\nThe field index notation `e.i`, where `i` is a positive number,\nis short for accessing the `i`-th field (1-indexed) of `e` if it is of a structure type. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.proj","kind":"def","line":822,"name":"Lean.Parser.Term.proj","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L822-L835"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.app\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">app</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">TrailingParser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.app","kind":"def","line":820,"name":"Lean.Parser.Term.app","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L820-L820"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.argument\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">argument</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.argument","kind":"def","line":813,"name":"Lean.Parser.Term.argument","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L813-L816"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ellipsis</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"In a function application, `..` notation inserts zero or more `_` placeholders. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis","kind":"def","line":810,"name":"Lean.Parser.Term.ellipsis","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L810-L812"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">namedArgument</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument","kind":"def","line":808,"name":"Lean.Parser.Term.namedArgument","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L808-L809"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noErrorIfUnused</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Helper parser for marking `match`-alternatives that should not trigger errors if unused.\nWe use them to implement `macro_rules` and `elab_rules`\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused","kind":"def","line":801,"name":"Lean.Parser.Term.noErrorIfUnused","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L801-L806"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">defaultOrOfNonempty</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty","kind":"def","line":798,"name":"Lean.Parser.Term.defaultOrOfNonempty","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L798-L799"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfContainsMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar","kind":"def","line":795,"name":"Lean.Parser.Term.waitIfContainsMVar","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L795-L796"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfTypeContainsMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar","kind":"def","line":793,"name":"Lean.Parser.Term.waitIfTypeContainsMVar","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L793-L794"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfTypeMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar","kind":"def","line":791,"name":"Lean.Parser.Term.waitIfTypeMVar","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L791-L792"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar","kind":"def","line":789,"name":"Lean.Parser.Term.letMVar","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L789-L790"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.clear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`clear% x; e` elaborates `x` after clearing the free variable `x` from the local context.\nIf `x` cannot be cleared (due to dependencies), it will keep `x` without failing.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.clear","kind":"def","line":782,"name":"Lean.Parser.Term.clear","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L782-L787"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.valueOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">valueOf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`value_of% x` elaborates to the value of `x`, which can be a local or global definition.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.valueOf","kind":"def","line":776,"name":"Lean.Parser.Term.valueOf","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L776-L780"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noImplicitLambda</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda","kind":"def","line":774,"name":"Lean.Parser.Term.noImplicitLambda","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L774-L775"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ensureExpectedType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType","kind":"def","line":772,"name":"Lean.Parser.Term.ensureExpectedType","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L772-L773"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ensureTypeOf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf","kind":"def","line":770,"name":"Lean.Parser.Term.ensureTypeOf","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L770-L771"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeOf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf","kind":"def","line":768,"name":"Lean.Parser.Term.typeOf","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L768-L769"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">withDeclName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"* `with_decl_name% id e` elaborates `e` in a context while changing the effective\n  declaration name to `id`.\n* `with_decl_name% ?id e` does the same, but resolves `id` as a new definition name\n  (appending the current namespaces).\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName","kind":"def","line":760,"name":"Lean.Parser.Term.withDeclName","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L760-L767"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.privateDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">privateDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`private_decl% e` elaborates `e` in a private context and wraps the result in a helper `def`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.privateDecl","kind":"def","line":756,"name":"Lean.Parser.Term.privateDecl","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L756-L758"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.declName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">declName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A macro which evaluates to the name of the currently elaborating declaration. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.declName","kind":"def","line":753,"name":"Lean.Parser.Term.declName","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L753-L754"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forInMacro'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'","kind":"def","line":750,"name":"Lean.Parser.Term.forInMacro'","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L750-L751"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forInMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro","kind":"def","line":748,"name":"Lean.Parser.Term.forInMacro","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L748-L749"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.unop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">unop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`unop% f a` elaborates `f a` as a unary operation using the type propagation protocol in `Lean.Elab.Extra`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unop","kind":"def","line":744,"name":"Lean.Parser.Term.unop","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L744-L746"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.rightact\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">rightact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`rightact% f a b` elaborates `f a b` as a right action using the type propagation protocol in `Lean.Elab.Extra`.\nIn particular, it is like a unary operation with a fixed parameter `b`, where only the left argument `a` participates in the operator coercion elaborator. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.rightact","kind":"def","line":740,"name":"Lean.Parser.Term.rightact","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L740-L743"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.leftact\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">leftact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`leftact% f a b` elaborates `f a b` as a left action using the type propagation protocol in `Lean.Elab.Extra`.\nIn particular, it is like a unary operation with a fixed parameter `a`, where only the right argument `b` participates in the operator coercion elaborator. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.leftact","kind":"def","line":736,"name":"Lean.Parser.Term.leftact","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L736-L739"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binop_lazy</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`binop_lazy%` is similar to `binop% f a b`, but it wraps `b` as a function from `Unit`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy","kind":"def","line":733,"name":"Lean.Parser.Term.binop_lazy","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L733-L735"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`binop% f a b` elaborates `f a b` as a binary operation using the type propagation protocol in `Lean.Elab.Extra`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop","kind":"def","line":730,"name":"Lean.Parser.Term.binop","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L730-L732"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binrel_no_prop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`binrel_no_prop% r a b` is similar to `binrel% r a b`, but it coerces `Prop` arguments into `Bool`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop","kind":"def","line":727,"name":"Lean.Parser.Term.binrel_no_prop","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L727-L729"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binrel\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binrel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`binrel% r a b` elaborates `r a b` as a binary relation using the type propagation protocol in `Lean.Elab.Extra`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel","kind":"def","line":724,"name":"Lean.Parser.Term.binrel","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L724-L726"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.unsafe\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">unsafe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`unsafe t : α` is an expression constructor which allows using unsafe declarations inside the\nbody of `t : α`, by creating an auxiliary definition containing `t` and using `implementedBy` to\nwrap it in a safe interface. It is required that `α` is nonempty for this to be sound,\nbut even beyond that, an `unsafe` block should be carefully inspected for memory safety because\nthe compiler is unable to guarantee the safety of the operation.\n\nFor example, the `evalExpr` function is unsafe, because the compiler cannot guarantee that when\nyou call ```evalExpr Foo ``Foo e``` that the type `Foo` corresponds to the name `Foo`, but in a\nparticular use case, we can ensure this, so `unsafe (evalExpr Foo ``Foo e)` is a correct usage.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unsafe","kind":"def","line":711,"name":"Lean.Parser.Term.unsafe","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L711-L722"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noindex\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noindex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noindex","kind":"def","line":708,"name":"Lean.Parser.Term.noindex","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L708-L709"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAltsWhereDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls","kind":"def","line":704,"name":"Lean.Parser.Term.matchAltsWhereDecls","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L704-L706"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">whereDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls","kind":"def","line":700,"name":"Lean.Parser.Term.whereDecls","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L700-L702"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.whereFinally\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">whereFinally</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The `finally` section trailing a `where` opens a tactic block to fill in `?hole`s in the definition body.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.whereFinally","kind":"def","line":694,"name":"Lean.Parser.Term.whereFinally","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L694-L698"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.whereFinallySubsection\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">whereFinallySubsection</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A named subsection of `where ... finally`. In the future, sections such as `decreasing_by` might become\nsyntactic sugar for an `where ... finally` subsection `| decreasing => ...`.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.whereFinallySubsection","kind":"def","line":687,"name":"Lean.Parser.Term.whereFinallySubsection","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L687-L692"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letrec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letrec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letrec","kind":"def","line":682,"name":"Lean.Parser.Term.letrec","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L682-L685"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letRecDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`letRecDecls` matches `letRecDecl,+`, a comma-separated list of let-rec declarations (see `letRecDecl`). ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls","kind":"def","line":678,"name":"Lean.Parser.Term.letRecDecls","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L678-L681"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letRecDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`letRecDecl` matches the body of a let-rec declaration: a doc comment, attributes, and then\na let declaration without the `let` keyword, such as `/-- foo -/ @[simp] bar := 1`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl","kind":"def","line":674,"name":"Lean.Parser.Term.letRecDecl","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L674-L677"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.suffix\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">suffix</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Termination hints are `termination_by` and `decreasing_by`, in that order.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.suffix","kind":"def","line":665,"name":"Lean.Parser.Termination.suffix","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L665-L669"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.decreasingBy\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">decreasingBy</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Manually prove that the termination measure (as specified with `termination_by` or inferred)\ndecreases at each recursive call.\n\nBy default, the tactic `decreasing_tactic` is used.\n\nForces the use of well-founded recursion and is hence incompatible with\n`termination_by structural`.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.decreasingBy","kind":"def","line":653,"name":"Lean.Parser.Termination.decreasingBy","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L653-L663"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.inductiveFixpoint\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">inductiveFixpoint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Defines an inductive predicate using lattice theory, based on the Knaster-Tarski fixpoint theorem.\n\nThis feature constructs inductive predicates by leveraging the lattice structure on `Prop`\nand ensures correctness through monotonicity.\n\nThe inductive predicate is defined as the least fixed point of a monotone function on `Prop`.\n\nBy default, monotonicity is verified automatically. However, users can provide custom proofs\nof monotonicity if needed.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.inductiveFixpoint","kind":"def","line":636,"name":"Lean.Parser.Termination.inductiveFixpoint","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L636-L651"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.coinductiveFixpoint\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">coinductiveFixpoint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Defines a coinductive predicate using lattice theory, based on the Knaster-Tarski fixpoint theorem.\n\nThis feature constructs coinductive predicates by leveraging the lattice structure on `Prop`\nand ensures correctness through monotonicity.\n\nThe coinductive predicate is defined as the greatest fixed point of a monotone function on `Prop`.\n\nBy default, monotonicity is verified automatically. However, users can provide custom proofs\nof monotonicity if needed.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.coinductiveFixpoint","kind":"def","line":619,"name":"Lean.Parser.Termination.coinductiveFixpoint","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L619-L634"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.partialFixpoint\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">partialFixpoint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Defines a possibly non-terminating function as a fixed-point in a suitable partial order.\n\nSuch a function is compiled as if it was marked `partial`, but its equations are provided as\ntheorems, so that it can be verified.\n\nIn general it accepts functions whose return type has a `Lean.Order.CCPO` instance and whose\ndefinition is `Lean.Order.monotone` with regard to its recursive calls.\n\nCommon special cases are\n\n* Functions whose type is inhabited a-priori (as with `partial`), and where all recursive\n  calls are in tail-call position.\n* Monadic in certain “monotone chain-complete monads” (in particular, `Option`) composed using\n  the bind operator and other supported monadic combinators.\n\nBy default, the monotonicity proof is performed by the compositional `monotonicity` tactic. Using\nthe syntax `partial_fixpoint monotonicity by $tac` the proof can be done manually.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.partialFixpoint","kind":"def","line":594,"name":"Lean.Parser.Termination.partialFixpoint","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L594-L617"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy?\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">terminationBy?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Specify a termination measure for recursive functions.\n```\ntermination_by a - b\n```\nindicates that termination of the currently defined recursive function follows\nbecause the difference between the arguments `a` and `b` decreases.\n\nIf the function takes further argument after the colon, you can name them as follows:\n```\ndef example (a : Nat) : Nat → Nat → Nat :=\ntermination_by b c => a - b\n```\n\nBy default, a `termination_by` clause will cause the function to be constructed using well-founded\nrecursion. The syntax `termination_by structural a` (or `termination_by structural _ c => c`)\nindicates the function is expected to be structural recursive on the argument. In this case\nthe body of the `termination_by` clause must be one of the function's parameters.\n\nIf omitted, a termination measure will be inferred. If written as `termination_by?`,\nthe inferred termination measure will be suggested.\n\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy?","kind":"def","line":590,"name":"Lean.Parser.Termination.terminationBy?","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L590-L592"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">terminationBy</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Specify a termination measure for recursive functions.\n```\ntermination_by a - b\n```\nindicates that termination of the currently defined recursive function follows\nbecause the difference between the arguments `a` and `b` decreases.\n\nIf the function takes further argument after the colon, you can name them as follows:\n```\ndef example (a : Nat) : Nat → Nat → Nat :=\ntermination_by b c => a - b\n```\n\nBy default, a `termination_by` clause will cause the function to be constructed using well-founded\nrecursion. The syntax `termination_by structural a` (or `termination_by structural _ c => c`)\nindicates the function is expected to be structural recursive on the argument. In this case\nthe body of the `termination_by` clause must be one of the function's parameters.\n\nIf omitted, a termination measure will be inferred. If written as `termination_by?`,\nthe inferred termination measure will be suggested.\n\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy","kind":"def","line":561,"name":"Lean.Parser.Termination.terminationBy","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L561-L588"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attributes\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attributes</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attributes","kind":"def","line":550,"name":"Lean.Parser.Term.attributes","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L550-L551"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attrInstance</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance","kind":"def","line":548,"name":"Lean.Parser.Term.attrInstance","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L548-L548"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attrKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`attrKind` matches `(\"scoped\" <|> \"local\")?`, used before an attribute like `@[local simp]`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind","kind":"def","line":546,"name":"Lean.Parser.Term.attrKind","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L546-L547"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.local\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">local</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.local","kind":"def","line":545,"name":"Lean.Parser.Term.local","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L545-L545"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.scoped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">scoped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scoped","kind":"def","line":544,"name":"Lean.Parser.Term.scoped","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L544-L544"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letI\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letI</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`letI` behaves like `let`, but inlines the value instead of producing a `let` term. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letI","kind":"def","line":540,"name":"Lean.Parser.Term.letI","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L540-L542"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveI\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveI</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`haveI` behaves like `have`, but inlines the value instead of producing a `have` term. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveI","kind":"def","line":537,"name":"Lean.Parser.Term.haveI","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L537-L539"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_tmp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`let`-declaration that is only included in the elaborated term if variable is still there.\nIt is often used when building macros.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp","kind":"def","line":531,"name":"Lean.Parser.Term.let_tmp","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L531-L536"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_delayed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`let_delayed x := v; b` is similar to `let x := v; b`, but `b` is elaborated before `v`.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed","kind":"def","line":526,"name":"Lean.Parser.Term.let_delayed","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L526-L530"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_fun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`let_fun x := v; b` is deprecated syntax sugar for `have x := v; b`.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun","kind":"def","line":521,"name":"Lean.Parser.Term.let_fun","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L521-L525"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.have\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">have</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`have` is used to declare local hypotheses and opaque local definitions.\n\nIt has the same syntax as `let`, and it is equivalent to `let +nondep`,\ncreating a *nondependent* let expression.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.have","kind":"def","line":513,"name":"Lean.Parser.Term.have","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L513-L520"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x => 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n\nThe *anaphoric let* `let := v` defines a variable called `this`.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let","kind":"def","line":488,"name":"Lean.Parser.Term.let","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L488-L512"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letConfig\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Configuration options for `let` tactics. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letConfig","kind":"def","line":485,"name":"Lean.Parser.Term.letConfig","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L485-L487"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letConfigItem\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letConfigItem</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letConfigItem","kind":"def","line":484,"name":"Lean.Parser.Term.letConfigItem","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L484-L484"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letOptEq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letOptEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`let (eq := h) x := v; ...` adds the equality `h : x = v` to the context while elaborating the body.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letOptEq","kind":"def","line":479,"name":"Lean.Parser.Term.letOptEq","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L479-L483"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letNegOpt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letNegOpt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letNegOpt","kind":"def","line":477,"name":"Lean.Parser.Term.letNegOpt","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L477-L478"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letPosOpt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letPosOpt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letPosOpt","kind":"def","line":475,"name":"Lean.Parser.Term.letPosOpt","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L475-L476"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letOpts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letOpts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letOpts","kind":"def","line":473,"name":"Lean.Parser.Term.letOpts","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L473-L474"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letOptGeneralize\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letOptGeneralize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`+generalize` directs `let`/`have` to generalize the value from the expected type before elaborating the body.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letOptGeneralize","kind":"def","line":468,"name":"Lean.Parser.Term.letOptGeneralize","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L468-L472"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letOptZeta\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letOptZeta</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`+zeta` immediately inlines the `let` value after elaboration (it zeta reduces the `let`).\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letOptZeta","kind":"def","line":463,"name":"Lean.Parser.Term.letOptZeta","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L463-L467"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letOptUsedOnly\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letOptUsedOnly</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`+usedOnly` causes unused `let`s bindings to be eliminated.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letOptUsedOnly","kind":"def","line":458,"name":"Lean.Parser.Term.letOptUsedOnly","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L458-L462"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letOptPostponeValue\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letOptPostponeValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`+postponeValue` causes the body of the `let` to be elaborated before the value.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letOptPostponeValue","kind":"def","line":453,"name":"Lean.Parser.Term.letOptPostponeValue","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L453-L457"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letOptNondep\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letOptNondep</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`+nondep` elaborates as a nondependent `let`, a `have` expression.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letOptNondep","kind":"def","line":448,"name":"Lean.Parser.Term.letOptNondep","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L448-L452"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`letDecl` matches the body of a let declaration `let f x1 x2 := e`,\n`let pat := e` (where `pat` is an arbitrary term) or `let f | pat1 => e1 | pat2 => e2 ...`\n(a pattern matching declaration), except for the `let` keyword itself.\n`let rec` declarations are not handled here. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl","kind":"def","line":439,"name":"Lean.Parser.Term.letDecl","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L439-L447"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letEqnsDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl","kind":"def","line":437,"name":"Lean.Parser.Term.letEqnsDecl","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L437-L438"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letPatDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">requireParens</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl","kind":"def","line":419,"name":"Lean.Parser.Term.letPatDecl","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L419-L420"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl","kind":"def","line":415,"name":"Lean.Parser.Term.letIdDecl","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L415-L416"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdLhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs","kind":"def","line":413,"name":"Lean.Parser.Term.letIdLhs","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L413-L414"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder","kind":"def","line":409,"name":"Lean.Parser.Term.letIdBinder","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L409-L411"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letId\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letId</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letId","kind":"def","line":405,"name":"Lean.Parser.Term.letId","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L405-L408"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">doubleQuotedName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A resolved name literal. Evaluates to the full name of the given constant if\nexistent in the current context, or else fails.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName","kind":"def","line":396,"name":"Lean.Parser.Term.doubleQuotedName","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L396-L403"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">quotedName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A literal of type `Name`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName","kind":"def","line":394,"name":"Lean.Parser.Term.quotedName","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L394-L395"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">borrowed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Indicates that an argument to a function marked `@[extern]` is borrowed.\n\nBeing borrowed only affects the ABI and runtime behavior of the function when compiled or interpreted. From the perspective of Lean's type system, this annotation has no effect. It similarly has no effect on functions not marked `@[extern]`.\n\nWhen a function argument is borrowed, the function does not consume the value. This means that the function will not decrement the value's reference count or deallocate it, and the caller is responsible for doing so.\n\nPlease see https://lean-lang.org/doc/reference/latest/find/?domain=Verso.Genre.Manual.section&name=ffi-borrowing for a complete description.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed","kind":"def","line":383,"name":"Lean.Parser.Term.borrowed","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L383-L393"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">trailing_parser</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser","kind":"def","line":380,"name":"Lean.Parser.Term.trailing_parser","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L380-L381"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">leading_parser</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser","kind":"def","line":378,"name":"Lean.Parser.Term.leading_parser","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L378-L379"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">withAnonymousAntiquot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot","kind":"def","line":375,"name":"Lean.Parser.Term.withAnonymousAntiquot","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L375-L377"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optExprPrecedence</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence","kind":"def","line":374,"name":"Lean.Parser.Term.optExprPrecedence","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L374-L374"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.fun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">fun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fun","kind":"def","line":371,"name":"Lean.Parser.Term.fun","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L371-L372"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">basicFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun","kind":"def","line":369,"name":"Lean.Parser.Term.basicFun","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L369-L370"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder","kind":"def","line":364,"name":"Lean.Parser.Term.funBinder","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L364-L366"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funStrictImplicitBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder","kind":"def","line":359,"name":"Lean.Parser.Term.funStrictImplicitBinder","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L359-L363"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funImplicitBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder","kind":"def","line":357,"name":"Lean.Parser.Term.funImplicitBinder","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L357-L358"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldEqns\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstFieldEqns</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldEqns","kind":"def","line":353,"name":"Lean.Parser.Term.structInstFieldEqns","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L353-L355"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldDef\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstFieldDef</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldDef","kind":"def","line":350,"name":"Lean.Parser.Term.structInstFieldDef","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L350-L352"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInst\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInst</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be\ninherited. If `e` is itself a variable called `x`, it can be elided:\n`fun y => { x := 1, y }`.\nA *structure update* of an existing value can be given via `with`:\n`{ point with x := 1 }`.\nThe structure type can be specified if not inferable:\n`{ x := 1, y := 2 : Point }`.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInst","kind":"def","line":335,"name":"Lean.Parser.Term.structInst","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L335-L348"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.nofun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">nofun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.nofun","kind":"def","line":333,"name":"Lean.Parser.Term.nofun","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L333-L333"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">nomatch</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch","kind":"def","line":326,"name":"Lean.Parser.Term.nomatch","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L326-L331"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.match\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">match</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Pattern matching. `match e, ... with | p, ... => f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... => f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" <|> \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo <|> \"bar\") ...\n```\nthey are not.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.match","kind":"def","line":290,"name":"Lean.Parser.Term.match","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L290-L325"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.motive\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">motive</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.motive","kind":"def","line":286,"name":"Lean.Parser.Term.motive","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L286-L288"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">generalizingParam</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam","kind":"def","line":282,"name":"Lean.Parser.Term.generalizingParam","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L282-L284"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">falseVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal","kind":"def","line":281,"name":"Lean.Parser.Term.falseVal","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L281-L281"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">trueVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal","kind":"def","line":280,"name":"Lean.Parser.Term.trueVal","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L280-L280"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchDiscr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`matchDiscr` matches a \"match discriminant\", either `h : tm` or `tm`, used in `match` as\n`match h1 : e1, e2, h3 : e3 with ...`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr","kind":"def","line":275,"name":"Lean.Parser.Term.matchDiscr","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L275-L278"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAlts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rhsParser</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> := <a href=\"./Lean/Parser/Basic.html#Lean.Parser.termParser\">termParser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts","kind":"def","line":272,"name":"Lean.Parser.Term.matchAlts","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L272-L273"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.matchAltExpr</span>) (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.matchAlt</span>)</span></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean","kind":"instance","line":269,"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L269-L270"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAltExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Useful for syntax quotations. Note that generic patterns such as `` `(matchAltExpr| | ... => $rhs) `` should also\nwork with other `rhsParser`s (of arity 1). ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr","kind":"def","line":264,"name":"Lean.Parser.Term.matchAltExpr","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L264-L267"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAlt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rhsParser</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a> := <a href=\"./Lean/Parser/Basic.html#Lean.Parser.termParser\">termParser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt","kind":"def","line":258,"name":"Lean.Parser.Term.matchAlt","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L258-L263"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forall\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forall</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forall","kind":"def","line":252,"name":"Lean.Parser.Term.forall","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L252-L256"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">depArrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow","kind":"def","line":249,"name":"Lean.Parser.Term.depArrow","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L249-L250"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">inaccessible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`.(e)` marks an \"inaccessible pattern\", which does not influence evaluation of the pattern match, but may be necessary for type-checking.\nIn contrast to regular patterns, `e` may be an arbitrary term of the appropriate type.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible","kind":"def","line":227,"name":"Lean.Parser.Term.inaccessible","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L227-L232"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`@x` disables automatic insertion of implicit parameters of the constant `x`.\n`@e` for any term `e` also disables the insertion of implicit lambdas at this position.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicit","kind":"def","line":221,"name":"Lean.Parser.Term.explicit","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L221-L226"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.show\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">show</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.show","kind":"def","line":220,"name":"Lean.Parser.Term.show","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L220-L220"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.suffices\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">suffices</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.suffices","kind":"def","line":218,"name":"Lean.Parser.Term.suffices","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L218-L219"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sufficesDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A `sufficesDecl` represents everything that comes after the `suffices` keyword:\nan optional `x :`, then a term `ty`, then `from val` or `by tac`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl","kind":"def","line":214,"name":"Lean.Parser.Term.sufficesDecl","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L214-L217"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">showRhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs","kind":"def","line":213,"name":"Lean.Parser.Term.showRhs","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L213-L213"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">fromTerm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm","kind":"def","line":211,"name":"Lean.Parser.Term.fromTerm","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L211-L212"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">anonymousCtor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the\nexpected type is an inductive type with a single constructor `c`.\nIf more terms are given than `c` has parameters, the remaining arguments\nare turned into a new anonymous constructor application. For example,\n`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor","kind":"def","line":202,"name":"Lean.Parser.Term.anonymousCtor","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L202-L210"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.paren\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">paren</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)` and `(· : Nat → Nat)`\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.paren","kind":"def","line":191,"name":"Lean.Parser.Term.paren","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L191-L201"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.tuple\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Tuple notation; `()` is short for `Unit.unit`, `(a, b, c)` for `Prod.mk a (Prod.mk b c)`, etc. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `(a, b)` in identifiers is `mk`.","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.tuple","kind":"def","line":185,"name":"Lean.Parser.Term.tuple","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L185-L187"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeAscription</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Type ascription notation: `(0 : Int)` instructs Lean to process `0` as a value of type `Int`.\nAn empty type ascription `(e :)` elaborates `e` without the expected type.\nThis is occasionally useful when Lean's heuristics for filling arguments from the expected type\ndo not yield the right result.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription","kind":"def","line":176,"name":"Lean.Parser.Term.typeAscription","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L176-L183"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.cdot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">cdot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.\nFor example, `(· + ·)` is equivalent to `fun x y => x + y`. Tuple notation and type ascription notation also serve as scopes.\nNote that `(· : ty)` expands to `((fun x => x) : ty)`, so `ty` should be a function type.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.cdot","kind":"def","line":169,"name":"Lean.Parser.Term.cdot","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L169-L175"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.hygienicLParen\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">hygienicLParen</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.hygienicLParen","kind":"def","line":167,"name":"Lean.Parser.Term.hygienicLParen","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L167-L168"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sorry\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sorry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The `sorry` term is a temporary placeholder for a missing proof or value.\n\nThe syntax is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a declaration depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n\n\"Go to definition\" on `sorry` in the Infoview will go to the source position where it was introduced, if such information is available.\n\nEach `sorry` is guaranteed to be unique, so for example the following fails:\n```lean\nexample : (sorry : Nat) = sorry := rfl -- fails\n```\n\nSee also the `sorry` tactic, which is short for `exact sorry`.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sorry","kind":"def","line":147,"name":"Lean.Parser.Term.sorry","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L147-L165"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.prop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">prop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The universe of propositions. `Prop ≡ Sort 0`.\n\nEvery proposition is propositionally equal to either `True` or `False`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.prop","kind":"def","line":140,"name":"Lean.Parser.Term.prop","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L140-L144"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sort\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sort</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A specific universe in Lean's infinite hierarchy of universes. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sort","kind":"def","line":137,"name":"Lean.Parser.Term.sort","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L137-L139"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.type\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">type</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.type","kind":"def","line":134,"name":"Lean.Parser.Term.type","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L134-L136"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.char\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">char</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.char","kind":"def","line":132,"name":"Lean.Parser.Term.char","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L132-L133"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.str\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">str</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.str","kind":"def","line":130,"name":"Lean.Parser.Term.str","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L130-L131"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.scientific\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">scientific</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scientific","kind":"def","line":128,"name":"Lean.Parser.Term.scientific","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L128-L129"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.num\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">num</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.num","kind":"def","line":126,"name":"Lean.Parser.Term.num","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L126-L127"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ident\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ident</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ident","kind":"def","line":124,"name":"Lean.Parser.Term.ident","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L124-L125"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon","kind":"def","line":120,"name":"Lean.Parser.Term.optSemicolon","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L120-L121"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">byTactic'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'","kind":"def","line":116,"name":"Lean.Parser.Term.byTactic'","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L116-L117"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">byTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic","kind":"def","line":106,"name":"Lean.Parser.Term.byTactic","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L106-L108"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">semicolonOrLinebreak</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak","kind":"def","line":100,"name":"Lean.Parser.semicolonOrLinebreak","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L100-L100"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.darrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">darrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.darrow","kind":"def","line":99,"name":"Lean.Parser.darrow","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L99-L99"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.plainDocComment\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">plainDocComment</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A `docComment` parses a \"documentation comment\" like `/-- foo -/`. This is not treated like\na regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.\n\nAt parse time, `docComment` checks the value of the `doc.verso` option. If it is true, the contents\nare parsed as Verso markup. If not, the contents are treated as plain text or Markdown. Use\n`plainDocComment` to always treat the contents as plain text.\n\nA plain text doc comment node contains a `/--` atom and then the remainder of the comment, `foo -/`\nin this example. Use `TSyntax.getDocString` to extract the body text from a doc string syntax node.\nA Verso comment node contains the `/--` atom, the document's syntax tree, and a closing `-/` atom.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.plainDocComment","kind":"def","line":94,"name":"Lean.Parser.Command.plainDocComment","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L94-L95"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.docComment\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">docComment</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A `docComment` parses a \"documentation comment\" like `/-- foo -/`. This is not treated like\na regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.\n\nAt parse time, `docComment` checks the value of the `doc.verso` option. If it is true, the contents\nare parsed as Verso markup. If not, the contents are treated as plain text or Markdown. Use\n`plainDocComment` to always treat the contents as plain text.\n\nA plain text doc comment node contains a `/--` atom and then the remainder of the comment, `foo -/`\nin this example. Use `TSyntax.getDocString` to extract the body text from a doc string syntax node.\nA Verso comment node contains the `/--` atom, the document's syntax tree, and a closing `-/` atom.\n","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.docComment","kind":"def","line":77,"name":"Lean.Parser.Command.docComment","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L77-L92"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter","kind":"def","line":74,"name":"Lean.Parser.Command.commentBody.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L74-L75"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span>.<span class=\"name\">parenthesizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer\">PrettyPrinter.Parenthesizer</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer","kind":"def","line":72,"name":"Lean.Parser.Command.commentBody.parenthesizer","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L72-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody","kind":"def","line":69,"name":"Lean.Parser.Command.commentBody","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L69-L70"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.versoCommentBody.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">versoCommentBody</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">PrettyPrinter.Formatter</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.versoCommentBody.formatter","kind":"def","line":62,"name":"Lean.Parser.Command.versoCommentBody.formatter","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L62-L67"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.versoCommentBody.parenthesizer\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">versoCommentBody</span>.<span class=\"name\">parenthesizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer\">PrettyPrinter.Parenthesizer</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.versoCommentBody.parenthesizer","kind":"def","line":57,"name":"Lean.Parser.Command.versoCommentBody.parenthesizer","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L57-L58"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.versoCommentBody\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">versoCommentBody</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.versoCommentBody","kind":"def","line":53,"name":"Lean.Parser.Command.versoCommentBody","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L53-L54"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.versoCommentBodyFn\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">versoCommentBodyFn</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.ParserFn\">ParserFn</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.versoCommentBodyFn","kind":"def","line":23,"name":"Lean.Parser.Command.versoCommentBodyFn","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term.lean#L23-L51"}}],"imports":["Lean.Parser.Term.Basic","Lean.Parser.Term.Basic","Lean.Parser.Term.Doc","Lean.DocString.Parser","Lean.DocString.Formatter"],"instances":[{"className":"Coe","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean","typeNames":["Lean.TSyntax","Lean.TSyntax"]},{"className":"Coe","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1","typeNames":["Lean.TSyntax","Lean.TSyntax"]}],"name":"Lean.Parser.Term"}