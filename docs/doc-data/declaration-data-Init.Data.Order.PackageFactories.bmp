{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.ofOrd\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">ofOrd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">Packages.LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span> := by exact { })</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Use this factory to conveniently define a linear order on a type `α` and all the associated\noperations and instances given an `Ord α` instance.\n\nCreates a `LinearOrderPackage α` instance. Such an instance entails `LE α`, `LT α`, `BEq α`,\n`Ord α`, `Min α` and `Max α` instances as well as an `IsLinearOrder α` instance and `LawfulOrder*`\ninstances proving the compatibility of the operations with the linear order.\n\nIn the presence of `Ord α`, `TransOrd α` and `LawfulEqOrd α` instances, no arguments are required\nand the factory can be used as in this\nexample:\n\n```lean\npublic instance : LinearOrderPackage X := .ofLE X\n```\n\nIf not all of these instances are available via typeclass synthesis, it is necessary to explicitly\nprovide some arguments:\n\n```lean\npublic instance : LinearOrderPackage X := .ofLE X {\n  transOrd := sorry\n  eq_of_compare := sorry }\n```\n\nIt is also possible to do all of this by hand, without resorting to `LinearOrderPackage`. This\ncan be useful if, say, one wants to avoid specifying an `LT α` instance, which is not possible with\n`LinearOrderPackage`.\n\n**How the arguments are filled**\n\nLean tries to fill all of the fields of the `args : Packages.LinearOrderOfLEArgs α` parameter\nautomatically. If it fails, it is necessary to provide some of the fields manually.\n\n* For the data-carrying typeclasses `LE`, `LT`, `BEq`, `Ord`, `Min` and `Max`, existing instances\n  are always preferred. If no existing instances can be synthesized, it is attempted to derive an\n  instance from the `Ord` instance.\n* Some proof obligations can be filled automatically if the data-carrying typeclasses have been\n  derived from the `Ord` instance. For example: If the `beq` field is omitted and no `BEq α` instance\n  can be synthesized, it is derived from the `LE α` instance. In this case, `beq_iff`\n  can be omitted because Lean can infer that `BEq α` and `Ord α` are compatible.\n* Other proof obligations, such as `transOrd`, can be omitted if matching instances can be\n  synthesized.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.ofOrd","kind":"def","line":750,"name":"Std.LinearOrderPackage.ofOrd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L750-L810"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.max_eq\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">max_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.max\">max</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_3</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Max.max\">Max.max</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isGE\">isGE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a> <span class=\"fn\">b</span></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.max_eq","kind":"theorem","line":740,"name":"Std.Packages.LinearOrderOfOrdArgs.max_eq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L740-L740"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.min_eq\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">min_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.min\">min</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_3</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Min.min\">Min.min</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isLE\">isLE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a> <span class=\"fn\">b</span></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.min_eq","kind":"theorem","line":731,"name":"Std.Packages.LinearOrderOfOrdArgs.min_eq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L731-L731"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.max\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">max</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.max","kind":"def","line":724,"name":"Std.Packages.LinearOrderOfOrdArgs.max","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L724-L724"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.min\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">min</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.min","kind":"def","line":717,"name":"Std.Packages.LinearOrderOfOrdArgs.min","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L717-L717"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.eq_of_compare\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">eq_of_compare</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.eq\">Ordering.eq</a> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.eq_of_compare","kind":"theorem","line":708,"name":"Std.Packages.LinearOrderOfOrdArgs.eq_of_compare","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L708-L708"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toLinearPreorderOfOrdArgs</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq_of_compare</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.eq\">Ordering.eq</a> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact fun _ _ =&gt; _root_.Std.LawfulEqOrd.eq_of_compare\n  |\n    fail &quot;Failed to derive a `LawfulEqOrd` instance. \\\n                  Please make sure that it can be synthesized or \\\n                  manually provide the field `eq_of_compare`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">min</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  | exact _root_.Std.FactoryInstances.instMinOfOrd)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">max</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  | exact _root_.Std.FactoryInstances.instMaxOfOrd)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">min_eq</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">min</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_3</span> := <span class=\"fn\">⋯</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Min.min\">Min.min</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>       <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isLE\">isLE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a> <span class=\"fn\">b</span></span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact fun a b =&gt; _root_.Std.min_eq_if_isLE_compare (a := a) (b := b)\n  |\n    fail &quot;Failed to automatically prove that `min` is left-leaning. \\\n                  Please ensure that a `LawfulOrderLeftLeaningMin` instance can be synthesized or \\\n                  manually provide the field `min_eq`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">max_eq</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">max</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_3</span> := <span class=\"fn\">⋯</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Max.max\">Max.max</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>       <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isGE\">isGE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a> <span class=\"fn\">b</span></span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact fun a b =&gt; _root_.Std.max_eq_if_isGE_compare (a := a) (b := b)\n  |\n    fail &quot;Failed to automatically prove that `max` is left-leaning. \\\n                  Please ensure that a `LawfulOrderLeftLeaningMax` instance can be synthesized or \\\n                  manually provide the field `max_eq`.&quot;)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.mk","kind":"ctor","line":706,"name":"Std.Packages.LinearOrderOfOrdArgs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L706-L706"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.toLinearPreorderOfOrdArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">toLinearPreorderOfOrdArgs</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.toLinearPreorderOfOrdArgs","kind":"def","line":706,"name":"Std.Packages.LinearOrderOfOrdArgs.toLinearPreorderOfOrdArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L706-L748"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">Std.Packages.LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This structure contains all the data needed to create a `LinearOrderPackage α` instance.\nIts fields are automatically provided if possible. For the detailed rules how the fields are\ninferred, see `LinearOrderPackage.ofOrd`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs","kind":"structure","line":701,"name":"Std.Packages.LinearOrderOfOrdArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L701-L748"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderLeftLeaningMaxOfOrd\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instLawfulOrderLeftLeaningMaxOfOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderLeftLeaningMax\">LawfulOrderLeftLeaningMax</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderLeftLeaningMaxOfOrd","kind":"instance","line":693,"name":"Std.FactoryInstances.instLawfulOrderLeftLeaningMaxOfOrd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L693-L697"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderLeftLeaningMinOfOrd\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instLawfulOrderLeftLeaningMinOfOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderLeftLeaningMin\">LawfulOrderLeftLeaningMin</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderLeftLeaningMinOfOrd","kind":"instance","line":687,"name":"Std.FactoryInstances.instLawfulOrderLeftLeaningMinOfOrd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L687-L691"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instMaxOfOrd\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instMaxOfOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instMaxOfOrd","kind":"def","line":683,"name":"Std.FactoryInstances.instMaxOfOrd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L683-L685"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instMinOfOrd\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instMinOfOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instMinOfOrd","kind":"def","line":679,"name":"Std.FactoryInstances.instMinOfOrd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L679-L681"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofOrd\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">ofOrd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">Packages.LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span> := by exact { })</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Use this factory to conveniently define a linear preorder on a type `α` and all the associated\noperations and instances given an `Ord α` instance.\n\nCreates a `LinearPreorderPackage α` instance. Such an instance entails `LE α`, `LT α`, `BEq α` and\n`Ord α` instances as well as an `IsLinearPreorder α` instance and `LawfulOrder*` instances proving\nthe compatibility of the operations with the linear preorder.\n\nIn the presence of `Ord α` and `TransOrd α` instances, no arguments are required and the factory can\nbe used as in this example:\n\n```lean\npublic instance : LinearPreorderPackage X := .ofOrd X\n```\n\nIf not all of these instances are available via typeclass synthesis, it is necessary to explicitly\nprovide some arguments:\n\n```lean\npublic instance : LinearPreorderPackage X := .ofOrd X {\n  ord := sorry\n  transOrd := sorry }\n```\n\nIt is also possible to do all of this by hand, without resorting to `LinearPreorderPackage`. This\ncan be useful if, say, one wants to avoid specifying an `LT α` instance, which is not possible with\n`LinearPreorderPackage`.\n\n**How the arguments are filled**\n\nLean tries to fill all of the fields of the `args : Packages.LinearPreorderOfOrdArgs α` parameter\nautomatically. If it fails, it is necessary to provide some of the fields manually.\n\n* For the data-carrying typeclasses `LE`, `LT`, `BEq` and `Ord`, existing instances are always\n  preferred. If no existing instances can be synthesized, it is attempted to derive an instance from\n  the `Ord` instance.\n* Some proof obligations can be filled automatically if the data-carrying typeclasses have been\n  derived from the `Ord` instance. For example: If the `beq` field is omitted and no `BEq α` instance\n  can be synthesized, it is derived from the `Ord α` instance. In this case, `beq_iff`\n  can be omitted because Lean can infer that `BEq α` and `Ord α` are compatible.\n* Other proof obligations, for example `transOrd`, can be omitted if a matching instance can be\n  synthesized.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofOrd","kind":"def","line":605,"name":"Std.LinearPreorderPackage.ofOrd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L605-L671"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq_iff\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">beq_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">let <span class=\"fn\">this_3</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq\">beq</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#BEq.beq\">==</a> <span class=\"fn\">b</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.eq\">Ordering.eq</a></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq_iff","kind":"theorem","line":595,"name":"Std.Packages.LinearPreorderOfOrdArgs.beq_iff","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L595-L595"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">beq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq","kind":"def","line":589,"name":"Std.Packages.LinearPreorderOfOrdArgs.beq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L589-L589"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.decidableLT\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">decidableLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt\">lt</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">have <span class=\"fn\">this_3</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.decidableLT","kind":"def","line":579,"name":"Std.Packages.LinearPreorderOfOrdArgs.decidableLT","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L579-L579"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt_iff\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">lt_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">let <span class=\"fn\">this_3</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt\">lt</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.lt\">Ordering.lt</a></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt_iff","kind":"theorem","line":570,"name":"Std.Packages.LinearPreorderOfOrdArgs.lt_iff","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L570-L570"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">lt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt","kind":"def","line":563,"name":"Std.Packages.LinearPreorderOfOrdArgs.lt","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L563-L563"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.decidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">decidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_1</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.decidableLE","kind":"def","line":553,"name":"Std.Packages.LinearPreorderOfOrdArgs.decidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L553-L553"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lawfulOrderOrd\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">lawfulOrderOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lawfulOrderOrd","kind":"theorem","line":544,"name":"Std.Packages.LinearPreorderOfOrdArgs.lawfulOrderOrd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L544-L544"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le","kind":"def","line":537,"name":"Std.Packages.LinearPreorderOfOrdArgs.le","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L537-L537"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.transOrd\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">transOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Ord.html#Std.TransOrd\">TransOrd</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.transOrd","kind":"theorem","line":536,"name":"Std.Packages.LinearPreorderOfOrdArgs.transOrd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L536-L536"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">ord</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord","kind":"def","line":535,"name":"Std.Packages.LinearPreorderOfOrdArgs.ord","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L535-L535"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ord</span> : <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span> := by infer_instance)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">transOrd</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/Ord.html#Std.TransOrd\">TransOrd</a> <span class=\"fn\">α</span></span> := by infer_instance)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  | exact _root_.LE.ofOrd _)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lawfulOrderOrd</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">transOrd</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span></span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  |\n    fail &quot;Failed to automatically derive a `LawfulOrderOrd` instance. \\\n                  Please ensure that the instance can be synthesized or \\\n                  manually provide the field `lawfulOrderOrd`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decidableLE</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_1</span> := <span class=\"fn\">lawfulOrderOrd</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span></span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  | exact _root_.DecidableLE.ofOrd _\n  |\n    fail &quot;Failed to automatically derive that `LE` is decidable.\\\n                  Please ensure that a `DecidableLE` instance can be synthesized or \\\n                  manually provide the field `decidableLE`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lt</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  | exact LT.ofOrd _)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lt_iff</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">lawfulOrderOrd</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_3</span> := <span class=\"fn\">lt</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.lt\">Ordering.lt</a></span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact fun _ _ =&gt; _root_.Std.compare_eq_lt.symm\n  |\n    fail &quot;Failed to automatically derive that `LT` and `Ord` are compatible. \\\n                  Please ensure that a `LawfulOrderLT` instance can be synthesized or \\\n                  manually provide the field `lt_iff`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decidableLT</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">lt</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">lawfulOrderOrd</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_3</span> := <span class=\"fn\">lt_iff</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></span></span></span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  | exact _root_DecidableLT.ofOrd _\n  |\n    fail &quot;Failed to automatically derive that `LT` is decidable. \\\n                  Please ensure that a `DecidableLT` instance can be synthesized or \\\n                  manually provide the field `decidableLT`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">beq</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  | exact _root_.BEq.ofOrd _)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">beq_iff</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">lawfulOrderOrd</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_3</span> := <span class=\"fn\">beq</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#BEq.beq\">==</a> <span class=\"fn\">b</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>         <a href=\"./Init/Data/Ord/Basic.html#Ordering.eq\">Ordering.eq</a></span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact fun _ _ =&gt; Std.compare_eq_eq.symm\n  |\n    fail &quot;Failed to automatically derive that `BEq` and `Ord` are compatible. \\\n                  Please ensure that a `LawfulOrderBEq` instance can be synthesized or \\\n                  manually provide the field `beq_iff`.&quot;)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.mk","kind":"ctor","line":534,"name":"Std.Packages.LinearPreorderOfOrdArgs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L534-L534"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This structure contains all the data needed to create a `LinearPreorderPackage α` instance.\nIts fields are automatically provided if possible. For the detailed rules how the fields are\ninferred, see `LinearPreorderPackage.ofOrd`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs","kind":"structure","line":529,"name":"Std.Packages.LinearPreorderOfOrdArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L529-L603"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.OrientedCmp.of_gt_iff_lt\"><span class=\"name\">Std</span>.<span class=\"name\">OrientedCmp</span>.<span class=\"name\">of_gt_iff_lt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cmp</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">cmp</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.gt\">Ordering.gt</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">cmp</span> <span class=\"fn\">b</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.lt\">Ordering.lt</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Ord.html#Std.OrientedCmp\">OrientedCmp</a> <span class=\"fn\">cmp</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.OrientedCmp.of_gt_iff_lt","kind":"theorem","line":514,"name":"Std.OrientedCmp.of_gt_iff_lt","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L514-L525"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.ofLE\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">ofLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">Packages.LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span> := by exact { })</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Use this factory to conveniently define a linear order on a type `α` and all the associated\noperations and instances given an `LE α` instance.\n\nCreates a `LinearOrderPackage α` instance. Such an instance entails `LE α`, `LT α`, `BEq α`,\n`Ord α`, `Min α` and `Max α` instances as well as an `IsLinearOrder α` instance and `LawfulOrder*`\ninstances proving the compatibility of the operations with the linear order.\n\nIn the presence of `LE α`, `DecidableLE α`, `Total (· ≤ ·)`, `Trans (· ≤ ·) (· ≤ ·) (· ≤ ·)` and\n`Antisymm (· ≤ ·)` instances, no arguments are required and the factory can be used as in this\nexample:\n\n```lean\npublic instance : LinearOrderPackage X := .ofLE X\n```\n\nIf not all of these instances are available via typeclass synthesis, it is necessary to explicitly\nprovide some arguments:\n\n```lean\npublic instance : LinearOrderPackage X := .ofLE X {\n  le_total := sorry\n  le_trans := sorry\n  le_antisymm := sorry }\n```\n\nIt is also possible to do all of this by hand, without resorting to `LinearOrderPackage`. This\ncan be useful if, say, one wants to avoid specifying an `LT α` instance, which is not possible with\n`LinearOrderPackage`.\n\n**How the arguments are filled**\n\nLean tries to fill all of the fields of the `args : Packages.LinearOrderOfLEArgs α` parameter\nautomatically. If it fails, it is necessary to provide some of the fields manually.\n\n* For the data-carrying typeclasses `LE`, `LT`, `BEq`, `Ord`, `Min` and `Max`, existing instances\n  are always preferred. If no existing instances can be synthesized, it is attempted to derive an\n  instance from the `LE` instance.\n* Some proof obligations can be filled automatically if the data-carrying typeclasses have been\n  derived from the `LE` instance. For example: If the `beq` field is omitted and no `BEq α` instance\n  can be synthesized, it is derived from the `LE α` instance. In this case, `beq_iff_le_and_ge` can be\n  omitted because Lean can infer that `BEq α` and `LE α` are compatible.\n* Other proof obligations, namely `le_total`, `le_trans` and `le_antisymm`, can be omitted if\n  `Total`, `Trans` and `Antisymm` instances can be synthesized.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.ofLE","kind":"def","line":443,"name":"Std.LinearOrderPackage.ofLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L443-L504"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.max_eq\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">max_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.max\">max</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Max.max\">Max.max</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a> <span class=\"fn\">b</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.max_eq","kind":"theorem","line":433,"name":"Std.Packages.LinearOrderOfLEArgs.max_eq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L433-L433"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.min_eq\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">min_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.min\">min</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Min.min\">Min.min</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a> <span class=\"fn\">b</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.min_eq","kind":"theorem","line":424,"name":"Std.Packages.LinearOrderOfLEArgs.min_eq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L424-L424"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.max\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">max</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.max","kind":"def","line":417,"name":"Std.Packages.LinearOrderOfLEArgs.max","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L417-L417"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.min\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">min</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.min","kind":"def","line":410,"name":"Std.Packages.LinearOrderOfLEArgs.min","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L410-L410"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.le_antisymm\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">le_antisymm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.le_antisymm","kind":"theorem","line":409,"name":"Std.Packages.LinearOrderOfLEArgs.le_antisymm","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L409-L409"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toLinearPreorderOfLEArgs</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_antisymm</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact _root_.Std.Antisymm.antisymm\n  |\n    fail &quot;Failed to automatically prove that the `LE` instance is antisymmetric. \\\n                  Please ensure that a `Antisymm` instance can be synthesized or \\\n                  manually provide the field `le_antisymm`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">min</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  | exact _root_.Min.leftLeaningOfLE _)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">max</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  | exact _root_.Max.leftLeaningOfLE _)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">min_eq</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">min</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Min.min\">Min.min</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a>         <span class=\"fn\">b</span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact fun a b =&gt; _root_.Std.min_eq_if (a := a) (b := b)\n  |\n    fail &quot;Failed to automatically prove that `min` is left-leaning. \\\n                  Please ensure that a `LawfulOrderLeftLeaningMin` instance can be synthesized or \\\n                  manually provide the field `min_eq`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">max_eq</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">max</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Max.max\">Max.max</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a>         <span class=\"fn\">b</span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact fun a b =&gt; _root_.Std.max_eq_if (a := a) (b := b)\n  |\n    fail &quot;Failed to automatically prove that `max` is left-leaning. \\\n                  Please ensure that a `LawfulOrderLeftLeaningMax` instance can be synthesized or \\\n                  manually provide the field `max_eq`.&quot;)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.mk","kind":"ctor","line":408,"name":"Std.Packages.LinearOrderOfLEArgs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L408-L408"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.toLinearPreorderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">toLinearPreorderOfLEArgs</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.toLinearPreorderOfLEArgs","kind":"def","line":408,"name":"Std.Packages.LinearOrderOfLEArgs.toLinearPreorderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L408-L441"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.toPartialOrderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">toPartialOrderOfLEArgs</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\">PartialOrderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.toPartialOrderOfLEArgs","kind":"def","line":408,"name":"Std.Packages.LinearOrderOfLEArgs.toPartialOrderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L408-L441"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">Std.Packages.LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\">Std.Packages.PartialOrderOfLEArgs</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This structure contains all the data needed to create a `LinearOrderPackage α` instance. Its fields\nare automatically provided if possible. For the detailed rules how the fields are inferred, see\n`LinearOrderPackage.ofLE`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs","kind":"structure","line":403,"name":"Std.Packages.LinearOrderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L403-L441"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.le_antisymm\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">le_antisymm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.le_antisymm","kind":"theorem","line":400,"name":"Std.LinearOrderPackage.le_antisymm","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L400-L400"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.mk\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLinearPreorderPackage</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_antisymm</span> : <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toMin</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toMax</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLawfulOrderMin</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderMin\">LawfulOrderMin</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLawfulOrderMax</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderMax\">LawfulOrderMax</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.mk","kind":"ctor","line":399,"name":"Std.LinearOrderPackage.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L399-L399"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toLawfulOrderMax\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toLawfulOrderMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderMax\">LawfulOrderMax</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toLawfulOrderMax","kind":"theorem","line":399,"name":"Std.LinearOrderPackage.toLawfulOrderMax","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L399-L401"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toLawfulOrderMin\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toLawfulOrderMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderMin\">LawfulOrderMin</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toLawfulOrderMin","kind":"theorem","line":399,"name":"Std.LinearOrderPackage.toLawfulOrderMin","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L399-L401"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toMax\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toMax","kind":"def","line":399,"name":"Std.LinearOrderPackage.toMax","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L399-L401"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toMin\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toMin","kind":"def","line":399,"name":"Std.LinearOrderPackage.toMin","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L399-L401"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toPartialOrderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toPartialOrderPackage</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">PartialOrderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toPartialOrderPackage","kind":"def","line":399,"name":"Std.LinearOrderPackage.toPartialOrderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L399-L401"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toIsLinearOrder\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toIsLinearOrder</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsLinearOrder\">IsLinearOrder</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toIsLinearOrder","kind":"theorem","line":399,"name":"Std.LinearOrderPackage.toIsLinearOrder","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L399-L401"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toLinearPreorderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toLinearPreorderPackage</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toLinearPreorderPackage","kind":"def","line":399,"name":"Std.LinearOrderPackage.toLinearPreorderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L399-L401"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">Std.LinearPreorderPackage</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">Std.PartialOrderPackage</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderMin\">Std.LawfulOrderMin</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderMax\">Std.LawfulOrderMax</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsLinearOrder\">Std.IsLinearOrder</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This class entails `LE α`, `LT α`, `BEq α`, `Ord α`, `Min α` and `Max α` instances as well as proofs\nthat these operations represent the same linear order structure on `α`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage","kind":"class","line":395,"name":"Std.LinearOrderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L395-L401"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofLE\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">ofLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">Packages.LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span> := by exact { })</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Use this factory to conveniently define a linear preorder on a type `α` and all the associated\noperations and instances given an `LE α` instance.\n\nCreates a `LinearPreorderPackage α` instance. Such an instance entails `LE α`, `LT α`, `BEq α` and\n`Ord α` instances as well as an `IsLinearPreorder α` instance and `LawfulOrder*` instances proving\nthe compatibility of the operations with the linear preorder.\n\nIn the presence of `LE α`, `DecidableLE α`, `Total (· ≤ ·)` and `Trans (· ≤ ·) (· ≤ ·) (· ≤ ·)`\ninstances, no arguments are required and the factory can be used as in this example:\n\n```lean\npublic instance : LinearPreorderPackage X := .ofLE X\n```\n\nIf not all of these instances are available via typeclass synthesis, it is necessary to explicitly\nprovide some arguments:\n\n```lean\npublic instance : LinearPreorderPackage X := .ofLE X {\n  le_total := sorry\n  le_trans := sorry }\n```\n\nIt is also possible to do all of this by hand, without resorting to `LinearPreorderPackage`. This\ncan be useful if, say, one wants to avoid specifying an `LT α` instance, which is not possible with\n`LinearPreorderPackage`.\n\n**How the arguments are filled**\n\nLean tries to fill all of the fields of the `args : Packages.LinearPreorderOfLEArgs α` parameter\nautomatically. If it fails, it is necessary to provide some of the fields manually.\n\n* For the data-carrying typeclasses `LE`, `LT`, `BEq` and `Ord`, existing instances are always\n  preferred. If no existing instances can be synthesized, it is attempted to derive an instance from\n  the `LE` instance.\n* Some proof obligations can be filled automatically if the data-carrying typeclasses have been\n  derived from the `LE` instance. For example: If the `beq` field is omitted and no `BEq α` instance\n  can be synthesized, it is derived from the `LE α` instance. In this case, `beq_iff_le_and_ge` can be\n  omitted because Lean can infer that `BEq α` and `LE α` are compatible.\n* Other proof obligations, namely `le_total` and `le_trans`, can be omitted if `Total` and `Trans`\n  instances can be synthesized.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofLE","kind":"def","line":343,"name":"Std.LinearPreorderPackage.ofLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L343-L393"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.isGE_compare\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span>.<span class=\"name\">isGE_compare</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">let <span class=\"fn\">this_3</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord\">ord</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isGE\">isGE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.isGE_compare","kind":"theorem","line":333,"name":"Std.Packages.LinearPreorderOfLEArgs.isGE_compare","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L333-L333"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.isLE_compare\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span>.<span class=\"name\">isLE_compare</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord\">ord</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isLE\">isLE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.isLE_compare","kind":"theorem","line":324,"name":"Std.Packages.LinearPreorderOfLEArgs.isLE_compare","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L324-L324"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.le_total\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span>.<span class=\"name\">le_total</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.le_total","kind":"theorem","line":316,"name":"Std.Packages.LinearPreorderOfLEArgs.le_total","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L316-L316"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span>.<span class=\"name\">ord</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord","kind":"def","line":309,"name":"Std.Packages.LinearPreorderOfLEArgs.ord","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L309-L309"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toPreorderOfLEArgs</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ord</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  | exact _root_.Std.FactoryInstances.instOrdOfDecidableLE)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_total</span> : <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span> := by\n  first\n  | exact _root_.Std.Total.total\n  |\n    fail &quot;Failed to automatically prove that the `LE` instance is total. \\\n                  Please ensure that a `Total` instance can be synthesized or \\\n                  manually provide the field `le_total`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isLE_compare</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isLE\">isLE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact _root_.Std.LawfulOrderOrd.isLE_compare\n  |\n    fail &quot;Failed to automatically prove that `(compare a b).isLE` is equivalent to `a ≤ b`. \\\n                  Please ensure that a `LawfulOrderOrd` instance can be synthesized or \\\n                  manually provide the field `isLE_compare`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isGE_compare</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">le_total</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_3</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isGE\">isGE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact _root_.Std.LawfulOrderOrd.isGE_compare\n  |\n    fail &quot;Failed to automatically prove that `(compare a b).isGE` is equivalent to `b ≤ a`. \\\n                  Please ensure that a `LawfulOrderOrd` instance can be synthesized or \\\n                  manually provide the field `isGE_compare`.&quot;)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.mk","kind":"ctor","line":307,"name":"Std.Packages.LinearPreorderOfLEArgs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L307-L307"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.toPreorderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span>.<span class=\"name\">toPreorderOfLEArgs</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.toPreorderOfLEArgs","kind":"def","line":307,"name":"Std.Packages.LinearPreorderOfLEArgs.toPreorderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L307-L341"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">Std.Packages.PreorderOfLEArgs</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This structure contains all the data needed to create a `LinearPreorderPackage α` instance. Its fields\nare automatically provided if possible. For the detailed rules how the fields are inferred, see\n`LinearPreorderPackage.ofLE`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs","kind":"structure","line":302,"name":"Std.Packages.LinearPreorderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L302-L341"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.le_total\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">le_total</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.le_total","kind":"theorem","line":300,"name":"Std.LinearPreorderPackage.le_total","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L300-L300"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.mk\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toPreorderPackage</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toOrd</span> : <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLawfulOrderOrd</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_total</span> : <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.mk","kind":"ctor","line":299,"name":"Std.LinearPreorderPackage.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L299-L299"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toOrd\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">toOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toOrd","kind":"def","line":299,"name":"Std.LinearPreorderPackage.toOrd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L299-L300"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toPreorderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">toPreorderPackage</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toPreorderPackage","kind":"def","line":299,"name":"Std.LinearPreorderPackage.toPreorderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L299-L300"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toLawfulOrderOrd\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">toLawfulOrderOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toLawfulOrderOrd","kind":"theorem","line":299,"name":"Std.LinearPreorderPackage.toLawfulOrderOrd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L299-L300"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toIsLinearPreorder\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">toIsLinearPreorder</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsLinearPreorder\">IsLinearPreorder</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toIsLinearPreorder","kind":"theorem","line":299,"name":"Std.LinearPreorderPackage.toIsLinearPreorder","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L299-L300"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">Std.PreorderPackage</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">Std.LawfulOrderOrd</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsLinearPreorder\">Std.IsLinearPreorder</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This class entails `LE α`, `LT α`, `BEq α` and `Ord α` instances as well as proofs that these\noperations represent the same linear preorder structure on `α`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage","kind":"class","line":295,"name":"Std.LinearPreorderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L295-L300"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderOrdOfDecidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instLawfulOrderOrdOfDecidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Core.html#Std.Total\">Total</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> <span class=\"fn\">x2</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\">x1</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x2</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderOrdOfDecidableLE","kind":"instance","line":287,"name":"Std.FactoryInstances.instLawfulOrderOrdOfDecidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L287-L291"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instOrdOfDecidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instOrdOfDecidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instOrdOfDecidableLE","kind":"def","line":267,"name":"Std.FactoryInstances.instOrdOfDecidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L267-L269"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.ofLE\"><span class=\"name\">Std</span>.<span class=\"name\">PartialOrderPackage</span>.<span class=\"name\">ofLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\">Packages.PartialOrderOfLEArgs</a> <span class=\"fn\">α</span></span> := by exact { })</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">PartialOrderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.ofLE","kind":"def","line":257,"name":"Std.PartialOrderPackage.ofLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L257-L261"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.le_antisymm\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PartialOrderOfLEArgs</span>.<span class=\"name\">le_antisymm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\">PartialOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.le_antisymm","kind":"theorem","line":202,"name":"Std.Packages.PartialOrderOfLEArgs.le_antisymm","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L202-L202"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PartialOrderOfLEArgs</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toPreorderOfLEArgs</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_antisymm</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact _root_.Std.Antisymm.antisymm\n  |\n    fail &quot;Failed to automatically prove that the `LE` instance is antisymmetric. \\\n                  Please ensure that a `Antisymm` instance can be synthesized or \\\n                  manually provide the field `le_antisymm`.&quot;)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\">PartialOrderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.mk","kind":"ctor","line":201,"name":"Std.Packages.PartialOrderOfLEArgs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L201-L201"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.toPreorderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PartialOrderOfLEArgs</span>.<span class=\"name\">toPreorderOfLEArgs</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\">PartialOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.toPreorderOfLEArgs","kind":"def","line":201,"name":"Std.Packages.PartialOrderOfLEArgs.toPreorderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L201-L210"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PartialOrderOfLEArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">Std.Packages.PreorderOfLEArgs</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This structure contains all the data needed to create a `PartialOrderPakckage α` instance. Its\nfields are automatically provided if possible. For the detailed rules how the fields are inferred,\nsee `PartialOrderPackage.ofLE`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs","kind":"structure","line":196,"name":"Std.Packages.PartialOrderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L196-L210"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.le_antisymm\"><span class=\"name\">Std</span>.<span class=\"name\">PartialOrderPackage</span>.<span class=\"name\">le_antisymm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">PartialOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.le_antisymm","kind":"theorem","line":194,"name":"Std.PartialOrderPackage.le_antisymm","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L194-L194"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.mk\"><span class=\"name\">Std</span>.<span class=\"name\">PartialOrderPackage</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toPreorderPackage</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_antisymm</span> : <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">PartialOrderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.mk","kind":"ctor","line":193,"name":"Std.PartialOrderPackage.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L193-L193"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.toIsPartialOrder\"><span class=\"name\">Std</span>.<span class=\"name\">PartialOrderPackage</span>.<span class=\"name\">toIsPartialOrder</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">PartialOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsPartialOrder\">IsPartialOrder</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.toIsPartialOrder","kind":"theorem","line":193,"name":"Std.PartialOrderPackage.toIsPartialOrder","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L193-L194"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.toPreorderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">PartialOrderPackage</span>.<span class=\"name\">toPreorderPackage</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">PartialOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.toPreorderPackage","kind":"def","line":193,"name":"Std.PartialOrderPackage.toPreorderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L193-L194"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">PartialOrderPackage</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">Std.PreorderPackage</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsPartialOrder\">Std.IsPartialOrder</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This class entails `LE α`, `LT α` and `BEq α` instances as well as proofs that these operations\nrepresent the same partial order structure on `α`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage","kind":"class","line":189,"name":"Std.PartialOrderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L189-L194"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">ofLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">Packages.PreorderOfLEArgs</a> <span class=\"fn\">α</span></span> := by exact { })</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Use this factory to conveniently define a preorder on a type `α` and all the associated operations\nand instances given an `LE α` instance.\n\nCreates a `PreorderPackage α` instance. Such an instance entails `LE α`, `LT α` and\n`BEq α` instances as well as an `IsPreorder α` instance and `LawfulOrder*` instances proving the\ncompatibility of the operations with the preorder.\n\nIn the presence of `LE α`, `DecidableLE α`, `Refl (· ≤ ·)` and `Trans (· ≤ ·) (· ≤ ·) (· ≤ ·)`\ninstances, no arguments are required and the factory can be used as in this example:\n\n```lean\npublic instance : PreorderPackage X := .ofLE X\n```\n\nIf not all of these instances are available via typeclass synthesis, it is necessary to explicitly\nprovide some arguments:\n\n```lean\npublic instance : PreorderPackage X := .ofLE X {\n  le_refl := sorry\n  le_trans := sorry }\n```\n\nIt is also possible to do all of this by hand, without resorting to `PreorderPackage`. This can\nbe useful if, say, one wants to avoid specifying an `LT α` instance, which is not possible with\n`PreorderPackage`.\n\n**How the arguments are filled**\n\nLean tries to fill all of the fields of the `args : Packages.PreorderOfLEArgs α` parameter\nautomatically. If it fails, it is necessary to provide some of the fields manually.\n\n* For the data-carrying typeclasses `LE`, `LT` and `BEq`, existing instances are always preferred.\n  If no existing instances can be synthesized, it is attempted to derive an instance from the `LE`\n  instance.\n* Some proof obligations can be filled automatically if the data-carrying typeclasses have been\n  derived from the `LE` instance. For example: If the `beq` field is omitted and no `BEq α` instance\n  can be synthesized, it is derived from the `LE α` instance. In this case, `beq_iff_le_and_ge` can\n  be omitted because Lean can infer that `BEq α` and `LE α` are compatible.\n* Other proof obligations, namely `le_refl` and `le_trans`, can be omitted if `Refl` and `Trans`\n  instances can be synthesized.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE","kind":"def","line":129,"name":"Std.PreorderPackage.ofLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L129-L183"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">le_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans","kind":"theorem","line":119,"name":"Std.Packages.PreorderOfLEArgs.le_trans","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L119-L119"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_refl\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">le_refl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_refl","kind":"theorem","line":110,"name":"Std.Packages.PreorderOfLEArgs.le_refl","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L110-L110"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">beq_iff_le_and_ge</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq\">beq</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#BEq.beq\">==</a> <span class=\"fn\">b</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge","kind":"theorem","line":101,"name":"Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L101-L101"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLT\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">decidableLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt\">lt</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_1</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLT","kind":"def","line":89,"name":"Std.Packages.PreorderOfLEArgs.decidableLT","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L89-L89"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt_iff\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">lt_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt\">lt</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#And\">∧</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt_iff","kind":"theorem","line":80,"name":"Std.Packages.PreorderOfLEArgs.lt_iff","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L80-L80"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">beq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq","kind":"def","line":73,"name":"Std.Packages.PreorderOfLEArgs.beq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L73-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">lt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt","kind":"def","line":66,"name":"Std.Packages.PreorderOfLEArgs.lt","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L66-L66"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">decidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE","kind":"def","line":65,"name":"Std.Packages.PreorderOfLEArgs.decidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L65-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le","kind":"def","line":64,"name":"Std.Packages.PreorderOfLEArgs.le","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L64-L64"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span> := by infer_instance)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decidableLE</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span> := by infer_instance)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lt</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  | exact _root_.Classical.Order.instLT)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">beq</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">decidableLE</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></span></span> := by\n  extract_lets \n  first\n  | infer_instance\n  | exact _root_.Std.FactoryInstances.beqOfDecidableLE)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lt_iff</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">lt</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#And\">∧</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></span> := by\n  extract_lets \n  first\n  | exact _root_.Std.LawfulOrderLT.lt_iff\n  |\n    fail &quot;Failed to automatically prove that the `LE` and `LT` instances are compatible. \\\n                  Please ensure that a `LawfulOrderLT` instance can be synthesized or \\\n                  manually provide the field `lt_iff`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decidableLT</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">decidableLE</span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">lt</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_1</span> := <span class=\"fn\">lt_iff</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></span></span></span></span> := by\n  extract_lets \n  haveI := @_root_.Std.LawfulOrderLT.mk (lt_iff := by assumption) ..\n  first\n  | infer_instance\n  | exact _root_.Std.FactoryInstances.decidableLTOfLE\n  |\n    fail &quot;Failed to automatically derive that `LT` is decidable. \\\n                  Please ensure that a `DecidableLT` instance can be synthesized or \\\n                  manually provide the field `decidableLT`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">beq_iff_le_and_ge</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">decidableLE</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">beq</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#BEq.beq\">==</a> <span class=\"fn\">b</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact _root_.Std.LawfulOrderBEq.beq_iff_le_and_ge\n  |\n    fail &quot;Failed to automatically prove that the `LE` and `BEq` instances are compatible. \\\n                    Please ensure that a `LawfulOrderBEq` instance can be synthesized or \\\n                    manually provide the field `beq_iff_le_and_ge`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_refl</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span> := by\n  extract_lets \n  first\n  | exact _root_.Std.Refl.refl (r := (· ≤ ·))\n  |\n    fail &quot;Failed to automatically prove that the `LE` instance is reflexive. \\\n                  Please ensure that a `Refl` instance can be synthesized or \\\n                  manually provide the field `le_refl`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_trans</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span></span></span></span></span> := by\n  extract_lets \n  first\n  | exact fun _ _ _ hab hbc =&gt; _root_.Trans.trans (r := (· ≤ ·)) (s := (· ≤ ·)) (t := (· ≤ ·)) hab hbc\n  |\n    fail &quot;Failed to automatically prove that the `LE` instance is transitive. \\\n                  Please ensure that a `Trans` instance can be synthesized or \\\n                  manually provide the field `le_trans`.&quot;)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.mk","kind":"ctor","line":63,"name":"Std.Packages.PreorderOfLEArgs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L63-L63"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This structure contains all the data needed to create a `PreorderPackage α` instance. Its fields\nare automatically provided if possible. For the detailed rules how the fields are inferred, see\n`PreorderPackage.ofLE`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs","kind":"structure","line":58,"name":"Std.Packages.PreorderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L58-L127"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.decidableLTOfLE\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">decidableLTOfLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x✝</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderLT\">LawfulOrderLT</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"If `LT` can be characterized in terms of a decidable `LE`, then `LT` is decidable either. ","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.decidableLTOfLE","kind":"def","line":48,"name":"Std.FactoryInstances.decidableLTOfLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L48-L54"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderBEqOfDecidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instLawfulOrderBEqOfDecidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderBEq\">LawfulOrderBEq</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderBEqOfDecidableLE","kind":"instance","line":44,"name":"Std.FactoryInstances.instLawfulOrderBEqOfDecidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L44-L46"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.beqOfDecidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">beqOfDecidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.beqOfDecidableLE","kind":"def","line":40,"name":"Std.FactoryInstances.beqOfDecidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L40-L42"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.instDecidableLT\"><span class=\"name\">Std</span>.<span class=\"name\">instDecidableLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.instDecidableLT","kind":"instance","line":36,"name":"Std.instDecidableLT","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L36-L36"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.instDecidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">instDecidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.instDecidableLE","kind":"instance","line":35,"name":"Std.instDecidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L35-L35"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLT\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">decidableLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLT","kind":"def","line":33,"name":"Std.PreorderPackage.decidableLT","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L33-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">decidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLE","kind":"def","line":32,"name":"Std.PreorderPackage.decidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L32-L32"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.mk\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLE</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLT</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toBEq</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLawfulOrderLT</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderLT\">LawfulOrderLT</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLawfulOrderBEq</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderBEq\">LawfulOrderBEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toIsPreorder</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsPreorder\">IsPreorder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decidableLE</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decidableLT</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.mk","kind":"ctor","line":30,"name":"Std.PreorderPackage.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L30-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLawfulOrderBEq\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">toLawfulOrderBEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderBEq\">LawfulOrderBEq</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLawfulOrderBEq","kind":"theorem","line":30,"name":"Std.PreorderPackage.toLawfulOrderBEq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L30-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toBEq\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">toBEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toBEq","kind":"def","line":30,"name":"Std.PreorderPackage.toBEq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L30-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLT\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">toLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLT","kind":"def","line":30,"name":"Std.PreorderPackage.toLT","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L30-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toIsPreorder\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">toIsPreorder</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsPreorder\">IsPreorder</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toIsPreorder","kind":"theorem","line":30,"name":"Std.PreorderPackage.toIsPreorder","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L30-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLawfulOrderLT\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">toLawfulOrderLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderLT\">LawfulOrderLT</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLawfulOrderLT","kind":"theorem","line":30,"name":"Std.PreorderPackage.toLawfulOrderLT","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L30-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLE\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">toLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLE","kind":"def","line":30,"name":"Std.PreorderPackage.toLE","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L30-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderLT\">Std.LawfulOrderLT</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderBEq\">Std.LawfulOrderBEq</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsPreorder\">Std.IsPreorder</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This class entails `LE α`, `LT α` and `BEq α` instances as well as proofs that these operations\nrepresent the same preorder structure on `α`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage","kind":"class","line":26,"name":"Std.PreorderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Data/Order/PackageFactories.lean#L26-L33"}}],"imports":["Init.Data.Order.LemmasExtra","Init.Data.Order.FactoriesExtra","Init.Data.Bool","Init.Data.Order.Lemmas"],"instances":[{"className":"Decidable","name":"Std.instDecidableLE","typeNames":["LE.le"]},{"className":"Decidable","name":"Std.instDecidableLT","typeNames":["LT.lt"]},{"className":"Std.LawfulOrderBEq","name":"Std.FactoryInstances.instLawfulOrderBEqOfDecidableLE","typeNames":[]},{"className":"Std.LawfulOrderOrd","name":"Std.FactoryInstances.instLawfulOrderOrdOfDecidableLE","typeNames":[]},{"className":"Std.LawfulOrderLeftLeaningMin","name":"Std.FactoryInstances.instLawfulOrderLeftLeaningMinOfOrd","typeNames":[]},{"className":"Std.LawfulOrderLeftLeaningMax","name":"Std.FactoryInstances.instLawfulOrderLeftLeaningMaxOfOrd","typeNames":[]}],"name":"Init.Data.Order.PackageFactories"}