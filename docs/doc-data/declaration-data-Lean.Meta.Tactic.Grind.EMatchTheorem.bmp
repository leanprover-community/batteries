{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.addEMatchAttrAndSuggest\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Extension</span>.<span class=\"name\">addEMatchAttrAndSuggest</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ext</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.Extension\">Extension</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ref</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">attrKind</span> : <a href=\"./Lean/Attributes.html#Lean.AttributeKind\">AttributeKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prios</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.SymbolPriorities\">SymbolPriorities</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">minIndexable </span><span class=\"fn\">showInfo</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isParam</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Tries different modifiers, logs info messages with modifiers that worked, but stores just the first one that worked.\n\nRemark: if `backward.grind.inferPattern` is `true`, then `.default false` is used.\nThe parameter `showInfo` is only taken into account when `backward.grind.inferPattern` is `true`.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.addEMatchAttrAndSuggest","kind":"def","line":1581,"name":"Lean.Meta.Grind.Extension.addEMatchAttrAndSuggest","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1581-L1597"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchTheoremAndSuggest\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkEMatchTheoremAndSuggest</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ref</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prios</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.SymbolPriorities\">SymbolPriorities</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">minIndexable</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isParam</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheorem\">EMatchTheorem</a></span></div></div>","info":{"doc":"Tries different modifiers, logs info messages with modifiers that worked, but returns just the first one that worked.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchTheoremAndSuggest","kind":"def","line":1527,"name":"Lean.Meta.Grind.mkEMatchTheoremAndSuggest","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1527-L1579"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.MinIndexableMode.both\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">MinIndexableMode</span>.<span class=\"name\">both</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.MinIndexableMode\">MinIndexableMode</a></div></div>","info":{"doc":"Tries with and without the minimal indexable subexpression condition, if both produce the\nsame pattern, use the one `minIndexable := false` since it is more compact.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.MinIndexableMode.both","kind":"ctor","line":1521,"name":"Lean.Meta.Grind.MinIndexableMode.both","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1521-L1525"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.MinIndexableMode.no\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">MinIndexableMode</span>.<span class=\"name\">no</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.MinIndexableMode\">MinIndexableMode</a></div></div>","info":{"doc":"`minIndexable := false` ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.MinIndexableMode.no","kind":"ctor","line":1519,"name":"Lean.Meta.Grind.MinIndexableMode.no","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1519-L1520"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.MinIndexableMode.yes\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">MinIndexableMode</span>.<span class=\"name\">yes</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.MinIndexableMode\">MinIndexableMode</a></div></div>","info":{"doc":"`minIndexable := true` ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.MinIndexableMode.yes","kind":"ctor","line":1517,"name":"Lean.Meta.Grind.MinIndexableMode.yes","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1517-L1518"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.MinIndexableMode\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">MinIndexableMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Helper type for generating suggestions for `grind` parameters ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.MinIndexableMode","kind":"inductive","line":1515,"name":"Lean.Meta.Grind.MinIndexableMode","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1515-L1525"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.grind.param.codeAction\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">grind</span>.<span class=\"name\">param</span>.<span class=\"name\">codeAction</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.grind.param.codeAction","kind":"opaque","line":1510,"name":"Lean.Meta.Grind.grind.param.codeAction","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1510-L1513"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind.toSyntax\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EMatchTheoremKind</span>.<span class=\"name\">toSyntax</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">kind</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.Parser.Attr.grindMod</span>)</span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind.toSyntax","kind":"def","line":1463,"name":"Lean.Meta.Grind.EMatchTheoremKind.toSyntax","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1463-L1479"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.addEMatchAttr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Extension</span>.<span class=\"name\">addEMatchAttr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ext</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.Extension\">Extension</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">attrKind</span> : <a href=\"./Lean/Attributes.html#Lean.AttributeKind\">AttributeKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">thmKind</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prios</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.SymbolPriorities\">SymbolPriorities</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">showInfo </span><span class=\"fn\">minIndexable</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.addEMatchAttr","kind":"def","line":1434,"name":"Lean.Meta.Grind.Extension.addEMatchAttr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1434-L1454"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems.eraseDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EMatchTheorems</span>.<span class=\"name\">eraseDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems\">EMatchTheorems</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems\">EMatchTheorems</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems.eraseDecl","kind":"def","line":1417,"name":"Lean.Meta.Grind.EMatchTheorems.eraseDecl","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1417-L1428"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchEqTheoremsForDef?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkEMatchEqTheoremsForDef?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">showInfo</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheorem\">EMatchTheorem</a>)</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchEqTheoremsForDef?","kind":"def","line":1402,"name":"Lean.Meta.Grind.mkEMatchEqTheoremsForDef?","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1402-L1405"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchTheoremForDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkEMatchTheoremForDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">thmKind</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prios</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.SymbolPriorities\">SymbolPriorities</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">showInfo </span><span class=\"fn\">minIndexable</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheorem\">EMatchTheorem</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchTheoremForDecl","kind":"def","line":1396,"name":"Lean.Meta.Grind.mkEMatchTheoremForDecl","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1396-L1400"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchTheoremWithKind?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkEMatchTheoremWithKind?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">origin</span> : <a href=\"./Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin\">Origin</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">levelParams</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">kind</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symPrios</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.SymbolPriorities\">SymbolPriorities</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">groundPatterns</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">showInfo </span><span class=\"fn\">minIndexable</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheorem\">EMatchTheorem</a>)</span></span></div></div>","info":{"doc":"Creates an E-match theorem using the given proof and kind.\nIf `groundPatterns` is `true`, it accepts patterns without pattern variables. This is useful for\ntheorems such as `theorem evenZ : Even 0`. For local theorems, we use `groundPatterns := false`\nsince the theorem is already in the `grind` state and there is nothing to be instantiated.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchTheoremWithKind?","kind":"def","line":1326,"name":"Lean.Meta.Grind.mkEMatchTheoremWithKind?","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1326-L1394"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchTheoremUsingSingletonPatterns\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkEMatchTheoremUsingSingletonPatterns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">origin</span> : <a href=\"./Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin\">Origin</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">levelParams</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">minPrio</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symPrios</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.SymbolPriorities\">SymbolPriorities</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">showInfo</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheorem\">EMatchTheorem</a>)</span></span></div></div>","info":{"doc":"Collects all singleton patterns in the type of the given proof.\nWe use this function to implement local forall expressions in a `grind` goal.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchTheoremUsingSingletonPatterns","kind":"def","line":1299,"name":"Lean.Meta.Grind.mkEMatchTheoremUsingSingletonPatterns","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1299-L1324"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind.gen\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EMatchTheoremKind</span>.<span class=\"name\">gen</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind.gen","kind":"def","line":1240,"name":"Lean.Meta.Grind.EMatchTheoremKind.gen","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1240-L1247"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.backward.grind.checkInferPatternDiscrepancy\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">backward</span>.<span class=\"name\">grind</span>.<span class=\"name\">checkInferPatternDiscrepancy</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.backward.grind.checkInferPatternDiscrepancy","kind":"opaque","line":1162,"name":"Lean.Meta.Grind.backward.grind.checkInferPatternDiscrepancy","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1162-L1165"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.backward.grind.inferPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">backward</span>.<span class=\"name\">grind</span>.<span class=\"name\">inferPattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.backward.grind.inferPattern","kind":"opaque","line":1157,"name":"Lean.Meta.Grind.backward.grind.inferPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L1157-L1160"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.addEMatchEqTheorem\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Extension</span>.<span class=\"name\">addEMatchEqTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ext</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.Extension\">Extension</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Adds an E-matching equality theorem to the environment.\nSee `mkEMatchEqTheorem`.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.addEMatchEqTheorem","kind":"def","line":953,"name":"Lean.Meta.Grind.Extension.addEMatchEqTheorem","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L953-L958"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.addEMatchTheorem\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Extension</span>.<span class=\"name\">addEMatchTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ext</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.Extension\">Extension</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numParams</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">patterns</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">kind</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">minIndexable</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">attrKind</span> : <a href=\"./Lean/Attributes.html#Lean.AttributeKind\">AttributeKind</a> := <a href=\"./Lean/Attributes.html#Lean.AttributeKind.global\">AttributeKind.global</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnstrs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremConstraint\">EMatchTheoremConstraint</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Adds an E-matching theorem to the environment.\nSee `mkEMatchTheorem`.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.addEMatchTheorem","kind":"def","line":945,"name":"Lean.Meta.Grind.Extension.addEMatchTheorem","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L945-L951"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchEqTheorem\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkEMatchEqTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">normalizePattern </span><span class=\"fn\">useLhs</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">gen </span><span class=\"fn\">showInfo</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheorem\">EMatchTheorem</a></span></div></div>","info":{"doc":"Given theorem with name `declName` and type of the form `∀ (a_1 ... a_n), lhs = rhs`,\ncreates an E-matching pattern for it using `addEMatchTheorem n [lhs]`\n\nIf `normalizePattern` is true, it applies the `grind` simplification theorems and simprocs to the\npattern.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchEqTheorem","kind":"def","line":935,"name":"Lean.Meta.Grind.mkEMatchEqTheorem","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L935-L943"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.getEMatchTheoremsForNamespace\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Extension</span>.<span class=\"name\">getEMatchTheoremsForNamespace</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ext</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.Extension\">Extension</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">namespaceName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheorem\">EMatchTheorem</a>)</span></span></div></div>","info":{"doc":"Returns the scoped E-matching theorems declared in the given namespace. ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.getEMatchTheoremsForNamespace","kind":"def","line":926,"name":"Lean.Meta.Grind.Extension.getEMatchTheoremsForNamespace","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L926-L933"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.getEMatchTheorems\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Extension</span>.<span class=\"name\">getEMatchTheorems</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ext</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.Extension\">Extension</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems\">EMatchTheorems</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.getEMatchTheorems","kind":"def","line":922,"name":"Lean.Meta.Grind.Extension.getEMatchTheorems","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L922-L923"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.isEMatchTheorem\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Extension</span>.<span class=\"name\">isEMatchTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ext</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.Extension\">Extension</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Extension.isEMatchTheorem","kind":"def","line":919,"name":"Lean.Meta.Grind.Extension.isEMatchTheorem","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L919-L920"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchEqBwdTheoremCore\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkEMatchEqBwdTheoremCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">origin</span> : <a href=\"./Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin\">Origin</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">levelParams</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">showInfo</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheorem\">EMatchTheorem</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchEqBwdTheoremCore","kind":"def","line":910,"name":"Lean.Meta.Grind.mkEMatchEqBwdTheoremCore","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L910-L917"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchEqTheoremCore\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkEMatchEqTheoremCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">origin</span> : <a href=\"./Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin\">Origin</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">levelParams</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">normalizePattern </span><span class=\"fn\">useLhs </span><span class=\"fn\">gen</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">showInfo</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheorem\">EMatchTheorem</a></span></div></div>","info":{"doc":"Given a theorem with proof `proof` and type of the form `∀ (a_1 ... a_n), lhs = rhs`,\ncreates an E-matching pattern for it using `addEMatchTheorem n [lhs]`\nIf `normalizePattern` is true, it applies the `grind` simplification theorems and simprocs to the pattern.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchEqTheoremCore","kind":"def","line":888,"name":"Lean.Meta.Grind.mkEMatchEqTheoremCore","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L888-L908"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchTheorem\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkEMatchTheorem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numParams</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">patterns</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">kind</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">minIndexable</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnstrs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremConstraint\">EMatchTheoremConstraint</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheorem\">EMatchTheorem</a></span></div></div>","info":{"doc":"Creates an E-matching theorem for `declName` with `numParams` parameters, and the given set of patterns.\nPattern variables are represented using de Bruijn indices.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchTheorem","kind":"def","line":880,"name":"Lean.Meta.Grind.mkEMatchTheorem","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L880-L886"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchTheoremCore\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkEMatchTheoremCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">origin</span> : <a href=\"./Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin\">Origin</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">levelParams</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numParams</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">patterns</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">kind</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnstrs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremConstraint\">EMatchTheoremConstraint</a></span> := <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">showInfo </span><span class=\"fn\">minIndexable</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheorem\">EMatchTheorem</a></span></div></div>","info":{"doc":"Creates an E-matching theorem for a theorem with proof `proof`, `numParams` parameters, and the given set of patterns.\nPattern variables are represented using de Bruijn indices.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEMatchTheoremCore","kind":"def","line":851,"name":"Lean.Meta.Grind.mkEMatchTheoremCore","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L851-L869"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.CheckCoverageResult.missing\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">CheckCoverageResult</span>.<span class=\"name\">missing</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pos</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.CheckCoverageResult\">CheckCoverageResult</a></div></div>","info":{"doc":"`checkCoverage` failed because some of the theorem parameters are missing,\n`pos` contains their positions\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.CheckCoverageResult.missing","kind":"ctor","line":750,"name":"Lean.Meta.Grind.CheckCoverageResult.missing","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L750-L754"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.CheckCoverageResult.ok\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">CheckCoverageResult</span>.<span class=\"name\">ok</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.CheckCoverageResult\">CheckCoverageResult</a></div></div>","info":{"doc":"`checkCoverage` succeeded ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.CheckCoverageResult.ok","kind":"ctor","line":748,"name":"Lean.Meta.Grind.CheckCoverageResult.ok","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L748-L749"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.CheckCoverageResult\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">CheckCoverageResult</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Auxiliary type for the `checkCoverage` function.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.CheckCoverageResult","kind":"inductive","line":744,"name":"Lean.Meta.Grind.CheckCoverageResult","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L744-L754"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.main\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">main</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">patterns</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symPrios</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.SymbolPriorities\">SymbolPriorities</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">minPrio</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/HeadIndex.html#Lean.HeadIndex\">HeadIndex</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Std/Data/HashSet/Basic.html#Std.HashSet\">Std.HashSet</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.main","kind":"def","line":709,"name":"Lean.Meta.Grind.NormalizePattern.main","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L709-L711"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.getPatternArgKinds\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">getPatternArgKinds</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numArgs</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind\">PatternArgKind</a>)</span></span></div></div>","info":{"doc":"Returns an array `kinds` s.ts `kinds[i]` is the kind of the corresponding argument.\n\n- a type (that is not a proposition) or type former (which has forward dependencies) or\n- a proof, or\n- an instance implicit argument\n\nWhen `kinds[i].isSupport` is `true`, we say the corresponding argument is a \"support\" argument.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.getPatternArgKinds","kind":"def","line":546,"name":"Lean.Meta.Grind.NormalizePattern.getPatternArgKinds","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L546-L598"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind.isSupport\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">PatternArgKind</span>.<span class=\"name\">isSupport</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind\">PatternArgKind</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind.isSupport","kind":"def","line":542,"name":"Lean.Meta.Grind.NormalizePattern.PatternArgKind.isSupport","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L542-L544"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.instReprPatternArgKind.repr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">instReprPatternArgKind</span>.<span class=\"name\">repr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind\">PatternArgKind</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Format</a></span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.instReprPatternArgKind.repr","kind":"def","line":540,"name":"Lean.Meta.Grind.NormalizePattern.instReprPatternArgKind.repr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L540-L540"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.instReprPatternArgKind\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">instReprPatternArgKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind\">PatternArgKind</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.instReprPatternArgKind","kind":"instance","line":540,"name":"Lean.Meta.Grind.NormalizePattern.instReprPatternArgKind","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L540-L540"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind.outParam\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">PatternArgKind</span>.<span class=\"name\">outParam</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind\">PatternArgKind</a></div></div>","info":{"doc":"`outParam` arguments are uniquely determined by type class resolution and should not\nbe part of the e-matching pattern. Including them is redundant (the instance, which is\nalready wildcarded, determines the `outParam` value) and harmful when the normalizer\nchanges their syntactic form.\n\n**Motivation.** Consider the `ToInt` class used by the `grind` linear arithmetic module:\n```\nclass ToInt (α : Type) (range : outParam IntInterval) where ...\ninstance : ToInt (Fin n) (.co 0 n) where ...\n@[grind =] theorem toInt_fin (x : Fin n) : ToInt.toInt x = x.val\n```\nThe elaborated pattern for `toInt_fin` is:\n```\n@ToInt.toInt (Fin #1) (IntInterval.co 0 (NatCast.natCast #1)) _ #0\n```\nThe `range` argument `IntInterval.co 0 (NatCast.natCast #1)` is included in the pattern\nbecause the pattern generator treats it as relevant. However, the `grind` normalizer pushes\n`NatCast.natCast` inside arithmetic operations, rewriting `↑(n + 1)` to `↑n + 1`. So when\n`grind` processes `Fin (n + 1)`, the e-graph contains:\n```\n@ToInt.toInt (Fin (n + 1)) (IntInterval.co 0 (↑n + 1)) inst x\n```\nThe pattern expects `NatCast.natCast #1` at the second position of `IntInterval.co`, but\nthe e-graph has `HAdd.hAdd (NatCast.natCast n) 1` — a different head symbol. The pattern\ncannot match, and `toInt_fin` never fires.\n\nSince `outParam` arguments are determined by type class resolution (just like instance\narguments, which are already wildcarded), they can be safely ignored in patterns. This is\njustified by the same reasoning: after e-matching finds candidate substitutions, the\ninstantiation step checks all arguments via `isDefEq`, preserving soundness.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind.outParam","kind":"ctor","line":507,"name":"Lean.Meta.Grind.NormalizePattern.PatternArgKind.outParam","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L507-L539"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind.typeFormer\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">PatternArgKind</span>.<span class=\"name\">typeFormer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind\">PatternArgKind</a></div></div>","info":{"doc":"Types and type formers are mostly ignored during E-matching, and processed using\n`isDefEq`. However, if the argument is of the form `C ..` where `C` is inductive type\nwe process it as part of the pattern. Suppose we have `as bs : List α`, and a pattern\ncandidate expression `as ++ bs`, i.e., `@HAppend.hAppend (List α) (List α) (List α) inst as bs`.\nIf we completely ignore the types, the pattern will just be\n```\n@HAppend.hAppend _ _ _ _ #1 #0\n```\nThis is not ideal because the E-matcher will try it in any goal that contains `++`,\neven if it does not even mention lists.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind.typeFormer","kind":"ctor","line":494,"name":"Lean.Meta.Grind.NormalizePattern.PatternArgKind.typeFormer","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L494-L506"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind.proof\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">PatternArgKind</span>.<span class=\"name\">proof</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind\">PatternArgKind</a></div></div>","info":{"doc":"Proofs are ignored during E-matching. Lean is proof irrelevant. ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind.proof","kind":"ctor","line":492,"name":"Lean.Meta.Grind.NormalizePattern.PatternArgKind.proof","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L492-L493"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind.instImplicit\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">PatternArgKind</span>.<span class=\"name\">instImplicit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind\">PatternArgKind</a></div></div>","info":{"doc":"Instance implicit arguments are considered support and handled using `isDefEq`. ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind.instImplicit","kind":"ctor","line":490,"name":"Lean.Meta.Grind.NormalizePattern.PatternArgKind.instImplicit","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L490-L491"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind.relevant\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">PatternArgKind</span>.<span class=\"name\">relevant</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind\">PatternArgKind</a></div></div>","info":{"doc":"Argument is relevant for E-matching. ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind.relevant","kind":"ctor","line":488,"name":"Lean.Meta.Grind.NormalizePattern.PatternArgKind.relevant","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L488-L489"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">PatternArgKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.PatternArgKind","kind":"inductive","line":487,"name":"Lean.Meta.Grind.NormalizePattern.PatternArgKind","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L487-L540"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State.bvarsFound\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">State</span>.<span class=\"name\">bvarsFound</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/HashSet/Basic.html#Std.HashSet\">Std.HashSet</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State.bvarsFound","kind":"def","line":437,"name":"Lean.Meta.Grind.NormalizePattern.State.bvarsFound","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L437-L437"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State.symbolSet\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">State</span>.<span class=\"name\">symbolSet</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/HashSet/Basic.html#Std.HashSet\">Std.HashSet</a> <a href=\"./Lean/HeadIndex.html#Lean.HeadIndex\">HeadIndex</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State.symbolSet","kind":"def","line":436,"name":"Lean.Meta.Grind.NormalizePattern.State.symbolSet","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L436-L436"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State.symbols\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">State</span>.<span class=\"name\">symbols</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/HeadIndex.html#Lean.HeadIndex\">HeadIndex</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State.symbols","kind":"def","line":435,"name":"Lean.Meta.Grind.NormalizePattern.State.symbols","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L435-L435"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">State</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symbols</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/HeadIndex.html#Lean.HeadIndex\">HeadIndex</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symbolSet</span> : <span class=\"fn\"><a href=\"./Std/Data/HashSet/Basic.html#Std.HashSet\">Std.HashSet</a> <a href=\"./Lean/HeadIndex.html#Lean.HeadIndex\">HeadIndex</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">bvarsFound</span> : <span class=\"fn\"><a href=\"./Std/Data/HashSet/Basic.html#Std.HashSet\">Std.HashSet</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State\">State</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State.mk","kind":"ctor","line":434,"name":"Lean.Meta.Grind.NormalizePattern.State.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L434-L434"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">NormalizePattern</span>.<span class=\"name\">State</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.NormalizePattern.State","kind":"structure","line":434,"name":"Lean.Meta.Grind.NormalizePattern.State","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L434-L437"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.ppPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">ppPattern</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pattern</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">MessageData</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.ppPattern","kind":"opaque","line":408,"name":"Lean.Meta.Grind.ppPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L408-L430"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.isPatternDontCare\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">isPatternDontCare</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.isPatternDontCare","kind":"def","line":402,"name":"Lean.Meta.Grind.isPatternDontCare","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L402-L403"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.groundPattern?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">groundPattern?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.groundPattern?","kind":"def","line":396,"name":"Lean.Meta.Grind.groundPattern?","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L396-L397"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkGroundPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkGroundPattern</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkGroundPattern","kind":"def","line":393,"name":"Lean.Meta.Grind.mkGroundPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L393-L394"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.splitWhileForbidden\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">splitWhileForbidden</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pat</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Auxiliary function to expand a pattern containing forbidden application symbols\ninto a multi-pattern.\n\nThis function enhances the usability of the `[grind =]` attribute by automatically handling\nforbidden pattern symbols. For example, consider the following theorem tagged with this attribute:\n```\ngetLast?_eq_some_iff {xs : List α} {a : α} : xs.getLast? = some a ↔ ∃ ys, xs = ys ++ [a]\n```\nHere, the selected pattern is `xs.getLast? = some a`, but `Eq` is a forbidden pattern symbol.\nInstead of producing an error, this function converts the pattern into a multi-pattern,\nallowing the attribute to be used conveniently.\n\nThe function recursively expands patterns with forbidden symbols by splitting them\ninto their sub-components. If the pattern does not contain forbidden symbols,\nit is returned as-is.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.splitWhileForbidden","kind":"opaque","line":364,"name":"Lean.Meta.Grind.splitWhileForbidden","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L364-L389"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem.getProofWithFreshMVarLevels\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EMatchTheorem</span>.<span class=\"name\">getProofWithFreshMVarLevels</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">thm</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheorem\">EMatchTheorem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem.getProofWithFreshMVarLevels","kind":"def","line":361,"name":"Lean.Meta.Grind.EMatchTheorem.getProofWithFreshMVarLevels","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L361-L362"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems.getKindsFor\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EMatchTheorems</span>.<span class=\"name\">getKindsFor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems\">EMatchTheorems</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">origin</span> : <a href=\"./Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin\">Origin</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems.getKindsFor","kind":"def","line":357,"name":"Lean.Meta.Grind.EMatchTheorems.getKindsFor","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L357-L359"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.ExtensionStateArray.containsWithSamePatterns\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">ExtensionStateArray</span>.<span class=\"name\">containsWithSamePatterns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.ExtensionStateArray\">ExtensionStateArray</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">origin</span> : <a href=\"./Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin\">Origin</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">patterns</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnstrs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremConstraint\">EMatchTheoremConstraint</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.ExtensionStateArray.containsWithSamePatterns","kind":"def","line":353,"name":"Lean.Meta.Grind.ExtensionStateArray.containsWithSamePatterns","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L353-L355"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems.containsWithSamePatterns\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EMatchTheorems</span>.<span class=\"name\">containsWithSamePatterns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems\">EMatchTheorems</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">origin</span> : <a href=\"./Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin\">Origin</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">patterns</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cnstrs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremConstraint\">EMatchTheoremConstraint</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Returns `true` if there is a theorem with exactly the same pattern and constraints is already in `s`\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems.containsWithSamePatterns","kind":"def","line":345,"name":"Lean.Meta.Grind.EMatchTheorems.containsWithSamePatterns","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L345-L351"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremsArray\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EMatchTheoremsArray</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A collection of sets of E-matching theorems. ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremsArray","kind":"def","line":342,"name":"Lean.Meta.Grind.EMatchTheoremsArray","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L342-L343"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EMatchTheorems</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Set of E-matching theorems. ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems","kind":"def","line":339,"name":"Lean.Meta.Grind.EMatchTheorems","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L339-L340"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind.toAttribute\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EMatchTheoremKind</span>.<span class=\"name\">toAttribute</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">minIndexable</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind.toAttribute","kind":"def","line":318,"name":"Lean.Meta.Grind.EMatchTheoremKind.toAttribute","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L318-L324"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind.toAttributeCore\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EMatchTheoremKind</span>.<span class=\"name\">toAttributeCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">kind</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind.toAttributeCore","kind":"def","line":300,"name":"Lean.Meta.Grind.EMatchTheoremKind.toAttributeCore","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L300-L316"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind.isDefault\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EMatchTheoremKind</span>.<span class=\"name\">isDefault</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind.isDefault","kind":"def","line":296,"name":"Lean.Meta.Grind.EMatchTheoremKind.isDefault","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L296-L298"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind.isEqLhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EMatchTheoremKind</span>.<span class=\"name\">isEqLhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.EMatchTheoremKind\">EMatchTheoremKind</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind.isEqLhs","kind":"def","line":292,"name":"Lean.Meta.Grind.EMatchTheoremKind.isEqLhs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L292-L294"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.preprocessPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">preprocessPattern</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pat</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">normalizePattern</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.preprocessPattern","kind":"def","line":281,"name":"Lean.Meta.Grind.preprocessPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L281-L290"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.isMatchCongrEqDeclName\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">isMatchCongrEqDeclName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Returns `true` if `declName` is the name of a `match`-expression congruence equation. ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.isMatchCongrEqDeclName","kind":"def","line":140,"name":"Lean.Meta.Grind.isMatchCongrEqDeclName","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L140-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.isGenPattern?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">isGenPattern?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pat</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo\">GenPatternInfo</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.isGenPattern?","kind":"def","line":128,"name":"Lean.Meta.Grind.isGenPattern?","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L128-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.instReprGenPatternInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">instReprGenPatternInfo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo\">GenPatternInfo</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.instReprGenPatternInfo","kind":"instance","line":126,"name":"Lean.Meta.Grind.instReprGenPatternInfo","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L126-L126"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.instReprGenPatternInfo.repr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">instReprGenPatternInfo</span>.<span class=\"name\">repr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo\">GenPatternInfo</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Format</a></span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.instReprGenPatternInfo.repr","kind":"def","line":126,"name":"Lean.Meta.Grind.instReprGenPatternInfo.repr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L126-L126"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo.xIdx\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">GenPatternInfo</span>.<span class=\"name\">xIdx</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo\">GenPatternInfo</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo.xIdx","kind":"def","line":125,"name":"Lean.Meta.Grind.GenPatternInfo.xIdx","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L125-L125"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo.hIdx\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">GenPatternInfo</span>.<span class=\"name\">hIdx</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo\">GenPatternInfo</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo.hIdx","kind":"def","line":124,"name":"Lean.Meta.Grind.GenPatternInfo.hIdx","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L124-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo.heq\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">GenPatternInfo</span>.<span class=\"name\">heq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo\">GenPatternInfo</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo.heq","kind":"def","line":123,"name":"Lean.Meta.Grind.GenPatternInfo.heq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L123-L123"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">GenPatternInfo</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heq</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hIdx </span><span class=\"fn\">xIdx</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo\">GenPatternInfo</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo.mk","kind":"ctor","line":122,"name":"Lean.Meta.Grind.GenPatternInfo.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L122-L122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">GenPatternInfo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Generalized pattern information. See `Grind.genPattern` gadget. ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.GenPatternInfo","kind":"structure","line":121,"name":"Lean.Meta.Grind.GenPatternInfo","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L121-L126"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkGenHEqPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkGenHEqPattern</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">u</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Level.html#Lean.Level\">Level</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α </span><span class=\"fn\">β </span><span class=\"fn\">h </span><span class=\"fn\">x </span><span class=\"fn\">val</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkGenHEqPattern","kind":"def","line":118,"name":"Lean.Meta.Grind.mkGenHEqPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L118-L119"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkGenPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkGenPattern</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">u</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Level.html#Lean.Level\">Level</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α </span><span class=\"fn\">h </span><span class=\"fn\">x </span><span class=\"fn\">val</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkGenPattern","kind":"def","line":115,"name":"Lean.Meta.Grind.mkGenPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L115-L116"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.isEqBwdPattern?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">isEqBwdPattern?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.isEqBwdPattern?","kind":"def","line":110,"name":"Lean.Meta.Grind.isEqBwdPattern?","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L110-L113"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.isEqBwdPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">isEqBwdPattern</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.isEqBwdPattern","kind":"def","line":107,"name":"Lean.Meta.Grind.isEqBwdPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L107-L108"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEqBwdPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkEqBwdPattern</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">u</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Level.html#Lean.Level\">Level</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α </span><span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkEqBwdPattern","kind":"def","line":104,"name":"Lean.Meta.Grind.mkEqBwdPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L104-L105"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.isOffsetPattern?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">isOffsetPattern?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pat</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.isOffsetPattern?","kind":"def","line":84,"name":"Lean.Meta.Grind.isOffsetPattern?","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L84-L87"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkOffsetPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">mkOffsetPattern</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pat</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.mkOffsetPattern","kind":"def","line":67,"name":"Lean.Meta.Grind.mkOffsetPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L67-L68"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.addSymbolPriorityAttr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">addSymbolPriorityAttr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">attrKind</span> : <a href=\"./Lean/Attributes.html#Lean.AttributeKind\">AttributeKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prio</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Sets `declName` priority to be used during E-matching pattern inference ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.addSymbolPriorityAttr","kind":"def","line":63,"name":"Lean.Meta.Grind.addSymbolPriorityAttr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L63-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.getGlobalSymbolPriorities\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">getGlobalSymbolPriorities</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.SymbolPriorities\">SymbolPriorities</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.getGlobalSymbolPriorities","kind":"def","line":60,"name":"Lean.Meta.Grind.getGlobalSymbolPriorities","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L60-L61"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.resetSymbolPrioExt\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">resetSymbolPrioExt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.resetSymbolPrioExt","kind":"def","line":57,"name":"Lean.Meta.Grind.resetSymbolPrioExt","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L57-L58"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorities.contains\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">SymbolPriorities</span>.<span class=\"name\">contains</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.SymbolPriorities\">SymbolPriorities</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Returns `true`, if there is an entry `declName ↦ prio` in `s`.\nRecall that symbols not in `s` are assumed to have default priority.\n","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorities.contains","kind":"def","line":44,"name":"Lean.Meta.Grind.SymbolPriorities.contains","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L44-L49"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorities.getPrio\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">SymbolPriorities</span>.<span class=\"name\">getPrio</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.SymbolPriorities\">SymbolPriorities</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"Returns `declName` priority for E-matching pattern inference in `s`. ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorities.getPrio","kind":"def","line":37,"name":"Lean.Meta.Grind.SymbolPriorities.getPrio","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L37-L42"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorities.erase\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">SymbolPriorities</span>.<span class=\"name\">erase</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.SymbolPriorities\">SymbolPriorities</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/Extension.html#Lean.Meta.Grind.SymbolPriorities\">SymbolPriorities</a></div></div>","info":{"doc":"Removes the given declaration from `s`. ","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorities.erase","kind":"def","line":33,"name":"Lean.Meta.Grind.SymbolPriorities.erase","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L33-L35"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.instInhabitedSymbolPriorityEntry\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">instInhabitedSymbolPriorityEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry\">SymbolPriorityEntry</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.instInhabitedSymbolPriorityEntry","kind":"instance","line":31,"name":"Lean.Meta.Grind.instInhabitedSymbolPriorityEntry","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L31-L31"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.instInhabitedSymbolPriorityEntry.default\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">instInhabitedSymbolPriorityEntry</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry\">SymbolPriorityEntry</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.instInhabitedSymbolPriorityEntry.default","kind":"def","line":31,"name":"Lean.Meta.Grind.instInhabitedSymbolPriorityEntry.default","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L31-L31"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry.prio\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">SymbolPriorityEntry</span>.<span class=\"name\">prio</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry\">SymbolPriorityEntry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry.prio","kind":"def","line":30,"name":"Lean.Meta.Grind.SymbolPriorityEntry.prio","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L30-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry.declName\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">SymbolPriorityEntry</span>.<span class=\"name\">declName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry\">SymbolPriorityEntry</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Name</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry.declName","kind":"def","line":29,"name":"Lean.Meta.Grind.SymbolPriorityEntry.declName","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L29-L29"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">SymbolPriorityEntry</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prio</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry\">SymbolPriorityEntry</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry.mk","kind":"ctor","line":28,"name":"Lean.Meta.Grind.SymbolPriorityEntry.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L28-L28"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">SymbolPriorityEntry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorityEntry","kind":"structure","line":28,"name":"Lean.Meta.Grind.SymbolPriorityEntry","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L28-L31"}}],"imports":["Lean.Meta.Tactic.Grind.Extension","Lean.Meta.Tactic.Grind.Util","Lean.Meta.Tactic.TryThis","Lean.Meta.Sym.Util","Lean.Meta.Sym.Eta"],"instances":[{"className":"Inhabited","name":"Lean.Meta.Grind.instInhabitedSymbolPriorityEntry","typeNames":["Lean.Meta.Grind.SymbolPriorityEntry"]},{"className":"Repr","name":"Lean.Meta.Grind.instReprGenPatternInfo","typeNames":["Lean.Meta.Grind.GenPatternInfo"]},{"className":"Repr","name":"Lean.Meta.Grind.NormalizePattern.instReprPatternArgKind","typeNames":["Lean.Meta.Grind.NormalizePattern.PatternArgKind"]}],"name":"Lean.Meta.Tactic.Grind.EMatchTheorem"}