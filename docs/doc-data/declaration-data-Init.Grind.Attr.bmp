{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grind!?\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grind!?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Like `@[grind!]`, but also prints the pattern(s) selected by `grind`\nas info messages. Combines minimal subexpression selection with debugging output.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grind!?","kind":"def","line":315,"name":"Lean.Parser.Attr.grind!?","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L315-L319"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grind?\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grind?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Like `@[grind]`, but also prints the pattern(s) selected by `grind`\nas info messages. Useful for debugging annotations and modifiers.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grind?","kind":"def","line":310,"name":"Lean.Parser.Attr.grind?","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L310-L314"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grind!\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grind!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Like `@[grind]`, but enforces the **minimal indexable subexpression condition**:\nwhen several subterms cover the same free variables, `grind!` chooses the smallest one.\n\nThis influences E-matching pattern selection.\n\n### Example\n```lean\ntheorem fg_eq (h : x > 0) : f (g x) = x\n\n@[grind <-] theorem fg_eq (h : x > 0) : f (g x) = x\n-- Pattern selected: `f (g x)`\n\n-- With minimal subexpression:\n@[grind! <-] theorem fg_eq (h : x > 0) : f (g x) = x\n-- Pattern selected: `g x`\n```\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grind!","kind":"def","line":291,"name":"Lean.Parser.Attr.grind!","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L291-L309"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Marks a theorem or definition for use by the `grind` tactic.\n\nAn optional modifier (e.g. `=`, `→`, `←`, `cases`, `intro`, `ext`, `inj`, etc.)\ncontrols how `grind` uses the declaration:\n* whether it is applied forwards, backwards, or both,\n* whether equalities are used on the left, right, or both sides,\n* whether case-splits, constructors, extensionality, or injectivity are applied,\n* or whether custom instantiation patterns are used.\n\nSee the individual modifier docstrings for details.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grind","kind":"def","line":278,"name":"Lean.Parser.Attr.grind","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L278-L290"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindMod\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindMod</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindMod","kind":"def","line":272,"name":"Lean.Parser.Attr.grindMod","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L272-L276"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindSym\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindSym</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`symbol <prio>` sets the priority of a constant for `grind`’s pattern-selection\nprocedure. `grind` prefers patterns that contain higher-priority symbols.\nExample:\n```\nopaque p : Nat → Nat → Prop\nopaque q : Nat → Nat → Prop\nopaque r : Nat → Nat → Prop\n\nattribute [grind symbol low] p\nattribute [grind symbol high] q\n\naxiom bar {x y} : p x y → q x x → r x y → r y x\nattribute [grind →] bar\n```\nHere `p` is low priority, `q` is high priority, and `r` is default. `grind` first\ntries to find a multi-pattern covering `x` and `y` using only high-priority\nsymbols while scanning hypotheses left to right. This fails because `q x x` does\nnot cover `y`. It then allows both high and default symbols and succeeds with\nthe multi-pattern `q x x, r x y`. The term `p x y` is ignored due to `p`’s low\npriority. Symbols with priority `0` are never used in patterns.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindSym","kind":"def","line":249,"name":"Lean.Parser.Attr.grindSym","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L249-L271"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindUnfold\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindUnfold</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `unfold` modifier instructs `grind` to unfold the given definition during the preprocessing step.\nExample:\n```\n@[grind unfold] def h (x : Nat) := 2 * x\nexample : 6 ∣ 3*h x := by grind\n```\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindUnfold","kind":"def","line":240,"name":"Lean.Parser.Attr.grindUnfold","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L240-L248"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindNorm\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindNorm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `norm` modifier instructs `grind` to use a theorem as a normalization rule. That is,\nthe theorem is applied during the preprocessing step.\nThis feature is meant for advanced users who understand how the preprocessor and `grind`'s search\nprocedure interact with each other.\nNew users can still benefit from this feature by restricting its use to theorems that completely\neliminate a symbol from the goal. Example:\n```\ntheorem max_def : max n m = if n ≤ m then m else n\n```\nFor a negative example, consider:\n```\nopaque f : Int → Int → Int → Int\ntheorem fax1 : f x 0 1 = 1 := sorry\ntheorem fax2 : f 1 x 1 = 1 := sorry\nattribute [grind norm] fax1\nattribute [grind =] fax2\n\nexample (h : c = 1) : f c 0 c = 1 := by\n  grind -- fails\n```\nIn this example, `fax1` is a normalization rule, but it is not applicable to the input goal since\n`f c 0 c` is not an instance of `f x 0 1`. However, `f c 0 c` matches the pattern `f 1 x 1` modulo\nthe equality `c = 1`. Thus, `grind` instantiates `fax2` with `x := 0`, producing the equality\n`f 1 0 1 = 1`, which the normalizer simplifies to `True`. As a result, nothing useful is learned.\nIn the future, we plan to include linters to automatically detect issues like these.\nExample:\n```\nopaque f : Nat → Nat\nopaque g : Nat → Nat\n\n@[grind norm] axiom fax : f x = x + 2\n@[grind norm ←] axiom fg : f x = g x\n\nexample : f x ≥ 2 := by grind\nexample : f x ≥ g x := by grind\nexample : f x + g x ≥ 4 := by grind\n```\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindNorm","kind":"def","line":200,"name":"Lean.Parser.Attr.grindNorm","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L200-L239"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindFunCC\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindFunCC</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `funCC` modifier marks global functions that support **function-valued congruence closure**.\nGiven an application `f a₁ a₂ … aₙ`, when `funCC := true`,\n`grind` generates and tracks equalities for all partial applications:\n- `f a₁`\n- `f a₁ a₂`\n- `…`\n- `f a₁ a₂ … aₙ`\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindFunCC","kind":"def","line":190,"name":"Lean.Parser.Attr.grindFunCC","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L190-L199"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindInj\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindInj</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `inj` modifier marks injectivity theorems for use by `grind`.\nThe conclusion of the theorem must be of the form `Function.Injective f`\nwhere the term `f` contains at least one constant symbol.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindInj","kind":"def","line":184,"name":"Lean.Parser.Attr.grindInj","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L184-L189"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindExt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindExt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `ext` modifier marks extensionality theorems for use by `grind`.\nFor example, the standard library marks `funext` with this attribute.\n\nWhenever `grind` encounters a disequality `a ≠ b`, it attempts to apply any\navailable extensionality theorems whose matches the type of `a` and `b`.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindExt","kind":"def","line":176,"name":"Lean.Parser.Attr.grindExt","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L176-L183"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindIntro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindIntro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `intro` modifier instructs `grind` to use the constructors (introduction rules)\nof an inductive predicate as E-matching theorems.Example:\n```\ninductive Even : Nat → Prop where\n| zero : Even 0\n| add2 : Even x → Even (x + 2)\n\nattribute [grind intro] Even\nexample (h : Even x) : Even (x + 6) := by grind\nexample : Even 0 := by grind\n```\nHere `attribute [grind intro] Even` acts like a macro that expands to\n`attribute [grind] Even.zero` and `attribute [grind] Even.add2`.\nThis is especially convenient for inductive predicates with many constructors.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindIntro","kind":"def","line":159,"name":"Lean.Parser.Attr.grindIntro","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L159-L175"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindCasesEager\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindCasesEager</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `cases eager` modifier marks inductively-defined predicates as suitable for case splitting,\nand instructs `grind` to perform it eagerly while preprocessing hypotheses.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindCasesEager","kind":"def","line":154,"name":"Lean.Parser.Attr.grindCasesEager","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L154-L158"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindCases\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindCases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `cases` modifier marks inductively-defined predicates as suitable for case splitting.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindCases","kind":"def","line":150,"name":"Lean.Parser.Attr.grindCases","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L150-L153"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindUsr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindUsr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `usr` modifier indicates that this theorem was applied using a\n**user-defined instantiation pattern**. Such patterns are declared with\nthe `grind_pattern` command, which lets you specify how `grind` should\nmatch and use particular theorems.\n\nExample:\n- `grind [usr myThm]` means `grind` is using `myThm`, but with\n  the custom pattern you defined with `grind_pattern`.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindUsr","kind":"def","line":139,"name":"Lean.Parser.Attr.grindUsr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L139-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindDef\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindDef</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `.` modifier instructs `grind` to select a multi-pattern by traversing the conclusion of the\ntheorem, and then the hypotheses from left to right. We say this is the default modifier.\nEach time it encounters a subexpression which covers an argument which was not\npreviously covered, it adds that subexpression as a pattern, until all arguments have been covered.\nIf `grind!` is used, then only minimal indexable subexpressions are considered.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindDef","kind":"def","line":131,"name":"Lean.Parser.Attr.grindDef","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L131-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindLR\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindLR</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `⇒` modifier instructs `grind` to select a multi-pattern by traversing all the hypotheses from\nleft to right, followed by the conclusion.\nEach time it encounters a subexpression which covers an argument which was not\npreviously covered, it adds that subexpression as a pattern, until all arguments have been covered.\nIf `grind!` is used, then only minimal indexable subexpressions are considered.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindLR","kind":"def","line":123,"name":"Lean.Parser.Attr.grindLR","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L123-L130"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindRL\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindRL</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `⇐` modifier instructs `grind` to select a multi-pattern by traversing the conclusion, and then\nall the hypotheses from right to left.\nEach time it encounters a subexpression which covers an argument which was not\npreviously covered, it adds that subexpression as a pattern, until all arguments have been covered.\nIf `grind!` is used, then only minimal indexable subexpressions are considered.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindRL","kind":"def","line":115,"name":"Lean.Parser.Attr.grindRL","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L115-L122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindFwd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindFwd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `→` modifier instructs `grind` to select a multi-pattern from the hypotheses of the theorem.\nIn other words, `grind` will use the theorem for forwards reasoning.\nTo generate a pattern, it traverses the hypotheses of the theorem from left to right.\nEach time it encounters a subexpression which covers an argument which was not\npreviously covered, it adds that subexpression as a pattern, until all arguments have been covered.\nIf `grind!` is used, then only minimal indexable subexpressions are considered.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindFwd","kind":"def","line":106,"name":"Lean.Parser.Attr.grindFwd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L106-L114"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindBwd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindBwd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `←` modifier instructs `grind` to select a multi-pattern from the conclusion of theorem.\nIn other words, `grind` will use the theorem for backwards reasoning.\nThis may fail if not all of the arguments to the theorem appear in the conclusion.\nEach time it encounters a subexpression which covers an argument which was not\npreviously covered, it adds that subexpression as a pattern, until all arguments have been covered.\nIf `grind!` is used, then only minimal indexable subexpressions are considered.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindBwd","kind":"def","line":97,"name":"Lean.Parser.Attr.grindBwd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L97-L105"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindEqBwd\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindEqBwd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `←=` modifier is unlike the other `grind` modifiers, and it used specifically for\nbackwards reasoning on equality. When a theorem's conclusion is an equality proposition and it\nis annotated with `@[grind ←=]`, grind `will` instantiate it whenever the corresponding disequality\nis assumed—this is a consequence of the fact that grind performs all proofs by contradiction.\nOrdinarily, the grind attribute does not consider the `=` symbol when generating patterns.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindEqBwd","kind":"def","line":89,"name":"Lean.Parser.Attr.grindEqBwd","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L89-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindEqBoth\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindEqBoth</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `_=_` modifier acts like a macro which expands to `=` and `=_`.  It adds two patterns,\nallowing the equality theorem to trigger in either direction.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindEqBoth","kind":"def","line":84,"name":"Lean.Parser.Attr.grindEqBoth","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L84-L88"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindEqRhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindEqRhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `=_` modifier instructs `grind` to check that the conclusion of the theorem is an equality,\nand then uses the right-hand side of the equality as a pattern. This may fail if not all of the arguments appear\nin the right-hand side.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindEqRhs","kind":"def","line":78,"name":"Lean.Parser.Attr.grindEqRhs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L78-L83"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindEq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `=` modifier instructs `grind` to check that the conclusion of the theorem is an equality,\nand then uses the left-hand side of the equality as a pattern. This may fail if not all of the arguments appear\nin the left-hand side.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindEq","kind":"def","line":72,"name":"Lean.Parser.Attr.grindEq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L72-L77"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.Attr.grindGen\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">grindGen</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Grind/Attr.html#Lean.Parser.Attr.grindGen","kind":"def","line":71,"name":"Lean.Parser.Attr.grindGen","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L71-L71"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Parser.resetGrindAttrs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">resetGrindAttrs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Reset all `grind` attributes. This command is intended for testing purposes only and should not be used in applications.\n","docLink":"./Init/Grind/Attr.html#Lean.Parser.resetGrindAttrs","kind":"def","line":65,"name":"Lean.Parser.resetGrindAttrs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L65-L68"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Grind.genHEqPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">genHEqPattern</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_h</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_val</span> : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"Similar to `genPattern` but for the heterogeneous case ","docLink":"./Init/Grind/Attr.html#Lean.Grind.genHEqPattern","kind":"def","line":60,"name":"Lean.Grind.genHEqPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L60-L61"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Attr.html#Lean.Grind.genPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">genPattern</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_h</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">_val</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"Gadget for representing generalization steps `h : x = val` in patterns\nThis gadget is used to represent patterns in theorems that have been generalized to reduce the\nnumber of casts introduced during E-matching based instantiation.\n\nFor example, consider the theorem\n```\nOption.pbind_some {α1 : Type u_1} {a : α1} {α2 : Type u_2}\n    {f : (a_1 : α1) → some a = some a_1 → Option α2}\n    : (some a).pbind f = f a rfl\n```\nNow, suppose we have a goal containing the term `c.pbind g` and the equivalence class\n`{c, some b}`. The E-matching module generates the instance\n```\n(some b).pbind (cast ⋯ g)\n```\nThe `cast` is necessary because `g`'s type contains `c` instead of `some b.\nThis `cast` problematic because we don't have a systematic way of pushing casts over functions\nto its arguments. Moreover, heterogeneous equality is not effective because the following theorem\nis not provable in DTT:\n```\ntheorem hcongr (h₁ : f ≍ g) (h₂ : a ≍ b)  : f a ≍ g b := ...\n```\nThe standard solution is to generalize the theorem above and write it as\n```\ntheorem Option.pbind_some'\n        {α1 : Type u_1} {a : α1} {α2 : Type u_2}\n        {x : Option α1}\n        {f : (a_1 : α1) → x = some a_1 → Option α2}\n        (h : x = some a)\n        : x.pbind f = f a h := by\n  subst h\n  apply Option.pbind_some\n```\nInternally, we use this gadget to mark the E-matching pattern as\n```\n(genPattern h x (some a)).pbind f\n```\nThis pattern is matched in the same way we match `(some a).pbind f`, but it saves the proof\nfor the actual term to the `some`-application in `f`, and the actual term in `x`.\n\nIn the example above, `c.pbind g` also matches the pattern `(genPattern h x (some a)).pbind f`,\nand stores `c` in `x`, `b` in `a`, and the proof that `c = some b` in `h`.\n","docLink":"./Init/Grind/Attr.html#Lean.Grind.genPattern","kind":"def","line":14,"name":"Lean.Grind.genPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Attr.lean#L14-L58"}}],"imports":["Init.Tactics"],"instances":[],"name":"Init.Grind.Attr"}