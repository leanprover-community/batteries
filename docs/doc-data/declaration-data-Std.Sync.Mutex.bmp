{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Mutex.atomicallyOnce\"><span class=\"name\">Std</span>.<span class=\"name\">Mutex</span>.<span class=\"name\">atomicallyOnce</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Except.html#MonadFinally\">MonadFinally</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <span class=\"fn\"><a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">condvar</span> : <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pred</span> : <span class=\"fn\"><a href=\"./Std/Sync/Basic.html#Std.AtomicT\">AtomicT</a> <span class=\"fn\">α</span> <span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Std/Sync/Basic.html#Std.AtomicT\">AtomicT</a> <span class=\"fn\">α</span> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>","info":{"doc":"`mutex.atomicallyOnce condvar pred k` runs `k`, waiting on `condvar` until `pred` returns true.\nBoth `k` and `pred` have access to the mutex's state.\n\nCalling `mutex.atomicallyOnce` while already holding the underlying `BaseMutex` in the same thread\nis undefined behavior. If this is unavoidable in your code, consider using `RecursiveMutex`.\n","docLink":"./Std/Sync/Mutex.html#Std.Mutex.atomicallyOnce","kind":"def","line":162,"name":"Std.Mutex.atomicallyOnce","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L162-L175"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Mutex.tryAtomically\"><span class=\"name\">Std</span>.<span class=\"name\">Mutex</span>.<span class=\"name\">tryAtomically</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Except.html#MonadFinally\">MonadFinally</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <span class=\"fn\"><a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Std/Sync/Basic.html#Std.AtomicT\">AtomicT</a> <span class=\"fn\">α</span> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">β</span>)</span></span></div></div>","info":{"doc":"`mutex.tryAtomically k` tries to lock `mutex` and runs `k` on it if it succeeds. On success the\nreturn value of `k` is returned as `some`, on failure `none` is returned.\n\nThis function does not block on the `mutex`. Additionally calling `mutex.tryAtomically` while\nalready holding the underlying `BaseMutex` in the same thread is undefined behavior. If this is\nunavoidable in your code, consider using `RecursiveMutex`.\n","docLink":"./Std/Sync/Mutex.html#Std.Mutex.tryAtomically","kind":"def","line":144,"name":"Std.Mutex.tryAtomically","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L144-L160"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Mutex.atomically\"><span class=\"name\">Std</span>.<span class=\"name\">Mutex</span>.<span class=\"name\">atomically</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Except.html#MonadFinally\">MonadFinally</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <span class=\"fn\"><a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Std/Sync/Basic.html#Std.AtomicT\">AtomicT</a> <span class=\"fn\">α</span> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>","info":{"doc":"`mutex.atomically k` runs `k` with access to the mutex's state while locking the mutex.\n\nCalling `mutex.atomically` while already holding the underlying `BaseMutex` in the same thread\nis undefined behavior. If this is unavoidable in your code, consider using `RecursiveMutex`.\n","docLink":"./Std/Sync/Mutex.html#Std.Mutex.atomically","kind":"def","line":130,"name":"Std.Mutex.atomically","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L130-L142"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Mutex.new\"><span class=\"name\">Std</span>.<span class=\"name\">Mutex</span>.<span class=\"name\">new</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">(<a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"Creates a new mutex. ","docLink":"./Std/Sync/Mutex.html#Std.Mutex.new","kind":"def","line":126,"name":"Std.Mutex.new","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L126-L128"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.instCoeOutMutexBaseMutex\"><span class=\"name\">Std</span>.<span class=\"name\">instCoeOutMutexBaseMutex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#CoeOut\">CoeOut</a> <span class=\"fn\">(<a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α</span>)</span> <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a></span></div></div>","info":{"doc":"","docLink":"./Std/Sync/Mutex.html#Std.instCoeOutMutexBaseMutex","kind":"instance","line":124,"name":"Std.instCoeOutMutexBaseMutex","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L124-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.instNonemptyMutex\"><span class=\"name\">Std</span>.<span class=\"name\">instNonemptyMutex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α✝</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α✝</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α✝</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Std/Sync/Mutex.html#Std.instNonemptyMutex","kind":"instance","line":122,"name":"Std.instNonemptyMutex","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L122-L122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Mutex.mutex\"><span class=\"name\">Std</span>.<span class=\"name\">Mutex</span>.<span class=\"name\">mutex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Std/Sync/Mutex.html#Std.Mutex\">Mutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a></div></div>","info":{"doc":"","docLink":"./Std/Sync/Mutex.html#Std.Mutex.mutex","kind":"def","line":121,"name":"Std.Mutex.mutex","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L121-L121"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Mutex\"><span class=\"name\">Std</span>.<span class=\"name\">Mutex</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Mutual exclusion primitive (lock) guarding shared state of type `α`.\n\nThe type `Mutex α` is similar to `IO.Ref α`, except that concurrent accesses are guarded by a mutex\ninstead of atomic pointer operations and busy-waiting.\n","docLink":"./Std/Sync/Mutex.html#Std.Mutex","kind":"structure","line":113,"name":"Std.Mutex","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L113-L122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Condvar.waitUntil\"><span class=\"name\">Std</span>.<span class=\"name\">Condvar</span>.<span class=\"name\">waitUntil</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">condvar</span> : <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pred</span> : <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Waits on the condition variable until the predicate is true. ","docLink":"./Std/Sync/Mutex.html#Std.Condvar.waitUntil","kind":"def","line":107,"name":"Std.Condvar.waitUntil","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L107-L111"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Condvar.notifyAll\"><span class=\"name\">Std</span>.<span class=\"name\">Condvar</span>.<span class=\"name\">notifyAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">condvar</span> : <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Wakes up all other threads executing `wait`. ","docLink":"./Std/Sync/Mutex.html#Std.Condvar.notifyAll","kind":"opaque","line":103,"name":"Std.Condvar.notifyAll","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L103-L105"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Condvar.notifyOne\"><span class=\"name\">Std</span>.<span class=\"name\">Condvar</span>.<span class=\"name\">notifyOne</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">condvar</span> : <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Wakes up a single other thread executing `wait`. ","docLink":"./Std/Sync/Mutex.html#Std.Condvar.notifyOne","kind":"opaque","line":99,"name":"Std.Condvar.notifyOne","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L99-L101"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Condvar.wait\"><span class=\"name\">Std</span>.<span class=\"name\">Condvar</span>.<span class=\"name\">wait</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">condvar</span> : <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Waits until another thread calls `notifyOne` or `notifyAll`. ","docLink":"./Std/Sync/Mutex.html#Std.Condvar.wait","kind":"opaque","line":95,"name":"Std.Condvar.wait","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L95-L97"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Condvar.new\"><span class=\"name\">Std</span>.<span class=\"name\">Condvar</span>.<span class=\"name\">new</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a></span></div></div>","info":{"doc":"Creates a new condition variable. ","docLink":"./Std/Sync/Mutex.html#Std.Condvar.new","kind":"opaque","line":91,"name":"Std.Condvar.new","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L91-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.instNonemptyCondvar\"><span class=\"name\">Std</span>.<span class=\"name\">instNonemptyCondvar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <a href=\"./Std/Sync/Mutex.html#Std.Condvar\">Condvar</a></span></div></div>","info":{"doc":"","docLink":"./Std/Sync/Mutex.html#Std.instNonemptyCondvar","kind":"instance","line":89,"name":"Std.instNonemptyCondvar","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L89-L89"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.Condvar\"><span class=\"name\">Std</span>.<span class=\"name\">Condvar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Condition variable, a synchronization primitive to be used with a `BaseMutex` or `Mutex`.\n\nThe thread that wants to modify the shared variable must:\n1. Lock the `BaseMutex` or `Mutex`\n2. Work on the shared variable\n3. Call `Condvar.notifyOne` or `Condvar.notifyAll` after it is done. Note that this may be done\n   before or after the mutex is unlocked.\n\nIf working with a `Mutex` the thread that waits on the `Condvar` can use `Mutex.atomicallyOnce`\nto wait until a condition is true. If working with a `BaseMutex` it must:\n1. Lock the `BaseMutex`.\n2. Do one of the following:\n  - Use `Condvar.waitUntil` to (potentially repeatedly wait) on the condition variable until\n     the condition is true.\n  - Implement the waiting manually by:\n    1. Checking the condition\n    2. Calling `Condvar.wait` which releases the `BaseMutex` and suspends execution until the\n       condition variable is notified.\n    3. Check the condition and resume waiting if not satisfied.\n","docLink":"./Std/Sync/Mutex.html#Std.Condvar","kind":"def","line":66,"name":"Std.Condvar","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L66-L87"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.BaseMutex.unlock\"><span class=\"name\">Std</span>.<span class=\"name\">BaseMutex</span>.<span class=\"name\">unlock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Unlocks a `BaseMutex`.\n\nThe current thread must have already locked the mutex.\nUnlocking an unlocked mutex is undefined behavior (inherited from the C++ implementation).\nIf this is unavoidable in your code, consider using `BaseRecursiveMutex`.\n","docLink":"./Std/Sync/Mutex.html#Std.BaseMutex.unlock","kind":"opaque","line":54,"name":"Std.BaseMutex.unlock","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L54-L62"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.BaseMutex.tryLock\"><span class=\"name\">Std</span>.<span class=\"name\">BaseMutex</span>.<span class=\"name\">tryLock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Attempts to lock a `BaseMutex`. If the mutex is not available return `false`, otherwise lock it and\nreturn `true`.\n\nThis function does not block.\n\nThe current thread must not have already locked the mutex.\nReentrant locking is undefined behavior (inherited from the C++ implementation).\nIf this is unavoidable in your code, consider using `BaseRecursiveMutex`.\n","docLink":"./Std/Sync/Mutex.html#Std.BaseMutex.tryLock","kind":"opaque","line":41,"name":"Std.BaseMutex.tryLock","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L41-L52"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.BaseMutex.lock\"><span class=\"name\">Std</span>.<span class=\"name\">BaseMutex</span>.<span class=\"name\">lock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Locks a `BaseMutex`.  Waits until no other thread has locked the mutex.\n\nThe current thread must not have already locked the mutex.\nReentrant locking is undefined behavior (inherited from the C++ implementation).\nIf this is unavoidable in your code, consider using `BaseRecursiveMutex`.\n","docLink":"./Std/Sync/Mutex.html#Std.BaseMutex.lock","kind":"opaque","line":31,"name":"Std.BaseMutex.lock","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L31-L39"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.BaseMutex.new\"><span class=\"name\">Std</span>.<span class=\"name\">BaseMutex</span>.<span class=\"name\">new</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a></span></div></div>","info":{"doc":"Creates a new `BaseMutex`. ","docLink":"./Std/Sync/Mutex.html#Std.BaseMutex.new","kind":"opaque","line":27,"name":"Std.BaseMutex.new","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L27-L29"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.instNonemptyBaseMutex\"><span class=\"name\">Std</span>.<span class=\"name\">instNonemptyBaseMutex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <a href=\"./Std/Sync/Mutex.html#Std.BaseMutex\">BaseMutex</a></span></div></div>","info":{"doc":"","docLink":"./Std/Sync/Mutex.html#Std.instNonemptyBaseMutex","kind":"instance","line":25,"name":"Std.instNonemptyBaseMutex","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L25-L25"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/Mutex.html#Std.BaseMutex\"><span class=\"name\">Std</span>.<span class=\"name\">BaseMutex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Mutual exclusion primitive (a lock).\n\nIf you want to guard shared state, use `Mutex α` instead.\n","docLink":"./Std/Sync/Mutex.html#Std.BaseMutex","kind":"def","line":18,"name":"Std.BaseMutex","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Sync/Mutex.lean#L18-L23"}}],"imports":["Std.Sync.Basic","Init.While"],"instances":[{"className":"Nonempty","name":"Std.instNonemptyBaseMutex","typeNames":["Std.BaseMutex"]},{"className":"Nonempty","name":"Std.instNonemptyCondvar","typeNames":["Std.Condvar"]},{"className":"Nonempty","name":"Std.instNonemptyMutex","typeNames":["Std.Mutex"]},{"className":"CoeOut","name":"Std.instCoeOutMutexBaseMutex","typeNames":["Std.Mutex","Std.BaseMutex"]}],"name":"Std.Sync.Mutex"}