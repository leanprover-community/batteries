{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.genMatchCongrEqnsImpl\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">genMatchCongrEqnsImpl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matchDeclName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span></div></div>","info":{"doc":"Generate the congruence equations for the given match auxiliary declaration.\nThe congruence equations have a completely unrestricted left-hand side (arbitrary discriminants),\nand take propositional equations relating the discriminants to the patterns as arguments. In this\nsense they combine a congruence lemma with the regular equation lemma.\nSince the motive depends on the discriminants, they are `HEq` equations.\n\nThe code duplicates a fair bit of the logic above, and has to repeat the calculation of the\n`notAlts`. One could avoid that and generate the generalized equations eagerly above, but they are\nnot always needed, so for now we live with the code duplication.\n","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.genMatchCongrEqnsImpl","kind":"def","line":247,"name":"Lean.Meta.Match.genMatchCongrEqnsImpl","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Match/MatchEqs.lean#L247-L326"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.getEquationsForImpl\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">getEquationsForImpl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matchDeclName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Meta/Match/MatchEqsExt.html#Lean.Meta.Match.MatchEqns\">MatchEqns</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.getEquationsForImpl","kind":"def","line":141,"name":"Lean.Meta.Match.getEquationsForImpl","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Match/MatchEqs.lean#L141-L245"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.proveCondEqThm\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">proveCondEqThm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matchDeclName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqPos </span><span class=\"fn\">heqNum</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Helper method for proving a conditional equational theorem associated with an alternative of\nthe `match`-eliminator `matchDeclName`. `type` contains the type of the theorem.\n\nThe `heqPos`/`heqNum` arguments indicate that these hypotheses are `Eq`/`HEq` hypotheses\nto substitute first; this is used for the generalized match equations.\n","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.proveCondEqThm","kind":"def","line":59,"name":"Lean.Meta.Match.proveCondEqThm","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Match/MatchEqs.lean#L59-L114"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.mkAppDiscrEqs\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Match</span>.<span class=\"name\">mkAppDiscrEqs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">alt</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numDiscrEqs</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Given an application of an matcher arm `alt` that is expecting the `numDiscrEqs`, and\nan array of `discr = pattern` equalities (one for each discriminant), apply those that\nare expected by the alternative.\n","docLink":"./Lean/Meta/Match/MatchEqs.html#Lean.Meta.Match.mkAppDiscrEqs","kind":"def","line":24,"name":"Lean.Meta.Match.mkAppDiscrEqs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Match/MatchEqs.lean#L24-L41"}}],"imports":["Lean.Meta.Match.Match","Lean.Meta.Match.MatchEqsExt","Lean.Meta.Tactic.Refl","Lean.Meta.Tactic.Delta","Lean.Meta.Tactic.SplitIf","Lean.Meta.Tactic.CasesOnStuckLHS","Lean.Meta.Match.SimpH","Lean.Meta.Match.AltTelescopes","Lean.Meta.Match.NamedPatterns","Lean.Meta.SplitSparseCasesOn"],"instances":[],"name":"Lean.Meta.Match.MatchEqs"}