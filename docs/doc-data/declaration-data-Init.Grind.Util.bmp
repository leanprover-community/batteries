{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.em\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">em</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Grind/Util.html#Lean.Grind.alreadyNorm\">alreadyNorm</a> <span class=\"fn\">p</span></span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\"><a href=\"./Init/Grind/Util.html#Lean.Grind.alreadyNorm\">alreadyNorm</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">p</span></span></div></div>","info":{"doc":"`Classical.em` variant where disjuncts are marked with `alreadyNorm` gadget.\nSee comment at `alreadyNorm`\n","docLink":"./Init/Grind/Util.html#Lean.Grind.em","kind":"theorem","line":118,"name":"Lean.Grind.em","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L118-L123"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.alreadyNorm\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">alreadyNorm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"A marker to indicate that a proposition has already been normalized and should not\nbe processed again.\n\nThis prevents issues when case-splitting on the condition `c` of an if-then-else\nexpression. Without this marker, the negated condition `¬c` might be rewritten into\nan alternative form `c'`, which `grind` may not recognize as equivalent to `¬c`.\nAs a result, `grind` could fail to propagate that `if c then a else b` simplifies to `b`\nin the `¬c` branch.\n","docLink":"./Init/Grind/Util.html#Lean.Grind.alreadyNorm","kind":"def","line":105,"name":"Lean.Grind.alreadyNorm","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L105-L116"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.natCastUnexpander\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">natCastUnexpander</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.PrettyPrinter.Unexpander\">PrettyPrinter.Unexpander</a></div></div>","info":{"doc":"","docLink":"./Init/Grind/Util.html#Lean.Grind.natCastUnexpander","kind":"def","line":99,"name":"Lean.Grind.natCastUnexpander","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L99-L103"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.offsetUnexpander\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">offsetUnexpander</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.PrettyPrinter.Unexpander\">PrettyPrinter.Unexpander</a></div></div>","info":{"doc":"","docLink":"./Init/Grind/Util.html#Lean.Grind.offsetUnexpander","kind":"def","line":86,"name":"Lean.Grind.offsetUnexpander","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L86-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.eqMatchUnexpander\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">eqMatchUnexpander</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.PrettyPrinter.Unexpander\">PrettyPrinter.Unexpander</a></div></div>","info":{"doc":"","docLink":"./Init/Grind/Util.html#Lean.Grind.eqMatchUnexpander","kind":"def","line":80,"name":"Lean.Grind.eqMatchUnexpander","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L80-L84"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.matchCondUnexpander\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">matchCondUnexpander</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.PrettyPrinter.Unexpander\">PrettyPrinter.Unexpander</a></div></div>","info":{"doc":"","docLink":"./Init/Grind/Util.html#Lean.Grind.matchCondUnexpander","kind":"def","line":74,"name":"Lean.Grind.matchCondUnexpander","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L74-L78"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.nestedProofUnexpander\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">nestedProofUnexpander</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.PrettyPrinter.Unexpander\">PrettyPrinter.Unexpander</a></div></div>","info":{"doc":"","docLink":"./Init/Grind/Util.html#Lean.Grind.nestedProofUnexpander","kind":"def","line":68,"name":"Lean.Grind.nestedProofUnexpander","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L68-L72"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.nestedDecidable_congr\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">nestedDecidable_congr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">q</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hp</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hq</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Grind/Util.html#Lean.Grind.nestedDecidable\">nestedDecidable</a> <span class=\"fn\">hp</span></span> <a href=\"./Init/Prelude.html#HEq\">≍</a> <span class=\"fn\"><a href=\"./Init/Grind/Util.html#Lean.Grind.nestedDecidable\">nestedDecidable</a> <span class=\"fn\">hq</span></span></div></div>","info":{"doc":"","docLink":"./Init/Grind/Util.html#Lean.Grind.nestedDecidable_congr","kind":"theorem","line":65,"name":"Lean.Grind.nestedDecidable_congr","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L65-L66"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.nestedProof_congr\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">nestedProof_congr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">q</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hp</span> : <span class=\"fn\">p</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hq</span> : <span class=\"fn\">q</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">⋯</span> <a href=\"./Init/Prelude.html#HEq\">≍</a> <span class=\"fn\">⋯</span></div></div>","info":{"doc":"","docLink":"./Init/Grind/Util.html#Lean.Grind.nestedProof_congr","kind":"theorem","line":62,"name":"Lean.Grind.nestedProof_congr","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L62-L63"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.PreMatchCond\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">PreMatchCond</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Similar to `MatchCond`, but not reducible. We use it to ensure `simp`\nwill not eliminate it. After we apply `simp`, we replace it with `MatchCond`.\n","docLink":"./Init/Grind/Util.html#Lean.Grind.PreMatchCond","kind":"def","line":56,"name":"Lean.Grind.PreMatchCond","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L56-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.MatchCond\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">MatchCond</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Gadget for annotating conditions of `match` equational lemmas.\nWe use this annotation for two different reasons:\n- We don't want to normalize them.\n- We have a propagator for them.\n","docLink":"./Init/Grind/Util.html#Lean.Grind.MatchCond","kind":"def","line":48,"name":"Lean.Grind.MatchCond","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L48-L54"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.EqMatch\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">EqMatch</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">_origin</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Gadget for annotating the equalities in `match`-equations conclusions.\n`_origin` is the term used to instantiate the `match`-equation using E-matching.\nWhen `EqMatch a b origin` is `True`, we mark `origin` as a resolved case-split.\n","docLink":"./Init/Grind/Util.html#Lean.Grind.EqMatch","kind":"def","line":41,"name":"Lean.Grind.EqMatch","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L41-L46"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.eqBwdPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">eqBwdPattern</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Gadget for representing `a = b` in patterns for backward propagation. ","docLink":"./Init/Grind/Util.html#Lean.Grind.eqBwdPattern","kind":"def","line":38,"name":"Lean.Grind.eqBwdPattern","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L38-L39"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.offset\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">offset</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"Gadget for representing offsets `t+k` in patterns. ","docLink":"./Init/Grind/Util.html#Lean.Grind.offset","kind":"def","line":35,"name":"Lean.Grind.offset","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L35-L36"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.simpMatchDiscrsOnly\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">simpMatchDiscrsOnly</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"Gadget for marking `match`-expressions that should not be reduced by the `grind` simplifier, but the discriminants should be normalized.\nWe use it when adding instances of `match`-equations to prevent them from being simplified to true.\n\nRemark: it must not be marked as `[reducible]`. Otherwise, `simp` will reduce\n```\nsimpMatchDiscrsOnly (match 0 with | 0 => true | _ => false) = true\n```\nusing `eq_self`.\n","docLink":"./Init/Grind/Util.html#Lean.Grind.simpMatchDiscrsOnly","kind":"def","line":23,"name":"Lean.Grind.simpMatchDiscrsOnly","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L23-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.nestedDecidable\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">nestedDecidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Prop</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">p</span></span></div></div>","info":{"doc":"A helper gadget for annotating nested decidable instances in goals. ","docLink":"./Init/Grind/Util.html#Lean.Grind.nestedDecidable","kind":"def","line":18,"name":"Lean.Grind.nestedDecidable","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L18-L21"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Util.html#Lean.Grind.nestedProof\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">nestedProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">h</span> : <span class=\"fn\">p</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">p</span></div></div>","info":{"doc":"A helper gadget for annotating nested proofs in goals. ","docLink":"./Init/Grind/Util.html#Lean.Grind.nestedProof","kind":"def","line":15,"name":"Lean.Grind.nestedProof","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Grind/Util.lean#L15-L16"}}],"imports":["Init.Classical"],"instances":[],"name":"Init.Grind.Util"}