{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRename\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalRename</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Tactic</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRename","kind":"def","line":347,"name":"Lean.Elab.Tactic.evalRename","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L347-L362"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabAsFVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabAsFVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">userName?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span></div></div>","info":{"doc":"Elaborate `stx`. If it is a free variable, return it. Otherwise, assert it, and return the free variable.\nNote that, the main goal is updated when `Meta.assert` is used in the second case. ","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabAsFVar","kind":"def","line":326,"name":"Lean.Elab.Tactic.elabAsFVar","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L326-L345"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithUnfoldingNone\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalWithUnfoldingNone</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Tactic</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithUnfoldingNone","kind":"def","line":323,"name":"Lean.Elab.Tactic.evalWithUnfoldingNone","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L323-L324"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithUnfoldingAll\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalWithUnfoldingAll</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Tactic</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithUnfoldingAll","kind":"def","line":320,"name":"Lean.Elab.Tactic.evalWithUnfoldingAll","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L320-L321"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithReducibleAndInstances\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalWithReducibleAndInstances</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Tactic</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithReducibleAndInstances","kind":"def","line":317,"name":"Lean.Elab.Tactic.evalWithReducibleAndInstances","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L317-L318"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithReducible\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalWithReducible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Tactic</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithReducible","kind":"def","line":314,"name":"Lean.Elab.Tactic.evalWithReducible","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L314-L315"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalConstructor\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalConstructor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Tactic</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalConstructor","kind":"def","line":308,"name":"Lean.Elab.Tactic.evalConstructor","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L308-L312"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalApply\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalApply</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Tactic</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalApply","kind":"def","line":303,"name":"Lean.Elab.Tactic.evalApply","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L303-L306"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalApplyLikeTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalApplyLikeTactic</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalApplyLikeTactic","kind":"def","line":283,"name":"Lean.Elab.Tactic.evalApplyLikeTactic","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L283-L301"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.getFVarIds\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getFVarIds</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ids</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.getFVarIds","kind":"def","line":280,"name":"Lean.Elab.Tactic.getFVarIds","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L280-L281"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.getFVarId\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getFVarId</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">id</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.getFVarId","kind":"def","line":273,"name":"Lean.Elab.Tactic.getFVarId","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L273-L278"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermForApply\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabTermForApply</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mayPostpone</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Given a tactic\n```\napply f\n```\nwe want the `apply` tactic to create all metavariables. The following\ndefinition will return `@f` for `f`. That is, it will **not** create\nmetavariables for implicit arguments.\nA similar method is also used in Lean 3.\nThis method is useful when applying lemmas such as:\n```\ntheorem infLeRight {s t : Set α} : s ⊓ t ≤ t\n```\nwhere `s ≤ t` here is defined as\n```\n∀ {x : α}, x ∈ s → x ∈ t\n```\n","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermForApply","kind":"def","line":248,"name":"Lean.Elab.Tactic.elabTermForApply","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L248-L271"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalSpecialize\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalSpecialize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Tactic</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalSpecialize","kind":"def","line":233,"name":"Lean.Elab.Tactic.evalSpecialize","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L233-L246"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRefine'\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalRefine'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Tactic</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRefine'","kind":"def","line":228,"name":"Lean.Elab.Tactic.evalRefine'","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L228-L231"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRefine\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalRefine</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Tactic</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRefine","kind":"def","line":223,"name":"Lean.Elab.Tactic.evalRefine","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L223-L226"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.refineCore\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">refineCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tagSuffix</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowNaturalHoles</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"If `allowNaturalHoles == true`, then we allow the resultant expression to contain unassigned \"natural\" metavariables.\nRecall that \"natural\" metavariables are created for explicit holes `_` and implicit arguments. They are meant to be\nfilled by typing constraints.\n\"Synthetic\" metavariables are meant to be filled by tactics and are usually created using the synthetic hole notation `?<hole-name>`. ","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.refineCore","kind":"def","line":201,"name":"Lean.Elab.Tactic.refineCore","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L201-L221"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermWithHoles\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabTermWithHoles</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expectedType?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tagSuffix</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowNaturalHoles</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parentTag?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span>)</span></div></div>","info":{"doc":"Elaborates `stx` and collects the `MVarId`s of any holes that were created during elaboration.\n\nWith `allowNaturalHoles := false` (the default), any new natural holes (`_`) which cannot\nbe synthesized during elaboration cause `elabTermWithHoles` to fail. (Natural goals appearing in\n`stx` which were created prior to elaboration are permitted.)\n\nUnnamed `MVarId`s are renamed to share the tag `parentTag?` (or the main goal's tag if `parentTag?` is `none`).\nIf multiple unnamed goals are encountered, `tagSuffix` is appended to this tag along with a numerical index.\n\nNote:\n* Previously-created `MVarId`s which appear in `stx` are not returned.\n* All parts of `elabTermWithHoles` operate at the current `MCtxDepth`, and therefore may assign\nmetavariables.\n* When `allowNaturalHoles := true`, `stx` is elaborated under `withAssignableSyntheticOpaque`,\nmeaning that `.syntheticOpaque` metavariables might be assigned during elaboration. This is a\nconsequence of the implementation. ","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermWithHoles","kind":"def","line":182,"name":"Lean.Elab.Tactic.elabTermWithHoles","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L182-L199"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.withCollectingNewGoalsFrom\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">withCollectingNewGoalsFrom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parentTag </span><span class=\"fn\">tagSuffix</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">allowNaturalHoles</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span>)</span></div></div>","info":{"doc":"Execute `k`, and collect new \"holes\" in the resulting expression.\n\n* `parentTag` and `tagSuffix` are used to tag untagged goals with `Lean.Elab.Tactic.tagUntaggedGoals`.\n* If `allowNaturalHoles` is true, then `_`'s are allowed and create new goals.\n","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.withCollectingNewGoalsFrom","kind":"def","line":134,"name":"Lean.Elab.Tactic.withCollectingNewGoalsFrom","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L134-L180"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.collectFreshMVars\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">collectFreshMVars</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span>)</span></div></div>","info":{"doc":"Execute `k`, and collect any fresh metavariables created during the execution of `k`.\n","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.collectFreshMVars","kind":"def","line":116,"name":"Lean.Elab.Tactic.collectFreshMVars","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L116-L132"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.sortMVarIdsByIndex\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sortMVarIdsByIndex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/MetavarContext.html#Lean.MonadMCtx\">MonadMCtx</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarIds</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.sortMVarIdsByIndex","kind":"def","line":113,"name":"Lean.Elab.Tactic.sortMVarIdsByIndex","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L113-L114"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.sortMVarIdArrayByIndex\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sortMVarIdArrayByIndex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/MetavarContext.html#Lean.MonadMCtx\">MonadMCtx</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarIds</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.sortMVarIdArrayByIndex","kind":"def","line":103,"name":"Lean.Elab.Tactic.sortMVarIdArrayByIndex","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L103-L111"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalExact\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalExact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Tactic</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalExact","kind":"def","line":98,"name":"Lean.Elab.Tactic.evalExact","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L98-L101"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.closeMainGoalUsing\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">closeMainGoalUsing</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tacName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Name</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">checkNewUnassigned</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Try to close main goal using `x target tag`, where `target` is the type of the main goal and `tag` is its user name.\n\nIf `checkNewUnassigned` is true, then throws an error if the resulting value has metavariables that were created during the execution of `x`.\nIf it is false, then it is the responsibility of `x` to add such metavariables to the goal list.\n\nDuring the execution of `x`:\n* The local context is that of the main goal.\n* The goal list has the main goal removed.\n* It is allowable to modify the goal list, for example with `Lean.Elab.Tactic.pushGoals`.\n\nOn failure, the main goal remains at the front of the goal list.\n","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.closeMainGoalUsing","kind":"def","line":70,"name":"Lean.Elab.Tactic.closeMainGoalUsing","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L70-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.filterOldMVars\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">filterOldMVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarIds</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarCounterSaved</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.filterOldMVars","kind":"def","line":66,"name":"Lean.Elab.Tactic.filterOldMVars","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L66-L68"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.logUnassignedAndAbort\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">logUnassignedAndAbort</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarIds</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.logUnassignedAndAbort","kind":"def","line":62,"name":"Lean.Elab.Tactic.logUnassignedAndAbort","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L62-L64"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermEnsuringType\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabTermEnsuringType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expectedType?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mayPostpone</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Elaborate `stx` in the current `MVarContext`. If given, the `expectedType` will be used to help\nelaboration and then a `TypeMismatchError` will be thrown if the elaborated type doesn't match.  ","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermEnsuringType","kind":"def","line":47,"name":"Lean.Elab.Tactic.elabTermEnsuringType","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L47-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTerm\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabTerm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expectedType?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mayPostpone</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Elaborate `stx` in the current `MVarContext`. If given, the `expectedType` will be used to help\nelaboration but not enforced (use `elabTermEnsuringType` to enforce an expected type). ","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTerm","kind":"def","line":41,"name":"Lean.Elab.Tactic.elabTerm","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L41-L45"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.runTermElab\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">runTermElab</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mayPostpone</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">TacticM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Runs a term elaborator inside a tactic, finalizing elaboration with `Term.synthesizeSyntheticMVars`.\n- `mayPostpone` controls the postponement behavior of `Term.synthesizeSyntheticMVars`.\n\nThis function ensures that term elaboration fails when backtracking,\ni.e., in `first| tac term | other`.\n","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.runTermElab","kind":"def","line":22,"name":"Lean.Elab.Tactic.runTermElab","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Elab/Tactic/ElabTerm.lean#L22-L39"}}],"imports":["Lean.Meta.Tactic.Constructor","Lean.Meta.Tactic.Assert","Lean.Meta.Tactic.Cleanup","Lean.Meta.Tactic.Rename","Lean.Elab.Tactic.Config"],"instances":[],"name":"Lean.Elab.Tactic.ElabTerm"}