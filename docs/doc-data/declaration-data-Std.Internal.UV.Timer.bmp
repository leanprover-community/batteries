{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer.cancel\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">Timer</span>.<span class=\"name\">cancel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">timer</span> : <a href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer\">Timer</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"This function has different behavior depending on the state of the `Timer`:\n- If it is initial or finished this is a no-op.\n- If it is running, the promise generated by the `next` function is dropped.\n  - If `repeating` is `false` then it sets the timer to the initial state.\n","docLink":"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer.cancel","kind":"opaque","line":86,"name":"Std.Internal.UV.Timer.cancel","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Internal/UV/Timer.lean#L86-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer.stop\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">Timer</span>.<span class=\"name\">stop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">timer</span> : <a href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer\">Timer</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"This function has different behavior depending on the state of the `Timer`:\n- If it is initial or finished this is a no-op.\n- If it is running the execution of the timer is stopped, it is put into the finished state and the\n  promise generated by the `next` function is dropped.\n","docLink":"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer.stop","kind":"opaque","line":77,"name":"Std.Internal.UV.Timer.stop","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Internal/UV/Timer.lean#L77-L84"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer.reset\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">Timer</span>.<span class=\"name\">reset</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">timer</span> : <a href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer\">Timer</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"This function has different behavior depending on the state and configuration of the `Timer`:\n- If it is initial or finished this is a no-op.\n- If it is running and `repeating` is `false` this will delay the resolution of the timer until\n  `timeout` milliseconds after the call of this function.\n- Delay the resolution of the next tick of the timer until `timeout` milliseconds after the\n  call of this function, then continue normal ticking behavior from there.\n","docLink":"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer.reset","kind":"opaque","line":66,"name":"Std.Internal.UV.Timer.reset","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Internal/UV/Timer.lean#L66-L75"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer.next\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">Timer</span>.<span class=\"name\">next</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">timer</span> : <a href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer\">Timer</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <span class=\"fn\">(<a href=\"./Init/System/Promise.html#IO.Promise\">IO.Promise</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a>)</span></span></div></div>","info":{"doc":"This function has different behavior depending on the state and configuration of the `Timer`:\n- if `repeating` is `false` and:\n  - it is initial, run it and return a new `IO.Promise` that is set to resolve once `timeout`\n    milliseconds have elapsed. After this `IO.Promise` is resolved the `Timer` is finished.\n  - it is running or finished, return the same `IO.Promise` that the first call to `next` returned.\n- if `repeating` is `true` and:\n  - it is initial, run it and return a new `IO.Promise` that resolves right away\n    (as it is the 0th multiple of `timeout`).\n  - it is running, check whether the last returned `IO.Promise` is already resolved:\n     - If it is, return a new `IO.Promise` that resolves upon finishing the next cycle\n     - If it is not, return the last `IO.Promise`\n     This ensures that the returned `IO.Promise` resolves at the next repetition of the timer.\n  - if it is finished, return the last `IO.Promise` created by `next`. Notably this could be one\n    that never resolves if the timer was stopped before fulfilling the last one.\n","docLink":"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer.next","kind":"opaque","line":47,"name":"Std.Internal.UV.Timer.next","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Internal/UV/Timer.lean#L47-L64"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">Timer</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">timeout</span> : <a href=\"./Init/Prelude.html#UInt64\">UInt64</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">repeating</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer\">Timer</a></span></div></div>","info":{"doc":"This creates a `Timer` in the initial state and doesn't run it yet.\n- If `repeating` is `false` this constructs a timer that resolves once after `timeout`\n  milliseconds, counting from when it's run.\n- If `repeating` is `true` this constructs a timer that resolves after multiples of `timeout`\n  milliseconds, counting from when it's run. Note that this includes the 0th multiple right after\n  starting the timer. Furthermore a repeating timer will only be freed after `Timer.stop` is called.\n","docLink":"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer.mk","kind":"opaque","line":36,"name":"Std.Internal.UV.Timer.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Internal/UV/Timer.lean#L36-L45"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.instNonemptyTimer\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">instNonemptyTimer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <a href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer\">Timer</a></span></div></div>","info":{"doc":"","docLink":"./Std/Internal/UV/Timer.html#Std.Internal.UV.instNonemptyTimer","kind":"instance","line":32,"name":"Std.Internal.UV.instNonemptyTimer","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Internal/UV/Timer.lean#L32-L32"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">Timer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"`Timer`s are used to generate `IO.Promise`s that resolve after some time.\n\nA `Timer` can be in one of 3 states:\n- Right after construction it's initial.\n- While it is ticking it's running.\n- If it has stopped for some reason it's finished.\n\nThis together with whether it was set up as `repeating` with `Timer.new` determines the behavior\nof all functions on `Timer`s.\n","docLink":"./Std/Internal/UV/Timer.html#Std.Internal.UV.Timer","kind":"def","line":19,"name":"Std.Internal.UV.Timer","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Std/Internal/UV/Timer.lean#L19-L30"}}],"imports":["Init.System.Promise"],"instances":[{"className":"Nonempty","name":"Std.Internal.UV.instNonemptyTimer","typeNames":["Std.Internal.UV.Timer"]}],"name":"Std.Internal.UV.Timer"}