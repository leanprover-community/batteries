{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.simpAppArgRange\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">Simp</span>.<span class=\"name\">simpAppArgRange</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">start </span><span class=\"fn\">stop</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM\">SimpM</a> <a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result\">Result</a></span></div></div>","info":{"doc":"Simplifies arguments in a specified range `[start, stop)` of a function application.\n\nGiven an expression `f a₀ a₁ ... aₙ`, this function simplifies only the arguments\nat positions `start ≤ i < stop`, leaving arguments outside this range unchanged.\nChanges are propagated using congruence lemmas.\n\n**Use case**: Useful for control-flow simplification where we want to simplify only\ndiscriminants of a `match` expression without touching the branches.\n","docLink":"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.simpAppArgRange","kind":"def","line":441,"name":"Lean.Meta.Sym.Simp.simpAppArgRange","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/App.lean#L441-L478"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.simpAppArgs\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">Simp</span>.<span class=\"name\">simpAppArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM\">SimpM</a> <a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result\">Result</a></span></div></div>","info":{"doc":"Main entry point for simplifying function application arguments.\nDispatches to the appropriate strategy based on the function's `CongrInfo`.\n","docLink":"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.simpAppArgs","kind":"def","line":429,"name":"Lean.Meta.Sym.Simp.simpAppArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/App.lean#L429-L439"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.simpInterlaced\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">Simp</span>.<span class=\"name\">simpInterlaced</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rewritable</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM\">SimpM</a> <a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result\">Result</a></span></div></div>","info":{"doc":"Simplifies arguments of a function application with interlaced rewritable/fixed arguments.\nUses `rewritable[i]` to determine whether argument `i` should be simplified.\nFor rewritable arguments, calls `simp` and uses `congrFun'`, `congrArg`, and `congr`; for fixed arguments,\nuses `congrFun` to propagate changes from earlier arguments.\n","docLink":"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.simpInterlaced","kind":"def","line":270,"name":"Lean.Meta.Sym.Simp.simpInterlaced","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/App.lean#L270-L298"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.simpFixedPrefix\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">Simp</span>.<span class=\"name\">simpFixedPrefix</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prefixSize </span><span class=\"fn\">suffixSize</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM\">SimpM</a> <a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result\">Result</a></span></div></div>","info":{"doc":"Simplifies arguments of a function application with a fixed prefix structure.\nRecursively simplifies the trailing `suffixSize` arguments, leaving the first\n`prefixSize` arguments unchanged.\n\nFor a function with `CongrInfo.fixedPrefix prefixSize suffixSize`, the arguments\nare structured as:\n```\nf a₁ ... aₚ b₁ ... bₛ\n  └───────┘ └───────┘\n   prefix    suffix (rewritable)\n```\n\nThe prefix arguments (types, instances) should\nnot be rewritten directly. Only the suffix arguments are recursively simplified.\n\n**Performance optimization**: We avoid calling `inferType` on applied expressions\nlike `f a₁ ... aₚ b₁` or `f a₁ ... aₚ b₁ ... bₛ`, which would have poor cache hit rates.\nInstead, we infer the type of the function prefix `f a₁ ... aₚ`\n(e.g., `@HAdd.hAdd Nat Nat Nat instAdd`) which is probably shared across many applications,\nthen traverse the forall telescope to extract argument and result types as needed.\n\nThe helper `go` returns `Result × Expr` where the `Expr` is the function type at that\nposition. However, the type is only meaningful (non-`default`) when `Result` is\n`.step`, since we only need types for constructing congruence proofs. This avoids\nunnecessary type inference when no rewriting occurs.\n","docLink":"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.simpFixedPrefix","kind":"def","line":199,"name":"Lean.Meta.Sym.Simp.simpFixedPrefix","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/App.lean#L199-L268"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.propagateOverApplied\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">Simp</span>.<span class=\"name\">propagateOverApplied</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numArgs</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">simpFn</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM\">SimpM</a> <a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result\">Result</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM\">SimpM</a> <a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result\">Result</a></span></div></div>","info":{"doc":"Handles over-applied function expressions by simplifying only the base function and\npropagating changes through extra arguments WITHOUT simplifying them.\n\nUnlike `simpOverApplied`, this function does not simplify the extra arguments themselves.\nIt only uses congruence (`mkCongrFun`) to propagate changes when the base function is simplified.\n\n**Algorithm**:\n1. Peel off `numArgs` extra arguments from `e`\n2. Apply `simpFn` to simplify the base function\n3. If the base changed, propagate the change through each extra argument using `mkCongrFun`\n4. Return `.rfl` if the base function was not simplified\n\n**Parameters**:\n- `e`: The over-applied expression\n- `numArgs`: Number of excess arguments to peel off\n- `simpFn`: Strategy for simplifying the base function after peeling\n\n**Contrast with `simpOverApplied`**:\n- `simpOverApplied`: Fully simplifies both base and extra arguments\n- `propagateOverApplied`: Only simplifies base, appends extra arguments unchanged\n","docLink":"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.propagateOverApplied","kind":"def","line":131,"name":"Lean.Meta.Sym.Simp.propagateOverApplied","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/App.lean#L131-L166"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.simpOverApplied\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">Simp</span>.<span class=\"name\">simpOverApplied</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numArgs</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">simpFn</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM\">SimpM</a> <a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result\">Result</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.SimpM\">SimpM</a> <a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result\">Result</a></span></div></div>","info":{"doc":"Handles simplification of over-applied function terms.\n\nWhen a function has more arguments than expected by its `CongrInfo`, we need to handle\nthe \"extra\" arguments separately. This function peels off `numArgs` trailing applications,\nsimplifies the remaining function using `simpFn`, then rebuilds the term by simplifying\nand re-applying the trailing arguments.\n\n**Over-application** occurs when:\n- A function with `fixedPrefix prefixSize suffixSize` is applied to more than `prefixSize + suffixSize` arguments\n- A function with `interlaced` rewritable mask is applied to more than `mask.size` arguments\n- A function with a congruence theorem is applied to more than the theorem expects\n\n**Example**: If `f` has `CongrInfo.fixedPrefix 2 3` (expects 5 arguments) but we see `f a₁ a₂ a₃ a₄ a₅ b₁ b₂`,\nthen `numArgs = 2` (the extra arguments) and we:\n1. Recursively simplify `f a₁ a₂ a₃ a₄ a₅` using the fixed prefix strategy (via `simpFn`)\n2. Simplify each extra argument `b₁` and `b₂`\n3. Rebuild the term using either `mkCongr` (for non-dependent arrows) or `mkCongrFun` (for dependent functions)\n\n**Parameters**:\n- `e`: The over-applied expression to simplify\n- `numArgs`: Number of excess arguments to peel off\n- `simpFn`: Strategy for simplifying the function after peeling (e.g., `simpFixedPrefix`, `simpInterlaced`, or `simpUsingCongrThm`)\n\n**Note**: This is a fallback path without specialized optimizations. The common case (correct number of arguments)\nis handled more efficiently by the specific strategies.\n","docLink":"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.simpOverApplied","kind":"def","line":83,"name":"Lean.Meta.Sym.Simp.simpOverApplied","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/App.lean#L83-L129"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.mkCongr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Sym</span>.<span class=\"name\">Simp</span>.<span class=\"name\">mkCongr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">f </span><span class=\"fn\">a</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fr </span><span class=\"fn\">ar</span> : <a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result\">Result</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.<a href=\"./Lean/Expr.html#Lean.Expr.app\">app</a></span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Sym/SymM.html#Lean.Meta.Sym.SymM\">SymM</a> <a href=\"./Lean/Meta/Sym/Simp/SimpM.html#Lean.Meta.Sym.Simp.Result\">Result</a></span></span></div></div>","info":{"doc":"Helper function for constructing a congruence proof using `congrFun'`, `congrArg`, `congr`.\nFor the dependent case, use `mkCongrFun`\n","docLink":"./Lean/Meta/Sym/Simp/App.html#Lean.Meta.Sym.Simp.mkCongr","kind":"def","line":40,"name":"Lean.Meta.Sym.Simp.mkCongr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Sym/Simp/App.lean#L40-L64"}}],"imports":["Lean.Meta.Sym.Simp.SimpM","Lean.Meta.Tactic.Simp.Types","Lean.Meta.Sym.AlphaShareBuilder","Lean.Meta.Sym.InferType","Lean.Meta.Sym.Simp.CongrInfo","Init.Omega"],"instances":[],"name":"Lean.Meta.Sym.Simp.App"}