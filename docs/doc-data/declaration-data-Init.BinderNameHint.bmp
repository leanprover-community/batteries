{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/BinderNameHint.html#binderNameHint\"><span class=\"name\">binderNameHint</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Sort</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">γ</span> : <a href=\"./foundational_types.html\">Sort</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">v</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">binder</span> : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">γ</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">γ</span></div></div>","info":{"doc":"The expression `binderNameHint v binder e` defined to be `e`.\n\nIf it is used on the right-hand side of an equation that is used for rewriting by `rw` or `simp`,\nand `v` is a local variable, and `binder` is an expression that (after beta-reduction) is a binder\n(`fun w => …` or `∀ w, …`), then it will rename `v` to the name used in that binder, and remove\nthe `binderNameHint`.\n\nA typical use of this gadget would be as follows; the gadget ensures that after rewriting, the local\nvariable is still `name`, and not `x`:\n```\ntheorem all_eq_not_any_not (l : List α) (p : α → Bool) :\n    l.all p = !l.any fun x => binderNameHint x p (!p x) := sorry\n\nexample (names : List String) : names.all (fun name => \"Waldo\".isPrefixOf name) = true := by\n  rw [all_eq_not_any_not]\n  -- ⊢ (!names.any fun name => !\"Waldo\".isPrefixOf name) = true\n```\n\nIf `binder` is not a binder, then the name of `v` attains a macro scope. This only matters when the\nresulting term is used in a non-hygienic way, e.g. in termination proofs for well-founded recursion.\n\nThis gadget is supported by\n* `simp`, `dsimp` and `rw` in the right-hand-side of an equation\n* `simp` in the assumptions of congruence rules\n\nIt is ineffective in other positions (hypotheses of rewrite rules) or when used by other tactics\n(e.g. `apply`).\n","docLink":"./Init/BinderNameHint.html#binderNameHint","kind":"def","line":15,"name":"binderNameHint","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/BinderNameHint.lean#L15-L45"}}],"imports":["Init.Tactics"],"instances":[],"name":"Init.BinderNameHint"}