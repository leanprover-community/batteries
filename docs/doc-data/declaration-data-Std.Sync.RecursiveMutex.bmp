{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.tryAtomically\"><span class=\"name\">Std</span>.<span class=\"name\">RecursiveMutex</span>.<span class=\"name\">tryAtomically</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Except.html#MonadFinally\">MonadFinally</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <span class=\"fn\"><a href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\">RecursiveMutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Std/Sync/Basic.html#Std.AtomicT\">AtomicT</a> <span class=\"fn\">α</span> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">β</span>)</span></span></div></div>","info":{"doc":"`mutex.tryAtomically k` tries to lock `mutex` and runs `k` on it if it succeeds. On success the\nreturn value of `k` is returned as `some`, on failure `none` is returned.\n\nThis function does not block on the `mutex`. Additionally `mutex.tryAtomically`, while already\nholding the underlying `BaseRecursiveMutex` in the same thread, does not block.\n","docLink":"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.tryAtomically","kind":"def","line":89,"name":"Std.RecursiveMutex.tryAtomically","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L89-L104"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.atomically\"><span class=\"name\">Std</span>.<span class=\"name\">RecursiveMutex</span>.<span class=\"name\">atomically</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Except.html#MonadFinally\">MonadFinally</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <span class=\"fn\"><a href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\">RecursiveMutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\"><a href=\"./Std/Sync/Basic.html#Std.AtomicT\">AtomicT</a> <span class=\"fn\">α</span> <span class=\"fn\">m</span> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>","info":{"doc":"`mutex.atomically k` runs `k` with access to the mutex's state while locking the mutex.\n\nCalling `mutex.atomically` while already holding the underlying `BaseRecursiveMutex` in the same\nthread does not block.\n","docLink":"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.atomically","kind":"def","line":75,"name":"Std.RecursiveMutex.atomically","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L75-L87"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.new\"><span class=\"name\">Std</span>.<span class=\"name\">RecursiveMutex</span>.<span class=\"name\">new</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <span class=\"fn\">(<a href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\">RecursiveMutex</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"Creates a new recursive mutex. ","docLink":"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.new","kind":"def","line":71,"name":"Std.RecursiveMutex.new","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L71-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.instCoeOutRecursiveMutexBaseRecursiveMutex\"><span class=\"name\">Std</span>.<span class=\"name\">instCoeOutRecursiveMutexBaseRecursiveMutex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#CoeOut\">CoeOut</a> <span class=\"fn\">(<a href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\">RecursiveMutex</a> <span class=\"fn\">α</span>)</span> <a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a></span></div></div>","info":{"doc":"","docLink":"./Std/Sync/RecursiveMutex.html#Std.instCoeOutRecursiveMutexBaseRecursiveMutex","kind":"instance","line":69,"name":"Std.instCoeOutRecursiveMutexBaseRecursiveMutex","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L69-L69"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.instNonemptyRecursiveMutex\"><span class=\"name\">Std</span>.<span class=\"name\">instNonemptyRecursiveMutex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α✝</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">α✝</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<a href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\">RecursiveMutex</a> <span class=\"fn\">α✝</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Std/Sync/RecursiveMutex.html#Std.instNonemptyRecursiveMutex","kind":"instance","line":67,"name":"Std.instNonemptyRecursiveMutex","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L67-L67"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.mutex\"><span class=\"name\">Std</span>.<span class=\"name\">RecursiveMutex</span>.<span class=\"name\">mutex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\">RecursiveMutex</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a></div></div>","info":{"doc":"","docLink":"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex.mutex","kind":"def","line":66,"name":"Std.RecursiveMutex.mutex","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L66-L66"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex\"><span class=\"name\">Std</span>.<span class=\"name\">RecursiveMutex</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Recursive (or reentrant) mutual exclusion primitive (lock) guarding shared state of type `α`.\n\nThe type `RecursiveMutex α` is similar to `IO.Ref α`, except that concurrent accesses are guarded\nby a mutex instead of atomic pointer operations and busy-waiting. Additionally locking a\n`RecursiveMutex` multiple times from the same thread does not block, unlike `Mutex`.\n","docLink":"./Std/Sync/RecursiveMutex.html#Std.RecursiveMutex","kind":"structure","line":57,"name":"Std.RecursiveMutex","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L57-L67"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.unlock\"><span class=\"name\">Std</span>.<span class=\"name\">BaseRecursiveMutex</span>.<span class=\"name\">unlock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Unlocks a `BaseRecursiveMutex`. The owning thread must make as many `unlock` calls as `lock` and\n`tryLock` calls in order to fully relinquish ownership of the mutex.\n\nThe current thread must have already locked the mutex at least once.\nUnlocking an unlocked mutex is undefined behavior (inherited from the C++ implementation).\n","docLink":"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.unlock","kind":"opaque","line":47,"name":"Std.BaseRecursiveMutex.unlock","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L47-L55"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.tryLock\"><span class=\"name\">Std</span>.<span class=\"name\">BaseRecursiveMutex</span>.<span class=\"name\">tryLock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Attempts to lock a `BaseRecursiveMutex`. If the mutex is not available return `false`, otherwise\nlock it and return `true`.\n\nThis function does not block. Furthermore the same thread may acquire the lock multiple times\nthrough this function.\n","docLink":"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.tryLock","kind":"opaque","line":37,"name":"Std.BaseRecursiveMutex.tryLock","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L37-L45"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.lock\"><span class=\"name\">Std</span>.<span class=\"name\">BaseRecursiveMutex</span>.<span class=\"name\">lock</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mutex</span> : <a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Locks a `BaseRecursiveMutex`. Waits until no other thread has locked the mutex.\nIf the current thread already holds the mutex this function doesn't block.\n","docLink":"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.lock","kind":"opaque","line":30,"name":"Std.BaseRecursiveMutex.lock","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L30-L35"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.new\"><span class=\"name\">Std</span>.<span class=\"name\">BaseRecursiveMutex</span>.<span class=\"name\">new</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#BaseIO\">BaseIO</a> <a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a></span></div></div>","info":{"doc":"Creates a new `BaseRecursiveMutex`. ","docLink":"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex.new","kind":"opaque","line":26,"name":"Std.BaseRecursiveMutex.new","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L26-L28"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.instNonemptyBaseRecursiveMutex\"><span class=\"name\">Std</span>.<span class=\"name\">instNonemptyBaseRecursiveMutex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <a href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\">BaseRecursiveMutex</a></span></div></div>","info":{"doc":"","docLink":"./Std/Sync/RecursiveMutex.html#Std.instNonemptyBaseRecursiveMutex","kind":"instance","line":24,"name":"Std.instNonemptyBaseRecursiveMutex","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L24-L24"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex\"><span class=\"name\">Std</span>.<span class=\"name\">BaseRecursiveMutex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Recursive (or reentrant) exclusion primitive.\n\nIf you want to guard shared state, use `RecursiveMutex α` instead.\n","docLink":"./Std/Sync/RecursiveMutex.html#Std.BaseRecursiveMutex","kind":"def","line":17,"name":"Std.BaseRecursiveMutex","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Sync/RecursiveMutex.lean#L17-L22"}}],"imports":["Std.Sync.Basic"],"instances":[{"className":"Nonempty","name":"Std.instNonemptyBaseRecursiveMutex","typeNames":["Std.BaseRecursiveMutex"]},{"className":"Nonempty","name":"Std.instNonemptyRecursiveMutex","typeNames":["Std.RecursiveMutex"]},{"className":"CoeOut","name":"Std.instCoeOutRecursiveMutexBaseRecursiveMutex","typeNames":["Std.RecursiveMutex","Std.BaseRecursiveMutex"]}],"name":"Std.Sync.RecursiveMutex"}