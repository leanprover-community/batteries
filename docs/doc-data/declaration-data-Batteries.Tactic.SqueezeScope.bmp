{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/SqueezeScope.html#Batteries.Tactic.squeezeScopes\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">squeezeScopes</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <span class=\"fn\">(<a href=\"./Lean/Data/NameMap/Basic.html#Lean.NameMap\">Lean.NameMap</a> <span class=\"fn\">(<a href=\"./Lean/Data/NameMap/Basic.html#Lean.NameMap\">Lean.NameMap</a> (<a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.UsedSimps\">Lean.Meta.Simp.UsedSimps</a></span>))</span>)</span></span></div></div>","info":{"doc":"We implement `squeeze_scope` using a global variable that tracks all `squeeze_scope` invocations\nin flight. It is a map `a => (x => (stx, simps))` where `a` is a unique identifier for\nthe `squeeze_scope` invocation which is shared with all contained simps, and `x` is a unique\nidentifier for a particular piece of simp syntax (which can be called multiple times).\nWithin that, `stx` is the simp syntax itself, and `simps` is the aggregated list of simps used\nso far.\n","docLink":"./Batteries/Tactic/SqueezeScope.html#Batteries.Tactic.squeezeScopes","kind":"opaque","line":70,"name":"Batteries.Tactic.squeezeScopes","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/SqueezeScope.lean#L70-L78"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/SqueezeScope.html#Batteries.Tactic.squeezeScope\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">squeezeScope</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The `squeeze_scope` tactic allows aggregating multiple calls to `simp` coming from the same syntax\nbut in different branches of execution, such as in `cases x <;> simp`.\nThe reported `simp` call covers all simp lemmas used by this syntax.\n```\n@[simp] def bar (z : Nat) := 1 + z\n@[simp] def baz (z : Nat) := 1 + z\n\n@[simp] def foo : Nat → Nat → Nat\n  | 0, z => bar z\n  | _+1, z => baz z\n\nexample : foo x y = 1 + y := by\n  cases x <;> simp? -- two printouts:\n  -- \"Try this: simp only [foo, bar]\"\n  -- \"Try this: simp only [foo, baz]\"\n\nexample : foo x y = 1 + y := by\n  squeeze_scope\n    cases x <;> simp -- only one printout: \"Try this: simp only [foo, baz, bar]\"\n```\n","docLink":"./Batteries/Tactic/SqueezeScope.html#Batteries.Tactic.squeezeScope","kind":"def","line":58,"name":"Batteries.Tactic.squeezeScope","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/SqueezeScope.lean#L58-L66"}}],"imports":["Init","Lean.Elab.Tactic.SimpTrace"],"instances":[],"name":"Batteries.Tactic.SqueezeScope"}