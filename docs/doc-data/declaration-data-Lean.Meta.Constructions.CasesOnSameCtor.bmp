{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Constructions/CasesOnSameCtor.html#Lean.mkCasesOnSameCtor\"><span class=\"name\">Lean</span>.<span class=\"name\">mkCasesOnSameCtor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName </span><span class=\"fn\">indName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"This constructs a matcher for a match statement that matches on the constructors of\na data type in parallel. So if `h : x1.ctorIdx = x2.ctorIdx`, then it implements\n```\nmatch x1, x2, h with\n| ctor1 .. , ctor1 .. , _ => ...\n| ctor2 .. , ctor2 .. , _ => ...\n```\nThe normal matcher supports such matches, but implements them using nested `casesOn`, which\nleads to a quadratic blow-up. This function uses the per-constructor eliminators to implement this\nmore efficiently.\n\nThis is useful for implementing or deriving functionality like `BEq`, `DecidableEq`, `Ord` and\nproving their lawfulness.\n\nOne could imagine a future where `match` compilation is smart enough to do that automatically; then\nthis module can be dropped.\n\nNote that for some data types where the indices determine the constructor (e.g. `Vec`), this leads\nto less efficient code than the normal matcher, as this needs to read the constructor tag on both\narguments, whereas the normal matcher produces code that reads just the first argument’s tag, and\nthen boldly reads the second argument’s fields.\n","docLink":"./Lean/Meta/Constructions/CasesOnSameCtor.html#Lean.mkCasesOnSameCtor","kind":"def","line":111,"name":"Lean.mkCasesOnSameCtor","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Constructions/CasesOnSameCtor.lean#L111-L228"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Constructions/CasesOnSameCtor.html#Lean.mkCasesOnSameCtorHet\"><span class=\"name\">Lean</span>.<span class=\"name\">mkCasesOnSameCtorHet</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName </span><span class=\"fn\">indName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Helper for `mkCasesOnSameCtor` that constructs a heterogeneous matcher (indices may differ)\nand does not include the equality proof in the motive (so it's not a the shape of a matcher) yet.\n","docLink":"./Lean/Meta/Constructions/CasesOnSameCtor.html#Lean.mkCasesOnSameCtorHet","kind":"def","line":25,"name":"Lean.mkCasesOnSameCtorHet","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Constructions/CasesOnSameCtor.lean#L25-L109"}}],"imports":["Lean.Meta.Basic","Lean.Meta.CompletionName","Lean.Meta.Constructions.CtorIdx","Lean.Meta.Constructions.CtorElim","Lean.Elab.App","Lean.Meta.SameCtorUtils"],"instances":[],"name":"Lean.Meta.Constructions.CasesOnSameCtor"}