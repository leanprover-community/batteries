{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.inferArgumentTypesN\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">inferArgumentTypesN</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>","info":{"doc":"Infers the types of the next `n` parameters that `e` expects. See `arrowDomainsN`.\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.inferArgumentTypesN","kind":"def","line":546,"name":"Lean.Meta.inferArgumentTypesN","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L546-L550"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.arrowDomainsN\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">arrowDomainsN</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></div></div>","info":{"doc":"Given `n` and a non-dependent function type `α₁ → α₂ → ... → αₙ → Sort u`, returns the\ntypes `α₁, α₂, ..., αₙ`. Throws an error if there are not at least `n` argument types or if a\nlater argument type depends on a prior one (i.e., it's a dependent function type).\n\nThis can be used to infer the expected type of the alternatives when constructing a `MatcherApp`.\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.arrowDomainsN","kind":"def","line":529,"name":"Lean.Meta.arrowDomainsN","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L529-L544"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormer\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isTypeFormer</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Returns `true` iff `e : Sort _` or `e : (forall As, Sort _)`.\nRemark: it subsumes `isType`\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormer","kind":"def","line":521,"name":"Lean.Meta.isTypeFormer","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L521-L526"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isPropFormerType\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isPropFormerType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Returns `true` iff `type` is `Prop` or `As → Prop`.\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isPropFormerType","kind":"def","line":515,"name":"Lean.Meta.isPropFormerType","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L515-L519"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormerType\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isTypeFormerType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Returns `true` iff `type` is `Sort _` or `As → Sort _`.\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormerType","kind":"def","line":509,"name":"Lean.Meta.isTypeFormerType","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L509-L513"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.typeFormerTypeLevel\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">typeFormerTypeLevel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Level.html#Lean.Level\">Level</a>)</span></span></div></div>","info":{"doc":"Returns `u` iff `type` is `Sort u` or `As → Sort u`.\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.typeFormerTypeLevel","kind":"def","line":490,"name":"Lean.Meta.typeFormerTypeLevel","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L490-L507"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.typeFormerTypeLevelQuick\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">typeFormerTypeLevelQuick</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Level.html#Lean.Level\">Level</a></span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/InferType.html#Lean.Meta.typeFormerTypeLevelQuick","kind":"def","line":485,"name":"Lean.Meta.typeFormerTypeLevelQuick","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L485-L488"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isType\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Returns `true` iff the type of `e` is a `Sort _`.\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isType","kind":"def","line":471,"name":"Lean.Meta.isType","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L471-L483"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isTypeQuick\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isTypeQuick</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Data/LBool.html#Lean.LBool\">LBool</a></span></span></div></div>","info":{"doc":"`isTypeQuick e` is an \"approximate\" predicate which returns `LBool.true` if `e` is a type.\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeQuick","kind":"opaque","line":454,"name":"Lean.Meta.isTypeQuick","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L454-L469"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isProof\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Check if `e` is a proof, i.e. the type of `e` is a proposition. ","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isProof","kind":"def","line":419,"name":"Lean.Meta.isProof","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L419-L424"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isProofQuick\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isProofQuick</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Data/LBool.html#Lean.LBool\">LBool</a></span></span></div></div>","info":{"doc":"`isProofQuick e` is an \"approximate\" predicate which returns `LBool.true` if `e` is a proof.\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isProofQuick","kind":"opaque","line":400,"name":"Lean.Meta.isProofQuick","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L400-L415"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isProp\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isProp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"`isProp e` returns `true` if `e` is a proposition.\n\nIf `e` contains metavariables, it may not be possible to decide whether it is a proposition or not.\nWe return `false` in this case. We considered using `LBool` and returning `LBool.undef`, but we\nhave no applications for it.\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isProp","kind":"def","line":288,"name":"Lean.Meta.isProp","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L288-L304"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.isPropQuick\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isPropQuick</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Data/LBool.html#Lean.LBool\">LBool</a></span></span></div></div>","info":{"doc":"`isPropQuick e` is an \"approximate\" predicate which returns `LBool.true`\nif `e` is a proposition.\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isPropQuick","kind":"opaque","line":270,"name":"Lean.Meta.isPropQuick","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L270-L286"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.inferTypeImp\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">inferTypeImp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/InferType.html#Lean.Meta.inferTypeImp","kind":"def","line":209,"name":"Lean.Meta.inferTypeImp","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L209-L226"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.withInferTypeConfig\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">withInferTypeConfig</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Ensure `MetaM` configuration is strong enough for inferring/checking types.\nFor example, `beta := true` is essential when type checking.\n\nRemark: we previously used the default configuration here, but this is problematic\nbecause it overrides unrelated configurations.\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.withInferTypeConfig","kind":"def","line":194,"name":"Lean.Meta.withInferTypeConfig","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L194-L207"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.throwUnknownMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">throwUnknownMVar</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwUnknownMVar","kind":"def","line":168,"name":"Lean.Meta.throwUnknownMVar","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L168-L169"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.getLevel\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">getLevel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Level.html#Lean.Level\">Level</a></span></div></div>","info":{"doc":"If `type : sort` and `sort` reduces to `Sort u` for some `u`, then `getLevel type` returns `u`.\n\nIf `sort` is an assignable MVar, then `getLevel type` produces a fresh level metavariable `?u`,\nassigns the MVar to `Sort ?u` and returns `?u`.\n","docLink":"./Lean/Meta/InferType.html#Lean.Meta.getLevel","kind":"def","line":133,"name":"Lean.Meta.getLevel","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L133-L151"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.throwTypeExpected\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">throwTypeExpected</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwTypeExpected","kind":"def","line":130,"name":"Lean.Meta.throwTypeExpected","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L130-L131"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.throwIncorrectNumberOfLevels\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">throwIncorrectNumberOfLevels</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">constName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">us</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Level.html#Lean.Level\">Level</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwIncorrectNumberOfLevels","kind":"def","line":93,"name":"Lean.Meta.throwIncorrectNumberOfLevels","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L93-L94"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Meta.throwFunctionExpected\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">throwFunctionExpected</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwFunctionExpected","kind":"def","line":76,"name":"Lean.Meta.throwFunctionExpected","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L76-L77"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/InferType.html#Lean.Expr.instantiateBetaRevRange\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">instantiateBetaRevRange</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">start </span><span class=\"fn\">stop</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"Auxiliary function for instantiating the loose bound variables in `e` with `args[start...stop]`.\nThis function is similar to `instantiateRevRange`, but it applies beta-reduction when\nwe instantiate a bound variable with a lambda expression.\n\nExample: Given the term `#0 a`, and `start := 0, stop := 1, args := #[fun x => x]` the result is\n`a` instead of `(fun x => x) a`.\nThis reduction is useful when we are inferring the type of eliminator-like applications.\nFor example, given `(n m : Nat) (f : Nat → Nat) (h : m = n)`,\nthe type of `Eq.subst (motive := fun x => f m = f x) h rfl`\nis `motive n` which is `(fun (x : Nat) => f m = f x) n`.\nThis function reduces the new application to `f m = f n`.\n\nWe use this to implement `inferAppType`.\n","docLink":"./Lean/Meta/InferType.html#Lean.Expr.instantiateBetaRevRange","kind":"def","line":17,"name":"Lean.Expr.instantiateBetaRevRange","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/InferType.lean#L17-L72"}}],"imports":["Lean.Data.LBool","Lean.Meta.Basic","Init.Data.Range.Polymorphic.Iterators"],"instances":[],"name":"Lean.Meta.InferType"}