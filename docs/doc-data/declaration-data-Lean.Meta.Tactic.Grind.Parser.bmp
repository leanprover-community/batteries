{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.initGrindNorm\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">initGrindNorm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.initGrindNorm","kind":"def","line":143,"name":"Lean.Parser.Command.initGrindNorm","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L143-L144"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.grindPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">grindPattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The `grind_pattern` command can be used to manually select a pattern for theorem instantiation.\nEnabling the option `trace.grind.ematch.instance` causes `grind` to print a trace message for each\ntheorem instance it generates, which can be helpful when determining patterns.\n\nWhen multiple patterns are specified together, all of them must match in the current context before\n`grind` attempts to instantiate the theorem. This is referred to as a *multi-pattern*.\nThis is useful for theorems such as transitivity rules, where multiple premises must be simultaneously\npresent for the rule to apply.\n\nIn the following example, `R` is a transitive binary relation over `Int`.\n```\nopaque R : Int → Int → Prop\naxiom Rtrans {x y z : Int} : R x y → R y z → R x z\n```\nTo use the fact that `R` is transitive, `grind` must already be able to satisfy both premises.\nThis is represented using a multi-pattern:\n```\ngrind_pattern Rtrans => R x y, R y z\n\nexample {a b c d} : R a b → R b c → R c d → R a d := by\n  grind\n```\nThe multi-pattern `R x y`, `R y z` instructs `grind` to instantiate `Rtrans` only when both `R x y`\nand `R y z` are available in the context. In the example, `grind` applies `Rtrans` to derive `R a c`\nfrom `R a b` and `R b c`, and can then repeat the same reasoning to deduce `R a d` from `R a c` and\n`R c d`.\n\nYou can add constraints to restrict theorem instantiation. For example:\n```\ngrind_pattern extract_extract => (as.extract i j).extract k l where\n  as =/= #[]\n```\nThe constraint instructs `grind` to instantiate the theorem only if `as` is **not** definitionally equal\nto `#[]`.\n\n## Constraints\n\n- `x =/= term`: The term bound to `x` (one of the theorem parameters) is **not** definitionally equal to `term`.\n  The term may contain holes (i.e., `_`).\n\n- `x =?= term`: The term bound to `x` is definitionally equal to `term`.\n  The term may contain holes (i.e., `_`).\n\n- `size x < n`: The term bound to `x` has size less than `n`. Implicit arguments\nand binder types are ignored when computing the size.\n\n- `depth x < n`: The term bound to `x` has depth less than `n`.\n\n- `is_ground x`: The term bound to `x` does not contain local variables or meta-variables.\n\n- `is_value x`: The term bound to `x` is a value. That is, it is a constructor fully applied to value arguments,\na literal (`Nat`, `Int`, `String`, etc.), or a lambda `fun x => t`.\n\n- `is_strict_value x`: Similar to `is_value`, but without lambdas.\n\n- `not_value x`: The term bound to `x` is a **not** value (see `is_value`).\n\n- `not_strict_value x`: Similar to `not_value`, but without lambdas.\n\n- `gen < n`: The theorem instance has generation less than `n`. Recall that each term is assigned a\ngeneration, and terms produced by theorem instantiation have a generation that is one greater than\nthe maximal generation of all the terms used to instantiate the theorem. This constraint complements\nthe `gen` option available in `grind`.\n\n- `max_insts < n`: A new instance is generated only if less than `n` instances have been generated so far.\n\n- `guard e`: The instantiation is delayed until `grind` learns that `e` is `true` in this state.\n\n- `check e`: Similar to `guard e`, but `grind` checks whether `e` is implied by its current state by\nassuming `¬ e` and trying to deduce an inconsistency.\n\n## Example\n\nConsider the following example where `f` is a monotonic function\n```\nopaque f : Nat → Nat\naxiom fMono : x ≤ y → f x ≤ f y\n```\nand you want to instruct `grind` to instantiate `fMono` for every pair of terms `f x` and `f y` when\n`x ≤ y` and `x` is **not** definitionally equal to `y`. You can use\n```\ngrind_pattern fMono => f x, f y where\n  guard x ≤ y\n  x =/= y\n```\nThen, in the following example, only three instances are generated.\n```\n/--\ntrace: [grind.ematch.instance] fMono: a ≤ f a → f a ≤ f (f a)\n[grind.ematch.instance] fMono: f a ≤ f (f a) → f (f a) ≤ f (f (f a))\n[grind.ematch.instance] fMono: a ≤ f (f a) → f a ≤ f (f (f a))\n-/\n#guard_msgs in\nexample : f b = f c → a ≤ f a → f (f a) ≤ f (f (f a)) := by\n  set_option trace.grind.ematch.instance true in\n  grind\n```\n","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.grindPattern","kind":"def","line":41,"name":"Lean.Parser.Command.grindPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L41-L141"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.grindPatternCnstrs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">grindPatternCnstrs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.grindPatternCnstrs","kind":"def","line":35,"name":"Lean.Parser.Command.grindPatternCnstrs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L35-L35"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.grindPatternCnstr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">grindPatternCnstr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.grindPatternCnstr","kind":"def","line":31,"name":"Lean.Parser.Command.grindPatternCnstr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L31-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.defEq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">defEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.defEq","kind":"def","line":26,"name":"Lean.Parser.Command.GrindCnstr.defEq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L26-L26"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.notDefEq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">notDefEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.notDefEq","kind":"def","line":25,"name":"Lean.Parser.Command.GrindCnstr.notDefEq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L25-L25"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.check\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">check</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.check","kind":"def","line":24,"name":"Lean.Parser.Command.GrindCnstr.check","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L24-L24"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.guard\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">guard</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.guard","kind":"def","line":23,"name":"Lean.Parser.Command.GrindCnstr.guard","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L23-L23"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.maxInsts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">maxInsts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.maxInsts","kind":"def","line":22,"name":"Lean.Parser.Command.GrindCnstr.maxInsts","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L22-L22"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.genLt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">genLt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.genLt","kind":"def","line":21,"name":"Lean.Parser.Command.GrindCnstr.genLt","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L21-L21"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.depthLt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">depthLt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.depthLt","kind":"def","line":20,"name":"Lean.Parser.Command.GrindCnstr.depthLt","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L20-L20"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.sizeLt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">sizeLt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.sizeLt","kind":"def","line":19,"name":"Lean.Parser.Command.GrindCnstr.sizeLt","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L19-L19"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.isGround\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">isGround</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.isGround","kind":"def","line":18,"name":"Lean.Parser.Command.GrindCnstr.isGround","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L18-L18"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.notStrictValue\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">notStrictValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.notStrictValue","kind":"def","line":17,"name":"Lean.Parser.Command.GrindCnstr.notStrictValue","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L17-L17"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.notValue\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">notValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.notValue","kind":"def","line":16,"name":"Lean.Parser.Command.GrindCnstr.notValue","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L16-L16"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.isStrictValue\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">isStrictValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.isStrictValue","kind":"def","line":15,"name":"Lean.Parser.Command.GrindCnstr.isStrictValue","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L15-L15"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.isValue\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">GrindCnstr</span>.<span class=\"name\">isValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Tactic/Grind/Parser.html#Lean.Parser.Command.GrindCnstr.isValue","kind":"def","line":14,"name":"Lean.Parser.Command.GrindCnstr.isValue","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Tactic/Grind/Parser.lean#L14-L14"}}],"imports":["Lean.Parser.Command"],"instances":[],"name":"Lean.Meta.Tactic.Grind.Parser"}