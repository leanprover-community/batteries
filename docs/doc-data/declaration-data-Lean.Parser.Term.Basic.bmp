{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstFields\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstFields</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstFields","kind":"def","line":296,"name":"Lean.Parser.Term.structInstFields","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L296-L297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstField\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstField</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstField","kind":"def","line":288,"name":"Lean.Parser.Term.structInstField","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L288-L290"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.optTypeForStructInst\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optTypeForStructInst</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.optTypeForStructInst","kind":"def","line":285,"name":"Lean.Parser.Term.optTypeForStructInst","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L285-L286"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstFieldBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstFieldBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstFieldBinder","kind":"def","line":281,"name":"Lean.Parser.Term.structInstFieldBinder","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L281-L284"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstLVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstLVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstLVal","kind":"def","line":277,"name":"Lean.Parser.Term.structInstLVal","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L277-L280"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstArrayRef\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstArrayRef</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstArrayRef","kind":"def","line":274,"name":"Lean.Parser.Term.structInstArrayRef","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L274-L276"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.optEllipsis\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optEllipsis</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.optEllipsis","kind":"def","line":271,"name":"Lean.Parser.Term.optEllipsis","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L271-L273"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstFieldDeclParser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstFieldDeclParser</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rbp</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.structInstFieldDeclParser","kind":"def","line":269,"name":"Lean.Parser.Term.structInstFieldDeclParser","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L269-L270"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.optType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.optType","kind":"def","line":260,"name":"Lean.Parser.Term.optType","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L260-L261"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.typeSpec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeSpec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.typeSpec","kind":"def","line":257,"name":"Lean.Parser.Term.typeSpec","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L257-L258"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.bracketedBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">bracketedBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">requireType</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A `bracketedBinder` matches any kind of binder group that uses some kind of brackets:\n* An explicit binder like `(x y : A)`\n* An implicit binder like `{x y : A}`\n* A strict implicit binder, `⦃y z : A⦄` or its ASCII alternative `{{y z : A}}`\n* An instance binder `[A]` or `[x : A]` (multiple variables are not allowed here)\n","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.bracketedBinder","kind":"def","line":246,"name":"Lean.Parser.Term.bracketedBinder","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L246-L255"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.instBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.instBinder","kind":"def","line":237,"name":"Lean.Parser.Term.instBinder","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L237-L245"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.optIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.optIdent","kind":"def","line":234,"name":"Lean.Parser.Term.optIdent","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L234-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.strictImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">requireType</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Strict-implicit binder, like `⦃x y : A⦄` or `⦃x y⦄`.\nIn contrast to `{ ... }` implicit binders, strict-implicit binders do not automatically insert\na `_` placeholder until at least one subsequent explicit parameter is specified.\nDo *not* use strict-implicit binders unless there is a subsequent explicit parameter.\nAssuming this rule is followed, for fully applied expressions implicit and strict-implicit binders have the same behavior.\n\nExample: If `h : ∀ ⦃x : A⦄, x ∈ s → p x` and `hs : y ∈ s`,\nthen `h` by itself elaborates to itself without inserting `_` for the `x : A` parameter,\nand `h hs` has type `p y`.\nIn contrast, if `h' : ∀ {x : A}, x ∈ s → p x`, then `h` by itself elaborates to have type `?m ∈ s → p ?m`\nwith `?m` a fresh metavariable.\n","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.strictImplicitBinder","kind":"def","line":217,"name":"Lean.Parser.Term.strictImplicitBinder","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L217-L232"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.strictImplicitRightBracket\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitRightBracket</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.strictImplicitRightBracket","kind":"def","line":216,"name":"Lean.Parser.Term.strictImplicitRightBracket","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L216-L216"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.strictImplicitLeftBracket\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitLeftBracket</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.strictImplicitLeftBracket","kind":"def","line":215,"name":"Lean.Parser.Term.strictImplicitLeftBracket","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L215-L215"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.implicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">implicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">requireType</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.implicitBinder","kind":"def","line":204,"name":"Lean.Parser.Term.implicitBinder","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L204-L214"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.explicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">requireType</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.explicitBinder","kind":"def","line":198,"name":"Lean.Parser.Term.explicitBinder","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L198-L203"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderDefault.parenthesizer\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderDefault</span>.<span class=\"name\">parenthesizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer\">PrettyPrinter.Parenthesizer</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderDefault.parenthesizer","kind":"def","line":189,"name":"Lean.Parser.Term.binderDefault.parenthesizer","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L189-L196"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderDefault\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderDefault</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderDefault","kind":"def","line":185,"name":"Lean.Parser.Term.binderDefault","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L185-L186"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderTactic","kind":"def","line":182,"name":"Lean.Parser.Term.binderTactic","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L182-L184"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">requireType</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderType","kind":"def","line":179,"name":"Lean.Parser.Term.binderType","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L179-L181"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.binderIdent","kind":"def","line":176,"name":"Lean.Parser.Term.binderIdent","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L176-L177"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.omission\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">omission</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The `⋯` term denotes a term that was omitted by the pretty printer.\nThe presence of `⋯` in pretty printer output is controlled by the `pp.deepTerms` and `pp.proofs` options,\nand these options can be further adjusted using `pp.deepTerms.threshold` and `pp.proofs.threshold`.\n\nIt is only meant to be used for pretty printing.\nHowever, in case it is copied and pasted from the Infoview, `⋯` logs a warning and elaborates like `_`.\n","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.omission","kind":"def","line":166,"name":"Lean.Parser.Term.omission","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L166-L175"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.syntheticHole\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">syntheticHole</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A *synthetic hole* (or *synthetic placeholder*), which stands for an unknown term that should be synthesized using tactics.\n- `?_` creates a fresh metavariable with an auto-generated name.\n- `?m` either refers to a pre-existing metavariable named `m` or creates a fresh metavariable with that name.\n\nIn particular, the synthetic hole syntax creates \"synthetic opaque metavariables\",\nthe same kind of metavariable used to represent goals in the tactic state.\n\nSynthetic holes are similar to holes in that `_` also creates metavariables,\nbut synthetic opaque metavariables have some different properties:\n- In tactics such as `refine`, only synthetic holes yield new goals.\n- During elaboration, unification will not solve for synthetic opaque metavariables, they are \"opaque\".\n  This is to prevent counterintuitive behavior such as disappearing goals.\n- When synthetic holes appear under binders, they capture local variables using a more complicated mechanism known as delayed assignment.\n\n## Delayed assigned metavariables\n\nThis section gives an overview of some technical details of synthetic holes, which you should feel free to skip.\nUnderstanding delayed assignments is mainly useful for those who are working on tactics and other metaprogramming.\nIt is included here until there is a suitable place for it in the reference manual.\n\nWhen a synthetic hole appears under a binding construct, such as for example `fun (x : α) (y : β) => ?s`,\nthe system creates a *delayed assignment*. This consists of\n1. A metavariable `?m` of type `(x : α) → (y : β) → γ x y` whose local context is the local context outside the `fun`,\n  where `γ x y` is the type of `?s`. Recall that `x` and `y` appear in the local context of `?s`.\n2. A delayed assignment record associating `?m` to `?s` and the variables `#[x, y]` in the local context of `?s`\n\nThen, this function elaborates as `fun (x : α) (y : β) => ?m x y`, where one should understand `x` and `y` here\nas being De Bruijn indexes, since Lean uses the locally nameless encoding of lambda calculus.\n\nOnce `?s` is fully solved for, in the sense that after metavariable instantiation it is a metavariable-free term `e`,\nthen we can make the assignment `?m := fun (x' : α) (y' : β) => e[x := x', y := y']`.\n(Implementation note: Lean only instantiates full applications `?m x' y'` of delayed assigned metavariables, to skip forming this function.)\nThis delayed assignment mechanism is essential to the operation of basic tactics like `intro`,\nand a good mental model is that it is a way to \"apply\" the metavariable `?s` by substituting values in for some of its local variables.\nWhile it would be easier to immediately assign `?s := ?m x y`,\ndelayed assignment preserves `?s` as an unsolved-for metavariable with a local context that still contains `x` and `y`,\nwhich is exactly what tactics like `intro` need.\n\nBy default, delayed assigned metavariables pretty print with what they are delayed assigned to.\nThe delayed assigned metavariables themselves can be pretty printed using `set_option pp.mvars.delayed true`.\n\nFor more information, see the \"Gruesome details\" module docstrings in `Lean.MetavarContext`.\n","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.syntheticHole","kind":"def","line":119,"name":"Lean.Parser.Term.syntheticHole","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L119-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.hole\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">hole</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.\nFor example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.\n\nThe way this works is that holes create fresh metavariables.\nThe elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.\nThis is often known as *unification*.\n\nNormally, all holes must be solved for. However, there are a few contexts where this is not necessary:\n* In `match` patterns, holes are catch-all patterns.\n* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.\n\nRelated concept: implicit parameters are automatically filled in with holes during the elaboration process.\n\nSee also `?m` syntax (synthetic holes).\n","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Term.hole","kind":"def","line":101,"name":"Lean.Parser.Term.hole","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L101-L118"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.seq1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">seq1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.seq1","kind":"def","line":94,"name":"Lean.Parser.Tactic.seq1","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L94-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeqIndentGt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeqIndentGt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"Same as [`tacticSeq`] but requires delimiter-free tactic sequence to have strict indentation.\nThe strict indentation requirement only apply to *nested* `by`s, as top-level `by`s do not have a\nposition set. ","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeqIndentGt","kind":"def","line":86,"name":"Lean.Parser.Tactic.tacticSeqIndentGt","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L86-L91"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"A sequence of tactics in brackets, or a delimiter-free indented sequence of tactics.\nDelimiter-free indentation is determined by the *first* tactic of the sequence. ","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeq","kind":"def","line":81,"name":"Lean.Parser.Tactic.tacticSeq","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L81-L84"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeqBracketed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeqBracketed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"The syntax `{ tacs }` is an alternative syntax for `· tacs`.\nIt runs the tactics in sequence, and fails if the goal is not solved. ","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeqBracketed","kind":"def","line":76,"name":"Lean.Parser.Tactic.tacticSeqBracketed","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L76-L79"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeq1Indented\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeq1Indented</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.tacticSeq1Indented","kind":"def","line":74,"name":"Lean.Parser.Tactic.tacticSeq1Indented","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L74-L75"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.sepBy1IndentSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sepBy1IndentSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`sepBy1IndentSemicolon(p)` parses a (nonempty) sequence of `p` optionally followed by `;`,\nsimilar to `many1Indent(p \";\"?)`, except that if two occurrences of `p` occur on the same line,\nthe `;` is mandatory. This is used by tactic parsing, so that\n```\nexample := by\n  skip\n  skip\n```\nis legal, but `by skip skip` is not - it must be written as `by skip; skip`. ","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.sepBy1IndentSemicolon","kind":"def","line":57,"name":"Lean.Parser.Tactic.sepBy1IndentSemicolon","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L57-L68"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.sepByIndentSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sepByIndentSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"`sepByIndentSemicolon(p)` parses a sequence of `p` optionally followed by `;`,\nsimilar to `manyIndent(p \";\"?)`, except that if two occurrences of `p` occur on the same line,\nthe `;` is mandatory. This is used by tactic parsing, so that\n```\nexample := by\n  skip\n  skip\n```\nis legal, but `by skip skip` is not - it must be written as `by skip; skip`. ","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.Tactic.sepByIndentSemicolon","kind":"def","line":44,"name":"Lean.Parser.Tactic.sepByIndentSemicolon","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L44-L55"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.convParser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">convParser</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rbp</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.convParser","kind":"def","line":39,"name":"Lean.Parser.convParser","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L39-L40"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term/Basic.html#Lean.Parser.tacticParser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">tacticParser</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rbp</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Parser</a></div></div>","info":{"doc":"","docLink":"./Lean/Parser/Term/Basic.html#Lean.Parser.tacticParser","kind":"def","line":36,"name":"Lean.Parser.tacticParser","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Parser/Term/Basic.lean#L36-L37"}}],"imports":["Lean.Parser.Attr","Lean.Parser.Level","Lean.Parser.Term.Doc","Lean.Parser.Basic"],"instances":[],"name":"Lean.Parser.Term.Basic"}