{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#MonadAttach.trivial\"><span class=\"name\">MonadAttach</span>.<span class=\"name\">trivial</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span></div></div>","info":{"doc":"A `MonadAttach` instance where all return values are possible and `attach` adds no\ninformation to the return value, except a trivial proof of `True`\\.\n\nThis instance is used whenever no more useful `MonadAttach` instance can be implemented\\.\nIt always has a `WeaklyLawfulMonadAttach`, but usually no `LawfulMonadAttach` instance\\.\n","docLink":"./Init/Control/MonadAttach.html#MonadAttach.trivial","kind":"def","line":66,"name":"MonadAttach.trivial","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L66-L76"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#MonadAttach.pbind\"><span class=\"name\">MonadAttach</span>.<span class=\"name\">pbind</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u_1 → <a href=\"./foundational_types.html\">Type</a> u_2</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach.CanReturn\">CanReturn</a> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">β</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>","info":{"doc":"Like `Bind.bind`, `pbind` sequences two computations `x : m α` and `f`,\nallowing the second to depend on the value computed by the first\\.\nBut other than with `Bind.bind`, the second computation can also depend on a proof that\nthe return value `a` of `x` satisfies `MonadAttach.CanReturn x a`\\.\n","docLink":"./Init/Control/MonadAttach.html#MonadAttach.pbind","kind":"def","line":56,"name":"MonadAttach.pbind","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L56-L64"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#LawfulMonadAttach.canReturn_map_imp\"><span class=\"name\">LawfulMonadAttach</span>.<span class=\"name\">canReturn_map_imp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝¹</span> : <span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#LawfulMonadAttach\">LawfulMonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">P</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">P</span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach.CanReturn\">MonadAttach.CanReturn</a> (<a href=\"./Init/Prelude.html#Subtype.val\">Subtype.val</a> <a href=\"./Init/Prelude.html#Functor.map\">&lt;$&gt;</a> <span class=\"fn\">x</span>) <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">a</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Control/MonadAttach.html#LawfulMonadAttach.canReturn_map_imp","kind":"theorem","line":53,"name":"LawfulMonadAttach.canReturn_map_imp","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L53-L53"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#LawfulMonadAttach.mk\"><span class=\"name\">LawfulMonadAttach</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toWeaklyLawfulMonadAttach</span> : <span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#WeaklyLawfulMonadAttach\">WeaklyLawfulMonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">canReturn_map_imp</span> :\n  <span class=\"fn\">∀ {<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u} {<span class=\"fn\">P</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>} {<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">P</span>)</span></span>} {<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}, <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach.CanReturn\">MonadAttach.CanReturn</a> (<a href=\"./Init/Prelude.html#Subtype.val\">Subtype.val</a> <a href=\"./Init/Prelude.html#Functor.map\">&lt;$&gt;</a> <span class=\"fn\">x</span>) <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">a</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#LawfulMonadAttach\">LawfulMonadAttach</a> <span class=\"fn\">m</span></span></div></div>","info":{"doc":"","docLink":"./Init/Control/MonadAttach.html#LawfulMonadAttach.mk","kind":"ctor","line":51,"name":"LawfulMonadAttach.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L51-L51"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#LawfulMonadAttach.toWeaklyLawfulMonadAttach\"><span class=\"name\">LawfulMonadAttach</span>.<span class=\"name\">toWeaklyLawfulMonadAttach</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝¹</span> : <span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#LawfulMonadAttach\">LawfulMonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#WeaklyLawfulMonadAttach\">WeaklyLawfulMonadAttach</a> <span class=\"fn\">m</span></span></div></div>","info":{"doc":"","docLink":"./Init/Control/MonadAttach.html#LawfulMonadAttach.toWeaklyLawfulMonadAttach","kind":"theorem","line":51,"name":"LawfulMonadAttach.toWeaklyLawfulMonadAttach","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L51-L54"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#LawfulMonadAttach\"><span class=\"name\">LawfulMonadAttach</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#WeaklyLawfulMonadAttach\">WeaklyLawfulMonadAttach</a> <span class=\"fn\">m</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"This type class ensures that `MonadAttach.CanReturn` is the unique strongest possible\npostcondition\\.\n","docLink":"./Init/Control/MonadAttach.html#LawfulMonadAttach","kind":"class","line":47,"name":"LawfulMonadAttach","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L47-L54"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#WeaklyLawfulMonadAttach.map_attach\"><span class=\"name\">WeaklyLawfulMonadAttach</span>.<span class=\"name\">map_attach</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝¹</span> : <span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#WeaklyLawfulMonadAttach\">WeaklyLawfulMonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Subtype.val\">Subtype.val</a> <a href=\"./Init/Prelude.html#Functor.map\">&lt;$&gt;</a> <span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach.attach\">MonadAttach.attach</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x</span></div></div>","info":{"doc":"","docLink":"./Init/Control/MonadAttach.html#WeaklyLawfulMonadAttach.map_attach","kind":"theorem","line":45,"name":"WeaklyLawfulMonadAttach.map_attach","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L45-L45"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#WeaklyLawfulMonadAttach.mk\"><span class=\"name\">WeaklyLawfulMonadAttach</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">map_attach</span> : <span class=\"fn\">∀ {<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u} {<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>}, <a href=\"./Init/Prelude.html#Subtype.val\">Subtype.val</a> <a href=\"./Init/Prelude.html#Functor.map\">&lt;$&gt;</a> <span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach.attach\">MonadAttach.attach</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#WeaklyLawfulMonadAttach\">WeaklyLawfulMonadAttach</a> <span class=\"fn\">m</span></span></div></div>","info":{"doc":"","docLink":"./Init/Control/MonadAttach.html#WeaklyLawfulMonadAttach.mk","kind":"ctor","line":44,"name":"WeaklyLawfulMonadAttach.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L44-L44"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#WeaklyLawfulMonadAttach\"><span class=\"name\">WeaklyLawfulMonadAttach</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"This type class ensures that every monadic action `x : m α` can be recovered by stripping the\nproof component from the subtypes returned by\n`(MonadAttach.attach x) : m { a : α // MonadAttach.CanReturn x a }` \\. In other words,\nthe type class ensures that `Subtype.val <$> MonadAttach.attach x = x`\\.\n","docLink":"./Init/Control/MonadAttach.html#WeaklyLawfulMonadAttach","kind":"class","line":44,"name":"WeaklyLawfulMonadAttach","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L44-L45"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#MonadAttach.attach\"><span class=\"name\">MonadAttach</span>.<span class=\"name\">attach</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">(<a href=\"./Init/Control/MonadAttach.html#MonadAttach.CanReturn\">CanReturn</a> <span class=\"fn\">x</span>)</span>)</span></span></div></div>","info":{"doc":"Attaches a proof of `MonadAttach.CanReturn` to the return value of `x`\\. This proof\n  can be used to prove the termination of well\\-founded recursive functions\\.\n  ","docLink":"./Init/Control/MonadAttach.html#MonadAttach.attach","kind":"def","line":40,"name":"MonadAttach.attach","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L40-L40"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#MonadAttach.CanReturn\"><span class=\"name\">MonadAttach</span>.<span class=\"name\">CanReturn</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"A predicate that can be assumed to be true for all return values `a` of actions `x`\n  in `m`, in all situations\\.\n  ","docLink":"./Init/Control/MonadAttach.html#MonadAttach.CanReturn","kind":"def","line":35,"name":"MonadAttach.CanReturn","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L35-L35"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#MonadAttach.mk\"><span class=\"name\">MonadAttach</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">CanReturn</span> : <span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u} → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">attach</span> : <span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u} → <span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>) → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Subtype\">Subtype</a> <span class=\"fn\">(<span class=\"fn\">CanReturn</span> <span class=\"fn\">x</span>)</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/MonadAttach.html#MonadAttach\">MonadAttach</a> <span class=\"fn\">m</span></span></div></div>","info":{"doc":"","docLink":"./Init/Control/MonadAttach.html#MonadAttach.mk","kind":"ctor","line":30,"name":"MonadAttach.mk","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L30-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Control/MonadAttach.html#MonadAttach\"><span class=\"name\">MonadAttach</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max (u + 1) v)</div></div>","info":{"doc":"For every `x : m α`, this type class provides a predicate `MonadAttach.CanReturn x`\nand a way to attach a proof of this predicate to the return values of `x` by providing\nan element `MonadAttach.attach x` of `m { a : α // MonadAttach.CanReturn x a }`\\.\n\nInstances should abide the law `Subtype.val <$> MonadAttach.attach x = x`, which is encoded by\nthe `WeaklyLawfulMonadAttach` type class\\. The stronger type class `LawfulMonadAttach`\nensures that `MonadAttach.CanReturn x` is the *unique* strongest possible predicate\\.\n\nSimilarly to `List.attach`, the purpose of\n`MonadAttach` is to attach proof terms necessary for well\\-founded termination proofs\\.\nThe iterator library relies on `MonadAttach` for combinators such as\n`Std.Iter.filterM` in order to automatically attach\ninformation about the monadic predicate's behavior that could be relevant for the termination\nbehavior of the iterator\\.\n\n**Limitations**:\n\nFor many monads, there is a strongly lawful `MonadAttach` instance, but there are exceptions\\.\nFor example, there is no way to provide a computable `MonadAttach` instance for the CPS monad\ntransformers\n`StateCpsT` and\n`ExceptCpsT` with a predicate that is not always\n`True`\\. Therefore, such CPS monads only provide the trivial `MonadAttach` instance\n`MonadAttach.trivial` together with `WeaklyLawfulMonadAttach`, but without\n`LawfulMonadAttach`\\.\n\nFor most monads with side effects, `MonadAttach` is too weak to fully capture the behavior of\ncomputations because the postcondition represented by `MonadAttach.CanReturn` neither depends\non the prior internal state of the monad, nor does it contain information about how the state of the\nmonad changes with the computation\\.\n","docLink":"./Init/Control/MonadAttach.html#MonadAttach","kind":"class","line":30,"name":"MonadAttach","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Control/MonadAttach.lean#L30-L40"}}],"imports":["Init.Core"],"instances":[],"name":"Init.Control.MonadAttach"}