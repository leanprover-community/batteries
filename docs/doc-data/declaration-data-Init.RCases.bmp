{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rintro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rintro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rintro","kind":"def","line":184,"name":"Lean.Parser.Tactic.rintro","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L184-L194"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.obtain\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">obtain</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n","docLink":"./Init/RCases.html#Lean.Parser.Tactic.obtain","kind":"def","line":155,"name":"Lean.Parser.Tactic.obtain","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L155-L172"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcases\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcases","kind":"def","line":110,"name":"Lean.Parser.Tactic.rcases","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L110-L153"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rintroPat.binder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rintroPat</span>.<span class=\"name\">binder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A multi argument binder `(pat1 pat2 : ty)` binds a list of patterns and gives them all type `ty`.\n","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rintroPat.binder","kind":"def","line":94,"name":"Lean.Parser.Tactic.rintroPat.binder","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L94-L98"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rintroPat.one\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rintroPat</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"An `rcases` pattern is an `rintro` pattern ","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rintroPat.one","kind":"def","line":92,"name":"Lean.Parser.Tactic.rintroPat.one","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L92-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Category.rintroPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">rintroPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>","info":{"doc":"The syntax category of `rintro` patterns. ","docLink":"./Init/RCases.html#Lean.Parser.Category.rintroPat","kind":"def","line":90,"name":"Lean.Parser.Category.rintroPat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L90-L91"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rintroPat.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rintroPat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rintroPat.quot","kind":"def","line":90,"name":"Lean.Parser.Tactic.rintroPat.quot","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L90-L91"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.paren\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">paren</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`(pat)` is a pattern which resets the precedence to low ","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.paren","kind":"def","line":87,"name":"Lean.Parser.Tactic.rcasesPat.paren","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L87-L88"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.tuple\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`⟨pat, ...⟩` is a pattern which matches on a tuple-like constructor\nor multi-argument inductive constructor\n","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.tuple","kind":"def","line":82,"name":"Lean.Parser.Tactic.rcasesPat.tuple","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L82-L86"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.explicit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">explicit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\nwhile leaving the `@` off will only use the patterns on the explicit arguments.\n","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.explicit","kind":"def","line":77,"name":"Lean.Parser.Tactic.rcasesPat.explicit","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L77-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.clear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`-` is a pattern which removes the value from the context ","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.clear","kind":"def","line":75,"name":"Lean.Parser.Tactic.rcasesPat.clear","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L75-L76"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.ignore\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">ignore</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`_` is a pattern which ignores the value and gives it an inaccessible name ","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.ignore","kind":"def","line":73,"name":"Lean.Parser.Tactic.rcasesPat.ignore","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L73-L74"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.one\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`x` is a pattern which binds `x` ","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.one","kind":"def","line":71,"name":"Lean.Parser.Tactic.rcasesPat.one","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L71-L72"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPatLo\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPatLo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A low precedence `rcases` pattern is a `rcasesPatMed` optionally followed by `: ty` ","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPatLo","kind":"def","line":69,"name":"Lean.Parser.Tactic.rcasesPatLo","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L69-L70"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPatMed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPatMed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A medium precedence `rcases` pattern is a list of `rcasesPat` separated by `|` ","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPatMed","kind":"def","line":67,"name":"Lean.Parser.Tactic.rcasesPatMed","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L67-L68"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/RCases.html#Lean.Parser.Tactic.rcasesPat.quot","kind":"def","line":65,"name":"Lean.Parser.Tactic.rcasesPat.quot","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L65-L66"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/RCases.html#Lean.Parser.Category.rcasesPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">rcasesPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>","info":{"doc":"The syntax category of `rcases` patterns. ","docLink":"./Init/RCases.html#Lean.Parser.Category.rcasesPat","kind":"def","line":65,"name":"Lean.Parser.Category.rcasesPat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/RCases.lean#L65-L66"}}],"imports":["Init.Meta"],"instances":[],"name":"Init.RCases"}