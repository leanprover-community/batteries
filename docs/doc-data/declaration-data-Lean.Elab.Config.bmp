{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Config.html#Lean.Elab.Term.setElabConfig\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Term</span>.<span class=\"name\">setElabConfig</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Lean/Meta/Basic.html#Lean.Meta.Config\">Meta.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.Config\">Meta.Config</a></div></div>","info":{"doc":"Set `isDefEq` configuration for the elaborator.\nNote that we enable all approximations but `quasiPatternApprox`\n\nIn Lean3 and Lean 4, we used to use the quasi-pattern approximation during elaboration.\nThe example:\n```\ndef ex : StateT δ (StateT σ Id) σ :=\nmonadLift (get : StateT σ Id σ)\n```\ndemonstrates why it produces counterintuitive behavior.\nWe have the `Monad-lift` application:\n```\n@monadLift ?m ?n ?c ?α (get : StateT σ id σ) : ?n ?α\n```\nIt produces the following unification problem when we process the expected type:\n```\n?n ?α =?= StateT δ (StateT σ id) σ\n==> (approximate using first-order unification)\n?n := StateT δ (StateT σ id)\n?α := σ\n```\nThen, we need to solve:\n```\n?m ?α =?= StateT σ id σ\n==> instantiate metavars\n?m σ =?= StateT σ id σ\n==> (approximate since it is a quasi-pattern unification constraint)\n?m := fun σ => StateT σ id σ\n```\nNote that the constraint is not a Milner pattern because σ is in\nthe local context of `?m`. We are ignoring the other possible solutions:\n```\n?m := fun σ' => StateT σ id σ\n?m := fun σ' => StateT σ' id σ\n?m := fun σ' => StateT σ id σ'\n```\n\nWe need the quasi-pattern approximation for elaborating recursor-like expressions (e.g., dependent `match with` expressions).\n\nIf we had use first-order unification, then we would have produced\nthe right answer: `?m := StateT σ id`\n\nHaskell would work on this example since it always uses\nfirst-order unification.\n","docLink":"./Lean/Elab/Config.html#Lean.Elab.Term.setElabConfig","kind":"def","line":15,"name":"Lean.Elab.Term.setElabConfig","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/Config.lean#L15-L62"}}],"imports":["Lean.Meta.Basic"],"instances":[],"name":"Lean.Elab.Config"}