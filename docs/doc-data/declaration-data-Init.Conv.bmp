{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.normCast\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">normCast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`norm_cast` tactic in `conv` mode. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.normCast","kind":"def","line":372,"name":"Lean.Parser.Tactic.Conv.normCast","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L372-L373"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.conv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">conv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.conv","kind":"def","line":357,"name":"Lean.Parser.Tactic.Conv.conv","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L357-L370"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.letToHave\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">letToHave</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Transforms `let` expressions into `have` expressions within the target expression when possible.\nThis is the conv mode version of the `let_to_have` tactic.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.letToHave","kind":"def","line":351,"name":"Lean.Parser.Tactic.Conv.letToHave","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L351-L355"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.liftLets\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">liftLets</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Lifts `let` and `have` expressions within the target expression as far out as possible.\nThis is the conv mode version of the `lift_lets` tactic.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.liftLets","kind":"def","line":345,"name":"Lean.Parser.Tactic.Conv.liftLets","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L345-L349"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.extractLets\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">extractLets</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Extracts `let` and `have` expressions from within the target expression.\nThis is the conv mode version of the `extract_lets` tactic.\n\n- `extract_lets` extracts all the lets from the target.\n- `extract_lets x y z` extracts all the lets from the target and uses `x`, `y`, and `z` for the first names.\n  Using `_` for a name leaves it unnamed.\n\nLimitation: the extracted local declarations do not persist outside of the `conv` goal.\nSee also `lift_lets`, which does not extract lets as local declarations.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.extractLets","kind":"def","line":332,"name":"Lean.Parser.Tactic.Conv.extractLets","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L332-L343"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRepeat_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convRepeat_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`repeat convs` runs the sequence `convs` repeatedly until it fails to apply. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRepeat_","kind":"def","line":327,"name":"Lean.Parser.Tactic.Conv.convRepeat_","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L327-L328"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.«conv_&lt;;&gt;_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">«conv_&lt;;&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">TrailingParserDescr</a></div></div>","info":{"doc":"`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal, concatenating all goals\nproduced by `tac'`.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.«conv_<;>_»","kind":"def","line":324,"name":"Lean.Parser.Tactic.Conv.«conv_<;>_»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L324-L325"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTry_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convTry_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`try tac` runs `tac` and succeeds even if `tac` failed. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTry_","kind":"def","line":318,"name":"Lean.Parser.Tactic.Conv.convTry_","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L318-L318"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.first\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">first</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`first | conv | ...` runs each `conv` until one succeeds, or else fails. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.first","kind":"def","line":314,"name":"Lean.Parser.Tactic.Conv.first","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L314-L315"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convApply_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convApply_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `apply thm` conv tactic is the same as `apply thm` the tactic.\nThere are no restrictions on `thm`, but strange results may occur if `thm`\ncannot be reasonably interpreted as proving one equality from a list of others. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convApply_","kind":"def","line":312,"name":"Lean.Parser.Tactic.Conv.convApply_","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L312-L312"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.enter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">enter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`enter [arg, ...]` is a compact way to describe a path to a subterm.\nIt is a shorthand for other conv tactics as follows:\n* `enter [i]` is equivalent to `arg i`.\n* `enter [@i]` is equivalent to `arg @i`.\n* `enter [x]` (where `x` is an identifier) is equivalent to `ext x`.\n* `enter [in e]` (where `e` is a term) is equivalent to `pattern e`.\n  Occurrences can be specified with `enter [in (occs := ...) e]`.\nFor example, given the target `f (g a (fun x => x b))`, `enter [1, 2, x, 1]`\nwill traverse to the subterm `b`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.enter","kind":"def","line":297,"name":"Lean.Parser.Tactic.Conv.enter","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L297-L306"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.enterArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">enterArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.enterArg","kind":"def","line":295,"name":"Lean.Parser.Tactic.Conv.enterArg","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L295-L295"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.enterPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">enterPattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.enterPattern","kind":"def","line":293,"name":"Lean.Parser.Tactic.Conv.enterPattern","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L293-L293"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convIntro___\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convIntro___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`intro` traverses into binders. Synonym for `ext`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convIntro___","kind":"def","line":291,"name":"Lean.Parser.Tactic.Conv.convIntro___","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L291-L291"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRight\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convRight</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`right` traverses into the right argument. Synonym for `rhs`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRight","kind":"def","line":289,"name":"Lean.Parser.Tactic.Conv.convRight","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L289-L289"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convLeft\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convLeft</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`left` traverses into the left argument. Synonym for `lhs`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convLeft","kind":"def","line":287,"name":"Lean.Parser.Tactic.Conv.convLeft","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L287-L287"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convArgs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`args` traverses into all arguments. Synonym for `congr`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convArgs","kind":"def","line":285,"name":"Lean.Parser.Tactic.Conv.convArgs","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L285-L285"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convErw__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convErw__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`erw [rules]` is a shorthand for `rw (transparency := .default) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convErw__","kind":"def","line":282,"name":"Lean.Parser.Tactic.Conv.convErw__","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L282-L282"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRw__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convRw__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rw [rules]` applies the given list of rewrite rules to the target.\nSee the `rw` tactic for more information. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRw__","kind":"def","line":277,"name":"Lean.Parser.Tactic.Conv.convRw__","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L277-L277"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.failIfSuccess\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">failIfSuccess</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`fail_if_success t` fails if the tactic `t` succeeds. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.failIfSuccess","kind":"def","line":272,"name":"Lean.Parser.Tactic.Conv.failIfSuccess","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L272-L273"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.«conv·._»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">«conv·</span>.<span class=\"name\">_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`· conv` focuses on the main conv goal and tries to solve it using `s`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.«conv·._»","kind":"def","line":268,"name":"Lean.Parser.Tactic.Conv.«conv·._»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L268-L268"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convConvSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convConvSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`conv => cs` runs `cs` in sequence on the target `t`,\nresulting in `t'`, which becomes the new target subgoal. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convConvSeq","kind":"def","line":263,"name":"Lean.Parser.Tactic.Conv.convConvSeq","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L263-L265"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.focus\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">focus</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.focus","kind":"def","line":261,"name":"Lean.Parser.Tactic.Conv.focus","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L261-L261"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.«convNext__=&gt;_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">«convNext__=&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.«convNext__=>_»","kind":"def","line":255,"name":"Lean.Parser.Tactic.Conv.«convNext__=>_»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L255-L255"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.case'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">case'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.case'","kind":"def","line":247,"name":"Lean.Parser.Tactic.Conv.case'","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L247-L248"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.case\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">case</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.case","kind":"def","line":238,"name":"Lean.Parser.Tactic.Conv.case","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L238-L239"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.anyGoals\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">anyGoals</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.anyGoals","kind":"def","line":228,"name":"Lean.Parser.Tactic.Conv.anyGoals","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L228-L229"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.allGoals\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">allGoals</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.allGoals","kind":"def","line":221,"name":"Lean.Parser.Tactic.Conv.allGoals","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L221-L222"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTrace_state\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convTrace_state</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`trace_state` prints the current goal state. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTrace_state","kind":"def","line":218,"name":"Lean.Parser.Tactic.Conv.convTrace_state","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L218-L218"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convDone\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convDone</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`done` succeeds iff there are no goals remaining. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convDone","kind":"def","line":215,"name":"Lean.Parser.Tactic.Conv.convDone","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L215-L215"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRfl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convRfl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rfl` closes one conv goal \"trivially\", by using reflexivity\n(that is, no rewriting). ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRfl","kind":"def","line":212,"name":"Lean.Parser.Tactic.Conv.convRfl","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L212-L212"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.paren\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">paren</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`(convs)` runs the `convs` in sequence on the current list of targets.\nThis is pure grouping with no added effects. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.paren","kind":"def","line":206,"name":"Lean.Parser.Tactic.Conv.paren","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L206-L208"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedConv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">nestedConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`{ convs }` runs the list of `convs` on the current target, and any subgoals that\nremain are trivially closed by `skip`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedConv","kind":"def","line":202,"name":"Lean.Parser.Tactic.Conv.nestedConv","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L202-L204"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Executes the given conv block without converting regular goal into a `conv` goal. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTactic","kind":"def","line":199,"name":"Lean.Parser.Tactic.Conv.convTactic","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L199-L200"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">nestedTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Focuses, converts the `conv` goal `⊢ lhs` into a regular goal `⊢ lhs = rhs`, and then executes the given tactic block. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedTactic","kind":"def","line":196,"name":"Lean.Parser.Tactic.Conv.nestedTactic","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L196-L197"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedTacticCore\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">nestedTacticCore</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Executes the given tactic block without converting `conv` goal into a regular goal. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedTacticCore","kind":"def","line":193,"name":"Lean.Parser.Tactic.Conv.nestedTacticCore","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L193-L194"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.clear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Removes one or more hypotheses from the local context. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.clear","kind":"def","line":190,"name":"Lean.Parser.Tactic.Conv.clear","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L190-L191"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.simpMatch\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">simpMatch</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp_match` simplifies match expressions. For example,\n```\nmatch [a, b] with\n| [] => 0\n| hd :: tl => hd\n```\nsimplifies to `a`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.simpMatch","kind":"def","line":181,"name":"Lean.Parser.Tactic.Conv.simpMatch","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L181-L188"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.dsimpTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">dsimpTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. See the `simp?` tactic for more information. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.dsimpTrace","kind":"def","line":178,"name":"Lean.Parser.Tactic.Conv.dsimpTrace","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L178-L179"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.dsimp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">dsimp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`dsimp` is the definitional simplifier in `conv`-mode. It differs from `simp` in that it only\napplies theorems that hold by reflexivity.\n\nExamples:\n\n```lean\nexample (a : Nat): (0 + 0) = a - a := by\n  conv =>\n    lhs\n    dsimp\n    rw [← Nat.sub_self a]\n```\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.dsimp","kind":"def","line":161,"name":"Lean.Parser.Tactic.Conv.dsimp","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L161-L176"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.simpTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">simpTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. See the `simp?` tactic for more information. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.simpTrace","kind":"def","line":157,"name":"Lean.Parser.Tactic.Conv.simpTrace","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L157-L159"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.simp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">simp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp [thm]` performs simplification using `thm` and marked `@[simp]` lemmas.\nSee the `simp` tactic for more information. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.simp","kind":"def","line":152,"name":"Lean.Parser.Tactic.Conv.simp","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L152-L155"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.rewrite\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">rewrite</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rw [thm]` rewrites the target using `thm`. See the `rw` tactic for more information. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.rewrite","kind":"def","line":149,"name":"Lean.Parser.Tactic.Conv.rewrite","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L149-L150"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.pattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">pattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `pattern pat` traverses to the first subterm of the target that matches `pat`.\n* `pattern (occs := *) pat` traverses to every subterm of the target that matches `pat`\n  which is not contained in another match of `pat`. It generates one subgoal for each matching\n  subterm.\n* `pattern (occs := 1 2 4) pat` matches occurrences `1, 2, 4` of `pat` and produces three subgoals.\n  Occurrences are numbered left to right from the outside in.\n\nNote that skipping an occurrence of `pat` will traverse inside that subexpression, which means\nit may find more matches and this can affect the numbering of subsequent pattern matches.\nFor example, if we are searching for `f _` in `f (f a) = f b`:\n* `occs := 1 2` (and `occs := *`) returns `| f (f a)` and `| f b`\n* `occs := 2` returns `| f a`\n* `occs := 2 3` returns `| f a` and `| f b`\n* `occs := 1 3` is an error, because after skipping `f b` there is no third match.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.pattern","kind":"def","line":131,"name":"Lean.Parser.Tactic.Conv.pattern","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L131-L147"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.unfold\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">unfold</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n\nThis is the `conv` version of the `unfold` tactic.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.unfold","kind":"def","line":116,"name":"Lean.Parser.Tactic.Conv.unfold","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L116-L129"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.delta\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">delta</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`delta id1 id2 ...` unfolds all occurrences of `id1`, `id2`, ... in the target.\nLike the `delta` tactic, this ignores any definitional equations and uses\nprimitive delta-reduction instead, which may result in leaking implementation details.\nUsers should prefer `unfold` for unfolding definitions. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.delta","kind":"def","line":110,"name":"Lean.Parser.Tactic.Conv.delta","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L110-L114"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.change\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">change</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`change t'` replaces the target `t` with `t'`,\nassuming `t` and `t'` are definitionally equal. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.change","kind":"def","line":106,"name":"Lean.Parser.Tactic.Conv.change","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L106-L108"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.ext\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`ext x` traverses into a binder (a `fun x => e` or `∀ x, e` expression)\nto target `e`, introducing name `x` in the process. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.ext","kind":"def","line":102,"name":"Lean.Parser.Tactic.Conv.ext","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L102-L104"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.arg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">arg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `arg i` traverses into the `i`'th argument of the target. For example if the\n  target is `f a b c d` then `arg 1` traverses to `a` and `arg 3` traverses to `c`.\n  The index may be negative; `arg -1` traverses into the last argument,\n  `arg -2` into the second-to-last argument, and so on.\n* `arg @i` is the same as `arg i` but it counts all arguments instead of just the\n  explicit arguments.\n* `arg 0` traverses into the function. If the target is `f a b c d`, `arg 0` traverses into `f`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.arg","kind":"def","line":92,"name":"Lean.Parser.Tactic.Conv.arg","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L92-L100"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.argArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">argArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.argArg","kind":"def","line":90,"name":"Lean.Parser.Tactic.Conv.argArg","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L90-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.congr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">congr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Performs one step of \"congruence\", which takes a term and produces\nsubgoals for all the function arguments. For example, if the target is `f x y` then\n`congr` produces two subgoals, one for `x` and one for `y`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.congr","kind":"def","line":85,"name":"Lean.Parser.Tactic.Conv.congr","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L85-L88"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.reduce\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">reduce</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Puts term in normal form, this tactic is meant for debugging purposes only. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.reduce","kind":"def","line":82,"name":"Lean.Parser.Tactic.Conv.reduce","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L82-L83"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.zeta\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">zeta</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Expands let-declarations and let-variables. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.zeta","kind":"def","line":79,"name":"Lean.Parser.Tactic.Conv.zeta","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L79-L80"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.whnf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">whnf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Reduces the target to Weak Head Normal Form. This reduces definitions\nin \"head position\" until a constructor is exposed. For example, `List.map f [a, b, c]`\nweak head normalizes to `f a :: List.map f [b, c]`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.whnf","kind":"def","line":74,"name":"Lean.Parser.Tactic.Conv.whnf","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L74-L77"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.fun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">fun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Traverses into the function of a (unary) function application.\nFor example, `| f a b` turns into `| f a`. (Use `arg 0` to traverse into `f`.)  ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.fun","kind":"def","line":70,"name":"Lean.Parser.Tactic.Conv.fun","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L70-L72"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.rhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">rhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Traverses into the right subterm of a binary operator.\n\nIn general, for an `n`-ary operator, it traverses into the last argument.\nIt is a synonym for `arg -1`.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.rhs","kind":"def","line":62,"name":"Lean.Parser.Tactic.Conv.rhs","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L62-L68"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.lhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">lhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Traverses into the left subterm of a binary operator.\n\nIn general, for an `n`-ary operator, it traverses into the second to last argument.\nIt is a synonym for `arg -2`.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.lhs","kind":"def","line":54,"name":"Lean.Parser.Tactic.Conv.lhs","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L54-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.skip\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">skip</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`skip` does nothing. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.skip","kind":"def","line":51,"name":"Lean.Parser.Tactic.Conv.skip","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L51-L52"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.withAnnotateState\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">withAnnotateState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`with_annotate_state stx t` annotates the lexical range of `stx : Syntax` with\nthe initial and final state of running tactic `t`.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.withAnnotateState","kind":"def","line":43,"name":"Lean.Parser.Tactic.Conv.withAnnotateState","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L43-L48"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.occs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">occs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"An occurrence specification, either `*` or a list of numbers. The default is `[1]`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.occs","kind":"def","line":40,"name":"Lean.Parser.Tactic.Conv.occs","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L40-L41"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.occsIndexed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">occsIndexed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A list `1 2 4` of occurrences means to apply to the first, second, and fourth\noccurrence of the pattern.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.occsIndexed","kind":"def","line":34,"name":"Lean.Parser.Tactic.Conv.occsIndexed","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L34-L38"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.occsWildcard\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">occsWildcard</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `*` occurrence list means to apply to all occurrences of the pattern. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.occsWildcard","kind":"def","line":31,"name":"Lean.Parser.Tactic.Conv.occsWildcard","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L31-L32"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeq","kind":"def","line":29,"name":"Lean.Parser.Tactic.Conv.convSeq","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L29-L29"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeqBracketed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convSeqBracketed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeqBracketed","kind":"def","line":26,"name":"Lean.Parser.Tactic.Conv.convSeqBracketed","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L26-L26"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeq1Indented\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convSeq1Indented</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeq1Indented","kind":"def","line":25,"name":"Lean.Parser.Tactic.Conv.convSeq1Indented","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L25-L25"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Category.conv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">conv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>","info":{"doc":"`conv` is the syntax category for a \"conv tactic\", where \"conv\" is short\nfor conversion. A conv tactic is a program which receives a target, printed as\n`| a`, and is tasked with coming up with some term `b` and a proof of `a = b`.\nIt is mainly used for doing targeted term transformations, for example rewriting\nonly on the left side of an equality. ","docLink":"./Init/Conv.html#Lean.Parser.Category.conv","kind":"def","line":18,"name":"Lean.Parser.Category.conv","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L18-L23"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.conv.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">conv</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.conv.quot","kind":"def","line":18,"name":"Lean.Parser.Tactic.Conv.conv.quot","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Init/Conv.lean#L18-L23"}}],"imports":["Init.Tactics","Init.Meta"],"instances":[],"name":"Init.Conv"}