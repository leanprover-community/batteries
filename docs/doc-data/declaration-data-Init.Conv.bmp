{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.normCast\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">normCast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`norm_cast` tactic in `conv` mode. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.normCast","kind":"def","line":387,"name":"Lean.Parser.Tactic.Conv.normCast","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L387-L388"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.conv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">conv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.conv","kind":"def","line":372,"name":"Lean.Parser.Tactic.Conv.conv","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L372-L385"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.letToHave\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">letToHave</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Transforms `let` expressions into `have` expressions within the target expression when possible.\nThis is the conv mode version of the `let_to_have` tactic.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.letToHave","kind":"def","line":366,"name":"Lean.Parser.Tactic.Conv.letToHave","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L366-L370"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.liftLets\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">liftLets</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Lifts `let` and `have` expressions within the target expression as far out as possible.\nThis is the conv mode version of the `lift_lets` tactic.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.liftLets","kind":"def","line":360,"name":"Lean.Parser.Tactic.Conv.liftLets","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L360-L364"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.extractLets\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">extractLets</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Extracts `let` and `have` expressions from within the target expression.\nThis is the conv mode version of the `extract_lets` tactic.\n\n- `extract_lets` extracts all the lets from the target.\n- `extract_lets x y z` extracts all the lets from the target and uses `x`, `y`, and `z` for the first names.\n  Using `_` for a name leaves it unnamed.\n\nLimitation: the extracted local declarations do not persist outside of the `conv` goal.\nSee also `lift_lets`, which does not extract lets as local declarations.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.extractLets","kind":"def","line":347,"name":"Lean.Parser.Tactic.Conv.extractLets","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L347-L358"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRepeat_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convRepeat_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`repeat convs` runs the sequence `convs` repeatedly until it fails to apply. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRepeat_","kind":"def","line":342,"name":"Lean.Parser.Tactic.Conv.convRepeat_","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L342-L343"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.«conv_&lt;;&gt;_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">«conv_&lt;;&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">TrailingParserDescr</a></div></div>","info":{"doc":"`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal, concatenating all goals\nproduced by `tac'`.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.«conv_<;>_»","kind":"def","line":339,"name":"Lean.Parser.Tactic.Conv.«conv_<;>_»","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L339-L340"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTry_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convTry_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`try tac` runs `tac` and succeeds even if `tac` failed. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTry_","kind":"def","line":333,"name":"Lean.Parser.Tactic.Conv.convTry_","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L333-L333"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.first\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">first</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`first | conv | ...` runs each `conv` until one succeeds, or else fails. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.first","kind":"def","line":329,"name":"Lean.Parser.Tactic.Conv.first","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L329-L330"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convApply_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convApply_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `apply thm` conv tactic is the same as `apply thm` the tactic.\nThere are no restrictions on `thm`, but strange results may occur if `thm`\ncannot be reasonably interpreted as proving one equality from a list of others. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convApply_","kind":"def","line":327,"name":"Lean.Parser.Tactic.Conv.convApply_","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L327-L327"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.enter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">enter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`enter [arg, ...]` is a compact way to describe a path to a subterm.\nIt is a shorthand for other conv tactics as follows:\n* `enter [i]` is equivalent to `arg i`.\n* `enter [@i]` is equivalent to `arg @i`.\n* `enter [x]` (where `x` is an identifier) is equivalent to `ext x`.\n* `enter [in e]` (where `e` is a term) is equivalent to `pattern e`.\n  Occurrences can be specified with `enter [in (occs := ...) e]`.\nFor example, given the target `f (g a (fun x => x b))`, `enter [1, 2, x, 1]`\nwill traverse to the subterm `b`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.enter","kind":"def","line":312,"name":"Lean.Parser.Tactic.Conv.enter","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L312-L321"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.enterArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">enterArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.enterArg","kind":"def","line":310,"name":"Lean.Parser.Tactic.Conv.enterArg","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L310-L310"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.enterPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">enterPattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.enterPattern","kind":"def","line":308,"name":"Lean.Parser.Tactic.Conv.enterPattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L308-L308"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convIntro___\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convIntro___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`intro` traverses into binders. Synonym for `ext`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convIntro___","kind":"def","line":306,"name":"Lean.Parser.Tactic.Conv.convIntro___","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L306-L306"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRight\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convRight</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`right` traverses into the right argument. Synonym for `rhs`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRight","kind":"def","line":304,"name":"Lean.Parser.Tactic.Conv.convRight","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L304-L304"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convLeft\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convLeft</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`left` traverses into the left argument. Synonym for `lhs`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convLeft","kind":"def","line":302,"name":"Lean.Parser.Tactic.Conv.convLeft","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L302-L302"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convArgs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`args` traverses into all arguments. Synonym for `congr`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convArgs","kind":"def","line":300,"name":"Lean.Parser.Tactic.Conv.convArgs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L300-L300"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convErw__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convErw__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`erw [rules]` is a shorthand for `rw (transparency := .default) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convErw__","kind":"def","line":297,"name":"Lean.Parser.Tactic.Conv.convErw__","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L297-L297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRw__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convRw__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rw [rules]` applies the given list of rewrite rules to the target.\nSee the `rw` tactic for more information. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRw__","kind":"def","line":292,"name":"Lean.Parser.Tactic.Conv.convRw__","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L292-L292"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.failIfSuccess\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">failIfSuccess</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`fail_if_success t` fails if the tactic `t` succeeds. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.failIfSuccess","kind":"def","line":287,"name":"Lean.Parser.Tactic.Conv.failIfSuccess","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L287-L288"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.«conv·._»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">«conv·</span>.<span class=\"name\">_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`· conv` focuses on the main conv goal and tries to solve it using `s`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.«conv·._»","kind":"def","line":283,"name":"Lean.Parser.Tactic.Conv.«conv·._»","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L283-L283"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convConvSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convConvSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`conv => cs` runs `cs` in sequence on the target `t`,\nresulting in `t'`, which becomes the new target subgoal. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convConvSeq","kind":"def","line":278,"name":"Lean.Parser.Tactic.Conv.convConvSeq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L278-L280"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.focus\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">focus</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.focus","kind":"def","line":276,"name":"Lean.Parser.Tactic.Conv.focus","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L276-L276"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.«convNext__=&gt;_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">«convNext__=&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.«convNext__=>_»","kind":"def","line":270,"name":"Lean.Parser.Tactic.Conv.«convNext__=>_»","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L270-L270"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.case'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">case'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.case'","kind":"def","line":262,"name":"Lean.Parser.Tactic.Conv.case'","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L262-L263"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.case\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">case</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.case","kind":"def","line":253,"name":"Lean.Parser.Tactic.Conv.case","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L253-L254"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.anyGoals\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">anyGoals</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.anyGoals","kind":"def","line":243,"name":"Lean.Parser.Tactic.Conv.anyGoals","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L243-L244"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.allGoals\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">allGoals</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.allGoals","kind":"def","line":236,"name":"Lean.Parser.Tactic.Conv.allGoals","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L236-L237"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTrace_state\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convTrace_state</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`trace_state` prints the current goal state. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTrace_state","kind":"def","line":233,"name":"Lean.Parser.Tactic.Conv.convTrace_state","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L233-L233"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convDone\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convDone</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`done` succeeds iff there are no goals remaining. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convDone","kind":"def","line":230,"name":"Lean.Parser.Tactic.Conv.convDone","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L230-L230"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRfl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convRfl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rfl` closes one conv goal \"trivially\", by using reflexivity\n(that is, no rewriting). ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRfl","kind":"def","line":227,"name":"Lean.Parser.Tactic.Conv.convRfl","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L227-L227"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.paren\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">paren</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`(convs)` runs the `convs` in sequence on the current list of targets.\nThis is pure grouping with no added effects. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.paren","kind":"def","line":221,"name":"Lean.Parser.Tactic.Conv.paren","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L221-L223"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedConv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">nestedConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`{ convs }` runs the list of `convs` on the current target, and any subgoals that\nremain are trivially closed by `skip`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedConv","kind":"def","line":217,"name":"Lean.Parser.Tactic.Conv.nestedConv","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L217-L219"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Executes the given conv block without converting regular goal into a `conv` goal. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTactic","kind":"def","line":214,"name":"Lean.Parser.Tactic.Conv.convTactic","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L214-L215"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">nestedTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Focuses, converts the `conv` goal `⊢ lhs` into a regular goal `⊢ lhs = rhs`, and then executes the given tactic block. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedTactic","kind":"def","line":211,"name":"Lean.Parser.Tactic.Conv.nestedTactic","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L211-L212"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedTacticCore\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">nestedTacticCore</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Executes the given tactic block without converting `conv` goal into a regular goal. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedTacticCore","kind":"def","line":208,"name":"Lean.Parser.Tactic.Conv.nestedTacticCore","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L208-L209"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.clear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Removes one or more hypotheses from the local context. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.clear","kind":"def","line":205,"name":"Lean.Parser.Tactic.Conv.clear","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L205-L206"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.simpMatch\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">simpMatch</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp_match` simplifies match expressions. For example,\n```\nmatch [a, b] with\n| [] => 0\n| hd :: tl => hd\n```\nsimplifies to `a`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.simpMatch","kind":"def","line":196,"name":"Lean.Parser.Tactic.Conv.simpMatch","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L196-L203"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.dsimpTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">dsimpTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. See the `simp?` tactic for more information. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.dsimpTrace","kind":"def","line":193,"name":"Lean.Parser.Tactic.Conv.dsimpTrace","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L193-L194"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.dsimp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">dsimp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`dsimp` is the definitional simplifier in `conv`-mode. It differs from `simp` in that it only\napplies theorems that hold by reflexivity.\n\nExamples:\n\n```lean\nexample (a : Nat): (0 + 0) = a - a := by\n  conv =>\n    lhs\n    dsimp\n    rw [← Nat.sub_self a]\n```\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.dsimp","kind":"def","line":176,"name":"Lean.Parser.Tactic.Conv.dsimp","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L176-L191"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.simpTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">simpTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. See the `simp?` tactic for more information. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.simpTrace","kind":"def","line":172,"name":"Lean.Parser.Tactic.Conv.simpTrace","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L172-L174"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.simp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">simp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp [thm]` performs simplification using `thm` and marked `@[simp]` lemmas.\nSee the `simp` tactic for more information. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.simp","kind":"def","line":167,"name":"Lean.Parser.Tactic.Conv.simp","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L167-L170"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.rewrite\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">rewrite</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rw [thm]` rewrites the target using `thm`. See the `rw` tactic for more information. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.rewrite","kind":"def","line":164,"name":"Lean.Parser.Tactic.Conv.rewrite","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L164-L165"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.pattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">pattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `pattern pat` traverses to the first subterm of the target that matches `pat`.\n* `pattern (occs := *) pat` traverses to every subterm of the target that matches `pat`\n  which is not contained in another match of `pat`. It generates one subgoal for each matching\n  subterm.\n* `pattern (occs := 1 2 4) pat` matches occurrences `1, 2, 4` of `pat` and produces three subgoals.\n  Occurrences are numbered left to right from the outside in.\n\nNote that skipping an occurrence of `pat` will traverse inside that subexpression, which means\nit may find more matches and this can affect the numbering of subsequent pattern matches.\nFor example, if we are searching for `f _` in `f (f a) = f b`:\n* `occs := 1 2` (and `occs := *`) returns `| f (f a)` and `| f b`\n* `occs := 2` returns `| f a`\n* `occs := 2 3` returns `| f a` and `| f b`\n* `occs := 1 3` is an error, because after skipping `f b` there is no third match.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.pattern","kind":"def","line":146,"name":"Lean.Parser.Tactic.Conv.pattern","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L146-L162"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.unfold\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">unfold</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n\nThis is the `conv` version of the `unfold` tactic.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.unfold","kind":"def","line":131,"name":"Lean.Parser.Tactic.Conv.unfold","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L131-L144"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.delta\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">delta</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`delta id1 id2 ...` unfolds all occurrences of `id1`, `id2`, ... in the target.\nLike the `delta` tactic, this ignores any definitional equations and uses\nprimitive delta-reduction instead, which may result in leaking implementation details.\nUsers should prefer `unfold` for unfolding definitions. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.delta","kind":"def","line":125,"name":"Lean.Parser.Tactic.Conv.delta","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L125-L129"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.change\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">change</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`change t'` replaces the target `t` with `t'`,\nassuming `t` and `t'` are definitionally equal. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.change","kind":"def","line":121,"name":"Lean.Parser.Tactic.Conv.change","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L121-L123"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.ext\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`ext x` traverses into a binder (a `fun x => e` or `∀ x, e` expression)\nto target `e`, introducing name `x` in the process. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.ext","kind":"def","line":117,"name":"Lean.Parser.Tactic.Conv.ext","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L117-L119"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.arg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">arg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `arg i` traverses into the `i`'th argument of the target. For example if the\n  target is `f a b c d` then `arg 1` traverses to `a` and `arg 3` traverses to `c`.\n  The index may be negative; `arg -1` traverses into the last argument,\n  `arg -2` into the second-to-last argument, and so on.\n* `arg @i` is the same as `arg i` but it counts all arguments instead of just the\n  explicit arguments.\n* `arg 0` traverses into the function. If the target is `f a b c d`, `arg 0` traverses into `f`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.arg","kind":"def","line":107,"name":"Lean.Parser.Tactic.Conv.arg","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L107-L115"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.argArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">argArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.argArg","kind":"def","line":105,"name":"Lean.Parser.Tactic.Conv.argArg","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L105-L105"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.congr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">congr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Performs one step of \"congruence\", which takes a term and produces\nsubgoals for all the function arguments. For example, if the target is `f x y` then\n`congr` produces two subgoals, one for `x` and one for `y`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.congr","kind":"def","line":100,"name":"Lean.Parser.Tactic.Conv.congr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L100-L103"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.reduce\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">reduce</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Puts term in normal form, this tactic is meant for debugging purposes only. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.reduce","kind":"def","line":97,"name":"Lean.Parser.Tactic.Conv.reduce","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L97-L98"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.zeta\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">zeta</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Expands let-declarations and let-variables. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.zeta","kind":"def","line":94,"name":"Lean.Parser.Tactic.Conv.zeta","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L94-L95"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.whnf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">whnf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Reduces the target to Weak Head Normal Form. This reduces definitions\nin \"head position\" until a constructor is exposed. For example, `List.map f [a, b, c]`\nweak head normalizes to `f a :: List.map f [b, c]`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.whnf","kind":"def","line":89,"name":"Lean.Parser.Tactic.Conv.whnf","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L89-L92"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.fun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">fun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Traverses into the function of a (unary) function application.\nFor example, `| f a b` turns into `| f a`. (Use `arg 0` to traverse into `f`.)  ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.fun","kind":"def","line":85,"name":"Lean.Parser.Tactic.Conv.fun","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L85-L87"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.rhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">rhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Traverses into the right subterm of a binary operator.\n\nIn general, for an `n`-ary operator, it traverses into the last argument.\nIt is a synonym for `arg -1`.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.rhs","kind":"def","line":77,"name":"Lean.Parser.Tactic.Conv.rhs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L77-L83"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.lhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">lhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Traverses into the left subterm of a binary operator.\n\nIn general, for an `n`-ary operator, it traverses into the second to last argument.\nIt is a synonym for `arg -2`.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.lhs","kind":"def","line":69,"name":"Lean.Parser.Tactic.Conv.lhs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L69-L75"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.cbv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">cbv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`cbv` performs simplification that closely mimics call-by-value evaluation.\nIt reduces the target term by unfolding definitions using their defining equations and\napplying matcher equations. The unfolding is propositional, so `cbv` also works\nwith functions defined via well-founded recursion or partial fixpoints.\n\nThe proofs produced by `cbv` only use the three standard axioms.\nIn particular, they do not require trust in the correctness of the code\ngenerator.\n\nThis tactic is experimental and its behavior is likely to change in upcoming\nreleases of Lean.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.cbv","kind":"def","line":54,"name":"Lean.Parser.Tactic.Conv.cbv","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L54-L67"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.skip\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">skip</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`skip` does nothing. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.skip","kind":"def","line":51,"name":"Lean.Parser.Tactic.Conv.skip","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L51-L52"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.withAnnotateState\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">withAnnotateState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`with_annotate_state stx t` annotates the lexical range of `stx : Syntax` with\nthe initial and final state of running tactic `t`.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.withAnnotateState","kind":"def","line":43,"name":"Lean.Parser.Tactic.Conv.withAnnotateState","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L43-L48"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.occs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">occs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"An occurrence specification, either `*` or a list of numbers. The default is `[1]`. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.occs","kind":"def","line":40,"name":"Lean.Parser.Tactic.Conv.occs","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L40-L41"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.occsIndexed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">occsIndexed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A list `1 2 4` of occurrences means to apply to the first, second, and fourth\noccurrence of the pattern.\n","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.occsIndexed","kind":"def","line":34,"name":"Lean.Parser.Tactic.Conv.occsIndexed","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L34-L38"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.occsWildcard\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">occsWildcard</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `*` occurrence list means to apply to all occurrences of the pattern. ","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.occsWildcard","kind":"def","line":31,"name":"Lean.Parser.Tactic.Conv.occsWildcard","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L31-L32"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeq","kind":"def","line":29,"name":"Lean.Parser.Tactic.Conv.convSeq","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L29-L29"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeqBracketed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convSeqBracketed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeqBracketed","kind":"def","line":26,"name":"Lean.Parser.Tactic.Conv.convSeqBracketed","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L26-L26"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeq1Indented\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">convSeq1Indented</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeq1Indented","kind":"def","line":25,"name":"Lean.Parser.Tactic.Conv.convSeq1Indented","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L25-L25"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Category.conv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">conv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>","info":{"doc":"`conv` is the syntax category for a \"conv tactic\", where \"conv\" is short\nfor conversion. A conv tactic is a program which receives a target, printed as\n`| a`, and is tasked with coming up with some term `b` and a proof of `a = b`.\nIt is mainly used for doing targeted term transformations, for example rewriting\nonly on the left side of an equality. ","docLink":"./Init/Conv.html#Lean.Parser.Category.conv","kind":"def","line":18,"name":"Lean.Parser.Category.conv","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L18-L23"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Conv.html#Lean.Parser.Tactic.Conv.conv.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">conv</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.conv.quot","kind":"def","line":18,"name":"Lean.Parser.Tactic.Conv.conv.quot","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Conv.lean#L18-L23"}}],"imports":["Init.Tactics","Init.Meta"],"instances":[],"name":"Init.Conv"}