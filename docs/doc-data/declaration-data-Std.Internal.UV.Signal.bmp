{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal.cancel\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">Signal</span>.<span class=\"name\">cancel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">signal</span> : <a href=\"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal\">Signal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"This function has different behavior depending on the state of the `Signal`:\n- If it is initial or finished this is a no-op.\n- If it's running then it drops the accept promise and if it's not repeatable it sets\n  the signal handler to the initial state.\n","docLink":"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal.cancel","kind":"opaque","line":80,"name":"Std.Internal.UV.Signal.cancel","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Internal/UV/Signal.lean#L80-L87"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal.stop\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">Signal</span>.<span class=\"name\">stop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">signal</span> : <a href=\"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal\">Signal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"This function has different behavior depending on the state of the `Signal`:\n- If it is initial or finished this is a no-op.\n- If it is running the signal handler is stopped and it is put into the finished state.\n  Note that if the last `IO.Promise` generated by `next` is unresolved and being waited\n  on this creates a memory leak and the waiting task is not going to be awoken anymore.\n","docLink":"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal.stop","kind":"opaque","line":70,"name":"Std.Internal.UV.Signal.stop","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Internal/UV/Signal.lean#L70-L78"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal.next\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">Signal</span>.<span class=\"name\">next</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">signal</span> : <a href=\"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal\">Signal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <span class=\"fn\">(<a href=\"./Init/System/Promise.html#IO.Promise\">IO.Promise</a> <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span></div></div>","info":{"doc":"This function has different behavior depending on the state and configuration of the `Signal`:\n- if `repeating` is `false` and:\n  - it is initial, start listening and return a new `IO.Promise` that is set to resolve once\n    the signal `signum` is received. After this `IO.Promise` is resolved the `Signal` is finished.\n  - it is running or finished, return the same `IO.Promise` that the first call to `next` returned.\n- if `repeating` is `true` and:\n  - it is initial, start listening and return a new `IO.Promise` that resolves when the next\n    signal `signum` is received.\n  - it is running, check whether the last returned `IO.Promise` is already resolved:\n     - If it is, return a new `IO.Promise` that resolves upon receiving the next signal\n     - If it is not, return the last `IO.Promise`\n     This ensures that the returned `IO.Promise` resolves at the next occurrence of the signal.\n  - if it is finished, return the last `IO.Promise` created by `next`. Notably this could be one\n    that never resolves if the signal handler was stopped before fulfilling the last one.\n\nThe resolved `IO.Promise` contains the signal number that was received.\n","docLink":"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal.next","kind":"opaque","line":49,"name":"Std.Internal.UV.Signal.next","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Internal/UV/Signal.lean#L49-L68"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">Signal</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">signum</span> : <a href=\"./Init/Data/SInt/Basic.html#Int32\">Int32</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">repeating</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal\">Signal</a></span></div></div>","info":{"doc":"This creates a `Signal` in the initial state and doesn't start listening yet.\n- If `repeating` is `false` this constructs a signal handler that resolves once when the specified\n  signal `signum` is received, then automatically stops listening.\n- If `repeating` is `true` this constructs a signal handler that resolves each time the specified\n  signal `signum` is received and continues listening. A repeating signal handler will only be\n  freed after `Signal.stop` is called.\n","docLink":"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal.mk","kind":"opaque","line":38,"name":"Std.Internal.UV.Signal.mk","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Internal/UV/Signal.lean#L38-L47"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Signal.html#Std.Internal.UV.instNonemptySignal\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">instNonemptySignal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <a href=\"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal\">Signal</a></span></div></div>","info":{"doc":"","docLink":"./Std/Internal/UV/Signal.html#Std.Internal.UV.instNonemptySignal","kind":"instance","line":34,"name":"Std.Internal.UV.instNonemptySignal","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Internal/UV/Signal.lean#L34-L34"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal\"><span class=\"name\">Std</span>.<span class=\"name\">Internal</span>.<span class=\"name\">UV</span>.<span class=\"name\">Signal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"`Signal`s are used to generate `IO.Promise`s that resolve when a specific signal is received.\n\nA `Signal` can be in one of 3 states:\n- Right after construction it's initial.\n- While it is listening for signals it's running.\n- If it has stopped for some reason it's finished.\n\nThis together with whether it was set up as `repeating` with `Signal.mk` determines the behavior\nof all functions on `Signal`s.\n","docLink":"./Std/Internal/UV/Signal.html#Std.Internal.UV.Signal","kind":"def","line":21,"name":"Std.Internal.UV.Signal","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Internal/UV/Signal.lean#L21-L32"}}],"imports":["Init.System.Promise","Init.Data.SInt","Std.Net"],"instances":[{"className":"Nonempty","name":"Std.Internal.UV.instNonemptySignal","typeNames":["Std.Internal.UV.Signal"]}],"name":"Std.Internal.UV.Signal"}