{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.propagateMatchCondDown\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">propagateMatchCondDown</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator\">Propagator</a></div></div>","info":{"doc":"Propagates `MatchCond` downwards ","docLink":"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.propagateMatchCondDown","kind":"def","line":425,"name":"Lean.Meta.Grind.propagateMatchCondDown","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/MatchCond.lean#L425-L429"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.propagateMatchCondUp\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">propagateMatchCondUp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator\">Propagator</a></div></div>","info":{"doc":"Propagates `MatchCond` upwards ","docLink":"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.propagateMatchCondUp","kind":"def","line":412,"name":"Lean.Meta.Grind.propagateMatchCondUp","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/MatchCond.lean#L412-L423"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.tryToProveFalse\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">tryToProveFalse</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM\">GoalM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Given a `match`-expression condition `e` that is known to be equal to `True`,\ntry to close the goal by proving `False`. We use the following to example to illustrate\nthe purpose of this function.\n```\ndef f : List Nat → List Nat → Nat\n  | _, 1 :: _ :: _ => 1\n  | _, _ :: _ => 2\n  | _, _  => 0\n\nexample : z = a :: as → y = z → f x y > 0 := by\n  grind [f.eq_def]\n```\nAfter `grind` unfolds `f`, it case splits on the `match`-expression producing\nthree subgoals. The first two are easily closed by it. In the third one,\nwe have the following two `match`-expression conditions stating that we\nare **not** in the first and second cases.\n```\nLean.Grind.MatchCond (∀ (head : Nat) (tail : List Nat), x✝² = 1 :: head :: tail → False)\nLean.Grind.MatchCond (∀ (head : Nat) (tail : List Nat), x✝² = head :: tail → False)\n```\nMoreover, we have the following equivalence class.\n```\n{z, y, x✝², a :: as}\n```\nThus, we can close the goal by using the second `match`-expression condition,\nwe just have to instantiate `head` and `tail` with `a` and `as` respectively,\nand use the fact that `x✝²` is equal to `a :: as`.\n","docLink":"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.tryToProveFalse","kind":"def","line":323,"name":"Lean.Meta.Grind.tryToProveFalse","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/MatchCond.lean#L323-L410"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.collectMatchCondLhssAndAbstract\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Grind</span>.<span class=\"name\">collectMatchCondLhssAndAbstract</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matchCond</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM\">GoalM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></div></div>","info":{"doc":"Given `e` a `match`-expression condition, returns the left-hand side\nof the ground equations, **and** function application that abstracts the left-hand sides.\nAs an example, assume we have a `match`-expression condition `C₁` of the form\n```\nGrind.MatchCond (∀ y₁ y₂ y₃, t = .mk₁ y₁ → s = .mk₂ y₂ y₃ → False)\n```\nthen the result returned by this function is\n```\n(#[t, s], (fun x₁ x₂ => (∀ y₁ y₂ y₃, x₁ = .mk₁ y₁ → x₂ = .mk₂ y₂ y₃ → False)) t s)\n```\nNote that the returned expression is definitionally equal to `C₁`.\nWe use this expression to detect whether two different `match`-expression conditions are\ncongruent.\nFor example, suppose we also have the `match`-expression `C₂` of the form\n```\nGrind.MatchCond (∀ y₁ y₂ y₃, a = .mk₁ y₁ → b = .mk₂ y₂ y₃ → False)\n```\nThis function would return\n```\n(#[a, b], (fun x₁ x₂ => (∀ y₁ y₂ y₃, x₁ = .mk₁ y₁ → x₂ = .mk₂ y₂ y₃ → False)) a b)\n```\nNote that the lambda abstraction is identical to the first one. Let's call it `l`.\nThus, we can write the two pairs above as\n- `(#[t, s], l t s)`\n- `(#[a, b], l a b)`\nMoreover, `C₁` is definitionally equal to `l t s`, and `C₂` is definitionally equal to `l a b`.\nThen, if `grind` infers that `t = a` and `s = b`, it will detect that `l t s` and `l a b` are\nequal by congruence, and consequently `C₁` is equal to `C₂`.\n\nGruesome details for heterogeneous equalities.\n\nWhen pattern matching on indexing families, the generated conditions often use heterogeneous equalities. Here is an example:\n```\n(∀ (x : Vec α 0), n = 0 → as ≍ Vec.nil → bs ≍ x → False)\n```\nIn this case, it is not sufficient to abstract the left-hand side. We also have\nto abstract its type. The following is produced in this case.\n```\n(#[n, Vec α n, as, Vec α n, bs],\n (fun (x_0 : Nat) (ty_1 : Type u_1) (x_1 : ty_1) (ty_2 : Type u_1) (x_2 : ty_2) =>\n    ∀ (x : Vec α 0), x_0 = 0 → x_1 ≍ Vec.nil → x_2 ≍ x → False)\n n (Vec α n) as (Vec α n) bs)\n```\nThe example makes it clear why this is needed, `as` and `bs` depend on `n`.\nNote that we can abstract the type without introducing type errors because\nheterogeneous equality is used for `as` and `bs`.\n","docLink":"./Lean/Meta/Tactic/Grind/MatchCond.html#Lean.Meta.Grind.collectMatchCondLhssAndAbstract","kind":"def","line":123,"name":"Lean.Meta.Grind.collectMatchCondLhssAndAbstract","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Meta/Tactic/Grind/MatchCond.lean#L123-L198"}}],"imports":["Lean.Meta.Tactic.Grind.Types","Init.Grind","Init.Simproc","Lean.Meta.Tactic.Contradiction","Lean.Meta.Tactic.Grind.ProveEq","Lean.Meta.Tactic.Grind.PropagatorAttr"],"instances":[],"name":"Lean.Meta.Tactic.Grind.MatchCond"}