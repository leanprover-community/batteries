{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Init.html#Batteries.Tactic.Conv.equals\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">equals</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The `conv` tactic `equals` claims that the currently focused subexpression is equal\n to the given expression, and proves this claim using the given tactic.\n```\nexample (P : (Nat → Nat) → Prop) : P (fun n => n - n) := by\n  conv in (_ - _) => equals 0 =>\n    -- current goal: ⊢ n - n = 0\n    apply Nat.sub_self\n  -- current goal: P (fun n => 0)\n```\n","docLink":"./Batteries/Tactic/Init.html#Batteries.Tactic.Conv.equals","kind":"def","line":104,"name":"Batteries.Tactic.Conv.equals","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/Init.lean#L104-L122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Init.html#Batteries.Tactic.Conv.exact\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">exact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`conv` tactic to close a goal using an equality theorem. ","docLink":"./Batteries/Tactic/Init.html#Batteries.Tactic.Conv.exact","kind":"def","line":102,"name":"Batteries.Tactic.Conv.exact","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/Init.lean#L102-L102"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Init.html#Batteries.Tactic.triv\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">triv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Deprecated variant of `trivial`. ","docLink":"./Batteries/Tactic/Init.html#Batteries.Tactic.triv","kind":"def","line":98,"name":"Batteries.Tactic.triv","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/Init.lean#L98-L99"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Init.html#Batteries.Tactic.tacticEapply_\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticEapply_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eapply e` is like `apply e` but it does not add subgoals for variables that appear\nin the types of other goals. Note that this can lead to a failure where there are\nno goals remaining but there are still metavariables in the term:\n```\nexample (h : ∀ x : Nat, x = x → True) : True := by\n  eapply h\n  rfl\n  -- no goals\n-- (kernel) declaration has metavariables '_example'\n```\n","docLink":"./Batteries/Tactic/Init.html#Batteries.Tactic.tacticEapply_","kind":"def","line":83,"name":"Batteries.Tactic.tacticEapply_","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/Init.lean#L83-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Init.html#Batteries.Tactic.tacticFapply_\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticFapply_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`fapply e` is like `apply e` but it adds goals in the order they appear,\nrather than putting the dependent goals first.\n","docLink":"./Batteries/Tactic/Init.html#Batteries.Tactic.tacticFapply_","kind":"def","line":76,"name":"Batteries.Tactic.tacticFapply_","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/Init.lean#L76-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Init.html#Batteries.Tactic.tacticSplit_ands\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSplit_ands</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`split_ands` applies `And.intro` until it does not make progress. ","docLink":"./Batteries/Tactic/Init.html#Batteries.Tactic.tacticSplit_ands","kind":"def","line":72,"name":"Batteries.Tactic.tacticSplit_ands","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/Init.lean#L72-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Init.html#Batteries.Tactic.tacticAbsurd_\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticAbsurd_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Given a proof `h` of `p`, `absurd h` changes the goal to `⊢ ¬ p`.\nIf `p` is a negation `¬q` then the goal is changed to `⊢ q` instead.\n","docLink":"./Batteries/Tactic/Init.html#Batteries.Tactic.tacticAbsurd_","kind":"def","line":65,"name":"Batteries.Tactic.tacticAbsurd_","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/Init.lean#L65-L70"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Init.html#Batteries.Tactic.byContra\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">byContra</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`by_contra h` proves `⊢ p` by contradiction,\nintroducing a hypothesis `h : ¬p` and proving `False`.\n* If `p` is a negation `¬q`, `h : q` will be introduced instead of `¬¬q`.\n* If `p` is decidable, it uses `Decidable.byContradiction` instead of `Classical.byContradiction`.\n* If `h` is omitted, the introduced variable will be called `this`.\n","docLink":"./Batteries/Tactic/Init.html#Batteries.Tactic.byContra","kind":"def","line":47,"name":"Batteries.Tactic.byContra","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/Init.lean#L47-L54"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Init.html#Batteries.Tactic.tacticBy_contra_core\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticBy_contra_core</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`by_contra_core` is the component of `by_contra` that turns the goal into the form `p → False`.\n`by_contra h` is defined as `by_contra_core` followed by `rintro h`.\n* If the goal is a negation `¬q`, the goal becomes `q → False`.\n* If the goal has a `Decidable` instance, it uses `Decidable.byContradiction` instead of\n  `Classical.byContradiction`.\n","docLink":"./Batteries/Tactic/Init.html#Batteries.Tactic.tacticBy_contra_core","kind":"def","line":42,"name":"Batteries.Tactic.tacticBy_contra_core","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/Init.lean#L42-L45"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Init.html#Batteries.Tactic.exacts\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">exacts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.\n","docLink":"./Batteries/Tactic/Init.html#Batteries.Tactic.exacts","kind":"def","line":27,"name":"Batteries.Tactic.exacts","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/Init.lean#L27-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Tactic/Init.html#Batteries.Tactic.tactic_\"><span class=\"name\">Batteries</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tactic_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`_` in tactic position acts like the `done` tactic: it fails and gives the list\nof goals if there are any. It is useful as a placeholder after starting a tactic block\nsuch as `by _` to make it syntactically correct and show the current goal.\n","docLink":"./Batteries/Tactic/Init.html#Batteries.Tactic.tactic_","kind":"def","line":25,"name":"Batteries.Tactic.tactic_","sourceLink":"https://github.com/leanprover-community/batteries/blob/77d10578945b31d794214a66937b75a6d4311674/Batteries/Tactic/Init.lean#L25-L25"}}],"imports":["Init","Lean.Elab.Tactic.ElabTerm","Lean.Meta.MatchUtil"],"instances":[],"name":"Batteries.Tactic.Init"}