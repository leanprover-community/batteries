{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.mapMwith\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">Positions</span>.<span class=\"name\">mapMwith</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">γ</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u_1 → <a href=\"./foundational_types.html\">Type</a> u_4</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">β</span></span> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">γ</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">positions</span> : <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions\">Positions</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ys</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">γ</span>)</span></span></div></div>","info":{"doc":"Let `positions.size = ys.size` and `positions.numIndices = xs.size`. Maps `f` over each `y` in `ys`,\nalso passing in those elements `xs` that belong to that are those elements of `xs` that belong to\n`y` according to `positions`.\n","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.mapMwith","kind":"def","line":82,"name":"Lean.Elab.Structural.Positions.mapMwith","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L82-L91"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.groupAndSort\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">Positions</span>.<span class=\"name\">groupAndSort</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ys</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions\">Positions</a></div></div>","info":{"doc":"Groups the `xs` by their `f` value, and puts these groups into the order given by `ys`.\n","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.groupAndSort","kind":"def","line":72,"name":"Lean.Elab.Structural.Positions.groupAndSort","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L72-L80"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.numIndices\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">Positions</span>.<span class=\"name\">numIndices</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">positions</span> : <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions\">Positions</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"The number of indices in the array.\n","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions.numIndices","kind":"def","line":66,"name":"Lean.Elab.Structural.Positions.numIndices","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L66-L70"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">Positions</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Lets say we have `n` mutually recursive functions whose recursive arguments are from a group\nof `m` mutually inductive data types. This mapping does not have to be one-to-one: for one type\nthere can be zero, one or more functions. We use the logic in the `FunPacker` modules to combine\nthe bodies (and motives) of multiple such functions.\n\nTherefore we have to take the `n` functions, group them by their recursive argument's type,\nand for each such type, keep track of the order of the functions.\n\nWe represent these positions as an `Array (Array Nat)`. We have that\n\n* `positions.size = indInfo.numTypeFormers`\n* `positions.flatten` is a permutation of `[0:n]`, so each of the `n` functions has exactly one\n  position, and each position refers to one of the `n` functions.\n* if `k ∈ positions[i]` then the recursive argument of function `k` is has type `indInfo.all[i]`\n  (or corresponding nested inductive type)\n\n","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.Positions","kind":"def","line":46,"name":"Lean.Elab.Structural.Positions","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L46-L64"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.recArgHasLooseBVarsAt\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">recArgHasLooseBVarsAt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recFnName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">recArgPos</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Return true iff `e` contains an application `recFnName .. t ..` where the term `t` is\nthe argument we are trying to recurse on, and it contains loose bound variables.\n\nWe use this test to decide whether we should process a matcher-application as a regular\napplication or not. That is, whether we should push the `below` argument should be affected by the matcher or not.\nIf `e` does not contain an application of the form `recFnName .. t ..`, then we know\nthe recursion doesn't depend on any pattern variable in this matcher.\n","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.recArgHasLooseBVarsAt","kind":"def","line":31,"name":"Lean.Elab.Structural.recArgHasLooseBVarsAt","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L31-L43"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.run\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">run</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.M\">M</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State\">State</a> := <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.mk\">{</a> <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.mk\">}</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State\">State</a>)</span></div></div>","info":{"doc":"","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.run","kind":"def","line":28,"name":"Lean.Elab.Structural.run","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L28-L29"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.instInhabitedM\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">instInhabitedM</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.M\">M</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.instInhabitedM","kind":"instance","line":25,"name":"Lean.Elab.Structural.instInhabitedM","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L25-L26"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.M\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">M</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.M","kind":"def","line":23,"name":"Lean.Elab.Structural.M","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L23-L23"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.addMatchers\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">State</span>.<span class=\"name\">addMatchers</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a>)</span></span></div></div>","info":{"doc":"As part of the inductive predicates case, we keep adding more and more discriminants from the\nlocal context and build up a bigger matcher application until we reach a fixed point.\nAs a side-effect, this creates matchers. Here we capture all these side-effects, because\nthe construction rolls back any changes done to the environment and the side-effects\nneed to be replayed. ","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.addMatchers","kind":"def","line":21,"name":"Lean.Elab.Structural.State.addMatchers","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L21-L21"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">State</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">addMatchers</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State\">State</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.mk","kind":"ctor","line":15,"name":"Lean.Elab.Structural.State.mk","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L15-L15"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Structural</span>.<span class=\"name\">State</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State","kind":"structure","line":15,"name":"Lean.Elab.Structural.State","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L15-L21"}}],"imports":["Lean.Meta.ForEachExpr"],"instances":[{"className":"Inhabited","name":"Lean.Elab.Structural.instInhabitedM","typeNames":["Lean.Elab.Structural.M"]}],"name":"Lean.Elab.PreDefinition.Structural.Basic"}