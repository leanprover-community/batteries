{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Lint.html#Lean.Grind.grindLintSkip\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">grindLintSkip</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`#grind_lint skip thm₁ …` marks the given theorem(s) to be skipped entirely by `#grind_lint check`.\nSkipped theorems are neither analyzed nor reported, but may still be used for\ninstantiation when analyzing other theorems.\n\n`#grind_lint skip suffix name₁ …` marks all theorems with the given suffix(es) to be skipped.\nFor example, `#grind_lint skip suffix foo` will skip `bar.foo`, `qux.foo`, etc.\n\nExamples:\n```\n#grind_lint skip Array.range_succ\n#grind_lint skip suffix append\n```\n","docLink":"./Init/Grind/Lint.html#Lean.Grind.grindLintSkip","kind":"def","line":75,"name":"Lean.Grind.grindLintSkip","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Lint.lean#L75-L89"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Lint.html#Lean.Grind.grindLintMute\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">grindLintMute</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`#grind_lint mute thm₁ …` marks the given theorem(s) as *muted* during linting.\n\nMuted theorems remain in the environment but are not instantiated when running\n`#grind_lint check` or `#grind_lint inspect`.\nThis is useful for suppressing noisy or recursive lemmas that cause excessive\nE-matching without removing their annotations.\n\nExample:\n```\n#grind_lint mute Array.zip_map Int.zero_shiftRight\n```\n","docLink":"./Init/Grind/Lint.html#Lean.Grind.grindLintMute","kind":"def","line":60,"name":"Lean.Grind.grindLintMute","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Lint.lean#L60-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Lint.html#Lean.Grind.grindLintInspect\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">grindLintInspect</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`#grind_lint inspect thm₁ …` analyzes the specified theorem(s) individually.\n\nIt always prints detailed statistics regardless of thresholds and is useful\nfor investigating specific `grind` lemmas that may generate excessive\ninstantiations.\nExamples:\n```\n#grind_lint inspect Array.zip_map\n```\nYou can use `set_option trace.grind.ematch.instance true` to instruct `grind` to display the\nactual instances it produces.\n","docLink":"./Init/Grind/Lint.html#Lean.Grind.grindLintInspect","kind":"def","line":45,"name":"Lean.Grind.grindLintInspect","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Lint.lean#L45-L58"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Lint.html#Lean.Grind.grindLintCheck\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">grindLintCheck</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`#grind_lint check` analyzes all theorems annotated for theorem instantiation using E-matching.\n\nIt creates artificial goals and reports the number of instances each theorem produces.\nThe command helps detect long or unbounded theorem instantiation chains.\n\nUsage examples:\n```\n#grind_lint check\n#grind_lint check (min:=10) (detailed:=50)\n#grind_lint check in Foo Bar -- restrict analysis to these namespaces\n#grind_lint check in module Foo -- restrict analysis to theorems defined in module `Foo` or any of its submodules\n```\n\nOptions can include any valid `grind` configuration option, and `min` and `detailed`.\n- `min`:      minimum number of instantiations to print a summary (default: 10)\n- `detailed`: minimum number of instantiations to print detailed breakdown (default: 50)\nIf the option `trace.grind.*` is enabled, additional details are printed.\n\nBy default, `#grind_lint` uses the following `grind` configuration:\n```\n  splits       := 0\n  lookahead    := false\n  mbtc         := false\n  ematch       := 20\n  instances    := 100\n  gen          := 10\n```\nConsider using `#grind_lint inspect <thm>` to focus on specific theorems.\n","docLink":"./Init/Grind/Lint.html#Lean.Grind.grindLintCheck","kind":"def","line":13,"name":"Lean.Grind.grindLintCheck","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Init/Grind/Lint.lean#L13-L43"}}],"imports":["Init.Tactics"],"instances":[],"name":"Init.Grind.Lint"}