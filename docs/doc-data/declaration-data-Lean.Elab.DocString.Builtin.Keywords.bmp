{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.suggestKw\"><span class=\"name\">Lean</span>.<span class=\"name\">Doc</span>.<span class=\"name\">suggestKw</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">code</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.StrLit\">StrLit</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/DocString.html#Lean.Doc.DocM\">DocM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Elab/DocString.html#Lean.Doc.CodeSuggestion\">CodeSuggestion</a>)</span></span></div></div>","info":{"doc":"Suggests the `kw` role, if applicable.\n","docLink":"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.suggestKw","kind":"def","line":493,"name":"Lean.Doc.suggestKw","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/DocString/Builtin/Keywords.lean#L493-L509"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.kw!.getArgs\"><span class=\"name\">Lean</span>.<span class=\"name\">Doc</span>.<span class=\"name\">kw!</span>.<span class=\"name\">getArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">TSyntaxArray</a> <span class=\"fn\">`inline</span> → <span class=\"fn\"><a href=\"./Init/Control/State.html#StateT\">StateT</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`doc_arg</span>))</span> <a href=\"./Lean/Elab/DocString.html#Lean.Doc.DocM\">DocM</a> <span class=\"fn\">(<a href=\"./Lean/DocString/Types.html#Lean.Doc.Inline\">Inline</a> <a href=\"./Lean/DocString/Extension.html#Lean.ElabInline\">ElabInline</a>)</span></span></span></div></div>","info":{"doc":"A reference to a particular syntax kind, via one of its atoms.\n\nIt is an error if the syntax kind can't be automatically determined to contain the atom, or if\nmultiple syntax kinds contain it. If the parser for the syntax kind is sufficiently complex,\ndetection may fail.\n\nSpecifying the category or kind using the named arguments `cat` and `of` can narrow down the\nprocess.\n\nUse `kw?` to receive a suggestion of a specific kind, and `kw!` to disable the check.\n","docLink":"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.kw!.getArgs","kind":"def","line":460,"name":"Lean.Doc.kw!.getArgs","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/DocString/Builtin/Keywords.lean#L460-L460"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.kw!\"><span class=\"name\">Lean</span>.<span class=\"name\">Doc</span>.<span class=\"name\">kw!</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">of</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Ident\">Ident</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">scope</span> : <a href=\"./Lean/Elab/DocString/Builtin/Scopes.html#Lean.Doc.DocScope\">DocScope</a> := <a href=\"./Lean/Elab/DocString/Builtin/Scopes.html#Lean.Doc.DocScope.local\">DocScope.local</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">TSyntaxArray</a> <span class=\"fn\">`inline</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/DocString.html#Lean.Doc.DocM\">DocM</a> <span class=\"fn\">(<a href=\"./Lean/DocString/Types.html#Lean.Doc.Inline\">Inline</a> <a href=\"./Lean/DocString/Extension.html#Lean.ElabInline\">ElabInline</a>)</span></span></div></div>","info":{"doc":"A reference to a particular syntax kind, via one of its atoms.\n\nIt is an error if the syntax kind can't be automatically determined to contain the atom, or if\nmultiple syntax kinds contain it. If the parser for the syntax kind is sufficiently complex,\ndetection may fail.\n\nSpecifying the category or kind using the named arguments `cat` and `of` can narrow down the\nprocess.\n\nUse `kw?` to receive a suggestion of a specific kind, and `kw!` to disable the check.\n","docLink":"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.kw!","kind":"def","line":460,"name":"Lean.Doc.kw!","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/DocString/Builtin/Keywords.lean#L460-L491"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.checkKindExists\"><span class=\"name\">Lean</span>.<span class=\"name\">Doc</span>.<span class=\"name\">checkKindExists</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/DocString/Builtin/Postponed.html#Lean.Doc.PostponedCheckHandler\">PostponedCheckHandler</a></div></div>","info":{"doc":"Checks that a syntax kind name exists.\n","docLink":"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.checkKindExists","kind":"def","line":447,"name":"Lean.Doc.checkKindExists","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/DocString/Builtin/Keywords.lean#L447-L457"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.kw?.getArgs\"><span class=\"name\">Lean</span>.<span class=\"name\">Doc</span>.<span class=\"name\">kw?</span>.<span class=\"name\">getArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">TSyntaxArray</a> <span class=\"fn\">`inline</span> → <span class=\"fn\"><a href=\"./Init/Control/State.html#StateT\">StateT</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`doc_arg</span>))</span> <a href=\"./Lean/Elab/DocString.html#Lean.Doc.DocM\">DocM</a> <span class=\"fn\">(<a href=\"./Lean/DocString/Types.html#Lean.Doc.Inline\">Inline</a> <a href=\"./Lean/DocString/Extension.html#Lean.ElabInline\">ElabInline</a>)</span></span></span></div></div>","info":{"doc":"A reference to a particular syntax kind, via one of its atoms.\n\nIt is an error if the syntax kind can't be automatically determined to contain the atom, or if\nmultiple syntax kinds contain it. If the parser for the syntax kind is sufficiently complex,\ndetection may fail.\n\nSpecifying the category or kind using the named arguments `cat` and `of` can narrow down the\nprocess.\n\nUse `kw?` to receive a suggestion of a specific kind, and `kw!` to disable the check.\n","docLink":"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.kw?.getArgs","kind":"def","line":441,"name":"Lean.Doc.kw?.getArgs","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/DocString/Builtin/Keywords.lean#L441-L441"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.kw?\"><span class=\"name\">Lean</span>.<span class=\"name\">Doc</span>.<span class=\"name\">kw?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cat </span><span class=\"fn\">of</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Ident\">Ident</a> := <span class=\"fn\"><a href=\"./Init/Meta/Defs.html#Lean.mkIdent\">mkIdent</a> <a href=\"./Init/Prelude.html#Lean.Name.anonymous\">Name.anonymous</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">TSyntaxArray</a> <span class=\"fn\">`inline</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/DocString.html#Lean.Doc.DocM\">DocM</a> <span class=\"fn\">(<a href=\"./Lean/DocString/Types.html#Lean.Doc.Inline\">Inline</a> <a href=\"./Lean/DocString/Extension.html#Lean.ElabInline\">ElabInline</a>)</span></span></div></div>","info":{"doc":"A reference to a particular syntax kind, via one of its atoms.\n\nIt is an error if the syntax kind can't be automatically determined to contain the atom, or if\nmultiple syntax kinds contain it. If the parser for the syntax kind is sufficiently complex,\ndetection may fail.\n\nSpecifying the category or kind using the named arguments `cat` and `of` can narrow down the\nprocess.\n\nUse `kw?` to receive a suggestion of a specific kind, and `kw!` to disable the check.\n","docLink":"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.kw?","kind":"def","line":441,"name":"Lean.Doc.kw?","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/DocString/Builtin/Keywords.lean#L441-L445"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.kw.getArgs\"><span class=\"name\">Lean</span>.<span class=\"name\">Doc</span>.<span class=\"name\">kw</span>.<span class=\"name\">getArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">TSyntaxArray</a> <span class=\"fn\">`inline</span> → <span class=\"fn\"><a href=\"./Init/Control/State.html#StateT\">StateT</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`doc_arg</span>))</span> <a href=\"./Lean/Elab/DocString.html#Lean.Doc.DocM\">DocM</a> <span class=\"fn\">(<a href=\"./Lean/DocString/Types.html#Lean.Doc.Inline\">Inline</a> <a href=\"./Lean/DocString/Extension.html#Lean.ElabInline\">ElabInline</a>)</span></span></span></div></div>","info":{"doc":"A reference to a particular syntax kind, via one of its atoms.\n\nIt is an error if the syntax kind can't be automatically determined to contain the atom, or if\nmultiple syntax kinds contain it. If the parser for the syntax kind is sufficiently complex,\ndetection may fail.\n\nSpecifying the category or kind using the named arguments `cat` and `of` can narrow down the\nprocess.\n\nUse `kw?` to receive a suggestion of a specific kind, and `kw!` to disable the check.\n","docLink":"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.kw.getArgs","kind":"def","line":435,"name":"Lean.Doc.kw.getArgs","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/DocString/Builtin/Keywords.lean#L435-L435"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.kw\"><span class=\"name\">Lean</span>.<span class=\"name\">Doc</span>.<span class=\"name\">kw</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cat </span><span class=\"fn\">of</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Ident\">Ident</a> := <span class=\"fn\"><a href=\"./Init/Meta/Defs.html#Lean.mkIdent\">mkIdent</a> <a href=\"./Init/Prelude.html#Lean.Name.anonymous\">Name.anonymous</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">TSyntaxArray</a> <span class=\"fn\">`inline</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/DocString.html#Lean.Doc.DocM\">DocM</a> <span class=\"fn\">(<a href=\"./Lean/DocString/Types.html#Lean.Doc.Inline\">Inline</a> <a href=\"./Lean/DocString/Extension.html#Lean.ElabInline\">ElabInline</a>)</span></span></div></div>","info":{"doc":"A reference to a particular syntax kind, via one of its atoms.\n\nIt is an error if the syntax kind can't be automatically determined to contain the atom, or if\nmultiple syntax kinds contain it. If the parser for the syntax kind is sufficiently complex,\ndetection may fail.\n\nSpecifying the category or kind using the named arguments `cat` and `of` can narrow down the\nprocess.\n\nUse `kw?` to receive a suggestion of a specific kind, and `kw!` to disable the check.\n","docLink":"./Lean/Elab/DocString/Builtin/Keywords.html#Lean.Doc.kw","kind":"def","line":423,"name":"Lean.Doc.kw","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Lean/Elab/DocString/Builtin/Keywords.lean#L423-L439"}}],"imports":["Lean.Elab.DocString.Builtin.Scopes","Lean.Elab.DocString.Builtin.Postponed","Lean.Elab.DocString.Builtin.Postponed","Lean.DocString.Syntax","Lean.Elab.InfoTree","Lean.Elab.Open","Lean.Parser","Lean.Meta.Reduce","Lean.Elab.Tactic.Doc","Lean.Data.EditDistance"],"instances":[],"name":"Lean.Elab.DocString.Builtin.Keywords"}