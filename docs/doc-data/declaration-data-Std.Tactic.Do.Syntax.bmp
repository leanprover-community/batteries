{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgenHint\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mvcgenHint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A hint tactic that expands to `mvcgen invariants?`.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgenHint","kind":"def","line":370,"name":"Lean.Parser.Tactic.mvcgenHint","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L370-L374"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mvcgen</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mvcgen` will break down a Hoare triple proof goal like `⦃P⦄ prog ⦃Q⦄` into verification conditions,\nprovided that all functions used in `prog` have specifications registered with `@[spec]`.\n\n### Verification Conditions and specifications\n\nA verification condition is an entailment in the stateful logic of `Std.Do.SPred`\nin which the original program `prog` no longer occurs.\nVerification conditions are introduced by the `mspec` tactic; see the `mspec` tactic for what they\nlook like.\nWhen there's no applicable `mspec` spec, `mvcgen` will try and rewrite an application\n`prog = f a b c` with the simp set registered via `@[spec]`.\n\n### Features\n\nWhen used like `mvcgen +noLetElim [foo_spec, bar_def, instBEqFloat]`, `mvcgen` will additionally\n\n* add a Hoare triple specification `foo_spec : ... → ⦃P⦄ foo ... ⦃Q⦄` to `spec` set for a\n  function `foo` occurring in `prog`,\n* unfold a definition `def bar_def ... := ...` in `prog`,\n* unfold any method of the `instBEqFloat : BEq Float` instance in `prog`.\n* it will no longer substitute away `let`-expressions that occur at most once in `P`, `Q` or `prog`.\n\n### Config options\n\n`+noLetElim` is just one config option of many. Check out `Lean.Elab.Tactic.Do.VCGen.Config` for all\noptions. Of particular note is `stepLimit = some 42`, which is useful for bisecting bugs in\n`mvcgen` and tracing its execution.\n\n### Extended syntax\n\nOften, `mvcgen` will be used like this:\n```\nmvcgen [...]\ncase inv1 => by exact I1\ncase inv2 => by exact I2\nall_goals (mleave; try grind)\n```\nThere is special syntax for this:\n```\nmvcgen [...] invariants\n· I1\n· I2\nwith grind\n```\nWhen `I1` and `I2` need to refer to inaccessibles (`mvcgen` will introduce a lot of them for program\nvariables), you can use case label syntax:\n```\nmvcgen [...] invariants\n| inv1 _ acc _ => I1 acc\n| _ => I2\nwith grind\n```\nThis is more convenient than the equivalent `· by rename_i _ acc _; exact I1 acc`.\n\n### Invariant suggestions\n\n`mvcgen` will suggest invariants for you if you use the `invariants?` keyword.\n```\nmvcgen [...] invariants?\n```\nThis is useful if you do not recall the exact syntax to construct invariants.\nFurthermore, it will suggest a concrete invariant encoding \"this holds at the start of the loop and\nthis must hold at the end of the loop\" by looking at the corresponding VCs.\nAlthough the suggested invariant is a good starting point, it is too strong and requires users to\ninterpolate it such that the inductive step can be proved. Example:\n```\ndef mySum (l : List Nat) : Nat := Id.run do\n  let mut acc := 0\n  for x in l do\n    acc := acc + x\n  return acc\n\n/--\ninfo: Try this:\n  invariants\n    · ⇓⟨xs, letMuts⟩ => ⌜xs.prefix = [] ∧ letMuts = 0 ∨ xs.suffix = [] ∧ letMuts = l.sum⌝\n-/\n#guard_msgs (info) in\ntheorem mySum_suggest_invariant (l : List Nat) : mySum l = l.sum := by\n  generalize h : mySum l = r\n  apply Id.of_wp_run_eq h\n  mvcgen invariants?\n  all_goals admit\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen","kind":"def","line":365,"name":"Lean.Parser.Tactic.mvcgen","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L365-L368"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.vcAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">vcAlts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"After `with`, there is an optional tactic that runs on all branches, and\nthen a list of alternatives.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.vcAlts","kind":"def","line":359,"name":"Lean.Parser.Tactic.vcAlts","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L359-L363"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.vcAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">vcAlt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.vcAlt","kind":"def","line":353,"name":"Lean.Parser.Tactic.vcAlt","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L353-L357"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.invariantAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">invariantAlts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"After `mvcgen [...]`, there can be an optional `invariants` followed by either\n* a bulleted list of invariants `· term; · term`.\n* a labelled list of invariants `| inv1 => term; inv2 a b c => term`, which is useful for naming\n  inaccessibles.\nThe tracing variant ` invariants? ` will suggest a skeleton for missing invariants; see the\ndocstring for `mvcgen`.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.invariantAlts","kind":"def","line":343,"name":"Lean.Parser.Tactic.invariantAlts","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L343-L351"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.invariantsKW\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">invariantsKW</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Either the contextual keyword ` invariants ` or its tracing form ` invariants? ` which suggests\nskeletons for missing invariants as a hint.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.invariantsKW","kind":"def","line":337,"name":"Lean.Parser.Tactic.invariantsKW","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L337-L341"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.invariantCaseAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">invariantCaseAlt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"An invariant alternative of the form `| inv<n> a b c => term`, one per invariant goal.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.invariantCaseAlt","kind":"def","line":332,"name":"Lean.Parser.Tactic.invariantCaseAlt","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L332-L335"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.invariantDotAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">invariantDotAlt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"An invariant alternative of the form `· term`, one per invariant goal.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.invariantDotAlt","kind":"def","line":327,"name":"Lean.Parser.Tactic.invariantDotAlt","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L327-L330"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.tacticMvcgen_trivial\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticMvcgen_trivial</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mvcgen_trivial` is the tactic automatically called by `mvcgen` to discharge VCs.\nIt tries to discharge the VC by applying `(try mpure_intro); trivial` and otherwise delegates to\n`mvcgen_trivial_extensible`.\nUsers are encouraged to extend `mvcgen_trivial_extensible` instead of this tactic in order not to\noverride the default `(try mpure_intro); trivial` behavior.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.tacticMvcgen_trivial","kind":"def","line":321,"name":"Lean.Parser.Tactic.tacticMvcgen_trivial","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L321-L325"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.tacticMvcgen_trivial_extensible\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticMvcgen_trivial_extensible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.tacticMvcgen_trivial_extensible","kind":"def","line":312,"name":"Lean.Parser.Tactic.tacticMvcgen_trivial_extensible","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L312-L312"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mspec` is an `apply`-like tactic that applies a Hoare triple specification to the target of the\nstateful goal.\n\nGiven a stateful goal `H ⊢ₛ wp⟦prog⟧ Q'`, `mspec foo_spec` will instantiate\n`foo_spec : ... → ⦃P⦄ foo ⦃Q⦄`, match `foo` against `prog` and produce subgoals for\nthe verification conditions `?pre : H ⊢ₛ P` and `?post : Q ⊢ₚ Q'`.\n\n* If `prog = x >>= f`, then `mspec Specs.bind` is tried first so that `foo` is matched against `x`\n  instead. Tactic `mspec_no_bind` does not attempt to do this decomposition.\n* If `?pre` or `?post` follow by `.rfl`, then they are discharged automatically.\n* `?post` is automatically simplified into constituent `⊢ₛ` entailments on\n  success and failure continuations.\n* `?pre` and `?post.*` goals introduce their stateful hypothesis under an inaccessible name.\n  You can give it a name with the `mrename_i` tactic.\n* Any uninstantiated MVar arising from instantiation of `foo_spec` becomes a new subgoal.\n* If the target of the stateful goal looks like `fun s => _` then `mspec` will first `mintro ∀s`.\n* If `P` has schematic variables that can be instantiated by doing `mintro ∀s`, for example\n  `foo_spec : ∀(n:Nat), ⦃fun s => ⌜n = s⌝⦄ foo ⦃Q⦄`, then `mspec` will do `mintro ∀s` first to\n  instantiate `n = s`.\n* Right before applying the spec, the `mframe` tactic is used, which has the following effect:\n  Any hypothesis `Hᵢ` in the goal `h₁:H₁, h₂:H₂, ..., hₙ:Hₙ ⊢ₛ T` that is\n  pure (i.e., equivalent to some `⌜φᵢ⌝`) will be moved into the pure context as `hᵢ:φᵢ`.\n\nAdditionally, `mspec` can be used without arguments or with a term argument:\n\n* `mspec` without argument will try and look up a spec for `x` registered with `@[spec]`.\n* `mspec (foo_spec blah ?bleh)` will elaborate its argument as a term with expected type\n  `⦃?P⦄ x ⦃?Q⦄` and introduce `?bleh` as a subgoal.\n  This is useful to pass an invariant to e.g., `Specs.forIn_list` and leave the inductive step\n  as a hole.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec","kind":"def","line":305,"name":"Lean.Parser.Tactic.mspec","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L305-L310"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoSimp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspecNoSimp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Like `mspec`, but does not attempt slight simplification and closing of trivial sub-goals.\n`mspec $spec` is roughly (the set of simp lemmas below might not be up to date)\n```\nmspec_no_simp $spec\nall_goals\n  ((try simp only [SPred.true_intro_simp, SPred.apply_pure]);\n   (try mpure_intro; trivial))\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoSimp","kind":"def","line":301,"name":"Lean.Parser.Tactic.mspecNoSimp","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L301-L302"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoBind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspecNoBind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mspec_no_simp $spec` first tries to decompose `Bind.bind`s before applying `$spec`.\nThis variant of `mspec_no_simp` does not; `mspec_no_bind $spec` is defined as\n```\ntry with_reducible mspec_no_bind Std.Do.Spec.bind\nmspec_no_bind $spec\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoBind","kind":"def","line":281,"name":"Lean.Parser.Tactic.mspecNoBind","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L281-L289"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevert\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrevert</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mrevert` is like `revert`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q R : SPred σs) : P ∧ Q ∧ R ⊢ₛ P → R := by\n  mintro ⟨HP, HQ, HR⟩\n  mrevert HR\n  mrevert HP\n  mintro HP'\n  mintro HR'\n  mexact HR'\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevert","kind":"def","line":275,"name":"Lean.Parser.Tactic.mrevert","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L275-L276"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrevertPat∀_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrevertPat∀_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrevertPat∀_»","kind":"def","line":273,"name":"Lean.Parser.Tactic.«mrevertPat∀_»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L273-L273"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevertPat_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrevertPat_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevertPat_","kind":"def","line":272,"name":"Lean.Parser.Tactic.mrevertPat_","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L272-L272"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mrevertPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">mrevertPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mrevertPat","kind":"def","line":270,"name":"Lean.Parser.Category.mrevertPat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L270-L270"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevertPat.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrevertPat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevertPat.quot","kind":"def","line":270,"name":"Lean.Parser.Tactic.mrevertPat.quot","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L270-L270"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mintro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Like `intro`, but introducing stateful hypotheses into the stateful context of the `Std.Do.SPred`\nproof mode.\nThat is, given a stateful goal `(hᵢ : Hᵢ)* ⊢ₛ P → T`, `mintro h` transforms\ninto `(hᵢ : Hᵢ)*, (h : P) ⊢ₛ T`.\n\nFurthermore, `mintro ∀s` is like `intro s`, but preserves the stateful goal.\nThat is, `mintro ∀s` brings the topmost state variable `s:σ` in scope and transforms\n`(hᵢ : Hᵢ)* ⊢ₛ T` (where the entailment is in `Std.Do.SPred (σ::σs)`) into\n`(hᵢ : Hᵢ s)* ⊢ₛ T s` (where the entailment is in `Std.Do.SPred σs`).\n\nBeyond that, `mintro` supports the full syntax of `mcases` patterns\n(`mintro pat = (mintro h; mcases h with pat`), and can perform multiple\nintroductions in sequence.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro","kind":"def","line":258,"name":"Lean.Parser.Tactic.mintro","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L258-L259"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mintroPat∀_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mintroPat∀_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mintroPat∀_»","kind":"def","line":256,"name":"Lean.Parser.Tactic.«mintroPat∀_»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L256-L256"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mintroPat_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat_","kind":"def","line":255,"name":"Lean.Parser.Tactic.mintroPat_","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L255-L255"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mintroPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">mintroPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mintroPat","kind":"def","line":254,"name":"Lean.Parser.Category.mintroPat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L254-L254"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mintroPat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat.quot","kind":"def","line":254,"name":"Lean.Parser.Tactic.mintroPat.quot","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L254-L254"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefine\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrefine</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Like `refine`, but operating on stateful `Std.Do.SPred` goals.\n```lean\nexample (P Q R : SPred σs) : (P ∧ Q ∧ R) ⊢ₛ P ∧ R := by\n  mintro ⟨HP, HQ, HR⟩\n  mrefine ⟨HP, HR⟩\n\nexample (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by\n  mintro H\n  mrefine ⟨⌜42⌝, H⟩\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefine","kind":"def","line":251,"name":"Lean.Parser.Tactic.mrefine","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L251-L252"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.parse.go\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">parse</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`mrefinePat</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></span></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.parse.go","kind":"opaque","line":242,"name":"Lean.Parser.Tactic.MRefinePat.parse.go","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L242-L249"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.parse\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">parse</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pat</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`mrefinePat</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.MacroM\">MacroM</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.parse","kind":"def","line":237,"name":"Lean.Parser.Tactic.MRefinePat.parse","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L237-L249"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">instInhabitedMRefinePat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat","kind":"instance","line":235,"name":"Lean.Parser.Tactic.instInhabitedMRefinePat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L235-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat.default\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">instInhabitedMRefinePat</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat.default","kind":"def","line":235,"name":"Lean.Parser.Tactic.instInhabitedMRefinePat.default","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L235-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMRefinePat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">instReprMRefinePat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMRefinePat","kind":"instance","line":235,"name":"Lean.Parser.Tactic.instReprMRefinePat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L235-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMRefinePat.repr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">instReprMRefinePat</span>.<span class=\"name\">repr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Std.Format</a></span></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMRefinePat.repr","kind":"opaque","line":235,"name":"Lean.Parser.Tactic.instReprMRefinePat.repr","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L235-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.hole\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">hole</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.hole","kind":"ctor","line":234,"name":"Lean.Parser.Tactic.MRefinePat.hole","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L234-L234"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.stateful\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">stateful</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.stateful","kind":"ctor","line":233,"name":"Lean.Parser.Tactic.MRefinePat.stateful","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L233-L233"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.pure\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">pure</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`term</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.pure","kind":"ctor","line":232,"name":"Lean.Parser.Tactic.MRefinePat.pure","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L232-L232"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.tuple\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.tuple","kind":"ctor","line":231,"name":"Lean.Parser.Tactic.MRefinePat.tuple","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L231-L231"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.one\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.one","kind":"ctor","line":230,"name":"Lean.Parser.Tactic.MRefinePat.one","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L230-L230"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat","kind":"inductive","line":229,"name":"Lean.Parser.Tactic.MRefinePat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L229-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat#_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrefinePat#_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat#_»","kind":"def","line":227,"name":"Lean.Parser.Tactic.«mrefinePat#_»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L227-L227"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat%_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrefinePat%_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat%_»","kind":"def","line":226,"name":"Lean.Parser.Tactic.«mrefinePat%_»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L226-L226"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat?_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrefinePat?_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat?_","kind":"def","line":224,"name":"Lean.Parser.Tactic.mrefinePat?_","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L224-L224"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat□_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrefinePat□_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat□_»","kind":"def","line":223,"name":"Lean.Parser.Tactic.«mrefinePat□_»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L223-L223"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat⌜_⌝»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrefinePat⌜_⌝»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat⌜_⌝»","kind":"def","line":222,"name":"Lean.Parser.Tactic.«mrefinePat⌜_⌝»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L222-L222"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat(_)»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrefinePat(_)»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat(_)»","kind":"def","line":221,"name":"Lean.Parser.Tactic.«mrefinePat(_)»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L221-L221"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat⟨_⟩»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrefinePat⟨_⟩»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat⟨_⟩»","kind":"def","line":220,"name":"Lean.Parser.Tactic.«mrefinePat⟨_⟩»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L220-L220"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePats\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrefinePats</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePats","kind":"def","line":219,"name":"Lean.Parser.Tactic.mrefinePats","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L219-L219"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrefinePat_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat_","kind":"def","line":218,"name":"Lean.Parser.Tactic.mrefinePat_","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L218-L218"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mrefinePat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">mrefinePat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mrefinePat","kind":"def","line":217,"name":"Lean.Parser.Category.mrefinePat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L217-L217"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrefinePat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat.quot","kind":"def","line":217,"name":"Lean.Parser.Tactic.mrefinePat.quot","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L217-L217"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mcases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Like `rcases`, but operating on stateful `Std.Do.SPred` goals.\nExample: Given a goal `h : (P ∧ (Q ∨ R) ∧ (Q → R)) ⊢ₛ R`,\n`mcases h with ⟨-, ⟨hq | hr⟩, hqr⟩` will yield two goals:\n`(hq : Q, hqr : Q → R) ⊢ₛ R` and `(hr : R) ⊢ₛ R`.\n\nThat is, `mcases h with pat` has the following semantics, based on `pat`:\n* `pat=□h'` renames `h` to `h'` in the stateful context, regardless of whether `h` is pure\n* `pat=⌜h'⌝` introduces `h' : φ`  to the pure local context if `h : ⌜φ⌝`\n  (c.f. `Lean.Elab.Tactic.Do.ProofMode.IsPure`)\n* `pat=h'` is like `pat=⌜h'⌝` if `h` is pure\n  (c.f. `Lean.Elab.Tactic.Do.ProofMode.IsPure`), otherwise it is like `pat=□h'`.\n* `pat=_` renames `h` to an inaccessible name\n* `pat=-` discards `h`\n* `⟨pat₁, pat₂⟩` matches on conjunctions and existential quantifiers and recurses via\n  `pat₁` and `pat₂`.\n* `⟨pat₁ | pat₂⟩` matches on disjunctions, matching the left alternative via `pat₁` and the right\n  alternative via `pat₂`.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases","kind":"def","line":214,"name":"Lean.Parser.Tactic.mcases","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L214-L215"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse.goAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">parse</span>.<span class=\"name\">goAlts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.mcasesPatAlts</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse.goAlts","kind":"opaque","line":207,"name":"Lean.Parser.Tactic.MCasesPat.parse.goAlts","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L207-L212"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse.go\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">parse</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`mcasesPat</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse.go","kind":"opaque","line":199,"name":"Lean.Parser.Tactic.MCasesPat.parse.go","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L199-L206"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">parse</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pat</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`mcasesPat</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.MacroM\">MacroM</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse","kind":"def","line":194,"name":"Lean.Parser.Tactic.MCasesPat.parse","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L194-L212"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">instInhabitedMCasesPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat","kind":"instance","line":192,"name":"Lean.Parser.Tactic.instInhabitedMCasesPat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L192-L192"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat.default\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">instInhabitedMCasesPat</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat.default","kind":"def","line":192,"name":"Lean.Parser.Tactic.instInhabitedMCasesPat.default","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L192-L192"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMCasesPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">instReprMCasesPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMCasesPat","kind":"instance","line":192,"name":"Lean.Parser.Tactic.instReprMCasesPat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L192-L192"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMCasesPat.repr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">instReprMCasesPat</span>.<span class=\"name\">repr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Std.Format</a></span></span></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMCasesPat.repr","kind":"opaque","line":192,"name":"Lean.Parser.Tactic.instReprMCasesPat.repr","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L192-L192"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.stateful\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">stateful</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.stateful","kind":"ctor","line":191,"name":"Lean.Parser.Tactic.MCasesPat.stateful","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L191-L191"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.pure\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">pure</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.pure","kind":"ctor","line":190,"name":"Lean.Parser.Tactic.MCasesPat.pure","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L190-L190"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.alts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">alts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.alts","kind":"ctor","line":189,"name":"Lean.Parser.Tactic.MCasesPat.alts","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L189-L189"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.tuple\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.tuple","kind":"ctor","line":188,"name":"Lean.Parser.Tactic.MCasesPat.tuple","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L188-L188"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.clear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.clear","kind":"ctor","line":187,"name":"Lean.Parser.Tactic.MCasesPat.clear","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L187-L187"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.one\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.one","kind":"ctor","line":186,"name":"Lean.Parser.Tactic.MCasesPat.one","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L186-L186"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat","kind":"inductive","line":185,"name":"Lean.Parser.Tactic.MCasesPat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L185-L192"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat#_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat#_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat#_»","kind":"def","line":183,"name":"Lean.Parser.Tactic.«mcasesPat#_»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L183-L183"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat%_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat%_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat%_»","kind":"def","line":182,"name":"Lean.Parser.Tactic.«mcasesPat%_»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L182-L182"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat□_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat□_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat□_»","kind":"def","line":180,"name":"Lean.Parser.Tactic.«mcasesPat□_»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L180-L180"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat⌜_⌝»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat⌜_⌝»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat⌜_⌝»","kind":"def","line":179,"name":"Lean.Parser.Tactic.«mcasesPat⌜_⌝»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L179-L179"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat(_)»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat(_)»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat(_)»","kind":"def","line":178,"name":"Lean.Parser.Tactic.«mcasesPat(_)»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L178-L178"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat⟨_⟩»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat⟨_⟩»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat⟨_⟩»","kind":"def","line":177,"name":"Lean.Parser.Tactic.«mcasesPat⟨_⟩»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L177-L177"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat-»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat-»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat-»","kind":"def","line":176,"name":"Lean.Parser.Tactic.«mcasesPat-»","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L176-L176"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mcasesPat_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat_","kind":"def","line":175,"name":"Lean.Parser.Tactic.mcasesPat_","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L175-L175"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPatAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mcasesPatAlts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPatAlts","kind":"def","line":174,"name":"Lean.Parser.Tactic.mcasesPatAlts","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L174-L174"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mcasesPat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat.quot","kind":"def","line":173,"name":"Lean.Parser.Tactic.mcasesPat.quot","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L173-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mcasesPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">mcasesPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mcasesPat","kind":"def","line":173,"name":"Lean.Parser.Category.mcasesPat","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L173-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleave\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mleave</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Leaves the stateful proof mode of `Std.Do.SPred`, tries to eta-expand through all definitions\nrelated to the logic of the `Std.Do.SPred` and gently simplifies the resulting pure Lean\nproposition. This is often the right thing to do after `mvcgen` in order for automation to prove\nthe goal.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleave","kind":"def","line":127,"name":"Lean.Parser.Tactic.mleave","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L127-L171"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mstop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Stops the stateful proof mode of `Std.Do.SPred`.\nThis will simply forget all the names given to stateful hypotheses and pretty-print\na bit differently.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstop","kind":"def","line":123,"name":"Lean.Parser.Tactic.mstop","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L123-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstart\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mstart</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Start the stateful proof mode of `Std.Do.SPred`.\nThis will transform a stateful goal of the form `H ⊢ₛ T` into `⊢ₛ H → T`\nupon which `mintro` can be used to re-introduce `H` and give it a name.\nIt is often more convenient to use `mintro` directly, which will\ntry `mstart` automatically if necessary.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstart","kind":"def","line":120,"name":"Lean.Parser.Tactic.mstart","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L120-L121"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecializePure\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspecializePure</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mspecialize_pure` is like `mspecialize`, but it specializes a hypothesis from the\n*pure* context with hypotheses from either the pure or stateful context or pure terms.\n```lean\nexample (y : Nat) (P Q : SPred σs) (Ψ : Nat → SPred σs) (hP : ⊢ₛ P) (hΨ : ∀ x, ⊢ₛ P → Q → Ψ x) : ⊢ₛ Q → Ψ (y + 1) := by\n  mintro HQ\n  mspecialize_pure (hΨ (y + 1)) hP HQ => HΨ\n  mexact HΨ\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecializePure","kind":"def","line":117,"name":"Lean.Parser.Tactic.mspecializePure","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L117-L118"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspecialize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mspecialize` is like `specialize`, but operating on a stateful `Std.Do.SPred` goal.\nIt specializes a hypothesis from the stateful context with hypotheses from either the pure\nor stateful context or pure terms.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mspecialize HPQ HP\n  mexact HPQ\n\nexample (y : Nat) (P Q : SPred σs) (Ψ : Nat → SPred σs) (hP : ⊢ₛ P) : ⊢ₛ Q → (∀ x, P → Q → Ψ x) → Ψ (y + 1) := by\n  mintro HQ HΨ\n  mspecialize HΨ (y + 1) hP HQ\n  mexact HΨ\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize","kind":"def","line":114,"name":"Lean.Parser.Tactic.mspecialize","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L114-L115"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrenameI\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrenameI</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mrename_i` is like `rename_i`, but names inaccessible stateful hypotheses in a `Std.Do.SPred` goal.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrenameI","kind":"def","line":111,"name":"Lean.Parser.Tactic.mrenameI","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L111-L112"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpureIntro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mpureIntro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mpure_intro` operates on a stateful `Std.Do.SPred` goal of the form `P ⊢ₛ ⌜φ⌝`.\nIt leaves the stateful proof mode (thereby discarding `P`), leaving the regular goal `φ`.\n```lean\ntheorem simple : ⊢ₛ (⌜True⌝ : SPred σs) := by\n  mpure_intro\n  exact True.intro\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpureIntro","kind":"def","line":108,"name":"Lean.Parser.Tactic.mpureIntro","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L108-L109"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpure\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mpure</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mpure` moves a pure hypothesis from the stateful context into the pure context.\n```lean\nexample (Q : SPred σs) (ψ : φ → ⊢ₛ Q): ⌜φ⌝ ⊢ₛ Q := by\n  mintro Hφ\n  mpure Hφ\n  mexact (ψ Hφ)\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpure","kind":"def","line":104,"name":"Lean.Parser.Tactic.mpure","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L104-L105"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleft\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mleft</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mleft` is like `left`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ P ∨ Q := by\n  mintro HP\n  mleft\n  mexact HP\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleft","kind":"def","line":101,"name":"Lean.Parser.Tactic.mleft","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L101-L102"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mright\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mright</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mright` is like `right`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ Q ∨ P := by\n  mintro HP\n  mright\n  mexact HP\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mright","kind":"def","line":98,"name":"Lean.Parser.Tactic.mright","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L98-L99"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mreplace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mreplace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mreplace` is like `replace`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mreplace HPQ : Q := by mspecialize HPQ HP; mexact HPQ\n  mexact HPQ\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mreplace","kind":"def","line":95,"name":"Lean.Parser.Tactic.mreplace","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L95-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mhave\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mhave</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mhave` is like `have`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mhave HQ : Q := by mspecialize HPQ HP; mexact HPQ\n  mexact HQ\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mhave","kind":"def","line":92,"name":"Lean.Parser.Tactic.mhave","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L92-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mdup\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mdup</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Duplicate a stateful `Std.Do.SPred` hypothesis. ","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mdup","kind":"def","line":89,"name":"Lean.Parser.Tactic.mdup","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L89-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mframe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mframe` infers which hypotheses from the stateful context can be moved into the pure context.\nThis is useful because pure hypotheses \"survive\" the next application of modus ponens\n(`Std.Do.SPred.mp`) and transitivity (`Std.Do.SPred.entails.trans`).\n\nIt is used as part of the `mspec` tactic.\n\n```lean\nexample (P Q : SPred σs) : ⊢ₛ ⌜p⌝ ∧ Q ∧ ⌜q⌝ ∧ ⌜r⌝ ∧ P ∧ ⌜s⌝ ∧ ⌜t⌝ → Q := by\n  mintro _\n  mframe\n  /- `h : p ∧ q ∧ r ∧ s ∧ t` in the pure context -/\n  mcases h with hP\n  mexact h\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe","kind":"def","line":86,"name":"Lean.Parser.Tactic.mframe","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L86-L87"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexists\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mexists</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mexists` is like `exists`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by\n  mintro H\n  mexists 42\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexists","kind":"def","line":83,"name":"Lean.Parser.Tactic.mexists","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L83-L84"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexfalso\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mexfalso</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mexfalso` is like `exfalso`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P : SPred σs) : ⌜False⌝ ⊢ₛ P := by\n  mintro HP\n  mexfalso\n  mexact HP\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexfalso","kind":"def","line":80,"name":"Lean.Parser.Tactic.mexfalso","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L80-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mexact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mexact` is like `exact`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (Q : SPred σs) : Q ⊢ₛ Q := by\n  mstart\n  mintro HQ\n  mexact HQ\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact","kind":"def","line":77,"name":"Lean.Parser.Tactic.mexact","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L77-L78"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mconstructor\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mconstructor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mconstructor` is like `constructor`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (Q : SPred σs) : Q ⊢ₛ Q ∧ Q := by\n  mintro HQ\n  mconstructor <;> mexact HQ\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mconstructor","kind":"def","line":74,"name":"Lean.Parser.Tactic.mconstructor","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L74-L75"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mclear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mclear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mclear` is like `clear`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ Q → Q := by\n  mintro HP\n  mintro HQ\n  mclear HP\n  mexact HQ\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mclear","kind":"def","line":71,"name":"Lean.Parser.Tactic.mclear","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L71-L72"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.massumption\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">massumption</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`massumption` is like `assumption`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : Q ⊢ₛ P → Q := by\n  mintro _ _\n  massumption\n```\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.massumption","kind":"def","line":68,"name":"Lean.Parser.Tactic.massumption","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L68-L69"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Attr.spec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">spec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Theorems tagged with the `spec` attribute are used by the `mspec` and `mvcgen` tactics.\n\n* When used on a theorem `foo_spec : Triple (foo a b c) P Q`, then `mspec` and `mvcgen` will use\n  `foo_spec` as a specification for calls to `foo`.\n* Otherwise, when used on a definition that `@[simp]` would work on, it is added to the internal\n  simp set of `mvcgen` that is used within `wp⟦·⟧` contexts to simplify match discriminants and\n  applications of constants.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Attr.spec","kind":"def","line":53,"name":"Lean.Parser.Attr.spec","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L53-L62"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.stepLimit\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Do</span>.<span class=\"name\">VCGen</span>.<span class=\"name\">Config</span>.<span class=\"name\">stepLimit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>","info":{"doc":"If set to `some n`, `mvcgen` will only do 42 steps of the VC generation procedure.\nThis is helpful for bisecting bugs in `mvcgen` and tracing its execution.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.stepLimit","kind":"def","line":46,"name":"Lean.Elab.Tactic.Do.VCGen.Config.stepLimit","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L46-L46"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.jp\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Do</span>.<span class=\"name\">VCGen</span>.<span class=\"name\">Config</span>.<span class=\"name\">jp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If `false` (the default), then we aggressively split `if` and `match` statements and inline join\npoints unconditionally. For some programs this causes exponential blowup of VCs.\nSet this flag to choose a more conservative (but slightly lossy) encoding that traverses\nevery join point only once and yields a formula the size of which is linear in the number of\ncontrol flow splits.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.jp","kind":"def","line":41,"name":"Lean.Elab.Tactic.Do.VCGen.Config.jp","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L41-L41"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.elimLets\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Do</span>.<span class=\"name\">VCGen</span>.<span class=\"name\">Config</span>.<span class=\"name\">elimLets</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If `true` (the default), we substitute away let-declarations that are used at most once before\nstarting VC generation and will do the same for every VC generated.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.elimLets","kind":"def","line":33,"name":"Lean.Elab.Tactic.Do.VCGen.Config.elimLets","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L33-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.leave\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Do</span>.<span class=\"name\">VCGen</span>.<span class=\"name\">Config</span>.<span class=\"name\">leave</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If `true` (the default), we will simplify every generated VC after trying\n`mvcgen_trivial` by running `mleave`. (Note that this can be expensive.)\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.leave","kind":"def","line":28,"name":"Lean.Elab.Tactic.Do.VCGen.Config.leave","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L28-L28"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.trivial\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Do</span>.<span class=\"name\">VCGen</span>.<span class=\"name\">Config</span>.<span class=\"name\">trivial</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If `true` (the default), we will try to prove VCs via `mvcgen_trivial`, which is extensible\nvia `macro_rules`.\n","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.trivial","kind":"def","line":23,"name":"Lean.Elab.Tactic.Do.VCGen.Config.trivial","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L23-L23"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Do</span>.<span class=\"name\">VCGen</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">trivial </span><span class=\"fn\">leave </span><span class=\"fn\">elimLets </span><span class=\"fn\">jp</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stepLimit</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config\">Config</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config.mk","kind":"ctor","line":18,"name":"Lean.Elab.Tactic.Do.VCGen.Config.mk","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L18-L18"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Do</span>.<span class=\"name\">VCGen</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Elab.Tactic.Do.VCGen.Config","kind":"structure","line":18,"name":"Lean.Elab.Tactic.Do.VCGen.Config","sourceLink":"https://github.com/leanprover/lean4/blob/744f98064b056ee27fc8c97f524797c8cc96f436/src/Std/Tactic/Do/Syntax.lean#L18-L46"}}],"imports":["Std.Do","Std.Tactic.Do.ProofMode"],"instances":[{"className":"Repr","name":"Lean.Parser.Tactic.instReprMCasesPat","typeNames":["Lean.Parser.Tactic.MCasesPat"]},{"className":"Inhabited","name":"Lean.Parser.Tactic.instInhabitedMCasesPat","typeNames":["Lean.Parser.Tactic.MCasesPat"]},{"className":"Repr","name":"Lean.Parser.Tactic.instReprMRefinePat","typeNames":["Lean.Parser.Tactic.MRefinePat"]},{"className":"Inhabited","name":"Lean.Parser.Tactic.instInhabitedMRefinePat","typeNames":["Lean.Parser.Tactic.MRefinePat"]}],"name":"Std.Tactic.Do.Syntax"}