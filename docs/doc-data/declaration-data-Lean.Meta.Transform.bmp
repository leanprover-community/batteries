{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.erasePatternRefAnnotations\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">erasePatternRefAnnotations</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Removes all `patternWithRef` annotations from `e`. ","docLink":"./Lean/Meta/Transform.html#Lean.Meta.erasePatternRefAnnotations","kind":"def","line":282,"name":"Lean.Meta.erasePatternRefAnnotations","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L282-L284"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.eraseInaccessibleAnnotations\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">eraseInaccessibleAnnotations</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Removes all `inaccessible` annotations from `e`. ","docLink":"./Lean/Meta/Transform.html#Lean.Meta.eraseInaccessibleAnnotations","kind":"def","line":278,"name":"Lean.Meta.eraseInaccessibleAnnotations","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L278-L280"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.unfoldIfArgIsAppOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">unfoldIfArgIsAppOf</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fnNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numSectionVars</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Unfolds theorems that are applied to `f x₁ .. xₙ` where `f` is in `fnNames` and\n`n ≤ numSectionVars` (i.e., an unsaturated application of `f`).\n\nThis is used to undo proof abstraction for termination checking, as otherwise the bare\noccurrence of the recursive function prevents termination checking from succeeding.\n\nUsually, the argument is just `f` (the constant), arising from `mkAuxTheorem` abstracting over the\naux decl representing `f`. If the mutual function is defined within the scope of `variable` commands,\nit is `f x y` where `x y` are the variables in scope, so we use the `numSectionVars` to recognize that\nwhile avoiding to unfold theorems applied to saturated applications of `f`.\n\nThis unfolds from the private environment. The resulting definitions are (usually) not\nexposed anyways.\n","docLink":"./Lean/Meta/Transform.html#Lean.Meta.unfoldIfArgIsAppOf","kind":"def","line":235,"name":"Lean.Meta.unfoldIfArgIsAppOf","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L235-L275"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.unfoldDeclsFrom\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">unfoldDeclsFrom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">biggerEnv</span> : <a href=\"./Lean/Environment.html#Lean.Environment\">Environment</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Unfold definitions and theorems in `e` that are not in the current environment, but are in `biggerEnv`. ","docLink":"./Lean/Meta/Transform.html#Lean.Meta.unfoldDeclsFrom","kind":"def","line":216,"name":"Lean.Meta.unfoldDeclsFrom","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L216-L233"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.zetaDeltaFVars\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">zetaDeltaFVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Zeta-reduces only the specified free variables, applying beta reduction after substitution.\nFor example, if `x` has value `fun y => y + 1` and appears as `x 2`, the result is `2 + 1`.\n","docLink":"./Lean/Meta/Transform.html#Lean.Meta.zetaDeltaFVars","kind":"def","line":200,"name":"Lean.Meta.zetaDeltaFVars","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L200-L214"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.zetaReduce\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">zetaReduce</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Replaces all free variables in `e` that have let-values with their values.\nThe substitution is applied recursively to the values themselves.\n","docLink":"./Lean/Meta/Transform.html#Lean.Meta.zetaReduce","kind":"def","line":187,"name":"Lean.Meta.zetaReduce","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L187-L198"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.transform\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">transform</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Basic.html#MonadControlT\">MonadControlT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">input</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pre</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep.continue\">TransformStep.continue</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">post</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Transform.html#Lean.TransformStep.done\">TransformStep.done</a> <span class=\"fn\">e</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">usedLetOnly </span><span class=\"fn\">skipConstInApp</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Similar to `Core.transform`, but terms provided to `pre` and `post` do not contain loose bound variables.\nSo, it is safe to use any `MetaM` method at `pre` and `post`.\n\nWarning: `pre` and `post` should not depend on variables in the local context introduced by `transform`.\nThis is in order to allow aggressive caching.\n\nIf `skipConstInApp := true`, then for an expression `mkAppN (.const f) args`, the subexpression\n`.const f` is not visited again. Put differently: every `.const f` is visited once, with its\narguments if present, on its own otherwise.\n","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform","kind":"def","line":166,"name":"Lean.Meta.transform","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L166-L185"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.transformWithCache\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">transformWithCache</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Basic.html#MonadControlT\">MonadControlT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">input</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cache</span> : <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Lean/Expr.html#Lean.ExprStructEq\">ExprStructEq</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pre</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep.continue\">TransformStep.continue</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">post</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Transform.html#Lean.TransformStep.done\">TransformStep.done</a> <span class=\"fn\">e</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">usedLetOnly </span><span class=\"fn\">skipConstInApp </span><span class=\"fn\">skipInstances</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Lean/Expr.html#Lean.ExprStructEq\">ExprStructEq</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></div></div>","info":{"doc":"Like `Meta.transform`, but accepts and returns a cache for reuse across multiple calls.\n\nParameters:\n- `usedLetOnly`: when true, `mkLambdaFVars`/`mkForallFVars`/`mkLetFVars` only abstract\n  over variables that are actually used in the body.\n- `skipConstInApp`: when true, constant heads in applications are not visited separately.\n- `skipInstances`: when true, instance arguments (determined via `getFunInfo`) are not visited.\n\nThe `skipInstances` flag is used by `dsimp` to avoid rewriting instances.\n\n**Warnings:**\n- The cache is only valid when using the same `pre` and `post` functions.\n- Ensure there are no other references to `cache` to avoid unnecessary hash map copying.\n","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transformWithCache","kind":"def","line":81,"name":"Lean.Meta.transformWithCache","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L81-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Core.betaReduce\"><span class=\"name\">Lean</span>.<span class=\"name\">Core</span>.<span class=\"name\">betaReduce</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Applies beta reduction to all beta-reducible subexpressions in `e`. ","docLink":"./Lean/Meta/Transform.html#Lean.Core.betaReduce","kind":"def","line":73,"name":"Lean.Core.betaReduce","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L73-L75"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Core.transform\"><span class=\"name\">Lean</span>.<span class=\"name\">Core</span>.<span class=\"name\">transform</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Basic.html#MonadControlT\">MonadControlT</a> <a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">input</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pre</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep.continue\">TransformStep.continue</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">post</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Transform.html#Lean.TransformStep.done\">TransformStep.done</a> <span class=\"fn\">e</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Recursively transforms `input` using `pre` and `post` callbacks.\n\nFor each subexpression:\n1. `pre` is invoked first; recursion continues according to the `TransformStep` result.\n2. After recursion (if any), `post` is invoked on the resulting expression.\n\nThe expressions passed to `pre` and `post` may contain loose bound variables.\nUse `Meta.transform` instead if you need operations like `whnf` or `inferType`\nthat require expressions without loose bound variables.\n\nResults are cached using pointer equality (`ExprStructEq`), so structurally\nidentical subexpressions are transformed only once.\n","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform","kind":"def","line":30,"name":"Lean.Core.transform","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L30-L71"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.instReprTransformStep.repr\"><span class=\"name\">Lean</span>.<span class=\"name\">instReprTransformStep</span>.<span class=\"name\">repr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Format</a></span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.instReprTransformStep.repr","kind":"def","line":26,"name":"Lean.instReprTransformStep.repr","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L26-L26"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.instReprTransformStep\"><span class=\"name\">Lean</span>.<span class=\"name\">instReprTransformStep</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.instReprTransformStep","kind":"instance","line":26,"name":"Lean.instReprTransformStep","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L26-L26"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.instInhabitedTransformStep\"><span class=\"name\">Lean</span>.<span class=\"name\">instInhabitedTransformStep</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.instInhabitedTransformStep","kind":"instance","line":26,"name":"Lean.instInhabitedTransformStep","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L26-L26"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.instInhabitedTransformStep.default\"><span class=\"name\">Lean</span>.<span class=\"name\">instInhabitedTransformStep</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.instInhabitedTransformStep.default","kind":"def","line":26,"name":"Lean.instInhabitedTransformStep.default","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L26-L26"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.TransformStep.continue\"><span class=\"name\">Lean</span>.<span class=\"name\">TransformStep</span>.<span class=\"name\">continue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></div></div>","info":{"doc":"Continue transformation with the given expression (defaults to current expression).\nFor `pre`, this means visiting the children of the expression.\nFor `post`, this is equivalent to returning `done`. ","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep.continue","kind":"ctor","line":21,"name":"Lean.TransformStep.continue","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L21-L25"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.TransformStep.visit\"><span class=\"name\">Lean</span>.<span class=\"name\">TransformStep</span>.<span class=\"name\">visit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></div></div>","info":{"doc":"Visit expression (which should be different from current expression) instead.\nThe new expression `e` is passed to `pre` again.\n","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep.visit","kind":"ctor","line":16,"name":"Lean.TransformStep.visit","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L16-L20"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.TransformStep.done\"><span class=\"name\">Lean</span>.<span class=\"name\">TransformStep</span>.<span class=\"name\">done</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></div></div>","info":{"doc":"Return expression without visiting any subexpressions. ","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep.done","kind":"ctor","line":14,"name":"Lean.TransformStep.done","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L14-L15"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.TransformStep\"><span class=\"name\">Lean</span>.<span class=\"name\">TransformStep</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep","kind":"inductive","line":13,"name":"Lean.TransformStep","sourceLink":"https://github.com/leanprover/lean4/blob/985f350dcd18fc7814dfa677cac09933f44f3215/src/Lean/Meta/Transform.lean#L13-L26"}}],"imports":["Lean.Meta.FunInfo","Init.Data.Range.Polymorphic.Iterators"],"instances":[{"className":"Inhabited","name":"Lean.instInhabitedTransformStep","typeNames":["Lean.TransformStep"]},{"className":"Repr","name":"Lean.instReprTransformStep","typeNames":["Lean.TransformStep"]}],"name":"Lean.Meta.Transform"}